
penguin.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000027ba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002cc  00802000  000027ba  0000284e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00007568  008022cc  008022cc  00002b1a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002b1a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002b4c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000938  00000000  00000000  00002b8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000f48d  00000000  00000000  000034c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002dbb  00000000  00000000  00012951  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000467d  00000000  00000000  0001570c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001a40  00000000  00000000  00019d8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005a17  00000000  00000000  0001b7cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007d36  00000000  00000000  000211e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000b68  00000000  00000000  00028f19  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 68 01 	jmp	0x2d0	; 0x2d0 <__ctors_end>
       4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
       8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
       c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      10:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      14:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      18:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      1c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      20:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      24:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      28:	0c 94 27 13 	jmp	0x264e	; 0x264e <__vector_10>
      2c:	0c 94 64 13 	jmp	0x26c8	; 0x26c8 <__vector_11>
      30:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      34:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      38:	0c 94 2d 03 	jmp	0x65a	; 0x65a <__vector_14>
      3c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      40:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      44:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      48:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      4c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      50:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      54:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      58:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      5c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      60:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      64:	0c 94 7f 0a 	jmp	0x14fe	; 0x14fe <__vector_25>
      68:	0c 94 93 0a 	jmp	0x1526	; 0x1526 <__vector_26>
      6c:	0c 94 89 0a 	jmp	0x1512	; 0x1512 <__vector_27>
      70:	0c 94 9d 0a 	jmp	0x153a	; 0x153a <__vector_28>
      74:	0c 94 b1 0a 	jmp	0x1562	; 0x1562 <__vector_29>
      78:	0c 94 a7 0a 	jmp	0x154e	; 0x154e <__vector_30>
      7c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      80:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      84:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      88:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      8c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      90:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      94:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      98:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      9c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      ac:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      bc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      cc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      dc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e8:	0c 94 d9 0a 	jmp	0x15b2	; 0x15b2 <__vector_58>
      ec:	0c 94 ed 0a 	jmp	0x15da	; 0x15da <__vector_59>
      f0:	0c 94 e3 0a 	jmp	0x15c6	; 0x15c6 <__vector_60>
      f4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      f8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      fc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     100:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     104:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     108:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     10c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     110:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     114:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     118:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     11c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     120:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     124:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     128:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     12c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     130:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     134:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     138:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     13c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     140:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     144:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     148:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     14c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     150:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     154:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     158:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     15c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     160:	0c 94 bb 0a 	jmp	0x1576	; 0x1576 <__vector_88>
     164:	0c 94 cf 0a 	jmp	0x159e	; 0x159e <__vector_89>
     168:	0c 94 c5 0a 	jmp	0x158a	; 0x158a <__vector_90>
     16c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     170:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     174:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     178:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     17c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     180:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     184:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     188:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     18c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     190:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     194:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     198:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     19c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1ac:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1bc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1cc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1dc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1ec:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1f0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1f4:	0c 94 8c 12 	jmp	0x2518	; 0x2518 <__vector_125>
     1f8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1fc:	64 0d       	add	r22, r4
     1fe:	8f 0d       	add	r24, r15
     200:	66 0e       	add	r6, r22
     202:	8f 0d       	add	r24, r15
     204:	66 0e       	add	r6, r22
     206:	ca 0d       	add	r28, r10
     208:	e1 0d       	add	r30, r1
     20a:	66 0e       	add	r6, r22
     20c:	38 0e       	add	r3, r24
     20e:	45 0e       	add	r4, r21

00000210 <__trampolines_start>:
     210:	0c 94 8c 07 	jmp	0xf18	; 0xf18 <thread_2>
     214:	0c 94 df 06 	jmp	0xdbe	; 0xdbe <prvIdleTask>
     218:	0c 94 7d 07 	jmp	0xefa	; 0xefa <USBThread>
     21c:	0c 94 95 07 	jmp	0xf2a	; 0xf2a <thread_1>
     220:	0c 94 7e 0b 	jmp	0x16fc	; 0x16fc <CDC_Device_putchar>
     224:	0c 94 66 0e 	jmp	0x1ccc	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
     228:	0c 94 45 0e 	jmp	0x1c8a	; 0x1c8a <USB_Device_ProcessControlRequest+0x228>
     22c:	0c 94 67 0c 	jmp	0x18ce	; 0x18ce <CDC_Device_getchar>
     230:	0c 94 e1 0d 	jmp	0x1bc2	; 0x1bc2 <USB_Device_ProcessControlRequest+0x160>
     234:	0c 94 38 0e 	jmp	0x1c70	; 0x1c70 <USB_Device_ProcessControlRequest+0x20e>
     238:	0c 94 ca 0d 	jmp	0x1b94	; 0x1b94 <USB_Device_ProcessControlRequest+0x132>
     23c:	0c 94 64 0d 	jmp	0x1ac8	; 0x1ac8 <USB_Device_ProcessControlRequest+0x66>
     240:	0c 94 8f 0d 	jmp	0x1b1e	; 0x1b1e <USB_Device_ProcessControlRequest+0xbc>

00000244 <ProductString>:
     244:	1c 03 4c 00 55 00 46 00 41 00 20 00 43 00 44 00     ..L.U.F.A. .C.D.
     254:	43 00 20 00 44 00 65 00 6d 00 6f 00 00 00           C. .D.e.m.o...

00000262 <ManufacturerString>:
     262:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
     272:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

0000027c <LanguageString>:
     27c:	04 03 09 04                                         ....

00000280 <ConfigurationDescriptor>:
     280:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
     290:	01 00 05 24 00 10 01 04 24 02 06 05 24 06 00 01     ...$....$...$...
     2a0:	07 05 82 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     2b0:	07 05 04 02 10 00 05 07 05 83 02 10 00 05           ..............

000002be <DeviceDescriptor>:
     2be:	12 01 10 01 02 00 00 08 eb 03 44 20 01 00 01 02     ..........D ....
     2ce:	dc 01                                               ..

000002d0 <__ctors_end>:
     2d0:	11 24       	eor	r1, r1
     2d2:	1f be       	out	0x3f, r1	; 63
     2d4:	cf ef       	ldi	r28, 0xFF	; 255
     2d6:	cd bf       	out	0x3d, r28	; 61
     2d8:	df e9       	ldi	r29, 0x9F	; 159
     2da:	de bf       	out	0x3e, r29	; 62
     2dc:	00 e0       	ldi	r16, 0x00	; 0
     2de:	0c bf       	out	0x3c, r16	; 60

000002e0 <__do_copy_data>:
     2e0:	12 e2       	ldi	r17, 0x22	; 34
     2e2:	a0 e0       	ldi	r26, 0x00	; 0
     2e4:	b0 e2       	ldi	r27, 0x20	; 32
     2e6:	ea eb       	ldi	r30, 0xBA	; 186
     2e8:	f7 e2       	ldi	r31, 0x27	; 39
     2ea:	00 e0       	ldi	r16, 0x00	; 0
     2ec:	0b bf       	out	0x3b, r16	; 59
     2ee:	02 c0       	rjmp	.+4      	; 0x2f4 <__do_copy_data+0x14>
     2f0:	07 90       	elpm	r0, Z+
     2f2:	0d 92       	st	X+, r0
     2f4:	ac 3c       	cpi	r26, 0xCC	; 204
     2f6:	b1 07       	cpc	r27, r17
     2f8:	d9 f7       	brne	.-10     	; 0x2f0 <__do_copy_data+0x10>

000002fa <__do_clear_bss>:
     2fa:	28 e9       	ldi	r18, 0x98	; 152
     2fc:	ac ec       	ldi	r26, 0xCC	; 204
     2fe:	b2 e2       	ldi	r27, 0x22	; 34
     300:	01 c0       	rjmp	.+2      	; 0x304 <.do_clear_bss_start>

00000302 <.do_clear_bss_loop>:
     302:	1d 92       	st	X+, r1

00000304 <.do_clear_bss_start>:
     304:	a4 33       	cpi	r26, 0x34	; 52
     306:	b2 07       	cpc	r27, r18
     308:	e1 f7       	brne	.-8      	; 0x302 <.do_clear_bss_loop>
     30a:	0e 94 9c 09 	call	0x1338	; 0x1338 <main>
     30e:	0c 94 db 13 	jmp	0x27b6	; 0x27b6 <_exit>

00000312 <__bad_interrupt>:
     312:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000316 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
     316:	29 2f       	mov	r18, r25
     318:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     31a:	22 30       	cpi	r18, 0x02	; 2
     31c:	31 05       	cpc	r19, r1
     31e:	59 f0       	breq	.+22     	; 0x336 <CALLBACK_USB_GetDescriptor+0x20>
     320:	23 30       	cpi	r18, 0x03	; 3
     322:	31 05       	cpc	r19, r1
     324:	69 f0       	breq	.+26     	; 0x340 <CALLBACK_USB_GetDescriptor+0x2a>
     326:	21 30       	cpi	r18, 0x01	; 1
     328:	31 05       	cpc	r19, r1
     32a:	29 f5       	brne	.+74     	; 0x376 <CALLBACK_USB_GetDescriptor+0x60>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     32c:	82 e1       	ldi	r24, 0x12	; 18
     32e:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     330:	2e eb       	ldi	r18, 0xBE	; 190
     332:	32 e0       	ldi	r19, 0x02	; 2
     334:	29 c0       	rjmp	.+82     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     336:	8e e3       	ldi	r24, 0x3E	; 62
     338:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     33a:	20 e8       	ldi	r18, 0x80	; 128
     33c:	32 e0       	ldi	r19, 0x02	; 2
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     33e:	24 c0       	rjmp	.+72     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
     340:	99 27       	eor	r25, r25
		case DTYPE_String:
			switch (DescriptorNumber)
     342:	81 30       	cpi	r24, 0x01	; 1
     344:	91 05       	cpc	r25, r1
     346:	59 f0       	breq	.+22     	; 0x35e <CALLBACK_USB_GetDescriptor+0x48>
     348:	82 30       	cpi	r24, 0x02	; 2
     34a:	91 05       	cpc	r25, r1
     34c:	71 f0       	breq	.+28     	; 0x36a <CALLBACK_USB_GetDescriptor+0x54>
     34e:	89 2b       	or	r24, r25
     350:	b9 f4       	brne	.+46     	; 0x380 <CALLBACK_USB_GetDescriptor+0x6a>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     352:	ec e7       	ldi	r30, 0x7C	; 124
     354:	f2 e0       	ldi	r31, 0x02	; 2
     356:	84 91       	lpm	r24, Z
     358:	90 e0       	ldi	r25, 0x00	; 0
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case STRING_ID_Language:
					Address = &LanguageString;
     35a:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
     35c:	15 c0       	rjmp	.+42     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     35e:	e2 e6       	ldi	r30, 0x62	; 98
     360:	f2 e0       	ldi	r31, 0x02	; 2
     362:	84 91       	lpm	r24, Z
     364:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
     366:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
     368:	0f c0       	rjmp	.+30     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     36a:	e4 e4       	ldi	r30, 0x44	; 68
     36c:	f2 e0       	ldi	r31, 0x02	; 2
     36e:	84 91       	lpm	r24, Z
     370:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
     372:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
     374:	09 c0       	rjmp	.+18     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     37a:	20 e0       	ldi	r18, 0x00	; 0
     37c:	30 e0       	ldi	r19, 0x00	; 0
     37e:	04 c0       	rjmp	.+8      	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
	uint16_t    Size    = NO_DESCRIPTOR;
     380:	80 e0       	ldi	r24, 0x00	; 0
     382:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     388:	fa 01       	movw	r30, r20
     38a:	20 83       	st	Z, r18
     38c:	31 83       	std	Z+1, r19	; 0x01
	return Size;
}
     38e:	08 95       	ret

00000390 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     390:	31 e1       	ldi	r19, 0x11	; 17
     392:	fc 01       	movw	r30, r24
     394:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	22 e2       	ldi	r18, 0x22	; 34
     39a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     39c:	31 97       	sbiw	r30, 0x01	; 1
     39e:	a3 e3       	ldi	r26, 0x33	; 51
     3a0:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3a2:	31 97       	sbiw	r30, 0x01	; 1
     3a4:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3a6:	31 97       	sbiw	r30, 0x01	; 1
     3a8:	70 83       	st	Z, r23
	pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__) && __AVR_3_BYTE_PC__
//#if PROGMEM_SIZE>65538 
	*pxTopOfStack = (portSTACK_TYPE ) 0;
     3aa:	31 97       	sbiw	r30, 0x01	; 1
     3ac:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     3ae:	31 97       	sbiw	r30, 0x01	; 1
     3b0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     3b2:	31 97       	sbiw	r30, 0x01	; 1
     3b4:	60 e8       	ldi	r22, 0x80	; 128
     3b6:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     3b8:	31 97       	sbiw	r30, 0x01	; 1
     3ba:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     3bc:	31 97       	sbiw	r30, 0x01	; 1
     3be:	62 e0       	ldi	r22, 0x02	; 2
     3c0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     3c2:	31 97       	sbiw	r30, 0x01	; 1
     3c4:	63 e0       	ldi	r22, 0x03	; 3
     3c6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     3c8:	31 97       	sbiw	r30, 0x01	; 1
     3ca:	64 e0       	ldi	r22, 0x04	; 4
     3cc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     3ce:	31 97       	sbiw	r30, 0x01	; 1
     3d0:	65 e0       	ldi	r22, 0x05	; 5
     3d2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     3d4:	31 97       	sbiw	r30, 0x01	; 1
     3d6:	66 e0       	ldi	r22, 0x06	; 6
     3d8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     3da:	31 97       	sbiw	r30, 0x01	; 1
     3dc:	67 e0       	ldi	r22, 0x07	; 7
     3de:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     3e0:	31 97       	sbiw	r30, 0x01	; 1
     3e2:	68 e0       	ldi	r22, 0x08	; 8
     3e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     3e6:	31 97       	sbiw	r30, 0x01	; 1
     3e8:	69 e0       	ldi	r22, 0x09	; 9
     3ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     3ec:	31 97       	sbiw	r30, 0x01	; 1
     3ee:	60 e1       	ldi	r22, 0x10	; 16
     3f0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     3f2:	31 97       	sbiw	r30, 0x01	; 1
     3f4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	32 e1       	ldi	r19, 0x12	; 18
     3fa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     3fc:	31 97       	sbiw	r30, 0x01	; 1
     3fe:	33 e1       	ldi	r19, 0x13	; 19
     400:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     402:	31 97       	sbiw	r30, 0x01	; 1
     404:	34 e1       	ldi	r19, 0x14	; 20
     406:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     408:	31 97       	sbiw	r30, 0x01	; 1
     40a:	35 e1       	ldi	r19, 0x15	; 21
     40c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     40e:	31 97       	sbiw	r30, 0x01	; 1
     410:	36 e1       	ldi	r19, 0x16	; 22
     412:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     414:	31 97       	sbiw	r30, 0x01	; 1
     416:	37 e1       	ldi	r19, 0x17	; 23
     418:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     41a:	31 97       	sbiw	r30, 0x01	; 1
     41c:	38 e1       	ldi	r19, 0x18	; 24
     41e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     420:	31 97       	sbiw	r30, 0x01	; 1
     422:	39 e1       	ldi	r19, 0x19	; 25
     424:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     426:	31 97       	sbiw	r30, 0x01	; 1
     428:	30 e2       	ldi	r19, 0x20	; 32
     42a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     42c:	31 97       	sbiw	r30, 0x01	; 1
     42e:	31 e2       	ldi	r19, 0x21	; 33
     430:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     432:	31 97       	sbiw	r30, 0x01	; 1
     434:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     436:	31 97       	sbiw	r30, 0x01	; 1
     438:	23 e2       	ldi	r18, 0x23	; 35
     43a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     43c:	31 97       	sbiw	r30, 0x01	; 1
     43e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     440:	31 97       	sbiw	r30, 0x01	; 1
     442:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     444:	31 97       	sbiw	r30, 0x01	; 1
     446:	26 e2       	ldi	r18, 0x26	; 38
     448:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	27 e2       	ldi	r18, 0x27	; 39
     44e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	28 e2       	ldi	r18, 0x28	; 40
     454:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     456:	31 97       	sbiw	r30, 0x01	; 1
     458:	29 e2       	ldi	r18, 0x29	; 41
     45a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     45c:	31 97       	sbiw	r30, 0x01	; 1
     45e:	20 e3       	ldi	r18, 0x30	; 48
     460:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	21 e3       	ldi	r18, 0x31	; 49
     466:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     468:	87 97       	sbiw	r24, 0x27	; 39
     46a:	08 95       	ret

0000046c <xPortStartScheduler>:
static void prvSetupTimerInterrupt( void )
{
    //Use TCC0 as a tick counter. If this is to be changed, change ISR as well
    TC0_t * tickTimer = &TCC0;
    //select the clock source and pre-scale by 64
    TC0_ConfigClockSource(tickTimer, TC_CLKSEL_DIV64_gc);
     46c:	65 e0       	ldi	r22, 0x05	; 5
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	98 e0       	ldi	r25, 0x08	; 8
     472:	0e 94 00 13 	call	0x2600	; 0x2600 <TC0_ConfigClockSource>
    //set period of counter
    tickTimer->PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 64 - 1;
     476:	83 ef       	ldi	r24, 0xF3	; 243
     478:	91 e0       	ldi	r25, 0x01	; 1
     47a:	80 93 26 08 	sts	0x0826, r24
     47e:	90 93 27 08 	sts	0x0827, r25

    //enable interrupt and set low level
    TC0_SetOverflowIntLevel(tickTimer, TC_OVFINTLVL_LO_gc);
     482:	61 e0       	ldi	r22, 0x01	; 1
     484:	80 e0       	ldi	r24, 0x00	; 0
     486:	98 e0       	ldi	r25, 0x08	; 8
     488:	0e 94 06 13 	call	0x260c	; 0x260c <TC0_SetOverflowIntLevel>
    //enable low level interrupts
    PMIC_EnableLowLevel();
     48c:	e0 ea       	ldi	r30, 0xA0	; 160
     48e:	f0 e0       	ldi	r31, 0x00	; 0
     490:	82 81       	ldd	r24, Z+2	; 0x02
     492:	81 60       	ori	r24, 0x01	; 1
     494:	82 83       	std	Z+2, r24	; 0x02
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     496:	a0 91 27 93 	lds	r26, 0x9327
     49a:	b0 91 28 93 	lds	r27, 0x9328
     49e:	cd 91       	ld	r28, X+
     4a0:	cd bf       	out	0x3d, r28	; 61
     4a2:	dd 91       	ld	r29, X+
     4a4:	de bf       	out	0x3e, r29	; 62
     4a6:	ff 91       	pop	r31
     4a8:	ef 91       	pop	r30
     4aa:	df 91       	pop	r29
     4ac:	cf 91       	pop	r28
     4ae:	bf 91       	pop	r27
     4b0:	af 91       	pop	r26
     4b2:	9f 91       	pop	r25
     4b4:	8f 91       	pop	r24
     4b6:	7f 91       	pop	r23
     4b8:	6f 91       	pop	r22
     4ba:	5f 91       	pop	r21
     4bc:	4f 91       	pop	r20
     4be:	3f 91       	pop	r19
     4c0:	2f 91       	pop	r18
     4c2:	1f 91       	pop	r17
     4c4:	0f 91       	pop	r16
     4c6:	ff 90       	pop	r15
     4c8:	ef 90       	pop	r14
     4ca:	df 90       	pop	r13
     4cc:	cf 90       	pop	r12
     4ce:	bf 90       	pop	r11
     4d0:	af 90       	pop	r10
     4d2:	9f 90       	pop	r9
     4d4:	8f 90       	pop	r8
     4d6:	7f 90       	pop	r7
     4d8:	6f 90       	pop	r6
     4da:	5f 90       	pop	r5
     4dc:	4f 90       	pop	r4
     4de:	3f 90       	pop	r3
     4e0:	2f 90       	pop	r2
     4e2:	1f 90       	pop	r1
     4e4:	0f 90       	pop	r0
     4e6:	0f be       	out	0x3f, r0	; 63
     4e8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4ea:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     4ec:	81 e0       	ldi	r24, 0x01	; 1
     4ee:	08 95       	ret

000004f0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     4f0:	0f 92       	push	r0
     4f2:	0f b6       	in	r0, 0x3f	; 63
     4f4:	f8 94       	cli
     4f6:	0f 92       	push	r0
     4f8:	1f 92       	push	r1
     4fa:	11 24       	eor	r1, r1
     4fc:	2f 92       	push	r2
     4fe:	3f 92       	push	r3
     500:	4f 92       	push	r4
     502:	5f 92       	push	r5
     504:	6f 92       	push	r6
     506:	7f 92       	push	r7
     508:	8f 92       	push	r8
     50a:	9f 92       	push	r9
     50c:	af 92       	push	r10
     50e:	bf 92       	push	r11
     510:	cf 92       	push	r12
     512:	df 92       	push	r13
     514:	ef 92       	push	r14
     516:	ff 92       	push	r15
     518:	0f 93       	push	r16
     51a:	1f 93       	push	r17
     51c:	2f 93       	push	r18
     51e:	3f 93       	push	r19
     520:	4f 93       	push	r20
     522:	5f 93       	push	r21
     524:	6f 93       	push	r22
     526:	7f 93       	push	r23
     528:	8f 93       	push	r24
     52a:	9f 93       	push	r25
     52c:	af 93       	push	r26
     52e:	bf 93       	push	r27
     530:	cf 93       	push	r28
     532:	df 93       	push	r29
     534:	ef 93       	push	r30
     536:	ff 93       	push	r31
     538:	a0 91 27 93 	lds	r26, 0x9327
     53c:	b0 91 28 93 	lds	r27, 0x9328
     540:	0d b6       	in	r0, 0x3d	; 61
     542:	0d 92       	st	X+, r0
     544:	0e b6       	in	r0, 0x3e	; 62
     546:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     548:	0e 94 10 07 	call	0xe20	; 0xe20 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     54c:	a0 91 27 93 	lds	r26, 0x9327
     550:	b0 91 28 93 	lds	r27, 0x9328
     554:	cd 91       	ld	r28, X+
     556:	cd bf       	out	0x3d, r28	; 61
     558:	dd 91       	ld	r29, X+
     55a:	de bf       	out	0x3e, r29	; 62
     55c:	ff 91       	pop	r31
     55e:	ef 91       	pop	r30
     560:	df 91       	pop	r29
     562:	cf 91       	pop	r28
     564:	bf 91       	pop	r27
     566:	af 91       	pop	r26
     568:	9f 91       	pop	r25
     56a:	8f 91       	pop	r24
     56c:	7f 91       	pop	r23
     56e:	6f 91       	pop	r22
     570:	5f 91       	pop	r21
     572:	4f 91       	pop	r20
     574:	3f 91       	pop	r19
     576:	2f 91       	pop	r18
     578:	1f 91       	pop	r17
     57a:	0f 91       	pop	r16
     57c:	ff 90       	pop	r15
     57e:	ef 90       	pop	r14
     580:	df 90       	pop	r13
     582:	cf 90       	pop	r12
     584:	bf 90       	pop	r11
     586:	af 90       	pop	r10
     588:	9f 90       	pop	r9
     58a:	8f 90       	pop	r8
     58c:	7f 90       	pop	r7
     58e:	6f 90       	pop	r6
     590:	5f 90       	pop	r5
     592:	4f 90       	pop	r4
     594:	3f 90       	pop	r3
     596:	2f 90       	pop	r2
     598:	1f 90       	pop	r1
     59a:	0f 90       	pop	r0
     59c:	0f be       	out	0x3f, r0	; 63
     59e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5a0:	08 95       	ret

000005a2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5a2:	0f 92       	push	r0
     5a4:	0f b6       	in	r0, 0x3f	; 63
     5a6:	f8 94       	cli
     5a8:	0f 92       	push	r0
     5aa:	1f 92       	push	r1
     5ac:	11 24       	eor	r1, r1
     5ae:	2f 92       	push	r2
     5b0:	3f 92       	push	r3
     5b2:	4f 92       	push	r4
     5b4:	5f 92       	push	r5
     5b6:	6f 92       	push	r6
     5b8:	7f 92       	push	r7
     5ba:	8f 92       	push	r8
     5bc:	9f 92       	push	r9
     5be:	af 92       	push	r10
     5c0:	bf 92       	push	r11
     5c2:	cf 92       	push	r12
     5c4:	df 92       	push	r13
     5c6:	ef 92       	push	r14
     5c8:	ff 92       	push	r15
     5ca:	0f 93       	push	r16
     5cc:	1f 93       	push	r17
     5ce:	2f 93       	push	r18
     5d0:	3f 93       	push	r19
     5d2:	4f 93       	push	r20
     5d4:	5f 93       	push	r21
     5d6:	6f 93       	push	r22
     5d8:	7f 93       	push	r23
     5da:	8f 93       	push	r24
     5dc:	9f 93       	push	r25
     5de:	af 93       	push	r26
     5e0:	bf 93       	push	r27
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	ef 93       	push	r30
     5e8:	ff 93       	push	r31
     5ea:	a0 91 27 93 	lds	r26, 0x9327
     5ee:	b0 91 28 93 	lds	r27, 0x9328
     5f2:	0d b6       	in	r0, 0x3d	; 61
     5f4:	0d 92       	st	X+, r0
     5f6:	0e b6       	in	r0, 0x3e	; 62
     5f8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     5fa:	0e 94 83 05 	call	0xb06	; 0xb06 <xTaskIncrementTick>
     5fe:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     600:	0e 94 10 07 	call	0xe20	; 0xe20 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     604:	a0 91 27 93 	lds	r26, 0x9327
     608:	b0 91 28 93 	lds	r27, 0x9328
     60c:	cd 91       	ld	r28, X+
     60e:	cd bf       	out	0x3d, r28	; 61
     610:	dd 91       	ld	r29, X+
     612:	de bf       	out	0x3e, r29	; 62
     614:	ff 91       	pop	r31
     616:	ef 91       	pop	r30
     618:	df 91       	pop	r29
     61a:	cf 91       	pop	r28
     61c:	bf 91       	pop	r27
     61e:	af 91       	pop	r26
     620:	9f 91       	pop	r25
     622:	8f 91       	pop	r24
     624:	7f 91       	pop	r23
     626:	6f 91       	pop	r22
     628:	5f 91       	pop	r21
     62a:	4f 91       	pop	r20
     62c:	3f 91       	pop	r19
     62e:	2f 91       	pop	r18
     630:	1f 91       	pop	r17
     632:	0f 91       	pop	r16
     634:	ff 90       	pop	r15
     636:	ef 90       	pop	r14
     638:	df 90       	pop	r13
     63a:	cf 90       	pop	r12
     63c:	bf 90       	pop	r11
     63e:	af 90       	pop	r10
     640:	9f 90       	pop	r9
     642:	8f 90       	pop	r8
     644:	7f 90       	pop	r7
     646:	6f 90       	pop	r6
     648:	5f 90       	pop	r5
     64a:	4f 90       	pop	r4
     64c:	3f 90       	pop	r3
     64e:	2f 90       	pop	r2
     650:	1f 90       	pop	r1
     652:	0f 90       	pop	r0
     654:	0f be       	out	0x3f, r0	; 63
     656:	0f 90       	pop	r0

	asm volatile ( "ret" );
     658:	08 95       	ret

0000065a <__vector_14>:
	 */
	
	void TCC0_OVF_vect( void ) __attribute__ ( ( signal, naked ) );
	void TCC0_OVF_vect( void )
	{
		vPortYieldFromTick();
     65a:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     65e:	18 95       	reti

00000660 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     660:	cf 93       	push	r28
     662:	df 93       	push	r29
     664:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     666:	0e 94 7d 05 	call	0xafa	; 0xafa <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     66a:	80 91 cc 22 	lds	r24, 0x22CC
     66e:	90 91 cd 22 	lds	r25, 0x22CD
     672:	89 2b       	or	r24, r25
     674:	31 f4       	brne	.+12     	; 0x682 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     676:	81 ed       	ldi	r24, 0xD1	; 209
     678:	92 e2       	ldi	r25, 0x22	; 34
     67a:	80 93 cc 22 	sts	0x22CC, r24
     67e:	90 93 cd 22 	sts	0x22CD, r25
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     682:	20 91 ce 22 	lds	r18, 0x22CE
     686:	30 91 cf 22 	lds	r19, 0x22CF
     68a:	ce 01       	movw	r24, r28
     68c:	82 0f       	add	r24, r18
     68e:	93 1f       	adc	r25, r19
     690:	8f 3f       	cpi	r24, 0xFF	; 255
     692:	4f e6       	ldi	r20, 0x6F	; 111
     694:	94 07       	cpc	r25, r20
     696:	70 f4       	brcc	.+28     	; 0x6b4 <pvPortMalloc+0x54>
     698:	28 17       	cp	r18, r24
     69a:	39 07       	cpc	r19, r25
     69c:	70 f4       	brcc	.+28     	; 0x6ba <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     69e:	c0 91 cc 22 	lds	r28, 0x22CC
     6a2:	d0 91 cd 22 	lds	r29, 0x22CD
     6a6:	c2 0f       	add	r28, r18
     6a8:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     6aa:	80 93 ce 22 	sts	0x22CE, r24
     6ae:	90 93 cf 22 	sts	0x22CF, r25
     6b2:	05 c0       	rjmp	.+10     	; 0x6be <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6b4:	c0 e0       	ldi	r28, 0x00	; 0
     6b6:	d0 e0       	ldi	r29, 0x00	; 0
     6b8:	02 c0       	rjmp	.+4      	; 0x6be <pvPortMalloc+0x5e>
     6ba:	c0 e0       	ldi	r28, 0x00	; 0
     6bc:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6be:	0e 94 3d 06 	call	0xc7a	; 0xc7a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6c2:	ce 01       	movw	r24, r28
     6c4:	df 91       	pop	r29
     6c6:	cf 91       	pop	r28
     6c8:	08 95       	ret

000006ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6ca:	08 95       	ret

000006cc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6cc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ce:	03 96       	adiw	r24, 0x03	; 3
     6d0:	81 83       	std	Z+1, r24	; 0x01
     6d2:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6d4:	2f ef       	ldi	r18, 0xFF	; 255
     6d6:	3f ef       	ldi	r19, 0xFF	; 255
     6d8:	23 83       	std	Z+3, r18	; 0x03
     6da:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6dc:	85 83       	std	Z+5, r24	; 0x05
     6de:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6e0:	87 83       	std	Z+7, r24	; 0x07
     6e2:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6e4:	10 82       	st	Z, r1
     6e6:	08 95       	ret

000006e8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6e8:	fc 01       	movw	r30, r24
     6ea:	10 86       	std	Z+8, r1	; 0x08
     6ec:	11 86       	std	Z+9, r1	; 0x09
     6ee:	08 95       	ret

000006f0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	9c 01       	movw	r18, r24
     6f6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6f8:	dc 01       	movw	r26, r24
     6fa:	11 96       	adiw	r26, 0x01	; 1
     6fc:	cd 91       	ld	r28, X+
     6fe:	dc 91       	ld	r29, X
     700:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     702:	c2 83       	std	Z+2, r28	; 0x02
     704:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     706:	8c 81       	ldd	r24, Y+4	; 0x04
     708:	9d 81       	ldd	r25, Y+5	; 0x05
     70a:	84 83       	std	Z+4, r24	; 0x04
     70c:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     70e:	8c 81       	ldd	r24, Y+4	; 0x04
     710:	9d 81       	ldd	r25, Y+5	; 0x05
     712:	dc 01       	movw	r26, r24
     714:	12 96       	adiw	r26, 0x02	; 2
     716:	6d 93       	st	X+, r22
     718:	7c 93       	st	X, r23
     71a:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
     71c:	6c 83       	std	Y+4, r22	; 0x04
     71e:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     720:	20 87       	std	Z+8, r18	; 0x08
     722:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
     724:	f9 01       	movw	r30, r18
     726:	80 81       	ld	r24, Z
     728:	8f 5f       	subi	r24, 0xFF	; 255
     72a:	80 83       	st	Z, r24
}
     72c:	df 91       	pop	r29
     72e:	cf 91       	pop	r28
     730:	08 95       	ret

00000732 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     738:	48 81       	ld	r20, Y
     73a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     73c:	4f 3f       	cpi	r20, 0xFF	; 255
     73e:	2f ef       	ldi	r18, 0xFF	; 255
     740:	52 07       	cpc	r21, r18
     742:	21 f4       	brne	.+8      	; 0x74c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     744:	fc 01       	movw	r30, r24
     746:	a7 81       	ldd	r26, Z+7	; 0x07
     748:	b0 85       	ldd	r27, Z+8	; 0x08
     74a:	0d c0       	rjmp	.+26     	; 0x766 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     74c:	dc 01       	movw	r26, r24
     74e:	13 96       	adiw	r26, 0x03	; 3
     750:	01 c0       	rjmp	.+2      	; 0x754 <vListInsert+0x22>
     752:	df 01       	movw	r26, r30
     754:	12 96       	adiw	r26, 0x02	; 2
     756:	ed 91       	ld	r30, X+
     758:	fc 91       	ld	r31, X
     75a:	13 97       	sbiw	r26, 0x03	; 3
     75c:	20 81       	ld	r18, Z
     75e:	31 81       	ldd	r19, Z+1	; 0x01
     760:	42 17       	cp	r20, r18
     762:	53 07       	cpc	r21, r19
     764:	b0 f7       	brcc	.-20     	; 0x752 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     766:	12 96       	adiw	r26, 0x02	; 2
     768:	ed 91       	ld	r30, X+
     76a:	fc 91       	ld	r31, X
     76c:	13 97       	sbiw	r26, 0x03	; 3
     76e:	ea 83       	std	Y+2, r30	; 0x02
     770:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     772:	c4 83       	std	Z+4, r28	; 0x04
     774:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
     776:	ac 83       	std	Y+4, r26	; 0x04
     778:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
     77a:	12 96       	adiw	r26, 0x02	; 2
     77c:	cd 93       	st	X+, r28
     77e:	dc 93       	st	X, r29
     780:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     782:	88 87       	std	Y+8, r24	; 0x08
     784:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
     786:	fc 01       	movw	r30, r24
     788:	20 81       	ld	r18, Z
     78a:	2f 5f       	subi	r18, 0xFF	; 255
     78c:	20 83       	st	Z, r18
}
     78e:	df 91       	pop	r29
     790:	cf 91       	pop	r28
     792:	08 95       	ret

00000794 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
     798:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     79a:	a0 85       	ldd	r26, Z+8	; 0x08
     79c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     79e:	c2 81       	ldd	r28, Z+2	; 0x02
     7a0:	d3 81       	ldd	r29, Z+3	; 0x03
     7a2:	84 81       	ldd	r24, Z+4	; 0x04
     7a4:	95 81       	ldd	r25, Z+5	; 0x05
     7a6:	8c 83       	std	Y+4, r24	; 0x04
     7a8:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7aa:	c4 81       	ldd	r28, Z+4	; 0x04
     7ac:	d5 81       	ldd	r29, Z+5	; 0x05
     7ae:	82 81       	ldd	r24, Z+2	; 0x02
     7b0:	93 81       	ldd	r25, Z+3	; 0x03
     7b2:	8a 83       	std	Y+2, r24	; 0x02
     7b4:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7b6:	11 96       	adiw	r26, 0x01	; 1
     7b8:	cd 91       	ld	r28, X+
     7ba:	dc 91       	ld	r29, X
     7bc:	12 97       	sbiw	r26, 0x02	; 2
     7be:	ce 17       	cp	r28, r30
     7c0:	df 07       	cpc	r29, r31
     7c2:	31 f4       	brne	.+12     	; 0x7d0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7c4:	8c 81       	ldd	r24, Y+4	; 0x04
     7c6:	9d 81       	ldd	r25, Y+5	; 0x05
     7c8:	11 96       	adiw	r26, 0x01	; 1
     7ca:	8d 93       	st	X+, r24
     7cc:	9c 93       	st	X, r25
     7ce:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7d0:	10 86       	std	Z+8, r1	; 0x08
     7d2:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
     7d4:	8c 91       	ld	r24, X
     7d6:	81 50       	subi	r24, 0x01	; 1
     7d8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7da:	df 91       	pop	r29
     7dc:	cf 91       	pop	r28
     7de:	08 95       	ret

000007e0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     7e0:	e0 91 ef 92 	lds	r30, 0x92EF
     7e4:	f0 91 f0 92 	lds	r31, 0x92F0
     7e8:	80 81       	ld	r24, Z
     7ea:	81 11       	cpse	r24, r1
     7ec:	07 c0       	rjmp	.+14     	; 0x7fc <prvResetNextTaskUnblockTime+0x1c>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     7ee:	8f ef       	ldi	r24, 0xFF	; 255
     7f0:	9f ef       	ldi	r25, 0xFF	; 255
     7f2:	80 93 89 22 	sts	0x2289, r24
     7f6:	90 93 8a 22 	sts	0x228A, r25
     7fa:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     7fc:	e0 91 ef 92 	lds	r30, 0x92EF
     800:	f0 91 f0 92 	lds	r31, 0x92F0
     804:	05 80       	ldd	r0, Z+5	; 0x05
     806:	f6 81       	ldd	r31, Z+6	; 0x06
     808:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     80a:	06 80       	ldd	r0, Z+6	; 0x06
     80c:	f7 81       	ldd	r31, Z+7	; 0x07
     80e:	e0 2d       	mov	r30, r0
     810:	82 81       	ldd	r24, Z+2	; 0x02
     812:	93 81       	ldd	r25, Z+3	; 0x03
     814:	80 93 89 22 	sts	0x2289, r24
     818:	90 93 8a 22 	sts	0x228A, r25
     81c:	08 95       	ret

0000081e <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     824:	e0 91 27 93 	lds	r30, 0x9327
     828:	f0 91 28 93 	lds	r31, 0x9328
     82c:	82 83       	std	Z+2, r24	; 0x02
     82e:	93 83       	std	Z+3, r25	; 0x03

	if( xTimeToWake < xTickCount )
     830:	80 91 d7 92 	lds	r24, 0x92D7
     834:	90 91 d8 92 	lds	r25, 0x92D8
     838:	c8 17       	cp	r28, r24
     83a:	d9 07       	cpc	r29, r25
     83c:	68 f4       	brcc	.+26     	; 0x858 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     83e:	60 91 27 93 	lds	r22, 0x9327
     842:	70 91 28 93 	lds	r23, 0x9328
     846:	80 91 ed 92 	lds	r24, 0x92ED
     84a:	90 91 ee 92 	lds	r25, 0x92EE
     84e:	6e 5f       	subi	r22, 0xFE	; 254
     850:	7f 4f       	sbci	r23, 0xFF	; 255
     852:	0e 94 99 03 	call	0x732	; 0x732 <vListInsert>
     856:	17 c0       	rjmp	.+46     	; 0x886 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     858:	60 91 27 93 	lds	r22, 0x9327
     85c:	70 91 28 93 	lds	r23, 0x9328
     860:	80 91 ef 92 	lds	r24, 0x92EF
     864:	90 91 f0 92 	lds	r25, 0x92F0
     868:	6e 5f       	subi	r22, 0xFE	; 254
     86a:	7f 4f       	sbci	r23, 0xFF	; 255
     86c:	0e 94 99 03 	call	0x732	; 0x732 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     870:	80 91 89 22 	lds	r24, 0x2289
     874:	90 91 8a 22 	lds	r25, 0x228A
     878:	c8 17       	cp	r28, r24
     87a:	d9 07       	cpc	r29, r25
     87c:	20 f4       	brcc	.+8      	; 0x886 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     87e:	c0 93 89 22 	sts	0x2289, r28
     882:	d0 93 8a 22 	sts	0x228A, r29
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     886:	df 91       	pop	r29
     888:	cf 91       	pop	r28
     88a:	08 95       	ret

0000088c <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     88c:	4f 92       	push	r4
     88e:	5f 92       	push	r5
     890:	6f 92       	push	r6
     892:	7f 92       	push	r7
     894:	8f 92       	push	r8
     896:	9f 92       	push	r9
     898:	af 92       	push	r10
     89a:	bf 92       	push	r11
     89c:	cf 92       	push	r12
     89e:	df 92       	push	r13
     8a0:	ef 92       	push	r14
     8a2:	ff 92       	push	r15
     8a4:	0f 93       	push	r16
     8a6:	1f 93       	push	r17
     8a8:	cf 93       	push	r28
     8aa:	df 93       	push	r29
     8ac:	4c 01       	movw	r8, r24
     8ae:	eb 01       	movw	r28, r22
     8b0:	5a 01       	movw	r10, r20
     8b2:	29 01       	movw	r4, r18
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     8b4:	81 e2       	ldi	r24, 0x21	; 33
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	0e 94 30 03 	call	0x660	; 0x660 <pvPortMalloc>
     8bc:	3c 01       	movw	r6, r24

	if( pxNewTCB != NULL )
     8be:	00 97       	sbiw	r24, 0x00	; 0
     8c0:	09 f4       	brne	.+2      	; 0x8c4 <xTaskGenericCreate+0x38>
     8c2:	de c0       	rjmp	.+444    	; 0xa80 <xTaskGenericCreate+0x1f4>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     8c4:	c1 14       	cp	r12, r1
     8c6:	d1 04       	cpc	r13, r1
     8c8:	09 f0       	breq	.+2      	; 0x8cc <xTaskGenericCreate+0x40>
     8ca:	d6 c0       	rjmp	.+428    	; 0xa78 <xTaskGenericCreate+0x1ec>
     8cc:	c5 01       	movw	r24, r10
     8ce:	0e 94 30 03 	call	0x660	; 0x660 <pvPortMalloc>
     8d2:	f3 01       	movw	r30, r6
     8d4:	87 8b       	std	Z+23, r24	; 0x17
     8d6:	90 8f       	std	Z+24, r25	; 0x18

		if( pxNewTCB->pxStack == NULL )
     8d8:	89 2b       	or	r24, r25
     8da:	21 f4       	brne	.+8      	; 0x8e4 <xTaskGenericCreate+0x58>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
     8dc:	c3 01       	movw	r24, r6
     8de:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
     8e2:	ce c0       	rjmp	.+412    	; 0xa80 <xTaskGenericCreate+0x1f4>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     8e4:	f1 e0       	ldi	r31, 0x01	; 1
     8e6:	af 1a       	sub	r10, r31
     8e8:	b1 08       	sbc	r11, r1
     8ea:	f3 01       	movw	r30, r6
     8ec:	87 89       	ldd	r24, Z+23	; 0x17
     8ee:	90 8d       	ldd	r25, Z+24	; 0x18
     8f0:	a8 0e       	add	r10, r24
     8f2:	b9 1e       	adc	r11, r25
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     8f4:	88 81       	ld	r24, Y
     8f6:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     8f8:	88 81       	ld	r24, Y
     8fa:	88 23       	and	r24, r24
     8fc:	81 f0       	breq	.+32     	; 0x91e <xTaskGenericCreate+0x92>
     8fe:	d3 01       	movw	r26, r6
     900:	5a 96       	adiw	r26, 0x1a	; 26
     902:	fe 01       	movw	r30, r28
     904:	31 96       	adiw	r30, 0x01	; 1
     906:	9e 01       	movw	r18, r28
     908:	28 5f       	subi	r18, 0xF8	; 248
     90a:	3f 4f       	sbci	r19, 0xFF	; 255
     90c:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     90e:	81 91       	ld	r24, Z+
     910:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     912:	88 81       	ld	r24, Y
     914:	88 23       	and	r24, r24
     916:	19 f0       	breq	.+6      	; 0x91e <xTaskGenericCreate+0x92>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     918:	e2 17       	cp	r30, r18
     91a:	f3 07       	cpc	r31, r19
     91c:	b9 f7       	brne	.-18     	; 0x90c <xTaskGenericCreate+0x80>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     91e:	f3 01       	movw	r30, r6
     920:	10 a2       	std	Z+32, r1	; 0x20
     922:	10 2f       	mov	r17, r16
     924:	04 30       	cpi	r16, 0x04	; 4
     926:	08 f0       	brcs	.+2      	; 0x92a <xTaskGenericCreate+0x9e>
     928:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     92a:	f3 01       	movw	r30, r6
     92c:	16 8b       	std	Z+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     92e:	e3 01       	movw	r28, r6
     930:	22 96       	adiw	r28, 0x02	; 2
     932:	ce 01       	movw	r24, r28
     934:	0e 94 74 03 	call	0x6e8	; 0x6e8 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     938:	c3 01       	movw	r24, r6
     93a:	0c 96       	adiw	r24, 0x0c	; 12
     93c:	0e 94 74 03 	call	0x6e8	; 0x6e8 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     940:	f3 01       	movw	r30, r6
     942:	60 86       	std	Z+8, r6	; 0x08
     944:	71 86       	std	Z+9, r7	; 0x09

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     946:	84 e0       	ldi	r24, 0x04	; 4
     948:	90 e0       	ldi	r25, 0x00	; 0
     94a:	81 1b       	sub	r24, r17
     94c:	91 09       	sbc	r25, r1
     94e:	84 87       	std	Z+12, r24	; 0x0c
     950:	95 87       	std	Z+13, r25	; 0x0d
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     952:	62 8a       	std	Z+18, r6	; 0x12
     954:	73 8a       	std	Z+19, r7	; 0x13
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     956:	a2 01       	movw	r20, r4
     958:	b4 01       	movw	r22, r8
     95a:	c5 01       	movw	r24, r10
     95c:	0e 94 c8 01 	call	0x390	; 0x390 <pxPortInitialiseStack>
     960:	f3 01       	movw	r30, r6
     962:	80 83       	st	Z, r24
     964:	91 83       	std	Z+1, r25	; 0x01
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     966:	e1 14       	cp	r14, r1
     968:	f1 04       	cpc	r15, r1
     96a:	19 f0       	breq	.+6      	; 0x972 <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     96c:	f7 01       	movw	r30, r14
     96e:	60 82       	st	Z, r6
     970:	71 82       	std	Z+1, r7	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     972:	0f b6       	in	r0, 0x3f	; 63
     974:	f8 94       	cli
     976:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     978:	80 91 d9 92 	lds	r24, 0x92D9
     97c:	8f 5f       	subi	r24, 0xFF	; 255
     97e:	80 93 d9 92 	sts	0x92D9, r24
			if( pxCurrentTCB == NULL )
     982:	80 91 27 93 	lds	r24, 0x9327
     986:	90 91 28 93 	lds	r25, 0x9328
     98a:	89 2b       	or	r24, r25
     98c:	a9 f5       	brne	.+106    	; 0x9f8 <xTaskGenericCreate+0x16c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     98e:	60 92 27 93 	sts	0x9327, r6
     992:	70 92 28 93 	sts	0x9328, r7

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     996:	80 91 d9 92 	lds	r24, 0x92D9
     99a:	81 30       	cpi	r24, 0x01	; 1
     99c:	e1 f5       	brne	.+120    	; 0xa16 <xTaskGenericCreate+0x18a>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     99e:	83 e0       	ldi	r24, 0x03	; 3
     9a0:	93 e9       	ldi	r25, 0x93	; 147
     9a2:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9a6:	8c e0       	ldi	r24, 0x0C	; 12
     9a8:	93 e9       	ldi	r25, 0x93	; 147
     9aa:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9ae:	85 e1       	ldi	r24, 0x15	; 21
     9b0:	93 e9       	ldi	r25, 0x93	; 147
     9b2:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9b6:	8e e1       	ldi	r24, 0x1E	; 30
     9b8:	93 e9       	ldi	r25, 0x93	; 147
     9ba:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     9be:	8a ef       	ldi	r24, 0xFA	; 250
     9c0:	92 e9       	ldi	r25, 0x92	; 146
     9c2:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     9c6:	81 ef       	ldi	r24, 0xF1	; 241
     9c8:	92 e9       	ldi	r25, 0x92	; 146
     9ca:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
	vListInitialise( &xPendingReadyList );
     9ce:	84 ee       	ldi	r24, 0xE4	; 228
     9d0:	92 e9       	ldi	r25, 0x92	; 146
     9d2:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     9d6:	8b ed       	ldi	r24, 0xDB	; 219
     9d8:	92 e9       	ldi	r25, 0x92	; 146
     9da:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     9de:	8a ef       	ldi	r24, 0xFA	; 250
     9e0:	92 e9       	ldi	r25, 0x92	; 146
     9e2:	80 93 ef 92 	sts	0x92EF, r24
     9e6:	90 93 f0 92 	sts	0x92F0, r25
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     9ea:	81 ef       	ldi	r24, 0xF1	; 241
     9ec:	92 e9       	ldi	r25, 0x92	; 146
     9ee:	80 93 ed 92 	sts	0x92ED, r24
     9f2:	90 93 ee 92 	sts	0x92EE, r25
     9f6:	0f c0       	rjmp	.+30     	; 0xa16 <xTaskGenericCreate+0x18a>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     9f8:	80 91 d5 92 	lds	r24, 0x92D5
     9fc:	81 11       	cpse	r24, r1
     9fe:	0b c0       	rjmp	.+22     	; 0xa16 <xTaskGenericCreate+0x18a>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     a00:	e0 91 27 93 	lds	r30, 0x9327
     a04:	f0 91 28 93 	lds	r31, 0x9328
     a08:	86 89       	ldd	r24, Z+22	; 0x16
     a0a:	08 17       	cp	r16, r24
     a0c:	20 f0       	brcs	.+8      	; 0xa16 <xTaskGenericCreate+0x18a>
					{
						pxCurrentTCB = pxNewTCB;
     a0e:	60 92 27 93 	sts	0x9327, r6
     a12:	70 92 28 93 	sts	0x9328, r7
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     a16:	80 91 d1 92 	lds	r24, 0x92D1
     a1a:	8f 5f       	subi	r24, 0xFF	; 255
     a1c:	80 93 d1 92 	sts	0x92D1, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     a20:	f3 01       	movw	r30, r6
     a22:	86 89       	ldd	r24, Z+22	; 0x16
     a24:	90 91 d6 92 	lds	r25, 0x92D6
     a28:	98 17       	cp	r25, r24
     a2a:	10 f4       	brcc	.+4      	; 0xa30 <xTaskGenericCreate+0x1a4>
     a2c:	80 93 d6 92 	sts	0x92D6, r24
     a30:	90 e0       	ldi	r25, 0x00	; 0
     a32:	9c 01       	movw	r18, r24
     a34:	22 0f       	add	r18, r18
     a36:	33 1f       	adc	r19, r19
     a38:	22 0f       	add	r18, r18
     a3a:	33 1f       	adc	r19, r19
     a3c:	22 0f       	add	r18, r18
     a3e:	33 1f       	adc	r19, r19
     a40:	82 0f       	add	r24, r18
     a42:	93 1f       	adc	r25, r19
     a44:	be 01       	movw	r22, r28
     a46:	8d 5f       	subi	r24, 0xFD	; 253
     a48:	9c 46       	sbci	r25, 0x6C	; 108
     a4a:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     a4e:	0f 90       	pop	r0
     a50:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     a52:	80 91 d5 92 	lds	r24, 0x92D5
     a56:	88 23       	and	r24, r24
     a58:	59 f0       	breq	.+22     	; 0xa70 <xTaskGenericCreate+0x1e4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     a5a:	e0 91 27 93 	lds	r30, 0x9327
     a5e:	f0 91 28 93 	lds	r31, 0x9328
     a62:	86 89       	ldd	r24, Z+22	; 0x16
     a64:	80 17       	cp	r24, r16
     a66:	30 f4       	brcc	.+12     	; 0xa74 <xTaskGenericCreate+0x1e8>
			{
				taskYIELD_IF_USING_PREEMPTION();
     a68:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYield>
     a6c:	81 e0       	ldi	r24, 0x01	; 1
     a6e:	09 c0       	rjmp	.+18     	; 0xa82 <xTaskGenericCreate+0x1f6>
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	07 c0       	rjmp	.+14     	; 0xa82 <xTaskGenericCreate+0x1f6>
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	05 c0       	rjmp	.+10     	; 0xa82 <xTaskGenericCreate+0x1f6>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     a78:	fc 01       	movw	r30, r24
     a7a:	c7 8a       	std	Z+23, r12	; 0x17
     a7c:	d0 8e       	std	Z+24, r13	; 0x18
     a7e:	32 cf       	rjmp	.-412    	; 0x8e4 <xTaskGenericCreate+0x58>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     a80:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     a82:	df 91       	pop	r29
     a84:	cf 91       	pop	r28
     a86:	1f 91       	pop	r17
     a88:	0f 91       	pop	r16
     a8a:	ff 90       	pop	r15
     a8c:	ef 90       	pop	r14
     a8e:	df 90       	pop	r13
     a90:	cf 90       	pop	r12
     a92:	bf 90       	pop	r11
     a94:	af 90       	pop	r10
     a96:	9f 90       	pop	r9
     a98:	8f 90       	pop	r8
     a9a:	7f 90       	pop	r7
     a9c:	6f 90       	pop	r6
     a9e:	5f 90       	pop	r5
     aa0:	4f 90       	pop	r4
     aa2:	08 95       	ret

00000aa4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     aa4:	af 92       	push	r10
     aa6:	bf 92       	push	r11
     aa8:	cf 92       	push	r12
     aaa:	df 92       	push	r13
     aac:	ef 92       	push	r14
     aae:	ff 92       	push	r15
     ab0:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     ab2:	a1 2c       	mov	r10, r1
     ab4:	b1 2c       	mov	r11, r1
     ab6:	c1 2c       	mov	r12, r1
     ab8:	d1 2c       	mov	r13, r1
     aba:	e1 2c       	mov	r14, r1
     abc:	f1 2c       	mov	r15, r1
     abe:	00 e0       	ldi	r16, 0x00	; 0
     ac0:	20 e0       	ldi	r18, 0x00	; 0
     ac2:	30 e0       	ldi	r19, 0x00	; 0
     ac4:	45 e5       	ldi	r20, 0x55	; 85
     ac6:	50 e0       	ldi	r21, 0x00	; 0
     ac8:	6c ea       	ldi	r22, 0xAC	; 172
     aca:	72 e2       	ldi	r23, 0x22	; 34
     acc:	8f ed       	ldi	r24, 0xDF	; 223
     ace:	96 e0       	ldi	r25, 0x06	; 6
     ad0:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     ad4:	81 30       	cpi	r24, 0x01	; 1
     ad6:	49 f4       	brne	.+18     	; 0xaea <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     ad8:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     ada:	80 93 d5 92 	sts	0x92D5, r24
		xTickCount = ( TickType_t ) 0U;
     ade:	10 92 d7 92 	sts	0x92D7, r1
     ae2:	10 92 d8 92 	sts	0x92D8, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     ae6:	0e 94 36 02 	call	0x46c	; 0x46c <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     aea:	0f 91       	pop	r16
     aec:	ff 90       	pop	r15
     aee:	ef 90       	pop	r14
     af0:	df 90       	pop	r13
     af2:	cf 90       	pop	r12
     af4:	bf 90       	pop	r11
     af6:	af 90       	pop	r10
     af8:	08 95       	ret

00000afa <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     afa:	80 91 d0 92 	lds	r24, 0x92D0
     afe:	8f 5f       	subi	r24, 0xFF	; 255
     b00:	80 93 d0 92 	sts	0x92D0, r24
     b04:	08 95       	ret

00000b06 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     b06:	df 92       	push	r13
     b08:	ef 92       	push	r14
     b0a:	ff 92       	push	r15
     b0c:	0f 93       	push	r16
     b0e:	1f 93       	push	r17
     b10:	cf 93       	push	r28
     b12:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     b14:	80 91 d0 92 	lds	r24, 0x92D0
     b18:	81 11       	cpse	r24, r1
     b1a:	9a c0       	rjmp	.+308    	; 0xc50 <xTaskIncrementTick+0x14a>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     b1c:	80 91 d7 92 	lds	r24, 0x92D7
     b20:	90 91 d8 92 	lds	r25, 0x92D8
     b24:	01 96       	adiw	r24, 0x01	; 1
     b26:	80 93 d7 92 	sts	0x92D7, r24
     b2a:	90 93 d8 92 	sts	0x92D8, r25

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     b2e:	e0 90 d7 92 	lds	r14, 0x92D7
     b32:	f0 90 d8 92 	lds	r15, 0x92D8

			if( xConstTickCount == ( TickType_t ) 0U )
     b36:	e1 14       	cp	r14, r1
     b38:	f1 04       	cpc	r15, r1
     b3a:	b9 f4       	brne	.+46     	; 0xb6a <xTaskIncrementTick+0x64>
			{
				taskSWITCH_DELAYED_LISTS();
     b3c:	80 91 ef 92 	lds	r24, 0x92EF
     b40:	90 91 f0 92 	lds	r25, 0x92F0
     b44:	20 91 ed 92 	lds	r18, 0x92ED
     b48:	30 91 ee 92 	lds	r19, 0x92EE
     b4c:	20 93 ef 92 	sts	0x92EF, r18
     b50:	30 93 f0 92 	sts	0x92F0, r19
     b54:	80 93 ed 92 	sts	0x92ED, r24
     b58:	90 93 ee 92 	sts	0x92EE, r25
     b5c:	80 91 d2 92 	lds	r24, 0x92D2
     b60:	8f 5f       	subi	r24, 0xFF	; 255
     b62:	80 93 d2 92 	sts	0x92D2, r24
     b66:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     b6a:	80 91 89 22 	lds	r24, 0x2289
     b6e:	90 91 8a 22 	lds	r25, 0x228A
     b72:	e8 16       	cp	r14, r24
     b74:	f9 06       	cpc	r15, r25
     b76:	10 f4       	brcc	.+4      	; 0xb7c <xTaskIncrementTick+0x76>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     b78:	d1 2c       	mov	r13, r1
     b7a:	52 c0       	rjmp	.+164    	; 0xc20 <xTaskIncrementTick+0x11a>
     b7c:	d1 2c       	mov	r13, r1
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b7e:	e0 91 ef 92 	lds	r30, 0x92EF
     b82:	f0 91 f0 92 	lds	r31, 0x92F0
     b86:	90 81       	ld	r25, Z
     b88:	91 11       	cpse	r25, r1
     b8a:	07 c0       	rjmp	.+14     	; 0xb9a <xTaskIncrementTick+0x94>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     b8c:	8f ef       	ldi	r24, 0xFF	; 255
     b8e:	9f ef       	ldi	r25, 0xFF	; 255
     b90:	80 93 89 22 	sts	0x2289, r24
     b94:	90 93 8a 22 	sts	0x228A, r25
						break;
     b98:	43 c0       	rjmp	.+134    	; 0xc20 <xTaskIncrementTick+0x11a>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b9a:	e0 91 ef 92 	lds	r30, 0x92EF
     b9e:	f0 91 f0 92 	lds	r31, 0x92F0
     ba2:	05 80       	ldd	r0, Z+5	; 0x05
     ba4:	f6 81       	ldd	r31, Z+6	; 0x06
     ba6:	e0 2d       	mov	r30, r0
     ba8:	c6 81       	ldd	r28, Z+6	; 0x06
     baa:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     bac:	2a 81       	ldd	r18, Y+2	; 0x02
     bae:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     bb0:	e2 16       	cp	r14, r18
     bb2:	f3 06       	cpc	r15, r19
     bb4:	28 f4       	brcc	.+10     	; 0xbc0 <xTaskIncrementTick+0xba>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     bb6:	20 93 89 22 	sts	0x2289, r18
     bba:	30 93 8a 22 	sts	0x228A, r19
							break;
     bbe:	30 c0       	rjmp	.+96     	; 0xc20 <xTaskIncrementTick+0x11a>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     bc0:	8e 01       	movw	r16, r28
     bc2:	0e 5f       	subi	r16, 0xFE	; 254
     bc4:	1f 4f       	sbci	r17, 0xFF	; 255
     bc6:	c8 01       	movw	r24, r16
     bc8:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     bcc:	8c 89       	ldd	r24, Y+20	; 0x14
     bce:	9d 89       	ldd	r25, Y+21	; 0x15
     bd0:	89 2b       	or	r24, r25
     bd2:	21 f0       	breq	.+8      	; 0xbdc <xTaskIncrementTick+0xd6>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     bd4:	ce 01       	movw	r24, r28
     bd6:	0c 96       	adiw	r24, 0x0c	; 12
     bd8:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     bdc:	2e 89       	ldd	r18, Y+22	; 0x16
     bde:	80 91 d6 92 	lds	r24, 0x92D6
     be2:	82 17       	cp	r24, r18
     be4:	10 f4       	brcc	.+4      	; 0xbea <xTaskIncrementTick+0xe4>
     be6:	20 93 d6 92 	sts	0x92D6, r18
     bea:	30 e0       	ldi	r19, 0x00	; 0
     bec:	c9 01       	movw	r24, r18
     bee:	88 0f       	add	r24, r24
     bf0:	99 1f       	adc	r25, r25
     bf2:	88 0f       	add	r24, r24
     bf4:	99 1f       	adc	r25, r25
     bf6:	88 0f       	add	r24, r24
     bf8:	99 1f       	adc	r25, r25
     bfa:	82 0f       	add	r24, r18
     bfc:	93 1f       	adc	r25, r19
     bfe:	b8 01       	movw	r22, r16
     c00:	8d 5f       	subi	r24, 0xFD	; 253
     c02:	9c 46       	sbci	r25, 0x6C	; 108
     c04:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c08:	e0 91 27 93 	lds	r30, 0x9327
     c0c:	f0 91 28 93 	lds	r31, 0x9328
     c10:	9e 89       	ldd	r25, Y+22	; 0x16
     c12:	86 89       	ldd	r24, Z+22	; 0x16
     c14:	98 17       	cp	r25, r24
     c16:	08 f4       	brcc	.+2      	; 0xc1a <xTaskIncrementTick+0x114>
     c18:	b2 cf       	rjmp	.-156    	; 0xb7e <xTaskIncrementTick+0x78>
							{
								xSwitchRequired = pdTRUE;
     c1a:	dd 24       	eor	r13, r13
     c1c:	d3 94       	inc	r13
     c1e:	af cf       	rjmp	.-162    	; 0xb7e <xTaskIncrementTick+0x78>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     c20:	e0 91 27 93 	lds	r30, 0x9327
     c24:	f0 91 28 93 	lds	r31, 0x9328
     c28:	86 89       	ldd	r24, Z+22	; 0x16
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	fc 01       	movw	r30, r24
     c2e:	ee 0f       	add	r30, r30
     c30:	ff 1f       	adc	r31, r31
     c32:	ee 0f       	add	r30, r30
     c34:	ff 1f       	adc	r31, r31
     c36:	ee 0f       	add	r30, r30
     c38:	ff 1f       	adc	r31, r31
     c3a:	8e 0f       	add	r24, r30
     c3c:	9f 1f       	adc	r25, r31
     c3e:	fc 01       	movw	r30, r24
     c40:	ed 5f       	subi	r30, 0xFD	; 253
     c42:	fc 46       	sbci	r31, 0x6C	; 108
     c44:	80 81       	ld	r24, Z
     c46:	82 30       	cpi	r24, 0x02	; 2
     c48:	48 f0       	brcs	.+18     	; 0xc5c <xTaskIncrementTick+0x156>
			{
				xSwitchRequired = pdTRUE;
     c4a:	dd 24       	eor	r13, r13
     c4c:	d3 94       	inc	r13
     c4e:	06 c0       	rjmp	.+12     	; 0xc5c <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     c50:	80 91 d4 92 	lds	r24, 0x92D4
     c54:	8f 5f       	subi	r24, 0xFF	; 255
     c56:	80 93 d4 92 	sts	0x92D4, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     c5a:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     c5c:	80 91 d3 92 	lds	r24, 0x92D3
     c60:	88 23       	and	r24, r24
     c62:	11 f0       	breq	.+4      	; 0xc68 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
     c64:	dd 24       	eor	r13, r13
     c66:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c68:	8d 2d       	mov	r24, r13
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	1f 91       	pop	r17
     c70:	0f 91       	pop	r16
     c72:	ff 90       	pop	r15
     c74:	ef 90       	pop	r14
     c76:	df 90       	pop	r13
     c78:	08 95       	ret

00000c7a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c7a:	df 92       	push	r13
     c7c:	ef 92       	push	r14
     c7e:	ff 92       	push	r15
     c80:	0f 93       	push	r16
     c82:	1f 93       	push	r17
     c84:	cf 93       	push	r28
     c86:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c88:	0f b6       	in	r0, 0x3f	; 63
     c8a:	f8 94       	cli
     c8c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c8e:	80 91 d0 92 	lds	r24, 0x92D0
     c92:	81 50       	subi	r24, 0x01	; 1
     c94:	80 93 d0 92 	sts	0x92D0, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c98:	80 91 d0 92 	lds	r24, 0x92D0
     c9c:	81 11       	cpse	r24, r1
     c9e:	62 c0       	rjmp	.+196    	; 0xd64 <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     ca0:	80 91 d9 92 	lds	r24, 0x92D9
     ca4:	81 11       	cpse	r24, r1
     ca6:	33 c0       	rjmp	.+102    	; 0xd0e <xTaskResumeAll+0x94>
     ca8:	60 c0       	rjmp	.+192    	; 0xd6a <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     caa:	d7 01       	movw	r26, r14
     cac:	15 96       	adiw	r26, 0x05	; 5
     cae:	ed 91       	ld	r30, X+
     cb0:	fc 91       	ld	r31, X
     cb2:	16 97       	sbiw	r26, 0x06	; 6
     cb4:	c6 81       	ldd	r28, Z+6	; 0x06
     cb6:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     cb8:	ce 01       	movw	r24, r28
     cba:	0c 96       	adiw	r24, 0x0c	; 12
     cbc:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     cc0:	8e 01       	movw	r16, r28
     cc2:	0e 5f       	subi	r16, 0xFE	; 254
     cc4:	1f 4f       	sbci	r17, 0xFF	; 255
     cc6:	c8 01       	movw	r24, r16
     cc8:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     ccc:	2e 89       	ldd	r18, Y+22	; 0x16
     cce:	80 91 d6 92 	lds	r24, 0x92D6
     cd2:	82 17       	cp	r24, r18
     cd4:	10 f4       	brcc	.+4      	; 0xcda <xTaskResumeAll+0x60>
     cd6:	20 93 d6 92 	sts	0x92D6, r18
     cda:	30 e0       	ldi	r19, 0x00	; 0
     cdc:	c9 01       	movw	r24, r18
     cde:	88 0f       	add	r24, r24
     ce0:	99 1f       	adc	r25, r25
     ce2:	88 0f       	add	r24, r24
     ce4:	99 1f       	adc	r25, r25
     ce6:	88 0f       	add	r24, r24
     ce8:	99 1f       	adc	r25, r25
     cea:	82 0f       	add	r24, r18
     cec:	93 1f       	adc	r25, r19
     cee:	b8 01       	movw	r22, r16
     cf0:	8d 5f       	subi	r24, 0xFD	; 253
     cf2:	9c 46       	sbci	r25, 0x6C	; 108
     cf4:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     cf8:	e0 91 27 93 	lds	r30, 0x9327
     cfc:	f0 91 28 93 	lds	r31, 0x9328
     d00:	9e 89       	ldd	r25, Y+22	; 0x16
     d02:	86 89       	ldd	r24, Z+22	; 0x16
     d04:	98 17       	cp	r25, r24
     d06:	58 f0       	brcs	.+22     	; 0xd1e <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
     d08:	d0 92 d3 92 	sts	0x92D3, r13
     d0c:	08 c0       	rjmp	.+16     	; 0xd1e <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     d0e:	0f 2e       	mov	r0, r31
     d10:	f4 ee       	ldi	r31, 0xE4	; 228
     d12:	ef 2e       	mov	r14, r31
     d14:	f2 e9       	ldi	r31, 0x92	; 146
     d16:	ff 2e       	mov	r15, r31
     d18:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     d1a:	dd 24       	eor	r13, r13
     d1c:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     d1e:	f7 01       	movw	r30, r14
     d20:	80 81       	ld	r24, Z
     d22:	81 11       	cpse	r24, r1
     d24:	c2 cf       	rjmp	.-124    	; 0xcaa <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     d26:	80 91 d4 92 	lds	r24, 0x92D4
     d2a:	88 23       	and	r24, r24
     d2c:	99 f0       	breq	.+38     	; 0xd54 <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     d2e:	80 91 d4 92 	lds	r24, 0x92D4
     d32:	88 23       	and	r24, r24
     d34:	79 f0       	breq	.+30     	; 0xd54 <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     d36:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     d38:	0e 94 83 05 	call	0xb06	; 0xb06 <xTaskIncrementTick>
     d3c:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     d3e:	c0 93 d3 92 	sts	0x92D3, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     d42:	80 91 d4 92 	lds	r24, 0x92D4
     d46:	81 50       	subi	r24, 0x01	; 1
     d48:	80 93 d4 92 	sts	0x92D4, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     d4c:	80 91 d4 92 	lds	r24, 0x92D4
     d50:	81 11       	cpse	r24, r1
     d52:	f2 cf       	rjmp	.-28     	; 0xd38 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     d54:	80 91 d3 92 	lds	r24, 0x92D3
     d58:	81 30       	cpi	r24, 0x01	; 1
     d5a:	31 f4       	brne	.+12     	; 0xd68 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     d5c:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     d60:	81 e0       	ldi	r24, 0x01	; 1
     d62:	03 c0       	rjmp	.+6      	; 0xd6a <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     d64:	80 e0       	ldi	r24, 0x00	; 0
     d66:	01 c0       	rjmp	.+2      	; 0xd6a <xTaskResumeAll+0xf0>
     d68:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     d6a:	0f 90       	pop	r0
     d6c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d6e:	df 91       	pop	r29
     d70:	cf 91       	pop	r28
     d72:	1f 91       	pop	r17
     d74:	0f 91       	pop	r16
     d76:	ff 90       	pop	r15
     d78:	ef 90       	pop	r14
     d7a:	df 90       	pop	r13
     d7c:	08 95       	ret

00000d7e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     d7e:	cf 93       	push	r28
     d80:	df 93       	push	r29
     d82:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     d84:	89 2b       	or	r24, r25
     d86:	b1 f0       	breq	.+44     	; 0xdb4 <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     d88:	0e 94 7d 05 	call	0xafa	; 0xafa <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     d8c:	80 91 d7 92 	lds	r24, 0x92D7
     d90:	90 91 d8 92 	lds	r25, 0x92D8
     d94:	c8 0f       	add	r28, r24
     d96:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     d98:	80 91 27 93 	lds	r24, 0x9327
     d9c:	90 91 28 93 	lds	r25, 0x9328
     da0:	02 96       	adiw	r24, 0x02	; 2
     da2:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     da6:	ce 01       	movw	r24, r28
     da8:	0e 94 0f 04 	call	0x81e	; 0x81e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     dac:	0e 94 3d 06 	call	0xc7a	; 0xc7a <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     db0:	81 11       	cpse	r24, r1
     db2:	02 c0       	rjmp	.+4      	; 0xdb8 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
     db4:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	08 95       	ret

00000dbe <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     dbe:	0b ed       	ldi	r16, 0xDB	; 219
     dc0:	12 e9       	ldi	r17, 0x92	; 146
     dc2:	29 c0       	rjmp	.+82     	; 0xe16 <prvIdleTask+0x58>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     dc4:	0e 94 7d 05 	call	0xafa	; 0xafa <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     dc8:	d8 01       	movw	r26, r16
     dca:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
     dcc:	0e 94 3d 06 	call	0xc7a	; 0xc7a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     dd0:	cc 23       	and	r28, r28
     dd2:	09 f1       	breq	.+66     	; 0xe16 <prvIdleTask+0x58>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     dd4:	0f b6       	in	r0, 0x3f	; 63
     dd6:	f8 94       	cli
     dd8:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     dda:	d8 01       	movw	r26, r16
     ddc:	15 96       	adiw	r26, 0x05	; 5
     dde:	ed 91       	ld	r30, X+
     de0:	fc 91       	ld	r31, X
     de2:	16 97       	sbiw	r26, 0x06	; 6
     de4:	c6 81       	ldd	r28, Z+6	; 0x06
     de6:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     de8:	ce 01       	movw	r24, r28
     dea:	02 96       	adiw	r24, 0x02	; 2
     dec:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
					--uxCurrentNumberOfTasks;
     df0:	80 91 d9 92 	lds	r24, 0x92D9
     df4:	81 50       	subi	r24, 0x01	; 1
     df6:	80 93 d9 92 	sts	0x92D9, r24
					--uxTasksDeleted;
     dfa:	80 91 da 92 	lds	r24, 0x92DA
     dfe:	81 50       	subi	r24, 0x01	; 1
     e00:	80 93 da 92 	sts	0x92DA, r24
				}
				taskEXIT_CRITICAL();
     e04:	0f 90       	pop	r0
     e06:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
     e08:	8f 89       	ldd	r24, Y+23	; 0x17
     e0a:	98 8d       	ldd	r25, Y+24	; 0x18
     e0c:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
		vPortFree( pxTCB );
     e10:	ce 01       	movw	r24, r28
     e12:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
     e16:	80 91 da 92 	lds	r24, 0x92DA
     e1a:	81 11       	cpse	r24, r1
     e1c:	d3 cf       	rjmp	.-90     	; 0xdc4 <prvIdleTask+0x6>
     e1e:	fb cf       	rjmp	.-10     	; 0xe16 <prvIdleTask+0x58>

00000e20 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     e20:	80 91 d0 92 	lds	r24, 0x92D0
     e24:	88 23       	and	r24, r24
     e26:	21 f0       	breq	.+8      	; 0xe30 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     e28:	81 e0       	ldi	r24, 0x01	; 1
     e2a:	80 93 d3 92 	sts	0x92D3, r24
     e2e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     e30:	10 92 d3 92 	sts	0x92D3, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     e34:	80 91 d6 92 	lds	r24, 0x92D6
     e38:	90 e0       	ldi	r25, 0x00	; 0
     e3a:	fc 01       	movw	r30, r24
     e3c:	ee 0f       	add	r30, r30
     e3e:	ff 1f       	adc	r31, r31
     e40:	ee 0f       	add	r30, r30
     e42:	ff 1f       	adc	r31, r31
     e44:	ee 0f       	add	r30, r30
     e46:	ff 1f       	adc	r31, r31
     e48:	8e 0f       	add	r24, r30
     e4a:	9f 1f       	adc	r25, r31
     e4c:	fc 01       	movw	r30, r24
     e4e:	ed 5f       	subi	r30, 0xFD	; 253
     e50:	fc 46       	sbci	r31, 0x6C	; 108
     e52:	80 81       	ld	r24, Z
     e54:	81 11       	cpse	r24, r1
     e56:	17 c0       	rjmp	.+46     	; 0xe86 <vTaskSwitchContext+0x66>
     e58:	80 91 d6 92 	lds	r24, 0x92D6
     e5c:	81 50       	subi	r24, 0x01	; 1
     e5e:	80 93 d6 92 	sts	0x92D6, r24
     e62:	80 91 d6 92 	lds	r24, 0x92D6
     e66:	90 e0       	ldi	r25, 0x00	; 0
     e68:	fc 01       	movw	r30, r24
     e6a:	ee 0f       	add	r30, r30
     e6c:	ff 1f       	adc	r31, r31
     e6e:	ee 0f       	add	r30, r30
     e70:	ff 1f       	adc	r31, r31
     e72:	ee 0f       	add	r30, r30
     e74:	ff 1f       	adc	r31, r31
     e76:	8e 0f       	add	r24, r30
     e78:	9f 1f       	adc	r25, r31
     e7a:	fc 01       	movw	r30, r24
     e7c:	ed 5f       	subi	r30, 0xFD	; 253
     e7e:	fc 46       	sbci	r31, 0x6C	; 108
     e80:	80 81       	ld	r24, Z
     e82:	88 23       	and	r24, r24
     e84:	49 f3       	breq	.-46     	; 0xe58 <vTaskSwitchContext+0x38>
     e86:	80 91 d6 92 	lds	r24, 0x92D6
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	9c 01       	movw	r18, r24
     e8e:	22 0f       	add	r18, r18
     e90:	33 1f       	adc	r19, r19
     e92:	22 0f       	add	r18, r18
     e94:	33 1f       	adc	r19, r19
     e96:	22 0f       	add	r18, r18
     e98:	33 1f       	adc	r19, r19
     e9a:	28 0f       	add	r18, r24
     e9c:	39 1f       	adc	r19, r25
     e9e:	d9 01       	movw	r26, r18
     ea0:	ad 5f       	subi	r26, 0xFD	; 253
     ea2:	bc 46       	sbci	r27, 0x6C	; 108
     ea4:	11 96       	adiw	r26, 0x01	; 1
     ea6:	ed 91       	ld	r30, X+
     ea8:	fc 91       	ld	r31, X
     eaa:	12 97       	sbiw	r26, 0x02	; 2
     eac:	02 80       	ldd	r0, Z+2	; 0x02
     eae:	f3 81       	ldd	r31, Z+3	; 0x03
     eb0:	e0 2d       	mov	r30, r0
     eb2:	11 96       	adiw	r26, 0x01	; 1
     eb4:	ed 93       	st	X+, r30
     eb6:	fc 93       	st	X, r31
     eb8:	12 97       	sbiw	r26, 0x02	; 2
     eba:	2a 5f       	subi	r18, 0xFA	; 250
     ebc:	3c 46       	sbci	r19, 0x6C	; 108
     ebe:	e2 17       	cp	r30, r18
     ec0:	f3 07       	cpc	r31, r19
     ec2:	29 f4       	brne	.+10     	; 0xece <vTaskSwitchContext+0xae>
     ec4:	22 81       	ldd	r18, Z+2	; 0x02
     ec6:	33 81       	ldd	r19, Z+3	; 0x03
     ec8:	fd 01       	movw	r30, r26
     eca:	21 83       	std	Z+1, r18	; 0x01
     ecc:	32 83       	std	Z+2, r19	; 0x02
     ece:	fc 01       	movw	r30, r24
     ed0:	ee 0f       	add	r30, r30
     ed2:	ff 1f       	adc	r31, r31
     ed4:	ee 0f       	add	r30, r30
     ed6:	ff 1f       	adc	r31, r31
     ed8:	ee 0f       	add	r30, r30
     eda:	ff 1f       	adc	r31, r31
     edc:	8e 0f       	add	r24, r30
     ede:	9f 1f       	adc	r25, r31
     ee0:	fc 01       	movw	r30, r24
     ee2:	ed 5f       	subi	r30, 0xFD	; 253
     ee4:	fc 46       	sbci	r31, 0x6C	; 108
     ee6:	01 80       	ldd	r0, Z+1	; 0x01
     ee8:	f2 81       	ldd	r31, Z+2	; 0x02
     eea:	e0 2d       	mov	r30, r0
     eec:	86 81       	ldd	r24, Z+6	; 0x06
     eee:	97 81       	ldd	r25, Z+7	; 0x07
     ef0:	80 93 27 93 	sts	0x9327, r24
     ef4:	90 93 28 93 	sts	0x9328, r25
     ef8:	08 95       	ret

00000efa <USBThread>:

	while(1){

		// want CDC and USB functions to run without interruption but
		// with interrupts enabled so ENTER/EXIT_CRITICAL won't work
		vTaskSuspendAll();
     efa:	0e 94 7d 05 	call	0xafa	; 0xafa <vTaskSuspendAll>
		CDC_Device_USBTask(&VirtualSerial_CDC_Interface);
     efe:	8b e8       	ldi	r24, 0x8B	; 139
     f00:	92 e2       	ldi	r25, 0x22	; 34
     f02:	0e 94 df 0b 	call	0x17be	; 0x17be <CDC_Device_USBTask>
		USB_USBTask();
     f06:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <USB_USBTask>
		xTaskResumeAll();
     f0a:	0e 94 3d 06 	call	0xc7a	; 0xc7a <xTaskResumeAll>
		vTaskDelay((portTickType) 1 );
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	0e 94 bf 06 	call	0xd7e	; 0xd7e <vTaskDelay>
	}
     f16:	f1 cf       	rjmp	.-30     	; 0xefa <USBThread>

00000f18 <thread_2>:
}


void thread_2( void *pvParameters ){
	while(1){
		vTaskDelay(100);
     f18:	84 e6       	ldi	r24, 0x64	; 100
     f1a:	90 e0       	ldi	r25, 0x00	; 0
     f1c:	0e 94 bf 06 	call	0xd7e	; 0xd7e <vTaskDelay>
		DigitalPin_ToggleValue(&led2);
     f20:	86 ea       	ldi	r24, 0xA6	; 166
     f22:	92 e2       	ldi	r25, 0x22	; 34
     f24:	0e 94 6f 0a 	call	0x14de	; 0x14de <DigitalPin_ToggleValue>
	}
     f28:	f7 cf       	rjmp	.-18     	; 0xf18 <thread_2>

00000f2a <thread_1>:

	uint8_t i =0;
	while(1){
		//xQueueSend( xQueue,( void * ) &i,( TickType_t ) 10 );
		i++;
		vTaskDelay(500);
     f2a:	84 ef       	ldi	r24, 0xF4	; 244
     f2c:	91 e0       	ldi	r25, 0x01	; 1
     f2e:	0e 94 bf 06 	call	0xd7e	; 0xd7e <vTaskDelay>
		DigitalPin_ToggleValue(&led);
     f32:	89 ea       	ldi	r24, 0xA9	; 169
     f34:	92 e2       	ldi	r25, 0x22	; 34
     f36:	0e 94 6f 0a 	call	0x14de	; 0x14de <DigitalPin_ToggleValue>
		
		vTaskSuspendAll();
     f3a:	0e 94 7d 05 	call	0xafa	; 0xafa <vTaskSuspendAll>
		fprintf(&USBSerialStream, "fuck you\r\n");
     f3e:	29 e2       	ldi	r18, 0x29	; 41
     f40:	33 e9       	ldi	r19, 0x93	; 147
     f42:	4a e0       	ldi	r20, 0x0A	; 10
     f44:	50 e0       	ldi	r21, 0x00	; 0
     f46:	61 e0       	ldi	r22, 0x01	; 1
     f48:	70 e0       	ldi	r23, 0x00	; 0
     f4a:	81 eb       	ldi	r24, 0xB1	; 177
     f4c:	92 e2       	ldi	r25, 0x22	; 34
     f4e:	0e 94 99 13 	call	0x2732	; 0x2732 <fwrite>
		xTaskResumeAll();
     f52:	0e 94 3d 06 	call	0xc7a	; 0xc7a <xTaskResumeAll>
		
		
	}
     f56:	e9 cf       	rjmp	.-46     	; 0xf2a <thread_1>

00000f58 <usart_spi_transmit_receive>:
 *
 * @param usart
 * @param txdata
 * @return data received from slave
 */
uint8_t usart_spi_transmit_receive(USART_t * usart,uint8_t txdata){
     f58:	fc 01       	movw	r30, r24
	
	while ((usart->STATUS & USART_DREIF_bm) == 0);
     f5a:	81 81       	ldd	r24, Z+1	; 0x01
     f5c:	85 ff       	sbrs	r24, 5
     f5e:	fd cf       	rjmp	.-6      	; 0xf5a <usart_spi_transmit_receive+0x2>
	usart->DATA = txdata;
     f60:	60 83       	st	Z, r22
	while((usart->STATUS & USART_TXCIF_bm) == 0);
     f62:	81 81       	ldd	r24, Z+1	; 0x01
     f64:	86 ff       	sbrs	r24, 6
     f66:	fd cf       	rjmp	.-6      	; 0xf62 <usart_spi_transmit_receive+0xa>
	(usart)->STATUS = USART_TXCIF_bm;
     f68:	80 e4       	ldi	r24, 0x40	; 64
     f6a:	81 83       	std	Z+1, r24	; 0x01
	return (usart)->DATA;
     f6c:	80 81       	ld	r24, Z
}
     f6e:	08 95       	ret

00000f70 <ssd1306_write_command>:
 * data write function is called based on the selected interface.
 *
 * \param command the command to write
 */
static void ssd1306_write_command(uint8_t command)
{
     f70:	1f 93       	push	r17
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
	port_out_value_clear_mask(&PORTF,(1<<3));//select device
     f76:	c0 ea       	ldi	r28, 0xA0	; 160
     f78:	d6 e0       	ldi	r29, 0x06	; 6
     f7a:	18 e0       	ldi	r17, 0x08	; 8
     f7c:	1e 83       	std	Y+6, r17	; 0x06
	port_out_value_clear_mask(&PORTD,(1<<0));//select command
     f7e:	e0 e6       	ldi	r30, 0x60	; 96
     f80:	f6 e0       	ldi	r31, 0x06	; 6
     f82:	91 e0       	ldi	r25, 0x01	; 1
     f84:	96 83       	std	Z+6, r25	; 0x06
	ssd1306_sel_cmd() ;
     f86:	96 83       	std	Z+6, r25	; 0x06
	usart_spi_transmit_receive(&USARTD0, command);//transmit
     f88:	68 2f       	mov	r22, r24
     f8a:	80 ea       	ldi	r24, 0xA0	; 160
     f8c:	99 e0       	ldi	r25, 0x09	; 9
     f8e:	0e 94 ac 07 	call	0xf58	; 0xf58 <usart_spi_transmit_receive>
	port_out_value_set_mask(&PORTF,(1<<3));//deselect device
     f92:	1d 83       	std	Y+5, r17	; 0x05
	
}
     f94:	df 91       	pop	r29
     f96:	cf 91       	pop	r28
     f98:	1f 91       	pop	r17
     f9a:	08 95       	ret

00000f9c <ssd1306_write_data>:
 * data write function is called based on the selected interface.
 *
 * \param data the data to write
 */
void ssd1306_write_data(uint8_t data)
{
     f9c:	ef 92       	push	r14
     f9e:	ff 92       	push	r15
     fa0:	0f 93       	push	r16
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
	
	port_out_value_clear_mask(&PORTF,(1<<3));//select device
     fa8:	c0 ea       	ldi	r28, 0xA0	; 160
     faa:	d6 e0       	ldi	r29, 0x06	; 6
     fac:	18 e0       	ldi	r17, 0x08	; 8
     fae:	1e 83       	std	Y+6, r17	; 0x06
	ssd1306_sel_data() ;
     fb0:	0f 2e       	mov	r0, r31
     fb2:	f0 e6       	ldi	r31, 0x60	; 96
     fb4:	ef 2e       	mov	r14, r31
     fb6:	f6 e0       	ldi	r31, 0x06	; 6
     fb8:	ff 2e       	mov	r15, r31
     fba:	f0 2d       	mov	r31, r0
     fbc:	01 e0       	ldi	r16, 0x01	; 1
     fbe:	f7 01       	movw	r30, r14
     fc0:	05 83       	std	Z+5, r16	; 0x05
	usart_spi_transmit_receive(&USARTD0, data);//transmit
     fc2:	68 2f       	mov	r22, r24
     fc4:	80 ea       	ldi	r24, 0xA0	; 160
     fc6:	99 e0       	ldi	r25, 0x09	; 9
     fc8:	0e 94 ac 07 	call	0xf58	; 0xf58 <usart_spi_transmit_receive>
	ssd1306_sel_cmd();
     fcc:	f7 01       	movw	r30, r14
     fce:	06 83       	std	Z+6, r16	; 0x06
	port_out_value_set_mask(&PORTF,(1<<3));//deselect device
     fd0:	1d 83       	std	Y+5, r17	; 0x05

}
     fd2:	df 91       	pop	r29
     fd4:	cf 91       	pop	r28
     fd6:	1f 91       	pop	r17
     fd8:	0f 91       	pop	r16
     fda:	ff 90       	pop	r15
     fdc:	ef 90       	pop	r14
     fde:	08 95       	ret

00000fe0 <ssd1306_set_page_address>:
 */
void ssd1306_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
     fe0:	87 70       	andi	r24, 0x07	; 7
     fe2:	80 6b       	ori	r24, 0xB0	; 176
     fe4:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
     fe8:	08 95       	ret

00000fea <ssd1306_set_column_address>:
 * \brief Set current column in display RAM
 *
 * \param address the column address
 */
void ssd1306_set_column_address(uint8_t address)
{
     fea:	cf 93       	push	r28
     fec:	c8 2f       	mov	r28, r24
	// Make sure the address is 7 bits
	address &= 0x7F;
     fee:	98 2f       	mov	r25, r24
     ff0:	9f 77       	andi	r25, 0x7F	; 127
	ssd1306_write_command(SSD1306_CMD_SET_HIGH_COL(address >> 4));
     ff2:	89 2f       	mov	r24, r25
     ff4:	82 95       	swap	r24
     ff6:	8f 70       	andi	r24, 0x0F	; 15
     ff8:	80 61       	ori	r24, 0x10	; 16
     ffa:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_write_command(SSD1306_CMD_SET_LOW_COL(address & 0x0F));
     ffe:	8c 2f       	mov	r24, r28
    1000:	8f 70       	andi	r24, 0x0F	; 15
    1002:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
}
    1006:	cf 91       	pop	r28
    1008:	08 95       	ret

0000100a <usart_init_spi>:
	}
}


void usart_init_spi(USART_t *usart, const usart_spi_options_emon_t *opt)
{
    100a:	cf 93       	push	r28
    100c:	df 93       	push	r29
    100e:	ec 01       	movw	r28, r24
    1010:	fb 01       	movw	r30, r22
	//ioport_pin_t sck_pin;
	//uint8_t invert_sck;

	(usart)->CTRLB &= ~USART_RXEN_bm;
    1012:	8c 81       	ldd	r24, Y+4	; 0x04
    1014:	8f 7e       	andi	r24, 0xEF	; 239
    1016:	8c 83       	std	Y+4, r24	; 0x04

	//invert_sck = (opt->spimode == 2) || (opt->spimode == 3);

	PORTD.DIRSET = (1<<1);//sck pin output
    1018:	a0 e6       	ldi	r26, 0x60	; 96
    101a:	b6 e0       	ldi	r27, 0x06	; 6
    101c:	82 e0       	ldi	r24, 0x02	; 2
    101e:	11 96       	adiw	r26, 0x01	; 1
    1020:	8c 93       	st	X, r24
    1022:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.OUTSET = (1<<1);//sck pin output level high
    1024:	15 96       	adiw	r26, 0x05	; 5
    1026:	8c 93       	st	X, r24

	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | USART_CMODE_MSPI_gc;
    1028:	8d 81       	ldd	r24, Y+5	; 0x05
    102a:	80 6c       	ori	r24, 0xC0	; 192
    102c:	8d 83       	std	Y+5, r24	; 0x05

	if (opt->spimode == 1 || opt->spimode == 3) {
    102e:	84 81       	ldd	r24, Z+4	; 0x04
    1030:	8d 7f       	andi	r24, 0xFD	; 253
    1032:	81 30       	cpi	r24, 0x01	; 1
    1034:	21 f4       	brne	.+8      	; 0x103e <usart_init_spi+0x34>
		usart->CTRLC |= USART_UCPHA_bm;
    1036:	8d 81       	ldd	r24, Y+5	; 0x05
    1038:	82 60       	ori	r24, 0x02	; 2
    103a:	8d 83       	std	Y+5, r24	; 0x05
    103c:	03 c0       	rjmp	.+6      	; 0x1044 <usart_init_spi+0x3a>
	}
	else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    103e:	8d 81       	ldd	r24, Y+5	; 0x05
    1040:	8d 7f       	andi	r24, 0xFD	; 253
    1042:	8d 83       	std	Y+5, r24	; 0x05
	}
	
	if (opt->data_order) {
    1044:	85 81       	ldd	r24, Z+5	; 0x05
    1046:	88 23       	and	r24, r24
    1048:	21 f0       	breq	.+8      	; 0x1052 <usart_init_spi+0x48>
		(usart)->CTRLC |= USART_DORD_bm;
    104a:	8d 81       	ldd	r24, Y+5	; 0x05
    104c:	84 60       	ori	r24, 0x04	; 4
    104e:	8d 83       	std	Y+5, r24	; 0x05
    1050:	03 c0       	rjmp	.+6      	; 0x1058 <usart_init_spi+0x4e>
	}
	else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1052:	8d 81       	ldd	r24, Y+5	; 0x05
    1054:	8b 7f       	andi	r24, 0xFB	; 251
    1056:	8d 83       	std	Y+5, r24	; 0x05
	}


	uint16_t bsel_value = (32000000UL/ (opt->baudrate*2)) -1 ;
    1058:	80 81       	ld	r24, Z
    105a:	91 81       	ldd	r25, Z+1	; 0x01
    105c:	a2 81       	ldd	r26, Z+2	; 0x02
    105e:	b3 81       	ldd	r27, Z+3	; 0x03
    1060:	9c 01       	movw	r18, r24
    1062:	ad 01       	movw	r20, r26
    1064:	22 0f       	add	r18, r18
    1066:	33 1f       	adc	r19, r19
    1068:	44 1f       	adc	r20, r20
    106a:	55 1f       	adc	r21, r21
    106c:	60 e0       	ldi	r22, 0x00	; 0
    106e:	78 e4       	ldi	r23, 0x48	; 72
    1070:	88 ee       	ldi	r24, 0xE8	; 232
    1072:	91 e0       	ldi	r25, 0x01	; 1
    1074:	0e 94 6f 13 	call	0x26de	; 0x26de <__udivmodsi4>
    1078:	21 50       	subi	r18, 0x01	; 1
    107a:	31 09       	sbc	r19, r1
	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    107c:	83 2f       	mov	r24, r19
    107e:	8f 70       	andi	r24, 0x0F	; 15
    1080:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1082:	2e 83       	std	Y+6, r18	; 0x06
	
	(usart)->CTRLB |= USART_TXEN_bm;
    1084:	8c 81       	ldd	r24, Y+4	; 0x04
    1086:	88 60       	ori	r24, 0x08	; 8
    1088:	8c 83       	std	Y+4, r24	; 0x04

}
    108a:	df 91       	pop	r29
    108c:	cf 91       	pop	r28
    108e:	08 95       	ret

00001090 <ssd1306_init>:




void ssd1306_init(void)
{
    1090:	cf 93       	push	r28
    1092:	df 93       	push	r29
    1094:	00 d0       	rcall	.+0      	; 0x1096 <ssd1306_init+0x6>
    1096:	00 d0       	rcall	.+0      	; 0x1098 <ssd1306_init+0x8>
    1098:	cd b7       	in	r28, 0x3d	; 61
    109a:	de b7       	in	r29, 0x3e	; 62

	port_direction_set_mask(&PORTF,(1<<3));//ss
    109c:	20 ea       	ldi	r18, 0xA0	; 160
    109e:	36 e0       	ldi	r19, 0x06	; 6
    10a0:	88 e0       	ldi	r24, 0x08	; 8
    10a2:	d9 01       	movw	r26, r18
    10a4:	11 96       	adiw	r26, 0x01	; 1
    10a6:	8c 93       	st	X, r24
	port_direction_set_mask(&PORTD,(1<<0));//data_cmd
    10a8:	a0 e6       	ldi	r26, 0x60	; 96
    10aa:	b6 e0       	ldi	r27, 0x06	; 6
    10ac:	91 e0       	ldi	r25, 0x01	; 1
    10ae:	11 96       	adiw	r26, 0x01	; 1
    10b0:	9c 93       	st	X, r25
    10b2:	11 97       	sbiw	r26, 0x01	; 1
	port_direction_set_mask(&PORTA,(1<<3));//reset
    10b4:	e0 e0       	ldi	r30, 0x00	; 0
    10b6:	f6 e0       	ldi	r31, 0x06	; 6
    10b8:	81 83       	std	Z+1, r24	; 0x01
	port_direction_set_mask(&PORTD,(1<<1));//sck
    10ba:	92 e0       	ldi	r25, 0x02	; 2
    10bc:	11 96       	adiw	r26, 0x01	; 1
    10be:	9c 93       	st	X, r25
    10c0:	11 97       	sbiw	r26, 0x01	; 1
	port_direction_set_mask(&PORTD,(1<<3));//mosi
    10c2:	11 96       	adiw	r26, 0x01	; 1
    10c4:	8c 93       	st	X, r24
// 	
	port_out_value_set_mask(&PORTF,(1<<3));//ss
    10c6:	d9 01       	movw	r26, r18
    10c8:	15 96       	adiw	r26, 0x05	; 5
    10ca:	8c 93       	st	X, r24
 * \note this functions should not be confused with the \ref ssd1306_soft_reset()
 * function, this command will control the RST pin.
 */
static inline void ssd1306_hard_reset(void)
{
	PORTA.OUTCLR = (1<<3);
    10cc:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    10ce:	ba e6       	ldi	r27, 0x6A	; 106
    10d0:	ba 95       	dec	r27
    10d2:	f1 f7       	brne	.-4      	; 0x10d0 <ssd1306_init+0x40>
    10d4:	00 c0       	rjmp	.+0      	; 0x10d6 <ssd1306_init+0x46>
	delay_us(10); // At least 3us
	PORTA.OUTSET = (1<<3);
    10d6:	85 83       	std	Z+5, r24	; 0x05
    10d8:	ea e6       	ldi	r30, 0x6A	; 106
    10da:	ea 95       	dec	r30
    10dc:	f1 f7       	brne	.-4      	; 0x10da <ssd1306_init+0x4a>
    10de:	00 c0       	rjmp	.+0      	; 0x10e0 <ssd1306_init+0x50>
	spi_flags_t spi_flags = 0;
	//board_spi_select_id_t spi_select_id = 0;
	
	//irqflags_t flags = cpu_irq_save();
	//*((uint8_t *)&PR.PRGEN + SYSCLK_PORT_D) &= ~PR_USART0_bm;
	PR.PRPD &= ~PR_USART0_bm;
    10e0:	e0 e7       	ldi	r30, 0x70	; 112
    10e2:	f0 e0       	ldi	r31, 0x00	; 0
    10e4:	84 81       	ldd	r24, Z+4	; 0x04
    10e6:	8f 7e       	andi	r24, 0xEF	; 239
    10e8:	84 83       	std	Z+4, r24	; 0x04
	
	//cpu_irq_restore(flags);
	
	usart_spi_options_emon_t opt;
	opt.baudrate=12000000;
    10ea:	80 e0       	ldi	r24, 0x00	; 0
    10ec:	9b e1       	ldi	r25, 0x1B	; 27
    10ee:	a7 eb       	ldi	r26, 0xB7	; 183
    10f0:	b0 e0       	ldi	r27, 0x00	; 0
    10f2:	89 83       	std	Y+1, r24	; 0x01
    10f4:	9a 83       	std	Y+2, r25	; 0x02
    10f6:	ab 83       	std	Y+3, r26	; 0x03
    10f8:	bc 83       	std	Y+4, r27	; 0x04
	opt.spimode=spi_flags;
    10fa:	1d 82       	std	Y+5, r1	; 0x05
	opt.data_order=0;
    10fc:	1e 82       	std	Y+6, r1	; 0x06
	usart_init_spi(&USARTD0, &opt);
    10fe:	be 01       	movw	r22, r28
    1100:	6f 5f       	subi	r22, 0xFF	; 255
    1102:	7f 4f       	sbci	r23, 0xFF	; 255
    1104:	80 ea       	ldi	r24, 0xA0	; 160
    1106:	99 e0       	ldi	r25, 0x09	; 9
    1108:	0e 94 05 08 	call	0x100a	; 0x100a <usart_init_spi>
	

	// 1/32 Duty (0x0F~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_MULTIPLEX_RATIO);
    110c:	88 ea       	ldi	r24, 0xA8	; 168
    110e:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_write_command(0x1F);
    1112:	8f e1       	ldi	r24, 0x1F	; 31
    1114:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	// Shift Mapping RAM Counter (0x00~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_OFFSET);
    1118:	83 ed       	ldi	r24, 0xD3	; 211
    111a:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_write_command(0x00);
    111e:	80 e0       	ldi	r24, 0x00	; 0
    1120:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	// Set Mapping RAM Display Start Line (0x00~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_START_LINE(0x00));
    1124:	80 e4       	ldi	r24, 0x40	; 64
    1126:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	// Set Column Address 0 Mapped to SEG0
	ssd1306_write_command(SSD1306_CMD_SET_SEGMENT_RE_MAP_COL127_SEG0);
    112a:	81 ea       	ldi	r24, 0xA1	; 161
    112c:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	// Set COM/Row Scan Scan from COM63 to 0
	ssd1306_write_command(SSD1306_CMD_SET_COM_OUTPUT_SCAN_DOWN);
    1130:	88 ec       	ldi	r24, 0xC8	; 200
    1132:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	// Set COM Pins hardware configuration
	ssd1306_write_command(SSD1306_CMD_SET_COM_PINS);
    1136:	8a ed       	ldi	r24, 0xDA	; 218
    1138:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_write_command(0x02);
    113c:	82 e0       	ldi	r24, 0x02	; 2
    113e:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	//ssd1306_set_contrast(0x8F);
	ssd1306_write_command(SSD1306_CMD_SET_CONTRAST_CONTROL_FOR_BANK0);
    1142:	81 e8       	ldi	r24, 0x81	; 129
    1144:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_write_command(0x8F);
    1148:	8f e8       	ldi	r24, 0x8F	; 143
    114a:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

		
	// Disable Entire display On
	ssd1306_write_command(SSD1306_CMD_ENTIRE_DISPLAY_AND_GDDRAM_ON);
    114e:	84 ea       	ldi	r24, 0xA4	; 164
    1150:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	//ssd1306_display_invert_disable();
	ssd1306_write_command(SSD1306_CMD_SET_NORMAL_DISPLAY);
    1154:	86 ea       	ldi	r24, 0xA6	; 166
    1156:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	// Set Display Clock Divide Ratio / Oscillator Frequency (Default => 0x80)
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_CLOCK_DIVIDE_RATIO);
    115a:	85 ed       	ldi	r24, 0xD5	; 213
    115c:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_write_command(0x80);
    1160:	80 e8       	ldi	r24, 0x80	; 128
    1162:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	// Enable charge pump regulator
	ssd1306_write_command(SSD1306_CMD_SET_CHARGE_PUMP_SETTING);
    1166:	8d e8       	ldi	r24, 0x8D	; 141
    1168:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_write_command(0x14);
    116c:	84 e1       	ldi	r24, 0x14	; 20
    116e:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	// Set VCOMH Deselect Level
	ssd1306_write_command(SSD1306_CMD_SET_VCOMH_DESELECT_LEVEL);
    1172:	8b ed       	ldi	r24, 0xDB	; 219
    1174:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_write_command(0x40); // Default => 0x20 (0.77*VCC)
    1178:	80 e4       	ldi	r24, 0x40	; 64
    117a:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	// Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
	ssd1306_write_command(SSD1306_CMD_SET_PRE_CHARGE_PERIOD);
    117e:	89 ed       	ldi	r24, 0xD9	; 217
    1180:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_write_command(0xF1);
    1184:	81 ef       	ldi	r24, 0xF1	; 241
    1186:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>

	//ssd1306_display_on();
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_ON);
    118a:	8f ea       	ldi	r24, 0xAF	; 175
    118c:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
}
    1190:	26 96       	adiw	r28, 0x06	; 6
    1192:	cd bf       	out	0x3d, r28	; 61
    1194:	de bf       	out	0x3e, r29	; 62
    1196:	df 91       	pop	r29
    1198:	cf 91       	pop	r28
    119a:	08 95       	ret

0000119c <ssd1306_write_text>:
/**
 * \brief Display text on OLED screen.
 * \param string String to display.
 */
void ssd1306_write_text(char *string)
{
    119c:	ef 92       	push	r14
    119e:	ff 92       	push	r15
    11a0:	0f 93       	push	r16
    11a2:	1f 93       	push	r17
    11a4:	cf 93       	push	r28
	uint8_t *char_ptr;
	uint8_t i;

	while (*string != '\0') {
    11a6:	dc 01       	movw	r26, r24
    11a8:	ec 91       	ld	r30, X
    11aa:	ee 23       	and	r30, r30
    11ac:	29 f1       	breq	.+74     	; 0x11f8 <ssd1306_write_text+0x5c>
    11ae:	7c 01       	movw	r14, r24
    11b0:	bf ef       	ldi	r27, 0xFF	; 255
    11b2:	eb 1a       	sub	r14, r27
    11b4:	fb 0a       	sbc	r15, r27
		if (*string < 0x7F) {
    11b6:	ef 37       	cpi	r30, 0x7F	; 127
    11b8:	d0 f4       	brcc	.+52     	; 0x11ee <ssd1306_write_text+0x52>
			char_ptr = font_table[*string - 32];
    11ba:	f0 e0       	ldi	r31, 0x00	; 0
    11bc:	ee 0f       	add	r30, r30
    11be:	ff 1f       	adc	r31, r31
    11c0:	e5 57       	subi	r30, 0x75	; 117
    11c2:	fe 4d       	sbci	r31, 0xDE	; 222
    11c4:	00 81       	ld	r16, Z
    11c6:	11 81       	ldd	r17, Z+1	; 0x01
			for (i = 1; i <= char_ptr[0]; i++) {
    11c8:	f8 01       	movw	r30, r16
    11ca:	80 81       	ld	r24, Z
    11cc:	88 23       	and	r24, r24
    11ce:	61 f0       	breq	.+24     	; 0x11e8 <ssd1306_write_text+0x4c>
    11d0:	c1 e0       	ldi	r28, 0x01	; 1
				ssd1306_write_data(char_ptr[i]);
    11d2:	f8 01       	movw	r30, r16
    11d4:	ec 0f       	add	r30, r28
    11d6:	f1 1d       	adc	r31, r1
    11d8:	80 81       	ld	r24, Z
    11da:	0e 94 ce 07 	call	0xf9c	; 0xf9c <ssd1306_write_data>
	uint8_t i;

	while (*string != '\0') {
		if (*string < 0x7F) {
			char_ptr = font_table[*string - 32];
			for (i = 1; i <= char_ptr[0]; i++) {
    11de:	cf 5f       	subi	r28, 0xFF	; 255
    11e0:	d8 01       	movw	r26, r16
    11e2:	9c 91       	ld	r25, X
    11e4:	9c 17       	cp	r25, r28
    11e6:	a8 f7       	brcc	.-22     	; 0x11d2 <ssd1306_write_text+0x36>
				ssd1306_write_data(char_ptr[i]);
			}
			ssd1306_write_data(0x00);
    11e8:	80 e0       	ldi	r24, 0x00	; 0
    11ea:	0e 94 ce 07 	call	0xf9c	; 0xf9c <ssd1306_write_data>
void ssd1306_write_text(char *string)
{
	uint8_t *char_ptr;
	uint8_t i;

	while (*string != '\0') {
    11ee:	d7 01       	movw	r26, r14
    11f0:	ed 91       	ld	r30, X+
    11f2:	7d 01       	movw	r14, r26
    11f4:	e1 11       	cpse	r30, r1
    11f6:	df cf       	rjmp	.-66     	; 0x11b6 <ssd1306_write_text+0x1a>
			}
			ssd1306_write_data(0x00);
		}
			string++;
	}
}
    11f8:	cf 91       	pop	r28
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	ff 90       	pop	r15
    1200:	ef 90       	pop	r14
    1202:	08 95       	ret

00001204 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(uint8_t page, uint8_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    1204:	20 e8       	ldi	r18, 0x80	; 128
    1206:	82 9f       	mul	r24, r18
    1208:	c0 01       	movw	r24, r0
    120a:	11 24       	eor	r1, r1
    120c:	86 0f       	add	r24, r22
    120e:	91 1d       	adc	r25, r1
    1210:	e0 91 37 93 	lds	r30, 0x9337
    1214:	f0 91 38 93 	lds	r31, 0x9338
    1218:	e8 0f       	add	r30, r24
    121a:	f9 1f       	adc	r31, r25
    121c:	40 83       	st	Z, r20
    121e:	08 95       	ret

00001220 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(uint8_t page, uint8_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    1220:	20 e8       	ldi	r18, 0x80	; 128
    1222:	82 9f       	mul	r24, r18
    1224:	c0 01       	movw	r24, r0
    1226:	11 24       	eor	r1, r1
    1228:	86 0f       	add	r24, r22
    122a:	91 1d       	adc	r25, r1
    122c:	e0 91 37 93 	lds	r30, 0x9337
    1230:	f0 91 38 93 	lds	r31, 0x9338
    1234:	e8 0f       	add	r30, r24
    1236:	f9 1f       	adc	r31, r25
}
    1238:	80 81       	ld	r24, Z
    123a:	08 95       	ret

0000123c <gfx_mono_ssd1306_put_byte>:
	gfx_mono_ssd1306_put_byte(0, 0, 0xFF, false);
\endcode
 */
void gfx_mono_ssd1306_put_byte(uint8_t page, uint8_t column,
		uint8_t data, uint8_t force)
{
    123c:	1f 93       	push	r17
    123e:	cf 93       	push	r28
    1240:	df 93       	push	r29
    1242:	18 2f       	mov	r17, r24
    1244:	d6 2f       	mov	r29, r22
    1246:	c4 2f       	mov	r28, r20
//#ifdef CONFIG_SSD1306_FRAMEBUFFER
	if (!force && data == gfx_mono_framebuffer_get_byte(page, column)) {
    1248:	21 11       	cpse	r18, r1
    124a:	04 c0       	rjmp	.+8      	; 0x1254 <gfx_mono_ssd1306_put_byte+0x18>
    124c:	0e 94 10 09 	call	0x1220	; 0x1220 <gfx_mono_framebuffer_get_byte>
    1250:	8c 17       	cp	r24, r28
    1252:	71 f0       	breq	.+28     	; 0x1270 <gfx_mono_ssd1306_put_byte+0x34>
		return;
	}
	gfx_mono_framebuffer_put_byte(page, column, data);
    1254:	4c 2f       	mov	r20, r28
    1256:	6d 2f       	mov	r22, r29
    1258:	81 2f       	mov	r24, r17
    125a:	0e 94 02 09 	call	0x1204	; 0x1204 <gfx_mono_framebuffer_put_byte>
//#endif

	ssd1306_set_page_address(page);
    125e:	81 2f       	mov	r24, r17
    1260:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <ssd1306_set_page_address>
	ssd1306_set_column_address(column);
    1264:	8d 2f       	mov	r24, r29
    1266:	0e 94 f5 07 	call	0xfea	; 0xfea <ssd1306_set_column_address>

	ssd1306_write_data(data);
    126a:	8c 2f       	mov	r24, r28
    126c:	0e 94 ce 07 	call	0xf9c	; 0xf9c <ssd1306_write_data>
}
    1270:	df 91       	pop	r29
    1272:	cf 91       	pop	r28
    1274:	1f 91       	pop	r17
    1276:	08 95       	ret

00001278 <SetupHardware>:
	}
}

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
    1278:	cf 93       	push	r28
    127a:	df 93       	push	r29
				  return false;

				switch (Source)
				{
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.PLLCTRL = (OSC_PLLSRC_RC2M_gc  | MulFactor);
    127c:	e0 e5       	ldi	r30, 0x50	; 80
    127e:	f0 e0       	ldi	r31, 0x00	; 0
    1280:	80 e1       	ldi	r24, 0x10	; 16
    1282:	85 83       	std	Z+5, r24	; 0x05
						break;
					default:
						return false;
				}

				OSC.CTRL |= OSC_PLLEN_bm;
    1284:	80 81       	ld	r24, Z
    1286:	80 61       	ori	r24, 0x10	; 16
    1288:	80 83       	st	Z, r24

				while (!(OSC.STATUS & OSC_PLLRDY_bm));
    128a:	81 81       	ldd	r24, Z+1	; 0x01
    128c:	84 ff       	sbrs	r24, 4
    128e:	fd cf       	rjmp	.-6      	; 0x128a <SetupHardware+0x12>
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    1290:	8f b7       	in	r24, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    1292:	f8 94       	cli
			 *  \param[in] Value    Value to write to the protected location
			 */
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value) ATTR_NON_NULL_PTR_ARG(1) ATTR_ALWAYS_INLINE;
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value)
			{
				__asm__ __volatile__ (
    1294:	a0 e4       	ldi	r26, 0x40	; 64
    1296:	b0 e0       	ldi	r27, 0x00	; 0
    1298:	94 e0       	ldi	r25, 0x04	; 4
    129a:	28 ed       	ldi	r18, 0xD8	; 216
    129c:	30 e0       	ldi	r19, 0x00	; 0
    129e:	1b be       	out	0x3b, r1	; 59
    12a0:	fd 01       	movw	r30, r26
    12a2:	24 bf       	out	0x34, r18	; 52
    12a4:	90 83       	st	Z, r25
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    12a6:	8f bf       	out	0x3f, r24	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    12a8:	8f e3       	ldi	r24, 0x3F	; 63
    12aa:	9f e1       	ldi	r25, 0x1F	; 31
    12ac:	01 97       	sbiw	r24, 0x01	; 1
    12ae:	f1 f7       	brne	.-4      	; 0x12ac <SetupHardware+0x34>
    12b0:	00 c0       	rjmp	.+0      	; 0x12b2 <SetupHardware+0x3a>
    12b2:	00 00       	nop
				XMEGACLK_CCP_Write(&CLK.CTRL, ClockSourceMask);

				SetGlobalInterruptMask(CurrentGlobalInt);

				Delay_MS(1);
				return (CLK.CTRL == ClockSourceMask);
    12b4:	8c 91       	ld	r24, X
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.CTRL |= OSC_RC2MEN_bm;
						while (!(OSC.STATUS & OSC_RC2MRDY_bm));
						return true;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.CTRL |= OSC_RC32MEN_bm;
    12b6:	e0 e5       	ldi	r30, 0x50	; 80
    12b8:	f0 e0       	ldi	r31, 0x00	; 0
    12ba:	80 81       	ld	r24, Z
    12bc:	82 60       	ori	r24, 0x02	; 2
    12be:	80 83       	st	Z, r24
						while (!(OSC.STATUS & OSC_RC32MRDY_bm));
    12c0:	81 81       	ldd	r24, Z+1	; 0x01
    12c2:	81 ff       	sbrs	r24, 1
    12c4:	fd cf       	rjmp	.-6      	; 0x12c0 <SetupHardware+0x48>
						DFLLRC2M.COMP1  = (DFLLCompare & 0xFF);
						DFLLRC2M.COMP2  = (DFLLCompare >> 8);
						DFLLRC2M.CTRL   = DFLL_ENABLE_bm;
						break;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.DFLLCTRL   |= (Reference << OSC_RC32MCREF_gp);
    12c6:	e0 e5       	ldi	r30, 0x50	; 80
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
    12ca:	86 81       	ldd	r24, Z+6	; 0x06
    12cc:	84 60       	ori	r24, 0x04	; 4
    12ce:	86 83       	std	Z+6, r24	; 0x06
						DFLLRC32M.COMP1 = (DFLLCompare & 0xFF);
    12d0:	a0 e6       	ldi	r26, 0x60	; 96
    12d2:	b0 e0       	ldi	r27, 0x00	; 0
    12d4:	8b e1       	ldi	r24, 0x1B	; 27
    12d6:	15 96       	adiw	r26, 0x05	; 5
    12d8:	8c 93       	st	X, r24
    12da:	15 97       	sbiw	r26, 0x05	; 5
						DFLLRC32M.COMP2 = (DFLLCompare >> 8);
    12dc:	87 eb       	ldi	r24, 0xB7	; 183
    12de:	16 96       	adiw	r26, 0x06	; 6
    12e0:	8c 93       	st	X, r24
    12e2:	16 97       	sbiw	r26, 0x06	; 6

						if (Reference == DFLL_REF_INT_USBSOF)
						{
							NVM.CMD        = NVM_CMD_READ_CALIB_ROW_gc;
    12e4:	c0 ec       	ldi	r28, 0xC0	; 192
    12e6:	d1 e0       	ldi	r29, 0x01	; 1
    12e8:	82 e0       	ldi	r24, 0x02	; 2
    12ea:	8a 87       	std	Y+10, r24	; 0x0a
							DFLLRC32M.CALA = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSCA));
    12ec:	ed e1       	ldi	r30, 0x1D	; 29
    12ee:	f0 e0       	ldi	r31, 0x00	; 0
    12f0:	e4 91       	lpm	r30, Z
    12f2:	12 96       	adiw	r26, 0x02	; 2
    12f4:	ec 93       	st	X, r30
    12f6:	12 97       	sbiw	r26, 0x02	; 2
							DFLLRC32M.CALB = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSC));
    12f8:	ec e1       	ldi	r30, 0x1C	; 28
    12fa:	f0 e0       	ldi	r31, 0x00	; 0
    12fc:	e4 91       	lpm	r30, Z
    12fe:	13 96       	adiw	r26, 0x03	; 3
    1300:	ec 93       	st	X, r30
    1302:	13 97       	sbiw	r26, 0x03	; 3
							NVM.CMD        = 0;
    1304:	1a 86       	std	Y+10, r1	; 0x0a
						}

						DFLLRC32M.CTRL  = DFLL_ENABLE_bm;
    1306:	81 e0       	ldi	r24, 0x01	; 1
    1308:	8c 93       	st	X, r24

	/* Start the 32MHz internal RC oscillator and start the DFLL to increase it to 48MHz using the USB SOF as a reference */
	XMEGACLK_StartInternalOscillator(CLOCK_SRC_INT_RC32MHZ);
	XMEGACLK_StartDFLL(CLOCK_SRC_INT_RC32MHZ, DFLL_REF_INT_USBSOF, F_USB);

	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
    130a:	87 e0       	ldi	r24, 0x07	; 7
    130c:	80 93 a2 00 	sts	0x00A2, r24

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				PORTR.DIRSET    = LEDS_PORTR_LEDS;
    1310:	e0 ee       	ldi	r30, 0xE0	; 224
    1312:	f7 e0       	ldi	r31, 0x07	; 7
    1314:	83 e0       	ldi	r24, 0x03	; 3
    1316:	81 83       	std	Z+1, r24	; 0x01
				PORTR.OUTCLR    = LEDS_PORTR_LEDS;
    1318:	86 83       	std	Z+6, r24	; 0x06

				PORTCFG.MPCMASK = LEDS_PORTR_LEDS;
    131a:	80 93 b0 00 	sts	0x00B0, r24
				PORTR.PIN0CTRL  = PORT_INVEN_bm;
    131e:	80 e4       	ldi	r24, 0x40	; 64
    1320:	80 8b       	std	Z+16, r24	; 0x10

				PORTD.DIRSET    = LEDS_PORTD_LEDS;
    1322:	e0 e6       	ldi	r30, 0x60	; 96
    1324:	f6 e0       	ldi	r31, 0x06	; 6
    1326:	90 e3       	ldi	r25, 0x30	; 48
    1328:	91 83       	std	Z+1, r25	; 0x01
				PORTD.OUTCLR    = LEDS_PORTD_LEDS;
    132a:	96 83       	std	Z+6, r25	; 0x06

				PORTD.PIN4CTRL  = PORT_INVEN_bm;
    132c:	84 8b       	std	Z+20, r24	; 0x14
#endif

	/* Hardware Initialization */
	LEDs_Init();
	USB_Init();
    132e:	0e 94 53 12 	call	0x24a6	; 0x24a6 <USB_Init>
}
    1332:	df 91       	pop	r29
    1334:	cf 91       	pop	r28
    1336:	08 95       	ret

00001338 <main>:
 */
int main(void)
{

	
	SetupHardware();
    1338:	0e 94 3c 09 	call	0x1278	; 0x1278 <SetupHardware>

	rtc_initialize();
    133c:	0e 94 0c 13 	call	0x2618	; 0x2618 <rtc_initialize>
	gfx_mono_set_framebuffer(framebuffer);
\endcode
 */
void gfx_mono_set_framebuffer(uint8_t *framebuffer)
{
	fbpointer = framebuffer;
    1340:	89 e3       	ldi	r24, 0x39	; 57
    1342:	93 e9       	ldi	r25, 0x93	; 147
    1344:	80 93 37 93 	sts	0x9337, r24
    1348:	90 93 38 93 	sts	0x9338, r25
	uint8_t page;
	uint8_t column;

	gfx_mono_set_framebuffer(framebuffer);

	ssd1306_init();
    134c:	0e 94 48 08 	call	0x1090	; 0x1090 <ssd1306_init>
	asm("nop");
    1350:	00 00       	nop
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    1352:	d0 e0       	ldi	r29, 0x00	; 0
    1354:	0f c0       	rjmp	.+30     	; 0x1374 <main+0x3c>
	{
		for (col = 0; col < 128; ++col)
		{
			ssd1306_set_page_address(page);
    1356:	8d 2f       	mov	r24, r29
    1358:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <ssd1306_set_page_address>
			ssd1306_set_column_address(col);
    135c:	8c 2f       	mov	r24, r28
    135e:	0e 94 f5 07 	call	0xfea	; 0xfea <ssd1306_set_column_address>
			ssd1306_write_data(0x00);
    1362:	80 e0       	ldi	r24, 0x00	; 0
    1364:	0e 94 ce 07 	call	0xf9c	; 0xf9c <ssd1306_write_data>
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
	{
		for (col = 0; col < 128; ++col)
    1368:	cf 5f       	subi	r28, 0xFF	; 255
    136a:	c0 38       	cpi	r28, 0x80	; 128
    136c:	a1 f7       	brne	.-24     	; 0x1356 <main+0x1e>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    136e:	df 5f       	subi	r29, 0xFF	; 255
    1370:	d4 30       	cpi	r29, 0x04	; 4
    1372:	11 f0       	breq	.+4      	; 0x1378 <main+0x40>

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
    1374:	c0 e0       	ldi	r28, 0x00	; 0
    1376:	ef cf       	rjmp	.-34     	; 0x1356 <main+0x1e>
 */
static inline void ssd1306_set_display_start_line_address(uint8_t address)
{
	// Make sure address is 6 bits
	address &= 0x3F;
	ssd1306_write_command(SSD1306_CMD_SET_START_LINE(address));
    1378:	80 e4       	ldi	r24, 0x40	; 64
    137a:	0e 94 b8 07 	call	0xf70	; 0xf70 <ssd1306_write_command>
	ssd1306_clear();

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    137e:	d0 e0       	ldi	r29, 0x00	; 0
    1380:	0c c0       	rjmp	.+24     	; 0x139a <main+0x62>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
    1382:	21 e0       	ldi	r18, 0x01	; 1
    1384:	40 e0       	ldi	r20, 0x00	; 0
    1386:	6c 2f       	mov	r22, r28
    1388:	8d 2f       	mov	r24, r29
    138a:	0e 94 1e 09 	call	0x123c	; 0x123c <gfx_mono_ssd1306_put_byte>

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    138e:	cf 5f       	subi	r28, 0xFF	; 255
    1390:	c0 38       	cpi	r28, 0x80	; 128
    1392:	b9 f7       	brne	.-18     	; 0x1382 <main+0x4a>
	ssd1306_clear();

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    1394:	df 5f       	subi	r29, 0xFF	; 255
    1396:	d4 30       	cpi	r29, 0x04	; 4
    1398:	11 f0       	breq	.+4      	; 0x139e <main+0x66>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    139a:	c0 e0       	ldi	r28, 0x00	; 0
    139c:	f2 cf       	rjmp	.-28     	; 0x1382 <main+0x4a>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
		}
	}

	asm("nop");
    139e:	00 00       	nop
	ssd1306_set_page_address(0);
    13a0:	80 e0       	ldi	r24, 0x00	; 0
    13a2:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <ssd1306_set_page_address>
	ssd1306_write_text("EMON");
    13a6:	8c eb       	ldi	r24, 0xBC	; 188
    13a8:	92 e2       	ldi	r25, 0x22	; 34
    13aa:	0e 94 ce 08 	call	0x119c	; 0x119c <ssd1306_write_text>



	DigitalPin_SetDIr(&led,1);
    13ae:	61 e0       	ldi	r22, 0x01	; 1
    13b0:	89 ea       	ldi	r24, 0xA9	; 169
    13b2:	92 e2       	ldi	r25, 0x22	; 34
    13b4:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <DigitalPin_SetDIr>
	DigitalPin_SetDIr(&led2,1);
    13b8:	61 e0       	ldi	r22, 0x01	; 1
    13ba:	86 ea       	ldi	r24, 0xA6	; 166
    13bc:	92 e2       	ldi	r25, 0x22	; 34
    13be:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <DigitalPin_SetDIr>
	//PORT_SetDirection(&PORTR,(1<<0));

	CLKSYS_Enable( OSC_RC32MEN_bm );
    13c2:	e0 e5       	ldi	r30, 0x50	; 80
    13c4:	f0 e0       	ldi	r31, 0x00	; 0
    13c6:	80 81       	ld	r24, Z
    13c8:	82 60       	ori	r24, 0x02	; 2
    13ca:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC32MRDY_bm ) == 0 );
    13cc:	81 81       	ldd	r24, Z+1	; 0x01
    13ce:	81 ff       	sbrs	r24, 1
    13d0:	fd cf       	rjmp	.-6      	; 0x13cc <main+0x94>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    13d2:	81 e0       	ldi	r24, 0x01	; 1
    13d4:	0e 94 16 0b 	call	0x162c	; 0x162c <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	0e 94 0c 0b 	call	0x1618	; 0x1618 <CLKSYS_Disable>

	char time_string[20];
	uint8_t rxData[33];


	PORTR.DIRSET = (1<<0);
    13de:	e0 ee       	ldi	r30, 0xE0	; 224
    13e0:	f7 e0       	ldi	r31, 0x07	; 7
    13e2:	81 e0       	ldi	r24, 0x01	; 1
    13e4:	81 83       	std	Z+1, r24	; 0x01
	PORTR.DIRSET = (1<<1);
    13e6:	82 e0       	ldi	r24, 0x02	; 2
    13e8:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = (1<<4);
    13ea:	80 e1       	ldi	r24, 0x10	; 16
    13ec:	80 93 61 06 	sts	0x0661, r24




	CDC_Device_CreateStream(&VirtualSerial_CDC_Interface, &USBSerialStream);
    13f0:	69 e2       	ldi	r22, 0x29	; 41
    13f2:	73 e9       	ldi	r23, 0x93	; 147
    13f4:	8b e8       	ldi	r24, 0x8B	; 139
    13f6:	92 e2       	ldi	r25, 0x22	; 34
    13f8:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <CDC_Device_CreateStream>
				#if (ARCH == ARCH_AVR8)
				sei();
				#elif (ARCH == ARCH_UC3)
				__builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				sei();
    13fc:	78 94       	sei
	//creating the threads
	//xTaskCreate(thread_1, (const char*) "t1", 100, NULL, tskIDLE_PRIORITY, NULL );
	//xTaskCreate(thread_2,(const char *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
	//
	
	xTaskCreate(thread_1,(signed portCHAR *) "t1", 100, NULL, tskIDLE_PRIORITY, NULL );
    13fe:	a1 2c       	mov	r10, r1
    1400:	b1 2c       	mov	r11, r1
    1402:	c1 2c       	mov	r12, r1
    1404:	d1 2c       	mov	r13, r1
    1406:	e1 2c       	mov	r14, r1
    1408:	f1 2c       	mov	r15, r1
    140a:	00 e0       	ldi	r16, 0x00	; 0
    140c:	20 e0       	ldi	r18, 0x00	; 0
    140e:	30 e0       	ldi	r19, 0x00	; 0
    1410:	44 e6       	ldi	r20, 0x64	; 100
    1412:	50 e0       	ldi	r21, 0x00	; 0
    1414:	61 ec       	ldi	r22, 0xC1	; 193
    1416:	72 e2       	ldi	r23, 0x22	; 34
    1418:	85 e9       	ldi	r24, 0x95	; 149
    141a:	97 e0       	ldi	r25, 0x07	; 7
    141c:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	xTaskCreate(thread_2,(signed portCHAR *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
    1420:	20 e0       	ldi	r18, 0x00	; 0
    1422:	30 e0       	ldi	r19, 0x00	; 0
    1424:	44 e6       	ldi	r20, 0x64	; 100
    1426:	50 e0       	ldi	r21, 0x00	; 0
    1428:	64 ec       	ldi	r22, 0xC4	; 196
    142a:	72 e2       	ldi	r23, 0x22	; 34
    142c:	8c e8       	ldi	r24, 0x8C	; 140
    142e:	97 e0       	ldi	r25, 0x07	; 7
    1430:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	xTaskCreate(USBThread,(signed portCHAR *) "usb", 200, NULL, tskIDLE_PRIORITY, NULL );
    1434:	20 e0       	ldi	r18, 0x00	; 0
    1436:	30 e0       	ldi	r19, 0x00	; 0
    1438:	48 ec       	ldi	r20, 0xC8	; 200
    143a:	50 e0       	ldi	r21, 0x00	; 0
    143c:	67 ec       	ldi	r22, 0xC7	; 199
    143e:	72 e2       	ldi	r23, 0x22	; 34
    1440:	8d e7       	ldi	r24, 0x7D	; 125
    1442:	97 e0       	ldi	r25, 0x07	; 7
    1444:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	

	//starting the scheduler
	vTaskStartScheduler();
    1448:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskStartScheduler>

	for (;;)
	{
// 		CDC_Device_USBTask(&VirtualSerial_CDC_Interface);
// 		USB_USBTask();
	}
    144c:	ff cf       	rjmp	.-2      	; 0x144c <main+0x114>

0000144e <EVENT_USB_Device_Connect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    144e:	83 e0       	ldi	r24, 0x03	; 3
    1450:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    1454:	80 e3       	ldi	r24, 0x30	; 48
    1456:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    145a:	82 e0       	ldi	r24, 0x02	; 2
    145c:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    1460:	80 e1       	ldi	r24, 0x10	; 16
    1462:	80 93 65 06 	sts	0x0665, r24
    1466:	08 95       	ret

00001468 <EVENT_USB_Device_Disconnect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    1468:	83 e0       	ldi	r24, 0x03	; 3
    146a:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    146e:	80 e3       	ldi	r24, 0x30	; 48
    1470:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    1474:	81 e0       	ldi	r24, 0x01	; 1
    1476:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    147a:	10 92 65 06 	sts	0x0665, r1
    147e:	08 95       	ret

00001480 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= CDC_Device_ConfigureEndpoints(&VirtualSerial_CDC_Interface);
    1480:	8b e8       	ldi	r24, 0x8B	; 139
    1482:	92 e2       	ldi	r25, 0x22	; 34
    1484:	0e 94 2b 0b 	call	0x1656	; 0x1656 <CDC_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
    1488:	81 11       	cpse	r24, r1
    148a:	02 c0       	rjmp	.+4      	; 0x1490 <EVENT_USB_Device_ConfigurationChanged+0x10>
    148c:	81 e1       	ldi	r24, 0x11	; 17
    148e:	01 c0       	rjmp	.+2      	; 0x1492 <EVENT_USB_Device_ConfigurationChanged+0x12>
    1490:	82 e2       	ldi	r24, 0x22	; 34
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    1492:	93 e0       	ldi	r25, 0x03	; 3
    1494:	90 93 e6 07 	sts	0x07E6, r25
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    1498:	90 e3       	ldi	r25, 0x30	; 48
    149a:	90 93 66 06 	sts	0x0666, r25

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    149e:	98 2f       	mov	r25, r24
    14a0:	93 70       	andi	r25, 0x03	; 3
    14a2:	90 93 e5 07 	sts	0x07E5, r25
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    14a6:	80 73       	andi	r24, 0x30	; 48
    14a8:	80 93 65 06 	sts	0x0665, r24
    14ac:	08 95       	ret

000014ae <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	CDC_Device_ProcessControlRequest(&VirtualSerial_CDC_Interface);
    14ae:	8b e8       	ldi	r24, 0x8B	; 139
    14b0:	92 e2       	ldi	r25, 0x22	; 34
    14b2:	0e 94 85 0c 	call	0x190a	; 0x190a <CDC_Device_ProcessControlRequest>
    14b6:	08 95       	ret

000014b8 <EVENT_CDC_Device_ControLineStateChanged>:
 *  control lines sent from the host..
 *
 *  \param[in] CDCInterfaceInfo  Pointer to the CDC class interface configuration structure being referenced
 */
void EVENT_CDC_Device_ControLineStateChanged(USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo)
{
    14b8:	08 95       	ret

000014ba <DigitalPin_SetDIr>:
	SREG = sreg;	
}


void DigitalPin_SetDIr(DigitalPin_t *pin , bool dir){
	if(dir) pin->_port->DIRSET = (1<< pin->_pin);
    14ba:	66 23       	and	r22, r22
    14bc:	79 f0       	breq	.+30     	; 0x14dc <DigitalPin_SetDIr+0x22>
    14be:	dc 01       	movw	r26, r24
    14c0:	ed 91       	ld	r30, X+
    14c2:	fc 91       	ld	r31, X
    14c4:	11 97       	sbiw	r26, 0x01	; 1
    14c6:	21 e0       	ldi	r18, 0x01	; 1
    14c8:	30 e0       	ldi	r19, 0x00	; 0
    14ca:	a9 01       	movw	r20, r18
    14cc:	12 96       	adiw	r26, 0x02	; 2
    14ce:	0c 90       	ld	r0, X
    14d0:	02 c0       	rjmp	.+4      	; 0x14d6 <DigitalPin_SetDIr+0x1c>
    14d2:	44 0f       	add	r20, r20
    14d4:	55 1f       	adc	r21, r21
    14d6:	0a 94       	dec	r0
    14d8:	e2 f7       	brpl	.-8      	; 0x14d2 <DigitalPin_SetDIr+0x18>
    14da:	41 83       	std	Z+1, r20	; 0x01
    14dc:	08 95       	ret

000014de <DigitalPin_ToggleValue>:
void DigitalPin_ClearValue(DigitalPin_t *pin){
	pin->_port->OUTCLR = (1<< pin->_pin);
}

void DigitalPin_ToggleValue(DigitalPin_t *pin){
	pin->_port->OUTTGL = (1<< pin->_pin);
    14de:	dc 01       	movw	r26, r24
    14e0:	ed 91       	ld	r30, X+
    14e2:	fc 91       	ld	r31, X
    14e4:	11 97       	sbiw	r26, 0x01	; 1
    14e6:	21 e0       	ldi	r18, 0x01	; 1
    14e8:	30 e0       	ldi	r19, 0x00	; 0
    14ea:	a9 01       	movw	r20, r18
    14ec:	12 96       	adiw	r26, 0x02	; 2
    14ee:	0c 90       	ld	r0, X
    14f0:	02 c0       	rjmp	.+4      	; 0x14f6 <DigitalPin_ToggleValue+0x18>
    14f2:	44 0f       	add	r20, r20
    14f4:	55 1f       	adc	r21, r21
    14f6:	0a 94       	dec	r0
    14f8:	e2 f7       	brpl	.-8      	; 0x14f2 <DigitalPin_ToggleValue+0x14>
    14fa:	47 83       	std	Z+7, r20	; 0x07
    14fc:	08 95       	ret

000014fe <__vector_25>:


}

#if defined(USARTC0)
ISR(USARTC0_RXC_vect){
    14fe:	1f 92       	push	r1
    1500:	0f 92       	push	r0
    1502:	0f b6       	in	r0, 0x3f	; 63
    1504:	0f 92       	push	r0
    1506:	11 24       	eor	r1, r1

}
    1508:	0f 90       	pop	r0
    150a:	0f be       	out	0x3f, r0	; 63
    150c:	0f 90       	pop	r0
    150e:	1f 90       	pop	r1
    1510:	18 95       	reti

00001512 <__vector_27>:

ISR(USARTC0_TXC_vect){
    1512:	1f 92       	push	r1
    1514:	0f 92       	push	r0
    1516:	0f b6       	in	r0, 0x3f	; 63
    1518:	0f 92       	push	r0
    151a:	11 24       	eor	r1, r1
	
}
    151c:	0f 90       	pop	r0
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	0f 90       	pop	r0
    1522:	1f 90       	pop	r1
    1524:	18 95       	reti

00001526 <__vector_26>:

ISR(USARTC0_DRE_vect){
    1526:	1f 92       	push	r1
    1528:	0f 92       	push	r0
    152a:	0f b6       	in	r0, 0x3f	; 63
    152c:	0f 92       	push	r0
    152e:	11 24       	eor	r1, r1
	
}
    1530:	0f 90       	pop	r0
    1532:	0f be       	out	0x3f, r0	; 63
    1534:	0f 90       	pop	r0
    1536:	1f 90       	pop	r1
    1538:	18 95       	reti

0000153a <__vector_28>:
#endif


#if defined(USARTC1)
ISR(USARTC1_RXC_vect){
    153a:	1f 92       	push	r1
    153c:	0f 92       	push	r0
    153e:	0f b6       	in	r0, 0x3f	; 63
    1540:	0f 92       	push	r0
    1542:	11 24       	eor	r1, r1
	
}
    1544:	0f 90       	pop	r0
    1546:	0f be       	out	0x3f, r0	; 63
    1548:	0f 90       	pop	r0
    154a:	1f 90       	pop	r1
    154c:	18 95       	reti

0000154e <__vector_30>:

ISR(USARTC1_TXC_vect){
    154e:	1f 92       	push	r1
    1550:	0f 92       	push	r0
    1552:	0f b6       	in	r0, 0x3f	; 63
    1554:	0f 92       	push	r0
    1556:	11 24       	eor	r1, r1
	
}
    1558:	0f 90       	pop	r0
    155a:	0f be       	out	0x3f, r0	; 63
    155c:	0f 90       	pop	r0
    155e:	1f 90       	pop	r1
    1560:	18 95       	reti

00001562 <__vector_29>:

ISR(USARTC1_DRE_vect){
    1562:	1f 92       	push	r1
    1564:	0f 92       	push	r0
    1566:	0f b6       	in	r0, 0x3f	; 63
    1568:	0f 92       	push	r0
    156a:	11 24       	eor	r1, r1
	
}
    156c:	0f 90       	pop	r0
    156e:	0f be       	out	0x3f, r0	; 63
    1570:	0f 90       	pop	r0
    1572:	1f 90       	pop	r1
    1574:	18 95       	reti

00001576 <__vector_88>:
#endif


#if defined(USARTD0)
ISR(USARTD0_RXC_vect){
    1576:	1f 92       	push	r1
    1578:	0f 92       	push	r0
    157a:	0f b6       	in	r0, 0x3f	; 63
    157c:	0f 92       	push	r0
    157e:	11 24       	eor	r1, r1
	
}
    1580:	0f 90       	pop	r0
    1582:	0f be       	out	0x3f, r0	; 63
    1584:	0f 90       	pop	r0
    1586:	1f 90       	pop	r1
    1588:	18 95       	reti

0000158a <__vector_90>:

ISR(USARTD0_TXC_vect){
    158a:	1f 92       	push	r1
    158c:	0f 92       	push	r0
    158e:	0f b6       	in	r0, 0x3f	; 63
    1590:	0f 92       	push	r0
    1592:	11 24       	eor	r1, r1
	
}
    1594:	0f 90       	pop	r0
    1596:	0f be       	out	0x3f, r0	; 63
    1598:	0f 90       	pop	r0
    159a:	1f 90       	pop	r1
    159c:	18 95       	reti

0000159e <__vector_89>:

ISR(USARTD0_DRE_vect){
    159e:	1f 92       	push	r1
    15a0:	0f 92       	push	r0
    15a2:	0f b6       	in	r0, 0x3f	; 63
    15a4:	0f 92       	push	r0
    15a6:	11 24       	eor	r1, r1
	
}
    15a8:	0f 90       	pop	r0
    15aa:	0f be       	out	0x3f, r0	; 63
    15ac:	0f 90       	pop	r0
    15ae:	1f 90       	pop	r1
    15b0:	18 95       	reti

000015b2 <__vector_58>:
	
}
#endif

#if defined(USARTE0)
ISR(USARTE0_RXC_vect){
    15b2:	1f 92       	push	r1
    15b4:	0f 92       	push	r0
    15b6:	0f b6       	in	r0, 0x3f	; 63
    15b8:	0f 92       	push	r0
    15ba:	11 24       	eor	r1, r1
	
}
    15bc:	0f 90       	pop	r0
    15be:	0f be       	out	0x3f, r0	; 63
    15c0:	0f 90       	pop	r0
    15c2:	1f 90       	pop	r1
    15c4:	18 95       	reti

000015c6 <__vector_60>:

ISR(USARTE0_TXC_vect){
    15c6:	1f 92       	push	r1
    15c8:	0f 92       	push	r0
    15ca:	0f b6       	in	r0, 0x3f	; 63
    15cc:	0f 92       	push	r0
    15ce:	11 24       	eor	r1, r1
	
}
    15d0:	0f 90       	pop	r0
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	0f 90       	pop	r0
    15d6:	1f 90       	pop	r1
    15d8:	18 95       	reti

000015da <__vector_59>:

ISR(USARTE0_DRE_vect){
    15da:	1f 92       	push	r1
    15dc:	0f 92       	push	r0
    15de:	0f b6       	in	r0, 0x3f	; 63
    15e0:	0f 92       	push	r0
    15e2:	11 24       	eor	r1, r1
	
}
    15e4:	0f 90       	pop	r0
    15e6:	0f be       	out	0x3f, r0	; 63
    15e8:	0f 90       	pop	r0
    15ea:	1f 90       	pop	r1
    15ec:	18 95       	reti

000015ee <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    15ee:	0f 93       	push	r16
    15f0:	cf 93       	push	r28
    15f2:	df 93       	push	r29
    15f4:	1f 92       	push	r1
    15f6:	cd b7       	in	r28, 0x3d	; 61
    15f8:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    15fa:	2f b7       	in	r18, 0x3f	; 63
    15fc:	29 83       	std	Y+1, r18	; 0x01
    15fe:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    1600:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    1602:	fc 01       	movw	r30, r24
    1604:	08 ed       	ldi	r16, 0xD8	; 216
    1606:	04 bf       	out	0x34, r16	; 52
    1608:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    160a:	89 81       	ldd	r24, Y+1	; 0x01
    160c:	8f bf       	out	0x3f, r24	; 63
#endif
}
    160e:	0f 90       	pop	r0
    1610:	df 91       	pop	r29
    1612:	cf 91       	pop	r28
    1614:	0f 91       	pop	r16
    1616:	08 95       	ret

00001618 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    1618:	e0 e5       	ldi	r30, 0x50	; 80
    161a:	f0 e0       	ldi	r31, 0x00	; 0
    161c:	90 81       	ld	r25, Z
    161e:	28 2f       	mov	r18, r24
    1620:	20 95       	com	r18
    1622:	92 23       	and	r25, r18
    1624:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    1626:	90 81       	ld	r25, Z
	return clkEnabled;
}
    1628:	89 23       	and	r24, r25
    162a:	08 95       	ret

0000162c <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    1634:	00 e4       	ldi	r16, 0x40	; 64
    1636:	10 e0       	ldi	r17, 0x00	; 0
    1638:	f8 01       	movw	r30, r16
    163a:	60 81       	ld	r22, Z
    163c:	68 7f       	andi	r22, 0xF8	; 248
    163e:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    1640:	80 e4       	ldi	r24, 0x40	; 64
    1642:	90 e0       	ldi	r25, 0x00	; 0
    1644:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    1648:	f8 01       	movw	r30, r16
    164a:	80 81       	ld	r24, Z
	return clkCtrl;
}
    164c:	8c 23       	and	r24, r28
    164e:	cf 91       	pop	r28
    1650:	1f 91       	pop	r17
    1652:	0f 91       	pop	r16
    1654:	08 95       	ret

00001656 <CDC_Device_ConfigureEndpoints>:
			break;
	}
}

bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    1656:	cf 93       	push	r28
    1658:	df 93       	push	r29
    165a:	ec 01       	movw	r28, r24
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));
    165c:	fc 01       	movw	r30, r24
    165e:	70 96       	adiw	r30, 0x10	; 16
    1660:	8b e0       	ldi	r24, 0x0B	; 11
    1662:	df 01       	movw	r26, r30
    1664:	1d 92       	st	X+, r1
    1666:	8a 95       	dec	r24
    1668:	e9 f7       	brne	.-6      	; 0x1664 <CDC_Device_ConfigureEndpoints+0xe>

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
    166a:	82 e0       	ldi	r24, 0x02	; 2
    166c:	8c 83       	std	Y+4, r24	; 0x04
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
    166e:	89 87       	std	Y+9, r24	; 0x09
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
    1670:	83 e0       	ldi	r24, 0x03	; 3
    1672:	8e 87       	std	Y+14, r24	; 0x0e

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
    1674:	61 e0       	ldi	r22, 0x01	; 1
    1676:	ce 01       	movw	r24, r28
    1678:	01 96       	adiw	r24, 0x01	; 1
    167a:	0e 94 21 11 	call	0x2242	; 0x2242 <Endpoint_ConfigureEndpointTable>
    167e:	88 23       	and	r24, r24
    1680:	61 f0       	breq	.+24     	; 0x169a <CDC_Device_ConfigureEndpoints+0x44>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
    1682:	61 e0       	ldi	r22, 0x01	; 1
    1684:	ce 01       	movw	r24, r28
    1686:	06 96       	adiw	r24, 0x06	; 6
    1688:	0e 94 21 11 	call	0x2242	; 0x2242 <Endpoint_ConfigureEndpointTable>
    168c:	88 23       	and	r24, r24
    168e:	29 f0       	breq	.+10     	; 0x169a <CDC_Device_ConfigureEndpoints+0x44>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.NotificationEndpoint, 1)))
    1690:	61 e0       	ldi	r22, 0x01	; 1
    1692:	ce 01       	movw	r24, r28
    1694:	0b 96       	adiw	r24, 0x0b	; 11
    1696:	0e 94 21 11 	call	0x2242	; 0x2242 <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
    169a:	df 91       	pop	r29
    169c:	cf 91       	pop	r28
    169e:	08 95       	ret

000016a0 <CDC_Device_SendByte>:
	return Endpoint_Write_PStream_LE(Buffer, Length, NULL);
}

uint8_t CDC_Device_SendByte(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const uint8_t Data)
{
    16a0:	cf 93       	push	r28
    16a2:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    16a4:	90 91 3f 95 	lds	r25, 0x953F
    16a8:	94 30       	cpi	r25, 0x04	; 4
    16aa:	19 f5       	brne	.+70     	; 0x16f2 <CDC_Device_SendByte+0x52>
    16ac:	84 89       	ldd	r24, Z+20	; 0x14
    16ae:	95 89       	ldd	r25, Z+21	; 0x15
    16b0:	a6 89       	ldd	r26, Z+22	; 0x16
    16b2:	b7 89       	ldd	r27, Z+23	; 0x17
    16b4:	89 2b       	or	r24, r25
    16b6:	8a 2b       	or	r24, r26
    16b8:	8b 2b       	or	r24, r27
    16ba:	e9 f0       	breq	.+58     	; 0x16f6 <CDC_Device_SendByte+0x56>
    16bc:	c6 2f       	mov	r28, r22
	  return ENDPOINT_RWSTREAM_DeviceDisconnected;

	Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
    16be:	81 81       	ldd	r24, Z+1	; 0x01
    16c0:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return (USB_Endpoint_SelectedFIFO->Position < USB_Endpoint_SelectedFIFO->Length);
    16c4:	80 91 48 95 	lds	r24, 0x9548
    16c8:	90 91 49 95 	lds	r25, 0x9549
    16cc:	fc 01       	movw	r30, r24
    16ce:	ef 5b       	subi	r30, 0xBF	; 191
    16d0:	ff 4f       	sbci	r31, 0xFF	; 255
    16d2:	20 81       	ld	r18, Z
    16d4:	31 97       	sbiw	r30, 0x01	; 1
    16d6:	80 81       	ld	r24, Z

	if (!(Endpoint_IsReadWriteAllowed()))
    16d8:	28 17       	cp	r18, r24
    16da:	30 f0       	brcs	.+12     	; 0x16e8 <CDC_Device_SendByte+0x48>
	{
		Endpoint_ClearIN();
    16dc:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>

		uint8_t ErrorCode;

		if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    16e0:	0e 94 d0 11 	call	0x23a0	; 0x23a0 <Endpoint_WaitUntilReady>
    16e4:	81 11       	cpse	r24, r1
    16e6:	08 c0       	rjmp	.+16     	; 0x16f8 <CDC_Device_SendByte+0x58>
		  return ErrorCode;
	}

	Endpoint_Write_8(Data);
    16e8:	8c 2f       	mov	r24, r28
    16ea:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
	return ENDPOINT_READYWAIT_NoError;
    16ee:	80 e0       	ldi	r24, 0x00	; 0
    16f0:	03 c0       	rjmp	.+6      	; 0x16f8 <CDC_Device_SendByte+0x58>

uint8_t CDC_Device_SendByte(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const uint8_t Data)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
	  return ENDPOINT_RWSTREAM_DeviceDisconnected;
    16f2:	82 e0       	ldi	r24, 0x02	; 2
    16f4:	01 c0       	rjmp	.+2      	; 0x16f8 <CDC_Device_SendByte+0x58>
    16f6:	82 e0       	ldi	r24, 0x02	; 2
		  return ErrorCode;
	}

	Endpoint_Write_8(Data);
	return ENDPOINT_READYWAIT_NoError;
}
    16f8:	cf 91       	pop	r28
    16fa:	08 95       	ret

000016fc <CDC_Device_putchar>:
	fdev_set_udata(Stream, CDCInterfaceInfo);
}

static int CDC_Device_putchar(char c,
                              FILE* Stream)
{
    16fc:	fb 01       	movw	r30, r22
	return CDC_Device_SendByte((USB_ClassInfo_CDC_Device_t*)fdev_get_udata(Stream), c) ? _FDEV_ERR : 0;
    16fe:	68 2f       	mov	r22, r24
    1700:	84 85       	ldd	r24, Z+12	; 0x0c
    1702:	95 85       	ldd	r25, Z+13	; 0x0d
    1704:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <CDC_Device_SendByte>
    1708:	21 e0       	ldi	r18, 0x01	; 1
    170a:	30 e0       	ldi	r19, 0x00	; 0
    170c:	81 11       	cpse	r24, r1
    170e:	02 c0       	rjmp	.+4      	; 0x1714 <CDC_Device_putchar+0x18>
    1710:	20 e0       	ldi	r18, 0x00	; 0
    1712:	30 e0       	ldi	r19, 0x00	; 0
}
    1714:	88 27       	eor	r24, r24
    1716:	99 27       	eor	r25, r25
    1718:	82 1b       	sub	r24, r18
    171a:	93 0b       	sbc	r25, r19
    171c:	08 95       	ret

0000171e <CDC_Device_Flush>:
	Endpoint_Write_8(Data);
	return ENDPOINT_READYWAIT_NoError;
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    171e:	cf 93       	push	r28
    1720:	df 93       	push	r29
    1722:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    1724:	90 91 3f 95 	lds	r25, 0x953F
    1728:	94 30       	cpi	r25, 0x04	; 4
    172a:	f1 f5       	brne	.+124    	; 0x17a8 <CDC_Device_Flush+0x8a>
    172c:	84 89       	ldd	r24, Z+20	; 0x14
    172e:	95 89       	ldd	r25, Z+21	; 0x15
    1730:	a6 89       	ldd	r26, Z+22	; 0x16
    1732:	b7 89       	ldd	r27, Z+23	; 0x17
    1734:	89 2b       	or	r24, r25
    1736:	8a 2b       	or	r24, r26
    1738:	8b 2b       	or	r24, r27
    173a:	c1 f1       	breq	.+112    	; 0x17ac <CDC_Device_Flush+0x8e>
	  return ENDPOINT_RWSTREAM_DeviceDisconnected;

	uint8_t ErrorCode;

	Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
    173c:	81 81       	ldd	r24, Z+1	; 0x01
    173e:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    1742:	80 91 4c 95 	lds	r24, 0x954C
    1746:	88 23       	and	r24, r24
    1748:	4c f4       	brge	.+18     	; 0x175c <CDC_Device_Flush+0x3e>
				  return USB_Endpoint_SelectedFIFO->Position;
    174a:	e0 91 48 95 	lds	r30, 0x9548
    174e:	f0 91 49 95 	lds	r31, 0x9549
    1752:	ef 5b       	subi	r30, 0xBF	; 191
    1754:	ff 4f       	sbci	r31, 0xFF	; 255
    1756:	80 81       	ld	r24, Z
    1758:	90 e0       	ldi	r25, 0x00	; 0
    175a:	0d c0       	rjmp	.+26     	; 0x1776 <CDC_Device_Flush+0x58>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    175c:	20 91 48 95 	lds	r18, 0x9548
    1760:	30 91 49 95 	lds	r19, 0x9549
    1764:	f9 01       	movw	r30, r18
    1766:	e0 5c       	subi	r30, 0xC0	; 192
    1768:	ff 4f       	sbci	r31, 0xFF	; 255
    176a:	80 81       	ld	r24, Z
    176c:	31 96       	adiw	r30, 0x01	; 1
    176e:	20 81       	ld	r18, Z
    1770:	90 e0       	ldi	r25, 0x00	; 0
    1772:	82 1b       	sub	r24, r18
    1774:	91 09       	sbc	r25, r1

	if (!(Endpoint_BytesInEndpoint()))
    1776:	89 2b       	or	r24, r25
    1778:	d9 f0       	breq	.+54     	; 0x17b0 <CDC_Device_Flush+0x92>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return (USB_Endpoint_SelectedFIFO->Position < USB_Endpoint_SelectedFIFO->Length);
    177a:	80 91 48 95 	lds	r24, 0x9548
    177e:	90 91 49 95 	lds	r25, 0x9549
    1782:	fc 01       	movw	r30, r24
    1784:	ef 5b       	subi	r30, 0xBF	; 191
    1786:	ff 4f       	sbci	r31, 0xFF	; 255
    1788:	d0 81       	ld	r29, Z
    178a:	31 97       	sbiw	r30, 0x01	; 1
    178c:	c0 81       	ld	r28, Z
	  return ENDPOINT_READYWAIT_NoError;

	bool BankFull = !(Endpoint_IsReadWriteAllowed());

	Endpoint_ClearIN();
    178e:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>

	if (BankFull)
    1792:	dc 17       	cp	r29, r28
    1794:	78 f0       	brcs	.+30     	; 0x17b4 <CDC_Device_Flush+0x96>
	{
		if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    1796:	0e 94 d0 11 	call	0x23a0	; 0x23a0 <Endpoint_WaitUntilReady>
    179a:	c8 2f       	mov	r28, r24
    179c:	81 11       	cpse	r24, r1
    179e:	0c c0       	rjmp	.+24     	; 0x17b8 <CDC_Device_Flush+0x9a>
		  return ErrorCode;

		Endpoint_ClearIN();
    17a0:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>
	}

	return ENDPOINT_READYWAIT_NoError;
    17a4:	8c 2f       	mov	r24, r28
    17a6:	08 c0       	rjmp	.+16     	; 0x17b8 <CDC_Device_Flush+0x9a>
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
	  return ENDPOINT_RWSTREAM_DeviceDisconnected;
    17a8:	82 e0       	ldi	r24, 0x02	; 2
    17aa:	06 c0       	rjmp	.+12     	; 0x17b8 <CDC_Device_Flush+0x9a>
    17ac:	82 e0       	ldi	r24, 0x02	; 2
    17ae:	04 c0       	rjmp	.+8      	; 0x17b8 <CDC_Device_Flush+0x9a>
	uint8_t ErrorCode;

	Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);

	if (!(Endpoint_BytesInEndpoint()))
	  return ENDPOINT_READYWAIT_NoError;
    17b0:	80 e0       	ldi	r24, 0x00	; 0
    17b2:	02 c0       	rjmp	.+4      	; 0x17b8 <CDC_Device_Flush+0x9a>
		  return ErrorCode;

		Endpoint_ClearIN();
	}

	return ENDPOINT_READYWAIT_NoError;
    17b4:	80 e0       	ldi	r24, 0x00	; 0
    17b6:	00 c0       	rjmp	.+0      	; 0x17b8 <CDC_Device_Flush+0x9a>
}
    17b8:	df 91       	pop	r29
    17ba:	cf 91       	pop	r28
    17bc:	08 95       	ret

000017be <CDC_Device_USBTask>:

	return true;
}

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    17be:	cf 93       	push	r28
    17c0:	df 93       	push	r29
    17c2:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    17c4:	90 91 3f 95 	lds	r25, 0x953F
    17c8:	94 30       	cpi	r25, 0x04	; 4
    17ca:	99 f4       	brne	.+38     	; 0x17f2 <CDC_Device_USBTask+0x34>
    17cc:	84 89       	ldd	r24, Z+20	; 0x14
    17ce:	95 89       	ldd	r25, Z+21	; 0x15
    17d0:	a6 89       	ldd	r26, Z+22	; 0x16
    17d2:	b7 89       	ldd	r27, Z+23	; 0x17
    17d4:	89 2b       	or	r24, r25
    17d6:	8a 2b       	or	r24, r26
    17d8:	8b 2b       	or	r24, r27
    17da:	59 f0       	breq	.+22     	; 0x17f2 <CDC_Device_USBTask+0x34>
    17dc:	ef 01       	movw	r28, r30
	  return;

	#if !defined(NO_CLASS_DRIVER_AUTOFLUSH)
	Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
    17de:	81 81       	ldd	r24, Z+1	; 0x01
    17e0:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	if (Endpoint_IsINReady())
    17e4:	0e 94 50 10 	call	0x20a0	; 0x20a0 <Endpoint_IsINReady>
    17e8:	88 23       	and	r24, r24
    17ea:	19 f0       	breq	.+6      	; 0x17f2 <CDC_Device_USBTask+0x34>
	  CDC_Device_Flush(CDCInterfaceInfo);
    17ec:	ce 01       	movw	r24, r28
    17ee:	0e 94 8f 0b 	call	0x171e	; 0x171e <CDC_Device_Flush>
	#endif
}
    17f2:	df 91       	pop	r29
    17f4:	cf 91       	pop	r28
    17f6:	08 95       	ret

000017f8 <CDC_Device_ReceiveByte>:
		return 0;
	}
}

int16_t CDC_Device_ReceiveByte(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    17f8:	cf 93       	push	r28
    17fa:	df 93       	push	r29
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    17fc:	20 91 3f 95 	lds	r18, 0x953F
    1800:	24 30       	cpi	r18, 0x04	; 4
    1802:	09 f0       	breq	.+2      	; 0x1806 <CDC_Device_ReceiveByte+0xe>
    1804:	56 c0       	rjmp	.+172    	; 0x18b2 <CDC_Device_ReceiveByte+0xba>
    1806:	fc 01       	movw	r30, r24
    1808:	44 89       	ldd	r20, Z+20	; 0x14
    180a:	55 89       	ldd	r21, Z+21	; 0x15
    180c:	66 89       	ldd	r22, Z+22	; 0x16
    180e:	77 89       	ldd	r23, Z+23	; 0x17
    1810:	45 2b       	or	r20, r21
    1812:	46 2b       	or	r20, r22
    1814:	47 2b       	or	r20, r23
    1816:	09 f4       	brne	.+2      	; 0x181a <CDC_Device_ReceiveByte+0x22>
    1818:	4f c0       	rjmp	.+158    	; 0x18b8 <CDC_Device_ReceiveByte+0xc0>
	  return -1;

	int16_t ReceivedByte = -1;

	Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpoint.Address);
    181a:	86 81       	ldd	r24, Z+6	; 0x06
    181c:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	if (Endpoint_IsOUTReceived())
    1820:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Endpoint_IsOUTReceived>
    1824:	88 23       	and	r24, r24
    1826:	09 f4       	brne	.+2      	; 0x182a <CDC_Device_ReceiveByte+0x32>
    1828:	4a c0       	rjmp	.+148    	; 0x18be <CDC_Device_ReceiveByte+0xc6>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    182a:	80 91 4c 95 	lds	r24, 0x954C
    182e:	88 23       	and	r24, r24
    1830:	4c f4       	brge	.+18     	; 0x1844 <CDC_Device_ReceiveByte+0x4c>
				  return USB_Endpoint_SelectedFIFO->Position;
    1832:	e0 91 48 95 	lds	r30, 0x9548
    1836:	f0 91 49 95 	lds	r31, 0x9549
    183a:	ef 5b       	subi	r30, 0xBF	; 191
    183c:	ff 4f       	sbci	r31, 0xFF	; 255
    183e:	80 81       	ld	r24, Z
    1840:	90 e0       	ldi	r25, 0x00	; 0
    1842:	0d c0       	rjmp	.+26     	; 0x185e <CDC_Device_ReceiveByte+0x66>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    1844:	20 91 48 95 	lds	r18, 0x9548
    1848:	30 91 49 95 	lds	r19, 0x9549
    184c:	f9 01       	movw	r30, r18
    184e:	e0 5c       	subi	r30, 0xC0	; 192
    1850:	ff 4f       	sbci	r31, 0xFF	; 255
    1852:	80 81       	ld	r24, Z
    1854:	31 96       	adiw	r30, 0x01	; 1
    1856:	20 81       	ld	r18, Z
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	82 1b       	sub	r24, r18
    185c:	91 09       	sbc	r25, r1
	{
		if (Endpoint_BytesInEndpoint())
    185e:	89 2b       	or	r24, r25
    1860:	29 f0       	breq	.+10     	; 0x186c <CDC_Device_ReceiveByte+0x74>
		  ReceivedByte = Endpoint_Read_8();
    1862:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <Endpoint_Read_8>
    1866:	c8 2f       	mov	r28, r24
    1868:	d0 e0       	ldi	r29, 0x00	; 0
    186a:	02 c0       	rjmp	.+4      	; 0x1870 <CDC_Device_ReceiveByte+0x78>
int16_t CDC_Device_ReceiveByte(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
	  return -1;

	int16_t ReceivedByte = -1;
    186c:	cf ef       	ldi	r28, 0xFF	; 255
    186e:	df ef       	ldi	r29, 0xFF	; 255
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    1870:	80 91 4c 95 	lds	r24, 0x954C
    1874:	88 23       	and	r24, r24
    1876:	4c f4       	brge	.+18     	; 0x188a <CDC_Device_ReceiveByte+0x92>
				  return USB_Endpoint_SelectedFIFO->Position;
    1878:	e0 91 48 95 	lds	r30, 0x9548
    187c:	f0 91 49 95 	lds	r31, 0x9549
    1880:	ef 5b       	subi	r30, 0xBF	; 191
    1882:	ff 4f       	sbci	r31, 0xFF	; 255
    1884:	20 81       	ld	r18, Z
    1886:	30 e0       	ldi	r19, 0x00	; 0
    1888:	0d c0       	rjmp	.+26     	; 0x18a4 <CDC_Device_ReceiveByte+0xac>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    188a:	40 91 48 95 	lds	r20, 0x9548
    188e:	50 91 49 95 	lds	r21, 0x9549
    1892:	fa 01       	movw	r30, r20
    1894:	e0 5c       	subi	r30, 0xC0	; 192
    1896:	ff 4f       	sbci	r31, 0xFF	; 255
    1898:	20 81       	ld	r18, Z
    189a:	31 96       	adiw	r30, 0x01	; 1
    189c:	80 81       	ld	r24, Z
    189e:	30 e0       	ldi	r19, 0x00	; 0
    18a0:	28 1b       	sub	r18, r24
    18a2:	31 09       	sbc	r19, r1
	if (Endpoint_IsOUTReceived())
	{
		if (Endpoint_BytesInEndpoint())
		  ReceivedByte = Endpoint_Read_8();

		if (!(Endpoint_BytesInEndpoint()))
    18a4:	23 2b       	or	r18, r19
    18a6:	71 f4       	brne	.+28     	; 0x18c4 <CDC_Device_ReceiveByte+0xcc>
		  Endpoint_ClearOUT();
    18a8:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <Endpoint_ClearOUT>
    18ac:	8c 2f       	mov	r24, r28
    18ae:	9d 2f       	mov	r25, r29
    18b0:	0b c0       	rjmp	.+22     	; 0x18c8 <CDC_Device_ReceiveByte+0xd0>
}

int16_t CDC_Device_ReceiveByte(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
	  return -1;
    18b2:	8f ef       	ldi	r24, 0xFF	; 255
    18b4:	9f ef       	ldi	r25, 0xFF	; 255
    18b6:	08 c0       	rjmp	.+16     	; 0x18c8 <CDC_Device_ReceiveByte+0xd0>
    18b8:	8f ef       	ldi	r24, 0xFF	; 255
    18ba:	9f ef       	ldi	r25, 0xFF	; 255
    18bc:	05 c0       	rjmp	.+10     	; 0x18c8 <CDC_Device_ReceiveByte+0xd0>

	int16_t ReceivedByte = -1;
    18be:	8f ef       	ldi	r24, 0xFF	; 255
    18c0:	9f ef       	ldi	r25, 0xFF	; 255
    18c2:	02 c0       	rjmp	.+4      	; 0x18c8 <CDC_Device_ReceiveByte+0xd0>
    18c4:	8c 2f       	mov	r24, r28
    18c6:	9d 2f       	mov	r25, r29
		if (!(Endpoint_BytesInEndpoint()))
		  Endpoint_ClearOUT();
	}

	return ReceivedByte;
}
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	08 95       	ret

000018ce <CDC_Device_getchar>:
	return CDC_Device_SendByte((USB_ClassInfo_CDC_Device_t*)fdev_get_udata(Stream), c) ? _FDEV_ERR : 0;
}

static int CDC_Device_getchar(FILE* Stream)
{
	int16_t ReceivedByte = CDC_Device_ReceiveByte((USB_ClassInfo_CDC_Device_t*)fdev_get_udata(Stream));
    18ce:	fc 01       	movw	r30, r24
    18d0:	84 85       	ldd	r24, Z+12	; 0x0c
    18d2:	95 85       	ldd	r25, Z+13	; 0x0d
    18d4:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <CDC_Device_ReceiveByte>

	if (ReceivedByte < 0)
    18d8:	99 23       	and	r25, r25
    18da:	14 f4       	brge	.+4      	; 0x18e0 <CDC_Device_getchar+0x12>
	  return _FDEV_EOF;
    18dc:	8e ef       	ldi	r24, 0xFE	; 254
    18de:	9f ef       	ldi	r25, 0xFF	; 255

	return ReceivedByte;
}
    18e0:	08 95       	ret

000018e2 <CDC_Device_CreateStream>:
}

#if defined(FDEV_SETUP_STREAM)
void CDC_Device_CreateStream(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                             FILE* const Stream)
{
    18e2:	fb 01       	movw	r30, r22
	*Stream = (FILE)FDEV_SETUP_STREAM(CDC_Device_putchar, CDC_Device_getchar, _FDEV_SETUP_RW);
    18e4:	2e e0       	ldi	r18, 0x0E	; 14
    18e6:	db 01       	movw	r26, r22
    18e8:	1d 92       	st	X+, r1
    18ea:	2a 95       	dec	r18
    18ec:	e9 f7       	brne	.-6      	; 0x18e8 <CDC_Device_CreateStream+0x6>
    18ee:	23 e0       	ldi	r18, 0x03	; 3
    18f0:	23 83       	std	Z+3, r18	; 0x03
    18f2:	2e e7       	ldi	r18, 0x7E	; 126
    18f4:	3b e0       	ldi	r19, 0x0B	; 11
    18f6:	20 87       	std	Z+8, r18	; 0x08
    18f8:	31 87       	std	Z+9, r19	; 0x09
    18fa:	27 e6       	ldi	r18, 0x67	; 103
    18fc:	3c e0       	ldi	r19, 0x0C	; 12
    18fe:	22 87       	std	Z+10, r18	; 0x0a
    1900:	33 87       	std	Z+11, r19	; 0x0b
	fdev_set_udata(Stream, CDCInterfaceInfo);
    1902:	84 87       	std	Z+12, r24	; 0x0c
    1904:	95 87       	std	Z+13, r25	; 0x0d
    1906:	08 95       	ret

00001908 <CDC_Device_Event_Stub>:
	return ReceivedByte;
}
#endif

void CDC_Device_Event_Stub(void)
{
    1908:	08 95       	ret

0000190a <CDC_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_CDC_DRIVER
#define  __INCLUDE_FROM_CDC_DEVICE_C
#include "CDCClassDevice.h"

void CDC_Device_ProcessControlRequest(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    190a:	ff 92       	push	r15
    190c:	0f 93       	push	r16
    190e:	1f 93       	push	r17
    1910:	cf 93       	push	r28
    1912:	df 93       	push	r29
    1914:	ec 01       	movw	r28, r24
	if (!(Endpoint_IsSETUPReceived()))
    1916:	0e 94 77 10 	call	0x20ee	; 0x20ee <Endpoint_IsSETUPReceived>
    191a:	88 23       	and	r24, r24
    191c:	09 f4       	brne	.+2      	; 0x1920 <CDC_Device_ProcessControlRequest+0x16>
    191e:	9b c0       	rjmp	.+310    	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
	  return;

	if (USB_ControlRequest.wIndex != CDCInterfaceInfo->Config.ControlInterfaceNumber)
    1920:	28 81       	ld	r18, Y
    1922:	30 e0       	ldi	r19, 0x00	; 0
    1924:	80 91 44 95 	lds	r24, 0x9544
    1928:	90 91 45 95 	lds	r25, 0x9545
    192c:	82 17       	cp	r24, r18
    192e:	93 07       	cpc	r25, r19
    1930:	09 f0       	breq	.+2      	; 0x1934 <CDC_Device_ProcessControlRequest+0x2a>
    1932:	91 c0       	rjmp	.+290    	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
	  return;

	switch (USB_ControlRequest.bRequest)
    1934:	80 91 41 95 	lds	r24, 0x9541
    1938:	81 32       	cpi	r24, 0x21	; 33
    193a:	59 f0       	breq	.+22     	; 0x1952 <CDC_Device_ProcessControlRequest+0x48>
    193c:	18 f4       	brcc	.+6      	; 0x1944 <CDC_Device_ProcessControlRequest+0x3a>
    193e:	80 32       	cpi	r24, 0x20	; 32
    1940:	81 f1       	breq	.+96     	; 0x19a2 <CDC_Device_ProcessControlRequest+0x98>
    1942:	89 c0       	rjmp	.+274    	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
    1944:	82 32       	cpi	r24, 0x22	; 34
    1946:	09 f4       	brne	.+2      	; 0x194a <CDC_Device_ProcessControlRequest+0x40>
    1948:	67 c0       	rjmp	.+206    	; 0x1a18 <CDC_Device_ProcessControlRequest+0x10e>
    194a:	83 32       	cpi	r24, 0x23	; 35
    194c:	09 f4       	brne	.+2      	; 0x1950 <CDC_Device_ProcessControlRequest+0x46>
    194e:	76 c0       	rjmp	.+236    	; 0x1a3c <CDC_Device_ProcessControlRequest+0x132>
    1950:	82 c0       	rjmp	.+260    	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
	{
		case CDC_REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    1952:	80 91 40 95 	lds	r24, 0x9540
    1956:	81 3a       	cpi	r24, 0xA1	; 161
    1958:	09 f0       	breq	.+2      	; 0x195c <CDC_Device_ProcessControlRequest+0x52>
    195a:	7d c0       	rjmp	.+250    	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    195c:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>

				while (!(Endpoint_IsINReady()));
    1960:	0e 94 50 10 	call	0x20a0	; 0x20a0 <Endpoint_IsINReady>
    1964:	88 23       	and	r24, r24
    1966:	e1 f3       	breq	.-8      	; 0x1960 <CDC_Device_ProcessControlRequest+0x56>

				Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
    1968:	8c 89       	ldd	r24, Y+20	; 0x14
    196a:	fd 88       	ldd	r15, Y+21	; 0x15
    196c:	0e 89       	ldd	r16, Y+22	; 0x16
    196e:	1f 89       	ldd	r17, Y+23	; 0x17
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_32_LE(const uint32_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_32_LE(const uint32_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    1970:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    1974:	8f 2d       	mov	r24, r15
    1976:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 16);
    197a:	80 2f       	mov	r24, r16
    197c:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 24);
    1980:	81 2f       	mov	r24, r17
    1982:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
    1986:	88 8d       	ldd	r24, Y+24	; 0x18
    1988:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
    198c:	89 8d       	ldd	r24, Y+25	; 0x19
    198e:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
    1992:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1994:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>

				Endpoint_ClearIN();
    1998:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>
				Endpoint_ClearStatusStage();
    199c:	0e 94 b5 11 	call	0x236a	; 0x236a <Endpoint_ClearStatusStage>
    19a0:	5a c0       	rjmp	.+180    	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    19a2:	80 91 40 95 	lds	r24, 0x9540
    19a6:	81 32       	cpi	r24, 0x21	; 33
    19a8:	09 f0       	breq	.+2      	; 0x19ac <CDC_Device_ProcessControlRequest+0xa2>
    19aa:	55 c0       	rjmp	.+170    	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    19ac:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>

				while (!(Endpoint_IsOUTReceived()))
    19b0:	05 c0       	rjmp	.+10     	; 0x19bc <CDC_Device_ProcessControlRequest+0xb2>
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    19b2:	80 91 3f 95 	lds	r24, 0x953F
    19b6:	88 23       	and	r24, r24
    19b8:	09 f4       	brne	.+2      	; 0x19bc <CDC_Device_ProcessControlRequest+0xb2>
    19ba:	4d c0       	rjmp	.+154    	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSETUP();

				while (!(Endpoint_IsOUTReceived()))
    19bc:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Endpoint_IsOUTReceived>
    19c0:	88 23       	and	r24, r24
    19c2:	b9 f3       	breq	.-18     	; 0x19b2 <CDC_Device_ProcessControlRequest+0xa8>
			 *  \return Next four bytes in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
    19c4:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <Endpoint_Read_8>
    19c8:	f8 2e       	mov	r15, r24
				uint32_t Byte1 = Endpoint_Read_8();
    19ca:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <Endpoint_Read_8>
    19ce:	18 2f       	mov	r17, r24
				uint32_t Byte2 = Endpoint_Read_8();
    19d0:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <Endpoint_Read_8>
    19d4:	08 2f       	mov	r16, r24
				uint32_t Byte3 = Endpoint_Read_8();
    19d6:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <Endpoint_Read_8>
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
				uint32_t Byte1 = Endpoint_Read_8();
				uint32_t Byte2 = Endpoint_Read_8();
    19da:	40 2f       	mov	r20, r16
    19dc:	50 e0       	ldi	r21, 0x00	; 0
    19de:	60 e0       	ldi	r22, 0x00	; 0
    19e0:	70 e0       	ldi	r23, 0x00	; 0
				uint32_t Byte3 = Endpoint_Read_8();

				return ((Byte3 << 24) | (Byte2 << 16) | (Byte1 << 8) | Byte0);
    19e2:	ba 01       	movw	r22, r20
    19e4:	55 27       	eor	r21, r21
    19e6:	44 27       	eor	r20, r20
    19e8:	78 2b       	or	r23, r24
    19ea:	4f 29       	or	r20, r15
    19ec:	51 2b       	or	r21, r17
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
					  return;
				}

				CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
    19ee:	4c 8b       	std	Y+20, r20	; 0x14
    19f0:	5d 8b       	std	Y+21, r21	; 0x15
    19f2:	6e 8b       	std	Y+22, r22	; 0x16
    19f4:	7f 8b       	std	Y+23, r23	; 0x17
				CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
    19f6:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <Endpoint_Read_8>
    19fa:	88 8f       	std	Y+24, r24	; 0x18
				CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
    19fc:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <Endpoint_Read_8>
    1a00:	89 8f       	std	Y+25, r24	; 0x19
				CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
    1a02:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <Endpoint_Read_8>
    1a06:	8a 8f       	std	Y+26, r24	; 0x1a

				Endpoint_ClearOUT();
    1a08:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <Endpoint_ClearOUT>
				Endpoint_ClearStatusStage();
    1a0c:	0e 94 b5 11 	call	0x236a	; 0x236a <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_LineEncodingChanged(CDCInterfaceInfo);
    1a10:	ce 01       	movw	r24, r28
    1a12:	0e 94 84 0c 	call	0x1908	; 0x1908 <CDC_Device_Event_Stub>
    1a16:	1f c0       	rjmp	.+62     	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SetControlLineState:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    1a18:	80 91 40 95 	lds	r24, 0x9540
    1a1c:	81 32       	cpi	r24, 0x21	; 33
    1a1e:	d9 f4       	brne	.+54     	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    1a20:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    1a24:	0e 94 b5 11 	call	0x236a	; 0x236a <Endpoint_ClearStatusStage>

				CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
    1a28:	80 91 42 95 	lds	r24, 0x9542
    1a2c:	90 91 43 95 	lds	r25, 0x9543
    1a30:	88 8b       	std	Y+16, r24	; 0x10
    1a32:	99 8b       	std	Y+17, r25	; 0x11

				EVENT_CDC_Device_ControLineStateChanged(CDCInterfaceInfo);
    1a34:	ce 01       	movw	r24, r28
    1a36:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <EVENT_CDC_Device_ControLineStateChanged>
    1a3a:	0d c0       	rjmp	.+26     	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SendBreak:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    1a3c:	80 91 40 95 	lds	r24, 0x9540
    1a40:	81 32       	cpi	r24, 0x21	; 33
    1a42:	49 f4       	brne	.+18     	; 0x1a56 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    1a44:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    1a48:	0e 94 b5 11 	call	0x236a	; 0x236a <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
    1a4c:	60 91 42 95 	lds	r22, 0x9542
    1a50:	ce 01       	movw	r24, r28
    1a52:	0e 94 84 0c 	call	0x1908	; 0x1908 <CDC_Device_Event_Stub>
			}

			break;
	}
}
    1a56:	df 91       	pop	r29
    1a58:	cf 91       	pop	r28
    1a5a:	1f 91       	pop	r17
    1a5c:	0f 91       	pop	r16
    1a5e:	ff 90       	pop	r15
    1a60:	08 95       	ret

00001a62 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1a62:	ef 92       	push	r14
    1a64:	ff 92       	push	r15
    1a66:	0f 93       	push	r16
    1a68:	1f 93       	push	r17
    1a6a:	cf 93       	push	r28
    1a6c:	df 93       	push	r29
    1a6e:	cd b7       	in	r28, 0x3d	; 61
    1a70:	de b7       	in	r29, 0x3e	; 62
    1a72:	ea 97       	sbiw	r28, 0x3a	; 58
    1a74:	cd bf       	out	0x3d, r28	; 61
    1a76:	de bf       	out	0x3e, r29	; 62
    1a78:	00 e4       	ldi	r16, 0x40	; 64
    1a7a:	15 e9       	ldi	r17, 0x95	; 149
    1a7c:	0f 2e       	mov	r0, r31
    1a7e:	f8 e4       	ldi	r31, 0x48	; 72
    1a80:	ef 2e       	mov	r14, r31
    1a82:	f5 e9       	ldi	r31, 0x95	; 149
    1a84:	ff 2e       	mov	r15, r31
    1a86:	f0 2d       	mov	r31, r0
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    1a88:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <Endpoint_Read_8>
    1a8c:	f8 01       	movw	r30, r16
    1a8e:	81 93       	st	Z+, r24
    1a90:	8f 01       	movw	r16, r30
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1a92:	ee 15       	cp	r30, r14
    1a94:	ff 05       	cpc	r31, r15
    1a96:	c1 f7       	brne	.-16     	; 0x1a88 <USB_Device_ProcessControlRequest+0x26>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    1a98:	0e 94 57 0a 	call	0x14ae	; 0x14ae <EVENT_USB_Device_ControlRequest>

	if (Endpoint_IsSETUPReceived())
    1a9c:	0e 94 77 10 	call	0x20ee	; 0x20ee <Endpoint_IsSETUPReceived>
    1aa0:	88 23       	and	r24, r24
    1aa2:	09 f4       	brne	.+2      	; 0x1aa6 <USB_Device_ProcessControlRequest+0x44>
    1aa4:	13 c1       	rjmp	.+550    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1aa6:	e0 e4       	ldi	r30, 0x40	; 64
    1aa8:	f5 e9       	ldi	r31, 0x95	; 149
    1aaa:	20 81       	ld	r18, Z

		switch (USB_ControlRequest.bRequest)
    1aac:	31 81       	ldd	r19, Z+1	; 0x01
    1aae:	83 2f       	mov	r24, r19
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	8a 30       	cpi	r24, 0x0A	; 10
    1ab4:	91 05       	cpc	r25, r1
    1ab6:	08 f0       	brcs	.+2      	; 0x1aba <USB_Device_ProcessControlRequest+0x58>
    1ab8:	09 c1       	rjmp	.+530    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
    1aba:	fc 01       	movw	r30, r24
    1abc:	88 27       	eor	r24, r24
    1abe:	e2 50       	subi	r30, 0x02	; 2
    1ac0:	ff 4f       	sbci	r31, 0xFF	; 255
    1ac2:	8f 4f       	sbci	r24, 0xFF	; 255
    1ac4:	0c 94 91 13 	jmp	0x2722	; 0x2722 <__tablejump2__>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1ac8:	20 38       	cpi	r18, 0x80	; 128
    1aca:	21 f0       	breq	.+8      	; 0x1ad4 <USB_Device_ProcessControlRequest+0x72>
    1acc:	22 38       	cpi	r18, 0x82	; 130
    1ace:	09 f0       	breq	.+2      	; 0x1ad2 <USB_Device_ProcessControlRequest+0x70>
    1ad0:	fd c0       	rjmp	.+506    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
    1ad2:	08 c0       	rjmp	.+16     	; 0x1ae4 <USB_Device_ProcessControlRequest+0x82>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    1ad4:	10 91 3c 95 	lds	r17, 0x953C
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    1ad8:	80 91 3d 95 	lds	r24, 0x953D
    1adc:	88 23       	and	r24, r24
    1ade:	91 f0       	breq	.+36     	; 0x1b04 <USB_Device_ProcessControlRequest+0xa2>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    1ae0:	12 60       	ori	r17, 0x02	; 2
    1ae2:	10 c0       	rjmp	.+32     	; 0x1b04 <USB_Device_ProcessControlRequest+0xa2>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1ae4:	80 91 44 95 	lds	r24, 0x9544
    1ae8:	8f 70       	andi	r24, 0x0F	; 15
    1aea:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    1aee:	e0 91 4a 95 	lds	r30, 0x954A
    1af2:	f0 91 4b 95 	lds	r31, 0x954B
    1af6:	11 81       	ldd	r17, Z+1	; 0x01
    1af8:	12 fb       	bst	r17, 2
    1afa:	11 27       	eor	r17, r17
    1afc:	10 f9       	bld	r17, 0

			CurrentStatus = Endpoint_IsStalled();

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    1afe:	80 e0       	ldi	r24, 0x00	; 0
    1b00:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>
			break;
		default:
			return;
	}

	Endpoint_ClearSETUP();
    1b04:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    1b08:	81 2f       	mov	r24, r17
    1b0a:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    1b0e:	80 e0       	ldi	r24, 0x00	; 0
    1b10:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();
    1b14:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>

	Endpoint_ClearStatusStage();
    1b18:	0e 94 b5 11 	call	0x236a	; 0x236a <Endpoint_ClearStatusStage>
    1b1c:	d7 c0       	rjmp	.+430    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1b1e:	22 23       	and	r18, r18
    1b20:	09 f4       	brne	.+2      	; 0x1b24 <USB_Device_ProcessControlRequest+0xc2>
    1b22:	dd c0       	rjmp	.+442    	; 0x1cde <USB_Device_ProcessControlRequest+0x27c>
    1b24:	22 30       	cpi	r18, 0x02	; 2
    1b26:	09 f0       	breq	.+2      	; 0x1b2a <USB_Device_ProcessControlRequest+0xc8>
    1b28:	d1 c0       	rjmp	.+418    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
    1b2a:	de c0       	rjmp	.+444    	; 0x1ce8 <USB_Device_ProcessControlRequest+0x286>
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    1b2c:	81 e0       	ldi	r24, 0x01	; 1
    1b2e:	33 30       	cpi	r19, 0x03	; 3
    1b30:	09 f0       	breq	.+2      	; 0x1b34 <USB_Device_ProcessControlRequest+0xd2>
    1b32:	80 e0       	ldi	r24, 0x00	; 0
    1b34:	80 93 3d 95 	sts	0x953D, r24
    1b38:	25 c0       	rjmp	.+74     	; 0x1b84 <USB_Device_ProcessControlRequest+0x122>
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1b3a:	e0 91 44 95 	lds	r30, 0x9544
    1b3e:	1e 2f       	mov	r17, r30
    1b40:	1f 70       	andi	r17, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    1b42:	09 f4       	brne	.+2      	; 0x1b46 <USB_Device_ProcessControlRequest+0xe4>
    1b44:	c3 c0       	rjmp	.+390    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
    1b46:	81 2f       	mov	r24, r17
    1b48:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

				if (Endpoint_IsEnabled())
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    1b4c:	80 91 41 95 	lds	r24, 0x9541
    1b50:	83 30       	cpi	r24, 0x03	; 3
    1b52:	19 f4       	brne	.+6      	; 0x1b5a <USB_Device_ProcessControlRequest+0xf8>
					{
						Endpoint_StallTransaction();
    1b54:	0e 94 bf 10 	call	0x217e	; 0x217e <Endpoint_StallTransaction>
    1b58:	15 c0       	rjmp	.+42     	; 0x1b84 <USB_Device_ProcessControlRequest+0x122>
			 *  \ingroup Group_EndpointPacketManagement_XMEGA
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				USB_Endpoint_SelectedHandle->CTRL &= ~USB_EP_STALL_bm;
    1b5a:	e0 91 4a 95 	lds	r30, 0x954A
    1b5e:	f0 91 4b 95 	lds	r31, 0x954B
    1b62:	81 81       	ldd	r24, Z+1	; 0x01
    1b64:	8b 7f       	andi	r24, 0xFB	; 251
    1b66:	81 83       	std	Z+1, r24	; 0x01
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				if (Address & ENDPOINT_DIR_IN)
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].IN.Position  = 0;
				else
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].OUT.Position = 0;
    1b68:	24 e8       	ldi	r18, 0x84	; 132
    1b6a:	12 9f       	mul	r17, r18
    1b6c:	f0 01       	movw	r30, r0
    1b6e:	11 24       	eor	r1, r1
    1b70:	e2 57       	subi	r30, 0x72	; 114
    1b72:	fa 46       	sbci	r31, 0x6A	; 106
    1b74:	10 82       	st	Z, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				USB_Endpoint_SelectedHandle->STATUS &= ~USB_EP_TOGGLE_bm;
    1b76:	e0 91 4a 95 	lds	r30, 0x954A
    1b7a:	f0 91 4b 95 	lds	r31, 0x954B
    1b7e:	80 81       	ld	r24, Z
    1b80:	8e 7f       	andi	r24, 0xFE	; 254
    1b82:	80 83       	st	Z, r24
		#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    1b84:	80 e0       	ldi	r24, 0x00	; 0
    1b86:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	Endpoint_ClearSETUP();
    1b8a:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    1b8e:	0e 94 b5 11 	call	0x236a	; 0x236a <Endpoint_ClearStatusStage>
    1b92:	9c c0       	rjmp	.+312    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    1b94:	21 11       	cpse	r18, r1
    1b96:	9a c0       	rjmp	.+308    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    1b98:	10 91 42 95 	lds	r17, 0x9542
    1b9c:	1f 77       	andi	r17, 0x7F	; 127

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();
    1b9e:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    1ba2:	0e 94 b5 11 	call	0x236a	; 0x236a <Endpoint_ClearStatusStage>

	while (!(Endpoint_IsINReady()));
    1ba6:	0e 94 50 10 	call	0x20a0	; 0x20a0 <Endpoint_IsINReady>
    1baa:	88 23       	and	r24, r24
    1bac:	e1 f3       	breq	.-8      	; 0x1ba6 <USB_Device_ProcessControlRequest+0x144>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    1bae:	10 93 c3 04 	sts	0x04C3, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    1bb2:	11 11       	cpse	r17, r1
    1bb4:	02 c0       	rjmp	.+4      	; 0x1bba <USB_Device_ProcessControlRequest+0x158>
    1bb6:	82 e0       	ldi	r24, 0x02	; 2
    1bb8:	01 c0       	rjmp	.+2      	; 0x1bbc <USB_Device_ProcessControlRequest+0x15a>
    1bba:	83 e0       	ldi	r24, 0x03	; 3
    1bbc:	80 93 3f 95 	sts	0x953F, r24
    1bc0:	85 c0       	rjmp	.+266    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1bc2:	20 58       	subi	r18, 0x80	; 128
    1bc4:	22 30       	cpi	r18, 0x02	; 2
    1bc6:	08 f0       	brcs	.+2      	; 0x1bca <USB_Device_ProcessControlRequest+0x168>
    1bc8:	81 c0       	rjmp	.+258    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    1bca:	80 91 42 95 	lds	r24, 0x9542
    1bce:	90 91 43 95 	lds	r25, 0x9543
    1bd2:	8c 3d       	cpi	r24, 0xDC	; 220
    1bd4:	e3 e0       	ldi	r30, 0x03	; 3
    1bd6:	9e 07       	cpc	r25, r30
    1bd8:	b9 f5       	brne	.+110    	; 0x1c48 <USB_Device_ProcessControlRequest+0x1e6>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    1bda:	83 e0       	ldi	r24, 0x03	; 3
    1bdc:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    1bde:	8a e3       	ldi	r24, 0x3A	; 58
    1be0:	89 83       	std	Y+1, r24	; 0x01
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    1be2:	7f b7       	in	r23, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    1be4:	f8 94       	cli
				#endif

				GCC_MEMORY_BARRIER();
    1be6:	ae 01       	movw	r20, r28
    1be8:	4d 5f       	subi	r20, 0xFD	; 253
    1bea:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1bec:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    1bee:	38 e0       	ldi	r19, 0x08	; 8

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte;

					NVM.CMD    = NVM_CMD_READ_CALIB_ROW_gc;
    1bf0:	a0 ec       	ldi	r26, 0xC0	; 192
    1bf2:	b1 e0       	ldi	r27, 0x01	; 1
    1bf4:	62 e0       	ldi	r22, 0x02	; 2
    1bf6:	1a 96       	adiw	r26, 0x0a	; 10
    1bf8:	6c 93       	st	X, r22
    1bfa:	1a 97       	sbiw	r26, 0x0a	; 10
					SerialByte = pgm_read_byte(SigReadAddress);
    1bfc:	e3 2f       	mov	r30, r19
    1bfe:	f0 e0       	ldi	r31, 0x00	; 0
    1c00:	84 91       	lpm	r24, Z
					NVM.CMD    = 0;
    1c02:	1a 96       	adiw	r26, 0x0a	; 10
    1c04:	1c 92       	st	X, r1
    1c06:	1a 97       	sbiw	r26, 0x0a	; 10

					if (SerialCharNum & 0x01)
    1c08:	20 ff       	sbrs	r18, 0
    1c0a:	03 c0       	rjmp	.+6      	; 0x1c12 <USB_Device_ProcessControlRequest+0x1b0>
					{
						SerialByte >>= 4;
    1c0c:	82 95       	swap	r24
    1c0e:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    1c10:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    1c12:	8f 70       	andi	r24, 0x0F	; 15

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    1c14:	8a 30       	cpi	r24, 0x0A	; 10
    1c16:	18 f0       	brcs	.+6      	; 0x1c1e <USB_Device_ProcessControlRequest+0x1bc>
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	c7 96       	adiw	r24, 0x37	; 55
    1c1c:	02 c0       	rjmp	.+4      	; 0x1c22 <USB_Device_ProcessControlRequest+0x1c0>
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	c0 96       	adiw	r24, 0x30	; 48
    1c22:	fa 01       	movw	r30, r20
    1c24:	81 93       	st	Z+, r24
    1c26:	91 93       	st	Z+, r25
    1c28:	af 01       	movw	r20, r30
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1c2a:	2f 5f       	subi	r18, 0xFF	; 255
    1c2c:	2c 31       	cpi	r18, 0x1C	; 28
    1c2e:	19 f7       	brne	.-58     	; 0x1bf6 <USB_Device_ProcessControlRequest+0x194>
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    1c30:	7f bf       	out	0x3f, r23	; 63

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();
    1c32:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    1c36:	6a e3       	ldi	r22, 0x3A	; 58
    1c38:	70 e0       	ldi	r23, 0x00	; 0
    1c3a:	ce 01       	movw	r24, r28
    1c3c:	01 96       	adiw	r24, 0x01	; 1
    1c3e:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <Endpoint_Write_Control_Stream_LE>
	Endpoint_ClearOUT();
    1c42:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <Endpoint_ClearOUT>
    1c46:	42 c0       	rjmp	.+132    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    1c48:	ae 01       	movw	r20, r28
    1c4a:	4f 5f       	subi	r20, 0xFF	; 255
    1c4c:	5f 4f       	sbci	r21, 0xFF	; 255
    1c4e:	60 91 44 95 	lds	r22, 0x9544
    1c52:	0e 94 8b 01 	call	0x316	; 0x316 <CALLBACK_USB_GetDescriptor>
    1c56:	8c 01       	movw	r16, r24
    1c58:	89 2b       	or	r24, r25
    1c5a:	c1 f1       	breq	.+112    	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
													 )) == NO_DESCRIPTOR)
	{
		return;
	}

	Endpoint_ClearSETUP();
    1c5c:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    1c60:	b8 01       	movw	r22, r16
    1c62:	89 81       	ldd	r24, Y+1	; 0x01
    1c64:	9a 81       	ldd	r25, Y+2	; 0x02
    1c66:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <Endpoint_Write_Control_PStream_LE>
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
    1c6a:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <Endpoint_ClearOUT>
    1c6e:	2e c0       	rjmp	.+92     	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    1c70:	20 38       	cpi	r18, 0x80	; 128
    1c72:	61 f5       	brne	.+88     	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
	EVENT_USB_Device_ConfigurationChanged();
}

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
    1c74:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    1c78:	80 91 3b 95 	lds	r24, 0x953B
    1c7c:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
	Endpoint_ClearIN();
    1c80:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>

	Endpoint_ClearStatusStage();
    1c84:	0e 94 b5 11 	call	0x236a	; 0x236a <Endpoint_ClearStatusStage>
    1c88:	21 c0       	rjmp	.+66     	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    1c8a:	21 11       	cpse	r18, r1
    1c8c:	1f c0       	rjmp	.+62     	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    1c8e:	80 91 42 95 	lds	r24, 0x9542
    1c92:	82 30       	cpi	r24, 0x02	; 2
    1c94:	d8 f4       	brcc	.+54     	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
	if ((uint8_t)USB_ControlRequest.wValue > DevDescriptorPtr->NumberOfConfigurations)
	  return;
	#endif
	#endif

	Endpoint_ClearSETUP();
    1c96:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    1c9a:	80 91 42 95 	lds	r24, 0x9542
    1c9e:	80 93 3b 95 	sts	0x953B, r24

	Endpoint_ClearStatusStage();
    1ca2:	0e 94 b5 11 	call	0x236a	; 0x236a <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    1ca6:	80 91 3b 95 	lds	r24, 0x953B
    1caa:	88 23       	and	r24, r24
    1cac:	21 f0       	breq	.+8      	; 0x1cb6 <USB_Device_ProcessControlRequest+0x254>
	  USB_DeviceState = DEVICE_STATE_Configured;
    1cae:	84 e0       	ldi	r24, 0x04	; 4
    1cb0:	80 93 3f 95 	sts	0x953F, r24
    1cb4:	09 c0       	rjmp	.+18     	; 0x1cc8 <USB_Device_ProcessControlRequest+0x266>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    1cb6:	80 91 c3 04 	lds	r24, 0x04C3
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1cba:	81 11       	cpse	r24, r1
    1cbc:	02 c0       	rjmp	.+4      	; 0x1cc2 <USB_Device_ProcessControlRequest+0x260>
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	01 c0       	rjmp	.+2      	; 0x1cc4 <USB_Device_ProcessControlRequest+0x262>
    1cc2:	84 e0       	ldi	r24, 0x04	; 4
    1cc4:	80 93 3f 95 	sts	0x953F, r24

	EVENT_USB_Device_ConfigurationChanged();
    1cc8:	0e 94 40 0a 	call	0x1480	; 0x1480 <EVENT_USB_Device_ConfigurationChanged>
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    1ccc:	0e 94 77 10 	call	0x20ee	; 0x20ee <Endpoint_IsSETUPReceived>
    1cd0:	88 23       	and	r24, r24
    1cd2:	81 f0       	breq	.+32     	; 0x1cf4 <USB_Device_ProcessControlRequest+0x292>
	{
		Endpoint_ClearSETUP();
    1cd4:	0e 94 91 10 	call	0x2122	; 0x2122 <Endpoint_ClearSETUP>
		Endpoint_StallTransaction();
    1cd8:	0e 94 bf 10 	call	0x217e	; 0x217e <Endpoint_StallTransaction>
    1cdc:	0b c0       	rjmp	.+22     	; 0x1cf4 <USB_Device_ProcessControlRequest+0x292>
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    1cde:	80 91 42 95 	lds	r24, 0x9542
    1ce2:	81 30       	cpi	r24, 0x01	; 1
    1ce4:	99 f7       	brne	.-26     	; 0x1ccc <USB_Device_ProcessControlRequest+0x26a>
    1ce6:	22 cf       	rjmp	.-444    	; 0x1b2c <USB_Device_ProcessControlRequest+0xca>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    1ce8:	80 91 42 95 	lds	r24, 0x9542
    1cec:	88 23       	and	r24, r24
    1cee:	09 f4       	brne	.+2      	; 0x1cf2 <USB_Device_ProcessControlRequest+0x290>
    1cf0:	24 cf       	rjmp	.-440    	; 0x1b3a <USB_Device_ProcessControlRequest+0xd8>
    1cf2:	48 cf       	rjmp	.-368    	; 0x1b84 <USB_Device_ProcessControlRequest+0x122>
	if (Endpoint_IsSETUPReceived())
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    1cf4:	ea 96       	adiw	r28, 0x3a	; 58
    1cf6:	cd bf       	out	0x3d, r28	; 61
    1cf8:	de bf       	out	0x3e, r29	; 62
    1cfa:	df 91       	pop	r29
    1cfc:	cf 91       	pop	r28
    1cfe:	1f 91       	pop	r17
    1d00:	0f 91       	pop	r16
    1d02:	ff 90       	pop	r15
    1d04:	ef 90       	pop	r14
    1d06:	08 95       	ret

00001d08 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    1d08:	08 95       	ret

00001d0a <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    1d0a:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    1d0c:	80 91 3f 95 	lds	r24, 0x953F
    1d10:	88 23       	and	r24, r24
    1d12:	69 f0       	breq	.+26     	; 0x1d2e <USB_USBTask+0x24>
			 *  \return Index of the currently selected endpoint.
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				return USB_Endpoint_SelectedEndpoint;
    1d14:	c0 91 4c 95 	lds	r28, 0x954C
	  return;

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    1d18:	80 e0       	ldi	r24, 0x00	; 0
    1d1a:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	if (Endpoint_IsSETUPReceived())
    1d1e:	0e 94 77 10 	call	0x20ee	; 0x20ee <Endpoint_IsSETUPReceived>
    1d22:	81 11       	cpse	r24, r1
	  USB_Device_ProcessControlRequest();
    1d24:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <USB_Device_ProcessControlRequest>

	Endpoint_SelectEndpoint(PrevEndpoint);
    1d28:	8c 2f       	mov	r24, r28
    1d2a:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    1d2e:	cf 91       	pop	r28
    1d30:	08 95       	ret

00001d32 <Endpoint_Write_Control_Stream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    1d32:	cf 92       	push	r12
    1d34:	df 92       	push	r13
    1d36:	ef 92       	push	r14
    1d38:	ff 92       	push	r15
    1d3a:	0f 93       	push	r16
    1d3c:	1f 93       	push	r17
    1d3e:	cf 93       	push	r28
    1d40:	df 93       	push	r29
    1d42:	c8 2e       	mov	r12, r24
    1d44:	d9 2e       	mov	r13, r25
    1d46:	8b 01       	movw	r16, r22
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    1d48:	80 91 4c 95 	lds	r24, 0x954C
    1d4c:	80 68       	ori	r24, 0x80	; 128
    1d4e:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	if (Length > USB_ControlRequest.wLength)
    1d52:	c0 91 46 95 	lds	r28, 0x9546
    1d56:	d0 91 47 95 	lds	r29, 0x9547
    1d5a:	c0 17       	cp	r28, r16
    1d5c:	d1 07       	cpc	r29, r17
    1d5e:	40 f0       	brcs	.+16     	; 0x1d70 <Endpoint_Write_Control_Stream_LE+0x3e>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1d60:	01 15       	cp	r16, r1
    1d62:	11 05       	cpc	r17, r1
    1d64:	21 f4       	brne	.+8      	; 0x1d6e <Endpoint_Write_Control_Stream_LE+0x3c>
	  Endpoint_ClearIN();
    1d66:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>
    1d6a:	e8 01       	movw	r28, r16
    1d6c:	01 c0       	rjmp	.+2      	; 0x1d70 <Endpoint_Write_Control_Stream_LE+0x3e>
    1d6e:	e8 01       	movw	r28, r16
    1d70:	ec 2c       	mov	r14, r12
    1d72:	fd 2c       	mov	r15, r13
    1d74:	d1 2c       	mov	r13, r1
    1d76:	49 c0       	rjmp	.+146    	; 0x1e0a <Endpoint_Write_Control_Stream_LE+0xd8>

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1d78:	80 91 3f 95 	lds	r24, 0x953F

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1d7c:	88 23       	and	r24, r24
    1d7e:	09 f4       	brne	.+2      	; 0x1d82 <Endpoint_Write_Control_Stream_LE+0x50>
    1d80:	5a c0       	rjmp	.+180    	; 0x1e36 <Endpoint_Write_Control_Stream_LE+0x104>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1d82:	85 30       	cpi	r24, 0x05	; 5
    1d84:	09 f4       	brne	.+2      	; 0x1d88 <Endpoint_Write_Control_Stream_LE+0x56>
    1d86:	59 c0       	rjmp	.+178    	; 0x1e3a <Endpoint_Write_Control_Stream_LE+0x108>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1d88:	0e 94 77 10 	call	0x20ee	; 0x20ee <Endpoint_IsSETUPReceived>
    1d8c:	81 11       	cpse	r24, r1
    1d8e:	57 c0       	rjmp	.+174    	; 0x1e3e <Endpoint_Write_Control_Stream_LE+0x10c>
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1d90:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Endpoint_IsOUTReceived>
    1d94:	81 11       	cpse	r24, r1
    1d96:	49 c0       	rjmp	.+146    	; 0x1e2a <Endpoint_Write_Control_Stream_LE+0xf8>
		  break;

		if (Endpoint_IsINReady())
    1d98:	0e 94 50 10 	call	0x20a0	; 0x20a0 <Endpoint_IsINReady>
    1d9c:	88 23       	and	r24, r24
    1d9e:	a9 f1       	breq	.+106    	; 0x1e0a <Endpoint_Write_Control_Stream_LE+0xd8>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    1da0:	80 91 4c 95 	lds	r24, 0x954C
    1da4:	88 23       	and	r24, r24
    1da6:	74 f4       	brge	.+28     	; 0x1dc4 <Endpoint_Write_Control_Stream_LE+0x92>
				  return USB_Endpoint_SelectedFIFO->Position;
    1da8:	e0 91 48 95 	lds	r30, 0x9548
    1dac:	f0 91 49 95 	lds	r31, 0x9549
    1db0:	ef 5b       	subi	r30, 0xBF	; 191
    1db2:	ff 4f       	sbci	r31, 0xFF	; 255
    1db4:	00 81       	ld	r16, Z
    1db6:	10 e0       	ldi	r17, 0x00	; 0
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1db8:	20 97       	sbiw	r28, 0x00	; 0
    1dba:	f9 f0       	breq	.+62     	; 0x1dfa <Endpoint_Write_Control_Stream_LE+0xc8>
    1dbc:	08 30       	cpi	r16, 0x08	; 8
    1dbe:	11 05       	cpc	r17, r1
    1dc0:	78 f0       	brcs	.+30     	; 0x1de0 <Endpoint_Write_Control_Stream_LE+0xae>
    1dc2:	1b c0       	rjmp	.+54     	; 0x1dfa <Endpoint_Write_Control_Stream_LE+0xc8>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    1dc4:	80 91 48 95 	lds	r24, 0x9548
    1dc8:	90 91 49 95 	lds	r25, 0x9549
    1dcc:	fc 01       	movw	r30, r24
    1dce:	e0 5c       	subi	r30, 0xC0	; 192
    1dd0:	ff 4f       	sbci	r31, 0xFF	; 255
    1dd2:	00 81       	ld	r16, Z
    1dd4:	31 96       	adiw	r30, 0x01	; 1
    1dd6:	80 81       	ld	r24, Z
    1dd8:	10 e0       	ldi	r17, 0x00	; 0
    1dda:	08 1b       	sub	r16, r24
    1ddc:	11 09       	sbc	r17, r1
    1dde:	ec cf       	rjmp	.-40     	; 0x1db8 <Endpoint_Write_Control_Stream_LE+0x86>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1de0:	f7 01       	movw	r30, r14
    1de2:	81 91       	ld	r24, Z+
    1de4:	7f 01       	movw	r14, r30
    1de6:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    1dea:	21 97       	sbiw	r28, 0x01	; 1
				BytesInEndpoint++;
    1dec:	0f 5f       	subi	r16, 0xFF	; 255
    1dee:	1f 4f       	sbci	r17, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1df0:	20 97       	sbiw	r28, 0x00	; 0
    1df2:	19 f0       	breq	.+6      	; 0x1dfa <Endpoint_Write_Control_Stream_LE+0xc8>
    1df4:	08 30       	cpi	r16, 0x08	; 8
    1df6:	11 05       	cpc	r17, r1
    1df8:	99 f7       	brne	.-26     	; 0x1de0 <Endpoint_Write_Control_Stream_LE+0xae>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1dfa:	dd 24       	eor	r13, r13
    1dfc:	d3 94       	inc	r13
    1dfe:	08 30       	cpi	r16, 0x08	; 8
    1e00:	11 05       	cpc	r17, r1
    1e02:	09 f0       	breq	.+2      	; 0x1e06 <Endpoint_Write_Control_Stream_LE+0xd4>
    1e04:	d1 2c       	mov	r13, r1
			Endpoint_ClearIN();
    1e06:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1e0a:	20 97       	sbiw	r28, 0x00	; 0
    1e0c:	09 f0       	breq	.+2      	; 0x1e10 <Endpoint_Write_Control_Stream_LE+0xde>
    1e0e:	b4 cf       	rjmp	.-152    	; 0x1d78 <Endpoint_Write_Control_Stream_LE+0x46>
    1e10:	d1 10       	cpse	r13, r1
    1e12:	b2 cf       	rjmp	.-156    	; 0x1d78 <Endpoint_Write_Control_Stream_LE+0x46>
    1e14:	0a c0       	rjmp	.+20     	; 0x1e2a <Endpoint_Write_Control_Stream_LE+0xf8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1e16:	80 91 3f 95 	lds	r24, 0x953F

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1e1a:	88 23       	and	r24, r24
    1e1c:	91 f0       	breq	.+36     	; 0x1e42 <Endpoint_Write_Control_Stream_LE+0x110>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1e1e:	85 30       	cpi	r24, 0x05	; 5
    1e20:	91 f0       	breq	.+36     	; 0x1e46 <Endpoint_Write_Control_Stream_LE+0x114>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1e22:	0e 94 77 10 	call	0x20ee	; 0x20ee <Endpoint_IsSETUPReceived>
    1e26:	81 11       	cpse	r24, r1
    1e28:	10 c0       	rjmp	.+32     	; 0x1e4a <Endpoint_Write_Control_Stream_LE+0x118>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1e2a:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Endpoint_IsOUTReceived>
    1e2e:	88 23       	and	r24, r24
    1e30:	91 f3       	breq	.-28     	; 0x1e16 <Endpoint_Write_Control_Stream_LE+0xe4>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1e32:	80 e0       	ldi	r24, 0x00	; 0
    1e34:	0b c0       	rjmp	.+22     	; 0x1e4c <Endpoint_Write_Control_Stream_LE+0x11a>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1e36:	82 e0       	ldi	r24, 0x02	; 2
    1e38:	09 c0       	rjmp	.+18     	; 0x1e4c <Endpoint_Write_Control_Stream_LE+0x11a>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1e3a:	83 e0       	ldi	r24, 0x03	; 3
    1e3c:	07 c0       	rjmp	.+14     	; 0x1e4c <Endpoint_Write_Control_Stream_LE+0x11a>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1e3e:	81 e0       	ldi	r24, 0x01	; 1
    1e40:	05 c0       	rjmp	.+10     	; 0x1e4c <Endpoint_Write_Control_Stream_LE+0x11a>
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1e42:	82 e0       	ldi	r24, 0x02	; 2
    1e44:	03 c0       	rjmp	.+6      	; 0x1e4c <Endpoint_Write_Control_Stream_LE+0x11a>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1e46:	83 e0       	ldi	r24, 0x03	; 3
    1e48:	01 c0       	rjmp	.+2      	; 0x1e4c <Endpoint_Write_Control_Stream_LE+0x11a>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1e4a:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1e4c:	df 91       	pop	r29
    1e4e:	cf 91       	pop	r28
    1e50:	1f 91       	pop	r17
    1e52:	0f 91       	pop	r16
    1e54:	ff 90       	pop	r15
    1e56:	ef 90       	pop	r14
    1e58:	df 90       	pop	r13
    1e5a:	cf 90       	pop	r12
    1e5c:	08 95       	ret

00001e5e <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    1e5e:	df 92       	push	r13
    1e60:	ef 92       	push	r14
    1e62:	ff 92       	push	r15
    1e64:	0f 93       	push	r16
    1e66:	1f 93       	push	r17
    1e68:	cf 93       	push	r28
    1e6a:	df 93       	push	r29
    1e6c:	e8 2e       	mov	r14, r24
    1e6e:	f9 2e       	mov	r15, r25
    1e70:	8b 01       	movw	r16, r22
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    1e72:	80 91 4c 95 	lds	r24, 0x954C
    1e76:	80 68       	ori	r24, 0x80	; 128
    1e78:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	if (Length > USB_ControlRequest.wLength)
    1e7c:	c0 91 46 95 	lds	r28, 0x9546
    1e80:	d0 91 47 95 	lds	r29, 0x9547
    1e84:	c0 17       	cp	r28, r16
    1e86:	d1 07       	cpc	r29, r17
    1e88:	40 f0       	brcs	.+16     	; 0x1e9a <Endpoint_Write_Control_PStream_LE+0x3c>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1e8a:	01 15       	cp	r16, r1
    1e8c:	11 05       	cpc	r17, r1
    1e8e:	21 f4       	brne	.+8      	; 0x1e98 <Endpoint_Write_Control_PStream_LE+0x3a>
	  Endpoint_ClearIN();
    1e90:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>
    1e94:	e8 01       	movw	r28, r16
    1e96:	01 c0       	rjmp	.+2      	; 0x1e9a <Endpoint_Write_Control_PStream_LE+0x3c>
    1e98:	e8 01       	movw	r28, r16
    1e9a:	0e 2d       	mov	r16, r14
    1e9c:	1f 2d       	mov	r17, r15
    1e9e:	d1 2c       	mov	r13, r1
    1ea0:	4e c0       	rjmp	.+156    	; 0x1f3e <Endpoint_Write_Control_PStream_LE+0xe0>

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1ea2:	80 91 3f 95 	lds	r24, 0x953F

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1ea6:	88 23       	and	r24, r24
    1ea8:	09 f4       	brne	.+2      	; 0x1eac <Endpoint_Write_Control_PStream_LE+0x4e>
    1eaa:	5f c0       	rjmp	.+190    	; 0x1f6a <Endpoint_Write_Control_PStream_LE+0x10c>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1eac:	85 30       	cpi	r24, 0x05	; 5
    1eae:	09 f4       	brne	.+2      	; 0x1eb2 <Endpoint_Write_Control_PStream_LE+0x54>
    1eb0:	5e c0       	rjmp	.+188    	; 0x1f6e <Endpoint_Write_Control_PStream_LE+0x110>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1eb2:	0e 94 77 10 	call	0x20ee	; 0x20ee <Endpoint_IsSETUPReceived>
    1eb6:	81 11       	cpse	r24, r1
    1eb8:	5c c0       	rjmp	.+184    	; 0x1f72 <Endpoint_Write_Control_PStream_LE+0x114>
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1eba:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Endpoint_IsOUTReceived>
    1ebe:	81 11       	cpse	r24, r1
    1ec0:	4e c0       	rjmp	.+156    	; 0x1f5e <Endpoint_Write_Control_PStream_LE+0x100>
		  break;

		if (Endpoint_IsINReady())
    1ec2:	0e 94 50 10 	call	0x20a0	; 0x20a0 <Endpoint_IsINReady>
    1ec6:	88 23       	and	r24, r24
    1ec8:	d1 f1       	breq	.+116    	; 0x1f3e <Endpoint_Write_Control_PStream_LE+0xe0>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    1eca:	80 91 4c 95 	lds	r24, 0x954C
    1ece:	88 23       	and	r24, r24
    1ed0:	7c f4       	brge	.+30     	; 0x1ef0 <Endpoint_Write_Control_PStream_LE+0x92>
				  return USB_Endpoint_SelectedFIFO->Position;
    1ed2:	e0 91 48 95 	lds	r30, 0x9548
    1ed6:	f0 91 49 95 	lds	r31, 0x9549
    1eda:	ef 5b       	subi	r30, 0xBF	; 191
    1edc:	ff 4f       	sbci	r31, 0xFF	; 255
    1ede:	e0 80       	ld	r14, Z
    1ee0:	f1 2c       	mov	r15, r1
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1ee2:	20 97       	sbiw	r28, 0x00	; 0
    1ee4:	19 f1       	breq	.+70     	; 0x1f2c <Endpoint_Write_Control_PStream_LE+0xce>
    1ee6:	88 e0       	ldi	r24, 0x08	; 8
    1ee8:	e8 16       	cp	r14, r24
    1eea:	f1 04       	cpc	r15, r1
    1eec:	78 f0       	brcs	.+30     	; 0x1f0c <Endpoint_Write_Control_PStream_LE+0xae>
    1eee:	1e c0       	rjmp	.+60     	; 0x1f2c <Endpoint_Write_Control_PStream_LE+0xce>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    1ef0:	80 91 48 95 	lds	r24, 0x9548
    1ef4:	90 91 49 95 	lds	r25, 0x9549
    1ef8:	fc 01       	movw	r30, r24
    1efa:	e0 5c       	subi	r30, 0xC0	; 192
    1efc:	ff 4f       	sbci	r31, 0xFF	; 255
    1efe:	e0 80       	ld	r14, Z
    1f00:	31 96       	adiw	r30, 0x01	; 1
    1f02:	80 81       	ld	r24, Z
    1f04:	f1 2c       	mov	r15, r1
    1f06:	e8 1a       	sub	r14, r24
    1f08:	f1 08       	sbc	r15, r1
    1f0a:	eb cf       	rjmp	.-42     	; 0x1ee2 <Endpoint_Write_Control_PStream_LE+0x84>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1f0c:	f8 01       	movw	r30, r16
    1f0e:	84 91       	lpm	r24, Z
    1f10:	0e 94 00 10 	call	0x2000	; 0x2000 <Endpoint_Write_8>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1f14:	0f 5f       	subi	r16, 0xFF	; 255
    1f16:	1f 4f       	sbci	r17, 0xFF	; 255
				Length--;
    1f18:	21 97       	sbiw	r28, 0x01	; 1
				BytesInEndpoint++;
    1f1a:	ff ef       	ldi	r31, 0xFF	; 255
    1f1c:	ef 1a       	sub	r14, r31
    1f1e:	ff 0a       	sbc	r15, r31

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1f20:	20 97       	sbiw	r28, 0x00	; 0
    1f22:	21 f0       	breq	.+8      	; 0x1f2c <Endpoint_Write_Control_PStream_LE+0xce>
    1f24:	88 e0       	ldi	r24, 0x08	; 8
    1f26:	e8 16       	cp	r14, r24
    1f28:	f1 04       	cpc	r15, r1
    1f2a:	81 f7       	brne	.-32     	; 0x1f0c <Endpoint_Write_Control_PStream_LE+0xae>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1f2c:	dd 24       	eor	r13, r13
    1f2e:	d3 94       	inc	r13
    1f30:	e8 e0       	ldi	r30, 0x08	; 8
    1f32:	ee 16       	cp	r14, r30
    1f34:	f1 04       	cpc	r15, r1
    1f36:	09 f0       	breq	.+2      	; 0x1f3a <Endpoint_Write_Control_PStream_LE+0xdc>
    1f38:	d1 2c       	mov	r13, r1
			Endpoint_ClearIN();
    1f3a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1f3e:	20 97       	sbiw	r28, 0x00	; 0
    1f40:	09 f0       	breq	.+2      	; 0x1f44 <Endpoint_Write_Control_PStream_LE+0xe6>
    1f42:	af cf       	rjmp	.-162    	; 0x1ea2 <Endpoint_Write_Control_PStream_LE+0x44>
    1f44:	d1 10       	cpse	r13, r1
    1f46:	ad cf       	rjmp	.-166    	; 0x1ea2 <Endpoint_Write_Control_PStream_LE+0x44>
    1f48:	0a c0       	rjmp	.+20     	; 0x1f5e <Endpoint_Write_Control_PStream_LE+0x100>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1f4a:	80 91 3f 95 	lds	r24, 0x953F

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1f4e:	88 23       	and	r24, r24
    1f50:	91 f0       	breq	.+36     	; 0x1f76 <Endpoint_Write_Control_PStream_LE+0x118>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1f52:	85 30       	cpi	r24, 0x05	; 5
    1f54:	91 f0       	breq	.+36     	; 0x1f7a <Endpoint_Write_Control_PStream_LE+0x11c>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1f56:	0e 94 77 10 	call	0x20ee	; 0x20ee <Endpoint_IsSETUPReceived>
    1f5a:	81 11       	cpse	r24, r1
    1f5c:	10 c0       	rjmp	.+32     	; 0x1f7e <Endpoint_Write_Control_PStream_LE+0x120>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1f5e:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Endpoint_IsOUTReceived>
    1f62:	88 23       	and	r24, r24
    1f64:	91 f3       	breq	.-28     	; 0x1f4a <Endpoint_Write_Control_PStream_LE+0xec>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1f66:	80 e0       	ldi	r24, 0x00	; 0
    1f68:	0b c0       	rjmp	.+22     	; 0x1f80 <Endpoint_Write_Control_PStream_LE+0x122>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1f6a:	82 e0       	ldi	r24, 0x02	; 2
    1f6c:	09 c0       	rjmp	.+18     	; 0x1f80 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1f6e:	83 e0       	ldi	r24, 0x03	; 3
    1f70:	07 c0       	rjmp	.+14     	; 0x1f80 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1f72:	81 e0       	ldi	r24, 0x01	; 1
    1f74:	05 c0       	rjmp	.+10     	; 0x1f80 <Endpoint_Write_Control_PStream_LE+0x122>
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1f76:	82 e0       	ldi	r24, 0x02	; 2
    1f78:	03 c0       	rjmp	.+6      	; 0x1f80 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1f7a:	83 e0       	ldi	r24, 0x03	; 3
    1f7c:	01 c0       	rjmp	.+2      	; 0x1f80 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1f80:	df 91       	pop	r29
    1f82:	cf 91       	pop	r28
    1f84:	1f 91       	pop	r17
    1f86:	0f 91       	pop	r16
    1f88:	ff 90       	pop	r15
    1f8a:	ef 90       	pop	r14
    1f8c:	df 90       	pop	r13
    1f8e:	08 95       	ret

00001f90 <Endpoint_ClearIN>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_ClearIN(void)
{
	USB_Endpoint_SelectedHandle->CNT     = USB_Endpoint_SelectedFIFO->Position;
    1f90:	e0 91 4a 95 	lds	r30, 0x954A
    1f94:	f0 91 4b 95 	lds	r31, 0x954B
    1f98:	a0 91 48 95 	lds	r26, 0x9548
    1f9c:	b0 91 49 95 	lds	r27, 0x9549
    1fa0:	af 5b       	subi	r26, 0xBF	; 191
    1fa2:	bf 4f       	sbci	r27, 0xFF	; 255
    1fa4:	8c 91       	ld	r24, X
    1fa6:	90 e0       	ldi	r25, 0x00	; 0
    1fa8:	82 83       	std	Z+2, r24	; 0x02
    1faa:	93 83       	std	Z+3, r25	; 0x03
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    1fac:	80 81       	ld	r24, Z
    1fae:	8d 79       	andi	r24, 0x9D	; 157
    1fb0:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1fb2:	e0 91 48 95 	lds	r30, 0x9548
    1fb6:	f0 91 49 95 	lds	r31, 0x9549
    1fba:	ef 5b       	subi	r30, 0xBF	; 191
    1fbc:	ff 4f       	sbci	r31, 0xFF	; 255
    1fbe:	10 82       	st	Z, r1
    1fc0:	08 95       	ret

00001fc2 <Endpoint_ClearOUT>:
}

void Endpoint_ClearOUT(void)
{
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    1fc2:	e0 91 4a 95 	lds	r30, 0x954A
    1fc6:	f0 91 4b 95 	lds	r31, 0x954B
    1fca:	80 81       	ld	r24, Z
    1fcc:	8d 79       	andi	r24, 0x9D	; 157
    1fce:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1fd0:	e0 91 48 95 	lds	r30, 0x9548
    1fd4:	f0 91 49 95 	lds	r31, 0x9549
    1fd8:	ef 5b       	subi	r30, 0xBF	; 191
    1fda:	ff 4f       	sbci	r31, 0xFF	; 255
    1fdc:	10 82       	st	Z, r1
    1fde:	08 95       	ret

00001fe0 <Endpoint_Read_8>:
	}
}

uint8_t Endpoint_Read_8(void)
{
	return USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++];
    1fe0:	80 91 48 95 	lds	r24, 0x9548
    1fe4:	90 91 49 95 	lds	r25, 0x9549
    1fe8:	fc 01       	movw	r30, r24
    1fea:	ef 5b       	subi	r30, 0xBF	; 191
    1fec:	ff 4f       	sbci	r31, 0xFF	; 255
    1fee:	20 81       	ld	r18, Z
    1ff0:	31 e0       	ldi	r19, 0x01	; 1
    1ff2:	32 0f       	add	r19, r18
    1ff4:	30 83       	st	Z, r19
    1ff6:	fc 01       	movw	r30, r24
    1ff8:	e2 0f       	add	r30, r18
    1ffa:	f1 1d       	adc	r31, r1
    1ffc:	80 81       	ld	r24, Z
}
    1ffe:	08 95       	ret

00002000 <Endpoint_Write_8>:

void Endpoint_Write_8(const uint8_t Data)
{
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
    2000:	20 91 48 95 	lds	r18, 0x9548
    2004:	30 91 49 95 	lds	r19, 0x9549
    2008:	f9 01       	movw	r30, r18
    200a:	ef 5b       	subi	r30, 0xBF	; 191
    200c:	ff 4f       	sbci	r31, 0xFF	; 255
    200e:	90 81       	ld	r25, Z
    2010:	41 e0       	ldi	r20, 0x01	; 1
    2012:	49 0f       	add	r20, r25
    2014:	40 83       	st	Z, r20
    2016:	f9 01       	movw	r30, r18
    2018:	e9 0f       	add	r30, r25
    201a:	f1 1d       	adc	r31, r1
    201c:	80 83       	st	Z, r24
    201e:	08 95       	ret

00002020 <Endpoint_SelectEndpoint>:

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);

	USB_Endpoint_SelectedEndpoint = Address;
    2020:	80 93 4c 95 	sts	0x954C, r24
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
}

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);
    2024:	28 2f       	mov	r18, r24
    2026:	2f 70       	andi	r18, 0x0F	; 15

	USB_Endpoint_SelectedEndpoint = Address;

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
    2028:	30 e0       	ldi	r19, 0x00	; 0
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;
    202a:	40 91 c6 04 	lds	r20, 0x04C6
    202e:	50 91 c7 04 	lds	r21, 0x04C7

	if (Address & ENDPOINT_DIR_IN)
    2032:	88 23       	and	r24, r24
    2034:	e4 f4       	brge	.+56     	; 0x206e <Endpoint_SelectEndpoint+0x4e>
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
    2036:	64 e8       	ldi	r22, 0x84	; 132
    2038:	62 9f       	mul	r22, r18
    203a:	c0 01       	movw	r24, r0
    203c:	63 9f       	mul	r22, r19
    203e:	90 0d       	add	r25, r0
    2040:	11 24       	eor	r1, r1
    2042:	81 57       	subi	r24, 0x71	; 113
    2044:	9a 46       	sbci	r25, 0x6A	; 106
    2046:	80 93 48 95 	sts	0x9548, r24
    204a:	90 93 49 95 	sts	0x9549, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].IN;
    204e:	c9 01       	movw	r24, r18
    2050:	82 95       	swap	r24
    2052:	92 95       	swap	r25
    2054:	90 7f       	andi	r25, 0xF0	; 240
    2056:	98 27       	eor	r25, r24
    2058:	80 7f       	andi	r24, 0xF0	; 240
    205a:	98 27       	eor	r25, r24
    205c:	08 96       	adiw	r24, 0x08	; 8
    205e:	9a 01       	movw	r18, r20
    2060:	28 0f       	add	r18, r24
    2062:	39 1f       	adc	r19, r25
    2064:	20 93 4a 95 	sts	0x954A, r18
    2068:	30 93 4b 95 	sts	0x954B, r19
    206c:	08 95       	ret
	}
	else
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->OUT;
    206e:	64 e8       	ldi	r22, 0x84	; 132
    2070:	62 9f       	mul	r22, r18
    2072:	c0 01       	movw	r24, r0
    2074:	63 9f       	mul	r22, r19
    2076:	90 0d       	add	r25, r0
    2078:	11 24       	eor	r1, r1
    207a:	83 5b       	subi	r24, 0xB3	; 179
    207c:	9a 46       	sbci	r25, 0x6A	; 106
    207e:	80 93 48 95 	sts	0x9548, r24
    2082:	90 93 49 95 	sts	0x9549, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].OUT;
    2086:	22 95       	swap	r18
    2088:	32 95       	swap	r19
    208a:	30 7f       	andi	r19, 0xF0	; 240
    208c:	32 27       	eor	r19, r18
    208e:	20 7f       	andi	r18, 0xF0	; 240
    2090:	32 27       	eor	r19, r18
    2092:	24 0f       	add	r18, r20
    2094:	35 1f       	adc	r19, r21
    2096:	20 93 4a 95 	sts	0x954A, r18
    209a:	30 93 4b 95 	sts	0x954B, r19
    209e:	08 95       	ret

000020a0 <Endpoint_IsINReady>:
volatile USB_EP_t*        USB_Endpoint_SelectedHandle;
volatile Endpoint_FIFO_t* USB_Endpoint_SelectedFIFO;

bool Endpoint_IsINReady(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    20a0:	80 91 4c 95 	lds	r24, 0x954C
    20a4:	80 68       	ori	r24, 0x80	; 128
    20a6:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	return ((USB_Endpoint_SelectedHandle->STATUS & USB_EP_BUSNACK0_bm) ? true : false);
    20aa:	e0 91 4a 95 	lds	r30, 0x954A
    20ae:	f0 91 4b 95 	lds	r31, 0x954B
    20b2:	80 81       	ld	r24, Z
}
    20b4:	86 95       	lsr	r24
    20b6:	81 70       	andi	r24, 0x01	; 1
    20b8:	08 95       	ret

000020ba <Endpoint_IsOUTReceived>:

bool Endpoint_IsOUTReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    20ba:	80 91 4c 95 	lds	r24, 0x954C
    20be:	8f 77       	andi	r24, 0x7F	; 127
    20c0:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_TRNCOMPL0_bm)
    20c4:	e0 91 4a 95 	lds	r30, 0x954A
    20c8:	f0 91 4b 95 	lds	r31, 0x954B
    20cc:	80 81       	ld	r24, Z
    20ce:	85 ff       	sbrs	r24, 5
    20d0:	0c c0       	rjmp	.+24     	; 0x20ea <Endpoint_IsOUTReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    20d2:	80 91 48 95 	lds	r24, 0x9548
    20d6:	90 91 49 95 	lds	r25, 0x9549
    20da:	22 81       	ldd	r18, Z+2	; 0x02
    20dc:	33 81       	ldd	r19, Z+3	; 0x03
    20de:	fc 01       	movw	r30, r24
    20e0:	e0 5c       	subi	r30, 0xC0	; 192
    20e2:	ff 4f       	sbci	r31, 0xFF	; 255
    20e4:	20 83       	st	Z, r18
		return true;
    20e6:	81 e0       	ldi	r24, 0x01	; 1
    20e8:	08 95       	ret
	}

	return false;
    20ea:	80 e0       	ldi	r24, 0x00	; 0
}
    20ec:	08 95       	ret

000020ee <Endpoint_IsSETUPReceived>:

bool Endpoint_IsSETUPReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    20ee:	80 91 4c 95 	lds	r24, 0x954C
    20f2:	8f 77       	andi	r24, 0x7F	; 127
    20f4:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_SETUP_bm)
    20f8:	e0 91 4a 95 	lds	r30, 0x954A
    20fc:	f0 91 4b 95 	lds	r31, 0x954B
    2100:	80 81       	ld	r24, Z
    2102:	84 ff       	sbrs	r24, 4
    2104:	0c c0       	rjmp	.+24     	; 0x211e <Endpoint_IsSETUPReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    2106:	80 91 48 95 	lds	r24, 0x9548
    210a:	90 91 49 95 	lds	r25, 0x9549
    210e:	22 81       	ldd	r18, Z+2	; 0x02
    2110:	33 81       	ldd	r19, Z+3	; 0x03
    2112:	fc 01       	movw	r30, r24
    2114:	e0 5c       	subi	r30, 0xC0	; 192
    2116:	ff 4f       	sbci	r31, 0xFF	; 255
    2118:	20 83       	st	Z, r18
		return true;
    211a:	81 e0       	ldi	r24, 0x01	; 1
    211c:	08 95       	ret
	}

	return false;
    211e:	80 e0       	ldi	r24, 0x00	; 0
}
    2120:	08 95       	ret

00002122 <Endpoint_ClearSETUP>:

void Endpoint_ClearSETUP(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    2122:	80 91 4c 95 	lds	r24, 0x954C
    2126:	8f 77       	andi	r24, 0x7F	; 127
    2128:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_SETUP_bm | USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    212c:	e0 91 4a 95 	lds	r30, 0x954A
    2130:	f0 91 4b 95 	lds	r31, 0x954B
    2134:	80 81       	ld	r24, Z
    2136:	8d 78       	andi	r24, 0x8D	; 141
    2138:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    213a:	e0 91 4a 95 	lds	r30, 0x954A
    213e:	f0 91 4b 95 	lds	r31, 0x954B
    2142:	80 81       	ld	r24, Z
    2144:	81 60       	ori	r24, 0x01	; 1
    2146:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    2148:	e0 91 48 95 	lds	r30, 0x9548
    214c:	f0 91 49 95 	lds	r31, 0x9549
    2150:	ef 5b       	subi	r30, 0xBF	; 191
    2152:	ff 4f       	sbci	r31, 0xFF	; 255
    2154:	10 82       	st	Z, r1

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    2156:	80 91 4c 95 	lds	r24, 0x954C
    215a:	80 68       	ori	r24, 0x80	; 128
    215c:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    2160:	e0 91 4a 95 	lds	r30, 0x954A
    2164:	f0 91 4b 95 	lds	r31, 0x954B
    2168:	80 81       	ld	r24, Z
    216a:	81 60       	ori	r24, 0x01	; 1
    216c:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    216e:	e0 91 48 95 	lds	r30, 0x9548
    2172:	f0 91 49 95 	lds	r31, 0x9549
    2176:	ef 5b       	subi	r30, 0xBF	; 191
    2178:	ff 4f       	sbci	r31, 0xFF	; 255
    217a:	10 82       	st	Z, r1
    217c:	08 95       	ret

0000217e <Endpoint_StallTransaction>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_StallTransaction(void)
{
	USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    217e:	e0 91 4a 95 	lds	r30, 0x954A
    2182:	f0 91 4b 95 	lds	r31, 0x954B
    2186:	81 81       	ldd	r24, Z+1	; 0x01
    2188:	84 60       	ori	r24, 0x04	; 4
    218a:	81 83       	std	Z+1, r24	; 0x01

	if ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_TYPE_gm) == USB_EP_TYPE_CONTROL_gc)
    218c:	e0 91 4a 95 	lds	r30, 0x954A
    2190:	f0 91 4b 95 	lds	r31, 0x954B
    2194:	81 81       	ldd	r24, Z+1	; 0x01
    2196:	80 7c       	andi	r24, 0xC0	; 192
    2198:	80 34       	cpi	r24, 0x40	; 64
    219a:	61 f4       	brne	.+24     	; 0x21b4 <Endpoint_StallTransaction+0x36>
	{
		Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint ^ ENDPOINT_DIR_IN);
    219c:	80 91 4c 95 	lds	r24, 0x954C
    21a0:	80 58       	subi	r24, 0x80	; 128
    21a2:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>
		USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    21a6:	e0 91 4a 95 	lds	r30, 0x954A
    21aa:	f0 91 4b 95 	lds	r31, 0x954B
    21ae:	81 81       	ldd	r24, Z+1	; 0x01
    21b0:	84 60       	ori	r24, 0x04	; 4
    21b2:	81 83       	std	Z+1, r24	; 0x01
    21b4:	08 95       	ret

000021b6 <Endpoint_ConfigureEndpoint_PRV>:
}

bool Endpoint_ConfigureEndpoint_PRV(const uint8_t Address,
                                    const uint8_t Config,
                                    const uint8_t Size)
{
    21b6:	1f 93       	push	r17
    21b8:	cf 93       	push	r28
    21ba:	df 93       	push	r29
    21bc:	d8 2f       	mov	r29, r24
    21be:	16 2f       	mov	r17, r22
    21c0:	c4 2f       	mov	r28, r20
	Endpoint_SelectEndpoint(Address);
    21c2:	0e 94 10 10 	call	0x2020	; 0x2020 <Endpoint_SelectEndpoint>

	USB_Endpoint_SelectedHandle->CTRL    = 0;
    21c6:	e0 91 4a 95 	lds	r30, 0x954A
    21ca:	f0 91 4b 95 	lds	r31, 0x954B
    21ce:	11 82       	std	Z+1, r1	; 0x01
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    21d0:	e0 91 4a 95 	lds	r30, 0x954A
    21d4:	f0 91 4b 95 	lds	r31, 0x954B
    21d8:	dd 23       	and	r29, r29
    21da:	a4 f0       	brlt	.+40     	; 0x2204 <Endpoint_ConfigureEndpoint_PRV+0x4e>
    21dc:	10 82       	st	Z, r1
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    21de:	e0 91 4a 95 	lds	r30, 0x954A
    21e2:	f0 91 4b 95 	lds	r31, 0x954B
    21e6:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    21e8:	e0 91 4a 95 	lds	r30, 0x954A
    21ec:	f0 91 4b 95 	lds	r31, 0x954B
    21f0:	12 82       	std	Z+2, r1	; 0x02
    21f2:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    21f4:	80 91 48 95 	lds	r24, 0x9548
    21f8:	90 91 49 95 	lds	r25, 0x9549
    21fc:	84 83       	std	Z+4, r24	; 0x04
    21fe:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    2200:	40 e0       	ldi	r20, 0x00	; 0
    2202:	14 c0       	rjmp	.+40     	; 0x222c <Endpoint_ConfigureEndpoint_PRV+0x76>
                                    const uint8_t Size)
{
	Endpoint_SelectEndpoint(Address);

	USB_Endpoint_SelectedHandle->CTRL    = 0;
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    2204:	82 e0       	ldi	r24, 0x02	; 2
    2206:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    2208:	e0 91 4a 95 	lds	r30, 0x954A
    220c:	f0 91 4b 95 	lds	r31, 0x954B
    2210:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    2212:	e0 91 4a 95 	lds	r30, 0x954A
    2216:	f0 91 4b 95 	lds	r31, 0x954B
    221a:	12 82       	std	Z+2, r1	; 0x02
    221c:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    221e:	80 91 48 95 	lds	r24, 0x9548
    2222:	90 91 49 95 	lds	r25, 0x9549
    2226:	84 83       	std	Z+4, r24	; 0x04
    2228:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    222a:	4c 2f       	mov	r20, r28
    222c:	fc 01       	movw	r30, r24
    222e:	e0 5c       	subi	r30, 0xC0	; 192
    2230:	ff 4f       	sbci	r31, 0xFF	; 255
    2232:	40 83       	st	Z, r20
	USB_Endpoint_SelectedFIFO->Position  = 0;
    2234:	31 96       	adiw	r30, 0x01	; 1
    2236:	10 82       	st	Z, r1

	return true;
}
    2238:	81 e0       	ldi	r24, 0x01	; 1
    223a:	df 91       	pop	r29
    223c:	cf 91       	pop	r28
    223e:	1f 91       	pop	r17
    2240:	08 95       	ret

00002242 <Endpoint_ConfigureEndpointTable>:
	}
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    2242:	af 92       	push	r10
    2244:	bf 92       	push	r11
    2246:	cf 92       	push	r12
    2248:	df 92       	push	r13
    224a:	ef 92       	push	r14
    224c:	ff 92       	push	r15
    224e:	0f 93       	push	r16
    2250:	1f 93       	push	r17
    2252:	cf 93       	push	r28
    2254:	df 93       	push	r29
	for (uint8_t i = 0; i < Entries; i++)
    2256:	66 23       	and	r22, r22
    2258:	09 f4       	brne	.+2      	; 0x225c <Endpoint_ConfigureEndpointTable+0x1a>
    225a:	57 c0       	rjmp	.+174    	; 0x230a <Endpoint_ConfigureEndpointTable+0xc8>
    225c:	a6 2e       	mov	r10, r22
    225e:	7c 01       	movw	r14, r24
    2260:	8c 01       	movw	r16, r24
    2262:	84 e0       	ldi	r24, 0x04	; 4
    2264:	e8 0e       	add	r14, r24
    2266:	f1 1c       	adc	r15, r1
    2268:	b1 2c       	mov	r11, r1
	{
		if (!(Table[i].Address))
    226a:	f8 01       	movw	r30, r16
    226c:	c0 80       	ld	r12, Z
    226e:	cc 20       	and	r12, r12
    2270:	09 f4       	brne	.+2      	; 0x2274 <Endpoint_ConfigureEndpointTable+0x32>
    2272:	41 c0       	rjmp	.+130    	; 0x22f6 <Endpoint_ConfigureEndpointTable+0xb4>
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    2274:	c1 81       	ldd	r28, Z+1	; 0x01
    2276:	d2 81       	ldd	r29, Z+2	; 0x02
    2278:	f7 01       	movw	r30, r14
    227a:	31 97       	sbiw	r30, 0x01	; 1
    227c:	80 81       	ld	r24, Z
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    227e:	f7 01       	movw	r30, r14
    2280:	90 81       	ld	r25, Z
    2282:	92 30       	cpi	r25, 0x02	; 2
    2284:	10 f4       	brcc	.+4      	; 0x228a <Endpoint_ConfigureEndpointTable+0x48>
    2286:	48 e0       	ldi	r20, 0x08	; 8
    2288:	01 c0       	rjmp	.+2      	; 0x228c <Endpoint_ConfigureEndpointTable+0x4a>
    228a:	48 e1       	ldi	r20, 0x18	; 24
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    228c:	c9 30       	cpi	r28, 0x09	; 9
    228e:	d1 05       	cpc	r29, r1
    2290:	50 f0       	brcs	.+20     	; 0x22a6 <Endpoint_ConfigureEndpointTable+0x64>
    2292:	28 e0       	ldi	r18, 0x08	; 8
    2294:	30 e0       	ldi	r19, 0x00	; 0
    2296:	90 e0       	ldi	r25, 0x00	; 0
				{
					MaskVal++;
    2298:	9f 5f       	subi	r25, 0xFF	; 255
					CheckBytes <<= 1;
    229a:	22 0f       	add	r18, r18
    229c:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    229e:	2c 17       	cp	r18, r28
    22a0:	3d 07       	cpc	r19, r29
    22a2:	d0 f3       	brcs	.-12     	; 0x2298 <Endpoint_ConfigureEndpointTable+0x56>
    22a4:	01 c0       	rjmp	.+2      	; 0x22a8 <Endpoint_ConfigureEndpointTable+0x66>
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    22a6:	90 e0       	ldi	r25, 0x00	; 0
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    22a8:	94 2b       	or	r25, r20

				if ((Address & ENDPOINT_EPNUM_MASK) >= ENDPOINT_TOTAL_ENDPOINTS)
    22aa:	2c 2d       	mov	r18, r12
    22ac:	2f 70       	andi	r18, 0x0F	; 15
    22ae:	30 e0       	ldi	r19, 0x00	; 0
    22b0:	25 30       	cpi	r18, 0x05	; 5
    22b2:	31 05       	cpc	r19, r1
    22b4:	64 f5       	brge	.+88     	; 0x230e <Endpoint_ConfigureEndpointTable+0xcc>
				  return false;

				// TODO - Fix once limitations are lifted
				EPConfigMask &= ~USB_EP_PINGPONG_bm;
    22b6:	9f 7e       	andi	r25, 0xEF	; 239
				if (Size > 64)
    22b8:	c1 34       	cpi	r28, 0x41	; 65
    22ba:	d1 05       	cpc	r29, r1
    22bc:	50 f5       	brcc	.+84     	; 0x2312 <Endpoint_ConfigureEndpointTable+0xd0>
				  return false;

				switch (Type)
    22be:	88 23       	and	r24, r24
    22c0:	19 f0       	breq	.+6      	; 0x22c8 <Endpoint_ConfigureEndpointTable+0x86>
    22c2:	81 30       	cpi	r24, 0x01	; 1
    22c4:	21 f0       	breq	.+8      	; 0x22ce <Endpoint_ConfigureEndpointTable+0x8c>
    22c6:	06 c0       	rjmp	.+12     	; 0x22d4 <Endpoint_ConfigureEndpointTable+0x92>
				{
					case EP_TYPE_CONTROL:
						EPConfigMask |= USB_EP_TYPE_CONTROL_gc;
    22c8:	90 64       	ori	r25, 0x40	; 64
    22ca:	d9 2e       	mov	r13, r25
    22cc:	07 c0       	rjmp	.+14     	; 0x22dc <Endpoint_ConfigureEndpointTable+0x9a>
						break;
					case EP_TYPE_ISOCHRONOUS:
						EPConfigMask |= USB_EP_TYPE_ISOCHRONOUS_gc;
    22ce:	90 6c       	ori	r25, 0xC0	; 192
    22d0:	d9 2e       	mov	r13, r25
    22d2:	0a c0       	rjmp	.+20     	; 0x22e8 <Endpoint_ConfigureEndpointTable+0xa6>
						break;
					default:
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
    22d4:	90 68       	ori	r25, 0x80	; 128
    22d6:	d9 2e       	mov	r13, r25
						break;
				}

				if (Type == EP_TYPE_CONTROL)
    22d8:	81 11       	cpse	r24, r1
    22da:	06 c0       	rjmp	.+12     	; 0x22e8 <Endpoint_ConfigureEndpointTable+0xa6>
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    22dc:	4c 2f       	mov	r20, r28
    22de:	6d 2d       	mov	r22, r13
    22e0:	80 e8       	ldi	r24, 0x80	; 128
    22e2:	8c 0d       	add	r24, r12
    22e4:	0e 94 db 10 	call	0x21b6	; 0x21b6 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    22e8:	4c 2f       	mov	r20, r28
    22ea:	6d 2d       	mov	r22, r13
    22ec:	8c 2d       	mov	r24, r12
    22ee:	0e 94 db 10 	call	0x21b6	; 0x21b6 <Endpoint_ConfigureEndpoint_PRV>
    22f2:	88 23       	and	r24, r24
    22f4:	79 f0       	breq	.+30     	; 0x2314 <Endpoint_ConfigureEndpointTable+0xd2>
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    22f6:	b3 94       	inc	r11
    22f8:	0b 5f       	subi	r16, 0xFB	; 251
    22fa:	1f 4f       	sbci	r17, 0xFF	; 255
    22fc:	f5 e0       	ldi	r31, 0x05	; 5
    22fe:	ef 0e       	add	r14, r31
    2300:	f1 1c       	adc	r15, r1
    2302:	ba 10       	cpse	r11, r10
    2304:	b2 cf       	rjmp	.-156    	; 0x226a <Endpoint_ConfigureEndpointTable+0x28>
		{
			return false;
		}
	}

	return true;
    2306:	81 e0       	ldi	r24, 0x01	; 1
    2308:	05 c0       	rjmp	.+10     	; 0x2314 <Endpoint_ConfigureEndpointTable+0xd2>
    230a:	81 e0       	ldi	r24, 0x01	; 1
    230c:	03 c0       	rjmp	.+6      	; 0x2314 <Endpoint_ConfigureEndpointTable+0xd2>
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		{
			return false;
    230e:	80 e0       	ldi	r24, 0x00	; 0
    2310:	01 c0       	rjmp	.+2      	; 0x2314 <Endpoint_ConfigureEndpointTable+0xd2>
    2312:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return true;
}
    2314:	df 91       	pop	r29
    2316:	cf 91       	pop	r28
    2318:	1f 91       	pop	r17
    231a:	0f 91       	pop	r16
    231c:	ff 90       	pop	r15
    231e:	ef 90       	pop	r14
    2320:	df 90       	pop	r13
    2322:	cf 90       	pop	r12
    2324:	bf 90       	pop	r11
    2326:	af 90       	pop	r10
    2328:	08 95       	ret

0000232a <Endpoint_ClearEndpoints>:

	return true;
}

void Endpoint_ClearEndpoints(void)
{
    232a:	20 e0       	ldi	r18, 0x00	; 0
    232c:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
    232e:	a0 ec       	ldi	r26, 0xC0	; 192
    2330:	b4 e0       	ldi	r27, 0x04	; 4
    2332:	16 96       	adiw	r26, 0x06	; 6
    2334:	ed 91       	ld	r30, X+
    2336:	fc 91       	ld	r31, X
    2338:	17 97       	sbiw	r26, 0x07	; 7
    233a:	c9 01       	movw	r24, r18
    233c:	82 95       	swap	r24
    233e:	92 95       	swap	r25
    2340:	90 7f       	andi	r25, 0xF0	; 240
    2342:	98 27       	eor	r25, r24
    2344:	80 7f       	andi	r24, 0xF0	; 240
    2346:	98 27       	eor	r25, r24
    2348:	e8 0f       	add	r30, r24
    234a:	f9 1f       	adc	r31, r25
    234c:	11 86       	std	Z+9, r1	; 0x09
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
    234e:	16 96       	adiw	r26, 0x06	; 6
    2350:	4d 91       	ld	r20, X+
    2352:	5c 91       	ld	r21, X
    2354:	17 97       	sbiw	r26, 0x07	; 7
    2356:	fa 01       	movw	r30, r20
    2358:	e8 0f       	add	r30, r24
    235a:	f9 1f       	adc	r31, r25
    235c:	11 82       	std	Z+1, r1	; 0x01
    235e:	2f 5f       	subi	r18, 0xFF	; 255
    2360:	3f 4f       	sbci	r19, 0xFF	; 255
	return true;
}

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    2362:	25 30       	cpi	r18, 0x05	; 5
    2364:	31 05       	cpc	r19, r1
    2366:	29 f7       	brne	.-54     	; 0x2332 <Endpoint_ClearEndpoints+0x8>
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
	}
}
    2368:	08 95       	ret

0000236a <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    236a:	80 91 40 95 	lds	r24, 0x9540
    236e:	88 23       	and	r24, r24
    2370:	84 f4       	brge	.+32     	; 0x2392 <Endpoint_ClearStatusStage+0x28>
    2372:	04 c0       	rjmp	.+8      	; 0x237c <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2374:	80 91 3f 95 	lds	r24, 0x953F
    2378:	88 23       	and	r24, r24
    237a:	89 f0       	breq	.+34     	; 0x239e <Endpoint_ClearStatusStage+0x34>

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    237c:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Endpoint_IsOUTReceived>
    2380:	88 23       	and	r24, r24
    2382:	c1 f3       	breq	.-16     	; 0x2374 <Endpoint_ClearStatusStage+0xa>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearOUT();
    2384:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <Endpoint_ClearOUT>
    2388:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    238a:	80 91 3f 95 	lds	r24, 0x953F
    238e:	88 23       	and	r24, r24
    2390:	31 f0       	breq	.+12     	; 0x239e <Endpoint_ClearStatusStage+0x34>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    2392:	0e 94 50 10 	call	0x20a0	; 0x20a0 <Endpoint_IsINReady>
    2396:	88 23       	and	r24, r24
    2398:	c1 f3       	breq	.-16     	; 0x238a <Endpoint_ClearStatusStage+0x20>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearIN();
    239a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Endpoint_ClearIN>
    239e:	08 95       	ret

000023a0 <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    23a0:	ff 92       	push	r15
    23a2:	0f 93       	push	r16
    23a4:	1f 93       	push	r17
    23a6:	cf 93       	push	r28
    23a8:	df 93       	push	r29
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return ((USB_EndpointTable_t*)USB.EPPTR)->FrameNum;
    23aa:	e0 91 c6 04 	lds	r30, 0x04C6
    23ae:	f0 91 c7 04 	lds	r31, 0x04C7
    23b2:	e0 5b       	subi	r30, 0xB0	; 176
    23b4:	ff 4f       	sbci	r31, 0xFF	; 255
    23b6:	c0 81       	ld	r28, Z
    23b8:	d1 81       	ldd	r29, Z+1	; 0x01
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    23ba:	0f 2e       	mov	r0, r31
    23bc:	f4 e6       	ldi	r31, 0x64	; 100
    23be:	ff 2e       	mov	r15, r31
    23c0:	f0 2d       	mov	r31, r0
    23c2:	00 ec       	ldi	r16, 0xC0	; 192
    23c4:	14 e0       	ldi	r17, 0x04	; 4
    23c6:	02 c0       	rjmp	.+4      	; 0x23cc <Endpoint_WaitUntilReady+0x2c>

		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    23c8:	f2 2e       	mov	r15, r18
    23ca:	ec 01       	movw	r28, r24
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN);
    23cc:	80 91 4c 95 	lds	r24, 0x954C

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    23d0:	88 23       	and	r24, r24
    23d2:	2c f4       	brge	.+10     	; 0x23de <Endpoint_WaitUntilReady+0x3e>
		{
			if (Endpoint_IsINReady())
    23d4:	0e 94 50 10 	call	0x20a0	; 0x20a0 <Endpoint_IsINReady>
    23d8:	88 23       	and	r24, r24
    23da:	29 f0       	breq	.+10     	; 0x23e6 <Endpoint_WaitUntilReady+0x46>
    23dc:	23 c0       	rjmp	.+70     	; 0x2424 <Endpoint_WaitUntilReady+0x84>
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    23de:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Endpoint_IsOUTReceived>
    23e2:	81 11       	cpse	r24, r1
    23e4:	21 c0       	rjmp	.+66     	; 0x2428 <Endpoint_WaitUntilReady+0x88>
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    23e6:	80 91 3f 95 	lds	r24, 0x953F

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    23ea:	88 23       	and	r24, r24
    23ec:	f9 f0       	breq	.+62     	; 0x242c <Endpoint_WaitUntilReady+0x8c>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    23ee:	85 30       	cpi	r24, 0x05	; 5
    23f0:	f9 f0       	breq	.+62     	; 0x2430 <Endpoint_WaitUntilReady+0x90>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    23f2:	e0 91 4a 95 	lds	r30, 0x954A
    23f6:	f0 91 4b 95 	lds	r31, 0x954B
    23fa:	81 81       	ldd	r24, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    23fc:	82 fd       	sbrc	r24, 2
    23fe:	1a c0       	rjmp	.+52     	; 0x2434 <Endpoint_WaitUntilReady+0x94>
    2400:	d8 01       	movw	r26, r16
    2402:	16 96       	adiw	r26, 0x06	; 6
    2404:	ed 91       	ld	r30, X+
    2406:	fc 91       	ld	r31, X
    2408:	17 97       	sbiw	r26, 0x07	; 7
    240a:	e0 5b       	subi	r30, 0xB0	; 176
    240c:	ff 4f       	sbci	r31, 0xFF	; 255
    240e:	80 81       	ld	r24, Z
    2410:	91 81       	ldd	r25, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    2412:	c8 17       	cp	r28, r24
    2414:	d9 07       	cpc	r29, r25
    2416:	c9 f2       	breq	.-78     	; 0x23ca <Endpoint_WaitUntilReady+0x2a>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    2418:	2f ef       	ldi	r18, 0xFF	; 255
    241a:	2f 0d       	add	r18, r15
    241c:	f1 10       	cpse	r15, r1
    241e:	d4 cf       	rjmp	.-88     	; 0x23c8 <Endpoint_WaitUntilReady+0x28>
			  return ENDPOINT_READYWAIT_Timeout;
    2420:	84 e0       	ldi	r24, 0x04	; 4
    2422:	09 c0       	rjmp	.+18     	; 0x2436 <Endpoint_WaitUntilReady+0x96>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    2424:	80 e0       	ldi	r24, 0x00	; 0
    2426:	07 c0       	rjmp	.+14     	; 0x2436 <Endpoint_WaitUntilReady+0x96>
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    2428:	80 e0       	ldi	r24, 0x00	; 0
    242a:	05 c0       	rjmp	.+10     	; 0x2436 <Endpoint_WaitUntilReady+0x96>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    242c:	82 e0       	ldi	r24, 0x02	; 2
    242e:	03 c0       	rjmp	.+6      	; 0x2436 <Endpoint_WaitUntilReady+0x96>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    2430:	83 e0       	ldi	r24, 0x03	; 3
    2432:	01 c0       	rjmp	.+2      	; 0x2436 <Endpoint_WaitUntilReady+0x96>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    2434:	81 e0       	ldi	r24, 0x01	; 1

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    2436:	df 91       	pop	r29
    2438:	cf 91       	pop	r28
    243a:	1f 91       	pop	r17
    243c:	0f 91       	pop	r16
    243e:	ff 90       	pop	r15
    2440:	08 95       	ret

00002442 <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    2442:	cf 93       	push	r28
    2444:	df 93       	push	r29
	{
		DividerIndex++;
		PrescalerNeeded >>= 1;
	}

	CLK.USBCTRL = (DividerIndex - 1) << CLK_USBPSDIV_gp;
    2446:	e0 e4       	ldi	r30, 0x40	; 64
    2448:	f0 e0       	ldi	r31, 0x00	; 0
    244a:	14 82       	std	Z+4, r1	; 0x04

	if (USB_Options & USB_OPT_PLLCLKSRC)
	  CLK.USBCTRL |= (CLK_USBSRC_PLL_gc   | CLK_USBSEN_bm);
	else
	  CLK.USBCTRL |= (CLK_USBSRC_RC32M_gc | CLK_USBSEN_bm);
    244c:	84 81       	ldd	r24, Z+4	; 0x04
    244e:	83 60       	ori	r24, 0x03	; 3
    2450:	84 83       	std	Z+4, r24	; 0x04

	USB_Device_SetDeviceAddress(0);

	USB_INT_DisableAllInterrupts();
    2452:	0e 94 7f 12 	call	0x24fe	; 0x24fe <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    2456:	0e 94 86 12 	call	0x250c	; 0x250c <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USB.CTRLA &= ~USB_ENABLE_bm;
    245a:	c0 ec       	ldi	r28, 0xC0	; 192
    245c:	d4 e0       	ldi	r29, 0x04	; 4
    245e:	88 81       	ld	r24, Y
    2460:	8f 77       	andi	r24, 0x7F	; 127
    2462:	88 83       	st	Y, r24
				USB.CTRLA |=  USB_ENABLE_bm;
    2464:	88 81       	ld	r24, Y
    2466:	80 68       	ori	r24, 0x80	; 128
    2468:	88 83       	st	Y, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    246a:	10 92 3f 95 	sts	0x953F, r1
	USB_Device_ConfigurationNumber  = 0;
    246e:	10 92 3b 95 	sts	0x953B, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    2472:	10 92 3d 95 	sts	0x953D, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    2476:	10 92 3c 95 	sts	0x953C, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				USB.CTRLA |=  USB_SPEED_bm;
    247a:	88 81       	ld	r24, Y
    247c:	80 64       	ori	r24, 0x40	; 64
    247e:	88 83       	st	Y, r24
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    2480:	48 e0       	ldi	r20, 0x08	; 8
    2482:	68 e4       	ldi	r22, 0x48	; 72
    2484:	80 e8       	ldi	r24, 0x80	; 128
    2486:	0e 94 db 10 	call	0x21b6	; 0x21b6 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    248a:	48 e0       	ldi	r20, 0x08	; 8
    248c:	68 e4       	ldi	r22, 0x48	; 72
    248e:	80 e0       	ldi	r24, 0x00	; 0
    2490:	0e 94 db 10 	call	0x21b6	; 0x21b6 <Endpoint_ConfigureEndpoint_PRV>
			static inline void USB_INT_Enable(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						USB.INTCTRLA |= USB_BUSEVIE_bm;
    2494:	88 85       	ldd	r24, Y+8	; 0x08
    2496:	80 64       	ori	r24, 0x40	; 64
    2498:	88 87       	std	Y+8, r24	; 0x08
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				USB.CTRLB |= USB_ATTACH_bm;
    249a:	89 81       	ldd	r24, Y+1	; 0x01
    249c:	81 60       	ori	r24, 0x01	; 1
    249e:	89 83       	std	Y+1, r24	; 0x01
	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();

	USB_Controller_Reset();
	USB_Init_Device();
}
    24a0:	df 91       	pop	r29
    24a2:	cf 91       	pop	r28
    24a4:	08 95       	ret

000024a6 <USB_Init>:

               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
    24a6:	cf 93       	push	r28
    24a8:	df 93       	push	r29
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    24aa:	2f b7       	in	r18, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    24ac:	f8 94       	cli
	#endif

	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();

	NVM.CMD  = NVM_CMD_READ_CALIB_ROW_gc;
    24ae:	c0 ec       	ldi	r28, 0xC0	; 192
    24b0:	d1 e0       	ldi	r29, 0x01	; 1
    24b2:	82 e0       	ldi	r24, 0x02	; 2
    24b4:	8a 87       	std	Y+10, r24	; 0x0a
	USB.CAL0 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL0));
    24b6:	ea e1       	ldi	r30, 0x1A	; 26
    24b8:	f0 e0       	ldi	r31, 0x00	; 0
    24ba:	e4 91       	lpm	r30, Z
    24bc:	a0 ec       	ldi	r26, 0xC0	; 192
    24be:	b4 e0       	ldi	r27, 0x04	; 4
    24c0:	da 96       	adiw	r26, 0x3a	; 58
    24c2:	ec 93       	st	X, r30
    24c4:	da 97       	sbiw	r26, 0x3a	; 58
	USB.CAL1 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL1));
    24c6:	eb e1       	ldi	r30, 0x1B	; 27
    24c8:	f0 e0       	ldi	r31, 0x00	; 0
    24ca:	e4 91       	lpm	r30, Z
    24cc:	db 96       	adiw	r26, 0x3b	; 59
    24ce:	ec 93       	st	X, r30
    24d0:	db 97       	sbiw	r26, 0x3b	; 59
	NVM.CMD  = NVM_CMD_NO_OPERATION_gc;
    24d2:	1a 86       	std	Y+10, r1	; 0x0a

	/* Ugly workaround to ensure an aligned table, since __BIGGEST_ALIGNMENT__ == 1 for the 8-bit AVR-GCC toolchain */
	USB.EPPTR = ((intptr_t)&USB_EndpointTable[1] & ~(1 << 0));
    24d4:	82 ee       	ldi	r24, 0xE2	; 226
    24d6:	97 e9       	ldi	r25, 0x97	; 151
    24d8:	8e 7f       	andi	r24, 0xFE	; 254
    24da:	16 96       	adiw	r26, 0x06	; 6
    24dc:	8d 93       	st	X+, r24
    24de:	9c 93       	st	X, r25
    24e0:	17 97       	sbiw	r26, 0x07	; 7
	USB.CTRLA = (USB_STFRNUM_bm | ((ENDPOINT_TOTAL_ENDPOINTS - 1) << USB_MAXEP_gp));
    24e2:	84 e1       	ldi	r24, 0x14	; 20
    24e4:	8c 93       	st	X, r24

	if ((USB_Options & USB_OPT_BUSEVENT_PRIHIGH) == USB_OPT_BUSEVENT_PRIHIGH)
	  USB.INTCTRLA = (3 << USB_INTLVL_gp);
    24e6:	83 e0       	ldi	r24, 0x03	; 3
    24e8:	18 96       	adiw	r26, 0x08	; 8
    24ea:	8c 93       	st	X, r24
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    24ec:	2f bf       	out	0x3f, r18	; 63

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;
    24ee:	81 e0       	ldi	r24, 0x01	; 1
    24f0:	80 93 3e 95 	sts	0x953E, r24

	USB_ResetInterface();
    24f4:	0e 94 21 12 	call	0x2442	; 0x2442 <USB_ResetInterface>
}
    24f8:	df 91       	pop	r29
    24fa:	cf 91       	pop	r28
    24fc:	08 95       	ret

000024fe <USB_INT_DisableAllInterrupts>:
#define  __INCLUDE_FROM_USB_DRIVER
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	USB.INTCTRLA    &= USB_INTLVL_gm;
    24fe:	e0 ec       	ldi	r30, 0xC0	; 192
    2500:	f4 e0       	ldi	r31, 0x04	; 4
    2502:	80 85       	ldd	r24, Z+8	; 0x08
    2504:	83 70       	andi	r24, 0x03	; 3
    2506:	80 87       	std	Z+8, r24	; 0x08
	USB.INTCTRLB     = 0;
    2508:	11 86       	std	Z+9, r1	; 0x09
    250a:	08 95       	ret

0000250c <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	USB.INTFLAGSACLR = 0xFF;
    250c:	e0 ec       	ldi	r30, 0xC0	; 192
    250e:	f4 e0       	ldi	r31, 0x04	; 4
    2510:	8f ef       	ldi	r24, 0xFF	; 255
    2512:	82 87       	std	Z+10, r24	; 0x0a
	USB.INTFLAGSBCLR = 0xFF;
    2514:	84 87       	std	Z+12, r24	; 0x0c
    2516:	08 95       	ret

00002518 <__vector_125>:
}

ISR(USB_BUSEVENT_vect)
{
    2518:	1f 92       	push	r1
    251a:	0f 92       	push	r0
    251c:	0f b6       	in	r0, 0x3f	; 63
    251e:	0f 92       	push	r0
    2520:	11 24       	eor	r1, r1
    2522:	0b b6       	in	r0, 0x3b	; 59
    2524:	0f 92       	push	r0
    2526:	2f 93       	push	r18
    2528:	3f 93       	push	r19
    252a:	4f 93       	push	r20
    252c:	5f 93       	push	r21
    252e:	6f 93       	push	r22
    2530:	7f 93       	push	r23
    2532:	8f 93       	push	r24
    2534:	9f 93       	push	r25
    2536:	af 93       	push	r26
    2538:	bf 93       	push	r27
    253a:	ef 93       	push	r30
    253c:	ff 93       	push	r31
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTFLAGSACLR & USB_SOFIF_bm) ? true : false);
    253e:	80 91 ca 04 	lds	r24, 0x04CA
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    2542:	88 23       	and	r24, r24
    2544:	4c f4       	brge	.+18     	; 0x2558 <__vector_125+0x40>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						return ((USB.INTCTRLA & USB_BUSEVIE_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTCTRLA & USB_SOFIE_bm) ? true : false);
    2546:	80 91 c8 04 	lds	r24, 0x04C8
    254a:	88 23       	and	r24, r24
    254c:	2c f4       	brge	.+10     	; 0x2558 <__vector_125+0x40>
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
						break;
					case USB_INT_SOFI:
						USB.INTFLAGSACLR = USB_SOFIF_bm;
    254e:	80 e8       	ldi	r24, 0x80	; 128
    2550:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    2554:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <USB_Event_Stub>
			static inline bool USB_INT_HasOccurred(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
    2558:	80 91 ca 04 	lds	r24, 0x04CA
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Suspend))
    255c:	86 ff       	sbrs	r24, 6
    255e:	07 c0       	rjmp	.+14     	; 0x256e <__vector_125+0x56>
			static inline void USB_INT_Clear(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
    2560:	80 e4       	ldi	r24, 0x40	; 64
    2562:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Suspend);

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    2566:	10 92 3f 95 	sts	0x953F, r1
		EVENT_USB_Device_Disconnect();
    256a:	0e 94 34 0a 	call	0x1468	; 0x1468 <EVENT_USB_Device_Disconnect>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
    256e:	80 91 ca 04 	lds	r24, 0x04CA
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Resume))
    2572:	85 ff       	sbrs	r24, 5
    2574:	16 c0       	rjmp	.+44     	; 0x25a2 <__vector_125+0x8a>
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
    2576:	80 e2       	ldi	r24, 0x20	; 32
    2578:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Resume);

		if (USB_Device_ConfigurationNumber)
    257c:	80 91 3b 95 	lds	r24, 0x953B
    2580:	88 23       	and	r24, r24
    2582:	21 f0       	breq	.+8      	; 0x258c <__vector_125+0x74>
		  USB_DeviceState = DEVICE_STATE_Configured;
    2584:	84 e0       	ldi	r24, 0x04	; 4
    2586:	80 93 3f 95 	sts	0x953F, r24
    258a:	09 c0       	rjmp	.+18     	; 0x259e <__vector_125+0x86>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    258c:	80 91 c3 04 	lds	r24, 0x04C3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    2590:	81 11       	cpse	r24, r1
    2592:	02 c0       	rjmp	.+4      	; 0x2598 <__vector_125+0x80>
    2594:	81 e0       	ldi	r24, 0x01	; 1
    2596:	01 c0       	rjmp	.+2      	; 0x259a <__vector_125+0x82>
    2598:	83 e0       	ldi	r24, 0x03	; 3
    259a:	80 93 3f 95 	sts	0x953F, r24

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
    259e:	0e 94 27 0a 	call	0x144e	; 0x144e <EVENT_USB_Device_Connect>
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
    25a2:	80 91 ca 04 	lds	r24, 0x04CA
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Reset))
    25a6:	84 ff       	sbrs	r24, 4
    25a8:	18 c0       	rjmp	.+48     	; 0x25da <__vector_125+0xc2>
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
    25aa:	e0 ec       	ldi	r30, 0xC0	; 192
    25ac:	f4 e0       	ldi	r31, 0x04	; 4
    25ae:	80 e1       	ldi	r24, 0x10	; 16
    25b0:	82 87       	std	Z+10, r24	; 0x0a
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Reset);

		USB_DeviceState                = DEVICE_STATE_Default;
    25b2:	82 e0       	ldi	r24, 0x02	; 2
    25b4:	80 93 3f 95 	sts	0x953F, r24
		USB_Device_ConfigurationNumber = 0;
    25b8:	10 92 3b 95 	sts	0x953B, r1
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    25bc:	13 82       	std	Z+3, r1	; 0x03

		USB_Device_EnableDeviceAddress(0);

		Endpoint_ClearEndpoints();
    25be:	0e 94 95 11 	call	0x232a	; 0x232a <Endpoint_ClearEndpoints>
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    25c2:	48 e0       	ldi	r20, 0x08	; 8
    25c4:	68 e4       	ldi	r22, 0x48	; 72
    25c6:	80 e8       	ldi	r24, 0x80	; 128
    25c8:	0e 94 db 10 	call	0x21b6	; 0x21b6 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    25cc:	48 e0       	ldi	r20, 0x08	; 8
    25ce:	68 e4       	ldi	r22, 0x48	; 72
    25d0:	80 e0       	ldi	r24, 0x00	; 0
    25d2:	0e 94 db 10 	call	0x21b6	; 0x21b6 <Endpoint_ConfigureEndpoint_PRV>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           USB_Device_ControlEndpointSize, 1);

		EVENT_USB_Device_Reset();
    25d6:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <USB_Event_Stub>
	}
}
    25da:	ff 91       	pop	r31
    25dc:	ef 91       	pop	r30
    25de:	bf 91       	pop	r27
    25e0:	af 91       	pop	r26
    25e2:	9f 91       	pop	r25
    25e4:	8f 91       	pop	r24
    25e6:	7f 91       	pop	r23
    25e8:	6f 91       	pop	r22
    25ea:	5f 91       	pop	r21
    25ec:	4f 91       	pop	r20
    25ee:	3f 91       	pop	r19
    25f0:	2f 91       	pop	r18
    25f2:	0f 90       	pop	r0
    25f4:	0b be       	out	0x3b, r0	; 59
    25f6:	0f 90       	pop	r0
    25f8:	0f be       	out	0x3f, r0	; 63
    25fa:	0f 90       	pop	r0
    25fc:	1f 90       	pop	r1
    25fe:	18 95       	reti

00002600 <TC0_ConfigClockSource>:
 *
 *  \param tc              Timer/Counter module instance.
 *  \param clockSelection  Timer/Counter clock source setting.
 */
void TC0_ConfigClockSource( volatile TC0_t * tc, TC_CLKSEL_t clockSelection )
{
    2600:	fc 01       	movw	r30, r24
	tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | clockSelection;
    2602:	90 81       	ld	r25, Z
    2604:	90 7f       	andi	r25, 0xF0	; 240
    2606:	69 2b       	or	r22, r25
    2608:	60 83       	st	Z, r22
    260a:	08 95       	ret

0000260c <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
    260c:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    260e:	96 81       	ldd	r25, Z+6	; 0x06
    2610:	9c 7f       	andi	r25, 0xFC	; 252
    2612:	69 2b       	or	r22, r25
    2614:	66 83       	std	Z+6, r22	; 0x06
    2616:	08 95       	ret

00002618 <rtc_initialize>:
/*
 *	initialize the rtc
 */
void rtc_initialize(){
	//enabling interrupt all three level, high, mid, and low
	OSC.RC32KCAL = 0x10;//smaller, the faster the clock
    2618:	80 e1       	ldi	r24, 0x10	; 16
    261a:	80 93 54 00 	sts	0x0054, r24
	PMIC_CTRL |= (7<<0);
    261e:	e2 ea       	ldi	r30, 0xA2	; 162
    2620:	f0 e0       	ldi	r31, 0x00	; 0
    2622:	80 81       	ld	r24, Z
    2624:	87 60       	ori	r24, 0x07	; 7
    2626:	80 83       	st	Z, r24
	//selecting clock source 32.768kHz from 32.768kHz crystal oscillator on TOSC, enabling RTC clock source
	CLK_RTCCTRL = (5<<1) | (1<<0);//crystal oscillator on TOSC| enabling clock
    2628:	8b e0       	ldi	r24, 0x0B	; 11
    262a:	80 93 43 00 	sts	0x0043, r24
	//enabling interrupts for overflow
	RTC_INTCTRL	|= (0b00000001);
    262e:	e2 e0       	ldi	r30, 0x02	; 2
    2630:	f4 e0       	ldi	r31, 0x04	; 4
    2632:	80 81       	ld	r24, Z
    2634:	81 60       	ori	r24, 0x01	; 1
    2636:	80 83       	st	Z, r24
	RTC_PER = RTC_PER_VAL; //period_val  = 2
    2638:	80 e8       	ldi	r24, 0x80	; 128
    263a:	90 e0       	ldi	r25, 0x00	; 0
    263c:	80 93 0a 04 	sts	0x040A, r24
    2640:	90 93 0b 04 	sts	0x040B, r25
	//selecting clock prescaling
	RTC_CTRL = (1<<0);//no prescaling
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	80 93 00 04 	sts	0x0400, r24
	sei();
    264a:	78 94       	sei
    264c:	08 95       	ret

0000264e <__vector_10>:

/*
 *	interrupt service routine for overflow interrupt event
 */
ISR(RTC_OVF_vect)
{
    264e:	1f 92       	push	r1
    2650:	0f 92       	push	r0
    2652:	0f b6       	in	r0, 0x3f	; 63
    2654:	0f 92       	push	r0
    2656:	11 24       	eor	r1, r1
    2658:	0b b6       	in	r0, 0x3b	; 59
    265a:	0f 92       	push	r0
    265c:	2f 93       	push	r18
    265e:	3f 93       	push	r19
    2660:	4f 93       	push	r20
    2662:	5f 93       	push	r21
    2664:	6f 93       	push	r22
    2666:	7f 93       	push	r23
    2668:	8f 93       	push	r24
    266a:	9f 93       	push	r25
    266c:	af 93       	push	r26
    266e:	bf 93       	push	r27
    2670:	ef 93       	push	r30
    2672:	ff 93       	push	r31
	#if (USE_RTC_TICK == 1)
	rtc_tick_global++;
    2674:	80 91 39 95 	lds	r24, 0x9539
    2678:	90 91 3a 95 	lds	r25, 0x953A
    267c:	01 96       	adiw	r24, 0x01	; 1
    267e:	80 93 39 95 	sts	0x9539, r24
    2682:	90 93 3a 95 	sts	0x953A, r25
	if(rtc_tick_global>=256){
    2686:	80 91 39 95 	lds	r24, 0x9539
    268a:	90 91 3a 95 	lds	r25, 0x953A
    268e:	8f 3f       	cpi	r24, 0xFF	; 255
    2690:	91 05       	cpc	r25, r1
    2692:	39 f0       	breq	.+14     	; 0x26a2 <__vector_10+0x54>
    2694:	34 f0       	brlt	.+12     	; 0x26a2 <__vector_10+0x54>
		rtc_tick_global = 0;
    2696:	10 92 39 95 	sts	0x9539, r1
    269a:	10 92 3a 95 	sts	0x953A, r1
		system_tick();
    269e:	0e 94 6e 13 	call	0x26dc	; 0x26dc <system_tick>
	#endif
	
	
	
	
}
    26a2:	ff 91       	pop	r31
    26a4:	ef 91       	pop	r30
    26a6:	bf 91       	pop	r27
    26a8:	af 91       	pop	r26
    26aa:	9f 91       	pop	r25
    26ac:	8f 91       	pop	r24
    26ae:	7f 91       	pop	r23
    26b0:	6f 91       	pop	r22
    26b2:	5f 91       	pop	r21
    26b4:	4f 91       	pop	r20
    26b6:	3f 91       	pop	r19
    26b8:	2f 91       	pop	r18
    26ba:	0f 90       	pop	r0
    26bc:	0b be       	out	0x3b, r0	; 59
    26be:	0f 90       	pop	r0
    26c0:	0f be       	out	0x3f, r0	; 63
    26c2:	0f 90       	pop	r0
    26c4:	1f 90       	pop	r1
    26c6:	18 95       	reti

000026c8 <__vector_11>:

/*
 *	interrupt service routine for compare interrupt event
 */
ISR(RTC_COMP_vect)
{
    26c8:	1f 92       	push	r1
    26ca:	0f 92       	push	r0
    26cc:	0f b6       	in	r0, 0x3f	; 63
    26ce:	0f 92       	push	r0
    26d0:	11 24       	eor	r1, r1


}
    26d2:	0f 90       	pop	r0
    26d4:	0f be       	out	0x3f, r0	; 63
    26d6:	0f 90       	pop	r0
    26d8:	1f 90       	pop	r1
    26da:	18 95       	reti

000026dc <system_tick>:

	
static char ascTimeBuffer[32];


void  system_tick(void){
    26dc:	08 95       	ret

000026de <__udivmodsi4>:
    26de:	a1 e2       	ldi	r26, 0x21	; 33
    26e0:	1a 2e       	mov	r1, r26
    26e2:	aa 1b       	sub	r26, r26
    26e4:	bb 1b       	sub	r27, r27
    26e6:	fd 01       	movw	r30, r26
    26e8:	0d c0       	rjmp	.+26     	; 0x2704 <__udivmodsi4_ep>

000026ea <__udivmodsi4_loop>:
    26ea:	aa 1f       	adc	r26, r26
    26ec:	bb 1f       	adc	r27, r27
    26ee:	ee 1f       	adc	r30, r30
    26f0:	ff 1f       	adc	r31, r31
    26f2:	a2 17       	cp	r26, r18
    26f4:	b3 07       	cpc	r27, r19
    26f6:	e4 07       	cpc	r30, r20
    26f8:	f5 07       	cpc	r31, r21
    26fa:	20 f0       	brcs	.+8      	; 0x2704 <__udivmodsi4_ep>
    26fc:	a2 1b       	sub	r26, r18
    26fe:	b3 0b       	sbc	r27, r19
    2700:	e4 0b       	sbc	r30, r20
    2702:	f5 0b       	sbc	r31, r21

00002704 <__udivmodsi4_ep>:
    2704:	66 1f       	adc	r22, r22
    2706:	77 1f       	adc	r23, r23
    2708:	88 1f       	adc	r24, r24
    270a:	99 1f       	adc	r25, r25
    270c:	1a 94       	dec	r1
    270e:	69 f7       	brne	.-38     	; 0x26ea <__udivmodsi4_loop>
    2710:	60 95       	com	r22
    2712:	70 95       	com	r23
    2714:	80 95       	com	r24
    2716:	90 95       	com	r25
    2718:	9b 01       	movw	r18, r22
    271a:	ac 01       	movw	r20, r24
    271c:	bd 01       	movw	r22, r26
    271e:	cf 01       	movw	r24, r30
    2720:	08 95       	ret

00002722 <__tablejump2__>:
    2722:	ee 0f       	add	r30, r30
    2724:	ff 1f       	adc	r31, r31
    2726:	88 1f       	adc	r24, r24
    2728:	8b bf       	out	0x3b, r24	; 59
    272a:	07 90       	elpm	r0, Z+
    272c:	f6 91       	elpm	r31, Z
    272e:	e0 2d       	mov	r30, r0
    2730:	19 94       	eijmp

00002732 <fwrite>:
    2732:	8f 92       	push	r8
    2734:	9f 92       	push	r9
    2736:	af 92       	push	r10
    2738:	bf 92       	push	r11
    273a:	cf 92       	push	r12
    273c:	df 92       	push	r13
    273e:	ef 92       	push	r14
    2740:	ff 92       	push	r15
    2742:	0f 93       	push	r16
    2744:	1f 93       	push	r17
    2746:	cf 93       	push	r28
    2748:	df 93       	push	r29
    274a:	5b 01       	movw	r10, r22
    274c:	4a 01       	movw	r8, r20
    274e:	79 01       	movw	r14, r18
    2750:	d9 01       	movw	r26, r18
    2752:	13 96       	adiw	r26, 0x03	; 3
    2754:	2c 91       	ld	r18, X
    2756:	21 ff       	sbrs	r18, 1
    2758:	1d c0       	rjmp	.+58     	; 0x2794 <fwrite+0x62>
    275a:	c0 e0       	ldi	r28, 0x00	; 0
    275c:	d0 e0       	ldi	r29, 0x00	; 0
    275e:	c8 15       	cp	r28, r8
    2760:	d9 05       	cpc	r29, r9
    2762:	d9 f0       	breq	.+54     	; 0x279a <fwrite+0x68>
    2764:	8c 01       	movw	r16, r24
    2766:	6c 01       	movw	r12, r24
    2768:	ca 0c       	add	r12, r10
    276a:	db 1c       	adc	r13, r11
    276c:	c8 01       	movw	r24, r16
    276e:	0c 15       	cp	r16, r12
    2770:	1d 05       	cpc	r17, r13
    2772:	71 f0       	breq	.+28     	; 0x2790 <fwrite+0x5e>
    2774:	0f 5f       	subi	r16, 0xFF	; 255
    2776:	1f 4f       	sbci	r17, 0xFF	; 255
    2778:	d7 01       	movw	r26, r14
    277a:	18 96       	adiw	r26, 0x08	; 8
    277c:	ed 91       	ld	r30, X+
    277e:	fc 91       	ld	r31, X
    2780:	19 97       	sbiw	r26, 0x09	; 9
    2782:	b7 01       	movw	r22, r14
    2784:	dc 01       	movw	r26, r24
    2786:	8c 91       	ld	r24, X
    2788:	19 95       	eicall
    278a:	89 2b       	or	r24, r25
    278c:	79 f3       	breq	.-34     	; 0x276c <fwrite+0x3a>
    278e:	05 c0       	rjmp	.+10     	; 0x279a <fwrite+0x68>
    2790:	21 96       	adiw	r28, 0x01	; 1
    2792:	e5 cf       	rjmp	.-54     	; 0x275e <fwrite+0x2c>
    2794:	80 e0       	ldi	r24, 0x00	; 0
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	01 c0       	rjmp	.+2      	; 0x279c <fwrite+0x6a>
    279a:	ce 01       	movw	r24, r28
    279c:	df 91       	pop	r29
    279e:	cf 91       	pop	r28
    27a0:	1f 91       	pop	r17
    27a2:	0f 91       	pop	r16
    27a4:	ff 90       	pop	r15
    27a6:	ef 90       	pop	r14
    27a8:	df 90       	pop	r13
    27aa:	cf 90       	pop	r12
    27ac:	bf 90       	pop	r11
    27ae:	af 90       	pop	r10
    27b0:	9f 90       	pop	r9
    27b2:	8f 90       	pop	r8
    27b4:	08 95       	ret

000027b6 <_exit>:
    27b6:	f8 94       	cli

000027b8 <__stop_program>:
    27b8:	ff cf       	rjmp	.-2      	; 0x27b8 <__stop_program>
