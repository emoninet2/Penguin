
penguin.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000027d6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002cc  00802000  000027d6  0000286a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00007568  008022cc  008022cc  00002b36  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002b36  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002b68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000958  00000000  00000000  00002ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000f8aa  00000000  00000000  00003500  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002e11  00000000  00000000  00012daa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006d73  00000000  00000000  00015bbb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ad4  00000000  00000000  0001c930  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005bb9  00000000  00000000  0001e404  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008145  00000000  00000000  00023fbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000b88  00000000  00000000  0002c102  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 68 01 	jmp	0x2d0	; 0x2d0 <__ctors_end>
       4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
       8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
       c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      10:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      14:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      18:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      1c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      20:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      24:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      28:	0c 94 2e 13 	jmp	0x265c	; 0x265c <__vector_10>
      2c:	0c 94 6b 13 	jmp	0x26d6	; 0x26d6 <__vector_11>
      30:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      34:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      38:	0c 94 2d 03 	jmp	0x65a	; 0x65a <__vector_14>
      3c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      40:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      44:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      48:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      4c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      50:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      54:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      58:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      5c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      60:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      64:	0c 94 86 0a 	jmp	0x150c	; 0x150c <__vector_25>
      68:	0c 94 9a 0a 	jmp	0x1534	; 0x1534 <__vector_26>
      6c:	0c 94 90 0a 	jmp	0x1520	; 0x1520 <__vector_27>
      70:	0c 94 a4 0a 	jmp	0x1548	; 0x1548 <__vector_28>
      74:	0c 94 b8 0a 	jmp	0x1570	; 0x1570 <__vector_29>
      78:	0c 94 ae 0a 	jmp	0x155c	; 0x155c <__vector_30>
      7c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      80:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      84:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      88:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      8c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      90:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      94:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      98:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      9c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      ac:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      bc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      cc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      dc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e8:	0c 94 e0 0a 	jmp	0x15c0	; 0x15c0 <__vector_58>
      ec:	0c 94 f4 0a 	jmp	0x15e8	; 0x15e8 <__vector_59>
      f0:	0c 94 ea 0a 	jmp	0x15d4	; 0x15d4 <__vector_60>
      f4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      f8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      fc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     100:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     104:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     108:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     10c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     110:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     114:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     118:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     11c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     120:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     124:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     128:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     12c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     130:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     134:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     138:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     13c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     140:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     144:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     148:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     14c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     150:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     154:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     158:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     15c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     160:	0c 94 c2 0a 	jmp	0x1584	; 0x1584 <__vector_88>
     164:	0c 94 d6 0a 	jmp	0x15ac	; 0x15ac <__vector_89>
     168:	0c 94 cc 0a 	jmp	0x1598	; 0x1598 <__vector_90>
     16c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     170:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     174:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     178:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     17c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     180:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     184:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     188:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     18c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     190:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     194:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     198:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     19c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1ac:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1bc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1cc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1dc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1ec:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1f0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1f4:	0c 94 93 12 	jmp	0x2526	; 0x2526 <__vector_125>
     1f8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1fc:	6b 0d       	add	r22, r11
     1fe:	96 0d       	add	r25, r6
     200:	6d 0e       	add	r6, r29
     202:	96 0d       	add	r25, r6
     204:	6d 0e       	add	r6, r29
     206:	d1 0d       	add	r29, r1
     208:	e8 0d       	add	r30, r8
     20a:	6d 0e       	add	r6, r29
     20c:	3f 0e       	add	r3, r31
     20e:	4c 0e       	add	r4, r28

00000210 <__trampolines_start>:
     210:	0c 94 4c 0e 	jmp	0x1c98	; 0x1c98 <USB_Device_ProcessControlRequest+0x228>
     214:	0c 94 84 07 	jmp	0xf08	; 0xf08 <USBThread>
     218:	0c 94 6b 0d 	jmp	0x1ad6	; 0x1ad6 <USB_Device_ProcessControlRequest+0x66>
     21c:	0c 94 d1 0d 	jmp	0x1ba2	; 0x1ba2 <USB_Device_ProcessControlRequest+0x132>
     220:	0c 94 9c 07 	jmp	0xf38	; 0xf38 <thread_1>
     224:	0c 94 93 07 	jmp	0xf26	; 0xf26 <thread_2>
     228:	0c 94 6d 0e 	jmp	0x1cda	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
     22c:	0c 94 3f 0e 	jmp	0x1c7e	; 0x1c7e <USB_Device_ProcessControlRequest+0x20e>
     230:	0c 94 6e 0c 	jmp	0x18dc	; 0x18dc <CDC_Device_getchar>
     234:	0c 94 e6 06 	jmp	0xdcc	; 0xdcc <prvIdleTask>
     238:	0c 94 e8 0d 	jmp	0x1bd0	; 0x1bd0 <USB_Device_ProcessControlRequest+0x160>
     23c:	0c 94 96 0d 	jmp	0x1b2c	; 0x1b2c <USB_Device_ProcessControlRequest+0xbc>
     240:	0c 94 85 0b 	jmp	0x170a	; 0x170a <CDC_Device_putchar>

00000244 <ProductString>:
     244:	1c 03 4c 00 55 00 46 00 41 00 20 00 43 00 44 00     ..L.U.F.A. .C.D.
     254:	43 00 20 00 44 00 65 00 6d 00 6f 00 00 00           C. .D.e.m.o...

00000262 <ManufacturerString>:
     262:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
     272:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

0000027c <LanguageString>:
     27c:	04 03 09 04                                         ....

00000280 <ConfigurationDescriptor>:
     280:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
     290:	01 00 05 24 00 10 01 04 24 02 06 05 24 06 00 01     ...$....$...$...
     2a0:	07 05 82 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     2b0:	07 05 04 02 10 00 05 07 05 83 02 10 00 05           ..............

000002be <DeviceDescriptor>:
     2be:	12 01 10 01 02 00 00 08 eb 03 44 20 01 00 01 02     ..........D ....
     2ce:	dc 01                                               ..

000002d0 <__ctors_end>:
     2d0:	11 24       	eor	r1, r1
     2d2:	1f be       	out	0x3f, r1	; 63
     2d4:	cf ef       	ldi	r28, 0xFF	; 255
     2d6:	cd bf       	out	0x3d, r28	; 61
     2d8:	df e9       	ldi	r29, 0x9F	; 159
     2da:	de bf       	out	0x3e, r29	; 62
     2dc:	00 e0       	ldi	r16, 0x00	; 0
     2de:	0c bf       	out	0x3c, r16	; 60

000002e0 <__do_copy_data>:
     2e0:	12 e2       	ldi	r17, 0x22	; 34
     2e2:	a0 e0       	ldi	r26, 0x00	; 0
     2e4:	b0 e2       	ldi	r27, 0x20	; 32
     2e6:	e6 ed       	ldi	r30, 0xD6	; 214
     2e8:	f7 e2       	ldi	r31, 0x27	; 39
     2ea:	00 e0       	ldi	r16, 0x00	; 0
     2ec:	0b bf       	out	0x3b, r16	; 59
     2ee:	02 c0       	rjmp	.+4      	; 0x2f4 <__do_copy_data+0x14>
     2f0:	07 90       	elpm	r0, Z+
     2f2:	0d 92       	st	X+, r0
     2f4:	ac 3c       	cpi	r26, 0xCC	; 204
     2f6:	b1 07       	cpc	r27, r17
     2f8:	d9 f7       	brne	.-10     	; 0x2f0 <__do_copy_data+0x10>

000002fa <__do_clear_bss>:
     2fa:	28 e9       	ldi	r18, 0x98	; 152
     2fc:	ac ec       	ldi	r26, 0xCC	; 204
     2fe:	b2 e2       	ldi	r27, 0x22	; 34
     300:	01 c0       	rjmp	.+2      	; 0x304 <.do_clear_bss_start>

00000302 <.do_clear_bss_loop>:
     302:	1d 92       	st	X+, r1

00000304 <.do_clear_bss_start>:
     304:	a4 33       	cpi	r26, 0x34	; 52
     306:	b2 07       	cpc	r27, r18
     308:	e1 f7       	brne	.-8      	; 0x302 <.do_clear_bss_loop>
     30a:	0e 94 a3 09 	call	0x1346	; 0x1346 <main>
     30e:	0c 94 e9 13 	jmp	0x27d2	; 0x27d2 <_exit>

00000312 <__bad_interrupt>:
     312:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000316 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
     316:	29 2f       	mov	r18, r25
     318:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     31a:	22 30       	cpi	r18, 0x02	; 2
     31c:	31 05       	cpc	r19, r1
     31e:	59 f0       	breq	.+22     	; 0x336 <CALLBACK_USB_GetDescriptor+0x20>
     320:	23 30       	cpi	r18, 0x03	; 3
     322:	31 05       	cpc	r19, r1
     324:	69 f0       	breq	.+26     	; 0x340 <CALLBACK_USB_GetDescriptor+0x2a>
     326:	21 30       	cpi	r18, 0x01	; 1
     328:	31 05       	cpc	r19, r1
     32a:	29 f5       	brne	.+74     	; 0x376 <CALLBACK_USB_GetDescriptor+0x60>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     32c:	82 e1       	ldi	r24, 0x12	; 18
     32e:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     330:	2e eb       	ldi	r18, 0xBE	; 190
     332:	32 e0       	ldi	r19, 0x02	; 2
     334:	29 c0       	rjmp	.+82     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     336:	8e e3       	ldi	r24, 0x3E	; 62
     338:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     33a:	20 e8       	ldi	r18, 0x80	; 128
     33c:	32 e0       	ldi	r19, 0x02	; 2
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     33e:	24 c0       	rjmp	.+72     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
     340:	99 27       	eor	r25, r25
		case DTYPE_String:
			switch (DescriptorNumber)
     342:	81 30       	cpi	r24, 0x01	; 1
     344:	91 05       	cpc	r25, r1
     346:	59 f0       	breq	.+22     	; 0x35e <CALLBACK_USB_GetDescriptor+0x48>
     348:	82 30       	cpi	r24, 0x02	; 2
     34a:	91 05       	cpc	r25, r1
     34c:	71 f0       	breq	.+28     	; 0x36a <CALLBACK_USB_GetDescriptor+0x54>
     34e:	89 2b       	or	r24, r25
     350:	b9 f4       	brne	.+46     	; 0x380 <CALLBACK_USB_GetDescriptor+0x6a>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     352:	ec e7       	ldi	r30, 0x7C	; 124
     354:	f2 e0       	ldi	r31, 0x02	; 2
     356:	84 91       	lpm	r24, Z
     358:	90 e0       	ldi	r25, 0x00	; 0
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case STRING_ID_Language:
					Address = &LanguageString;
     35a:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
     35c:	15 c0       	rjmp	.+42     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     35e:	e2 e6       	ldi	r30, 0x62	; 98
     360:	f2 e0       	ldi	r31, 0x02	; 2
     362:	84 91       	lpm	r24, Z
     364:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
     366:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
     368:	0f c0       	rjmp	.+30     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     36a:	e4 e4       	ldi	r30, 0x44	; 68
     36c:	f2 e0       	ldi	r31, 0x02	; 2
     36e:	84 91       	lpm	r24, Z
     370:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
     372:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
     374:	09 c0       	rjmp	.+18     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     37a:	20 e0       	ldi	r18, 0x00	; 0
     37c:	30 e0       	ldi	r19, 0x00	; 0
     37e:	04 c0       	rjmp	.+8      	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
	uint16_t    Size    = NO_DESCRIPTOR;
     380:	80 e0       	ldi	r24, 0x00	; 0
     382:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     388:	fa 01       	movw	r30, r20
     38a:	20 83       	st	Z, r18
     38c:	31 83       	std	Z+1, r19	; 0x01
	return Size;
}
     38e:	08 95       	ret

00000390 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     390:	31 e1       	ldi	r19, 0x11	; 17
     392:	fc 01       	movw	r30, r24
     394:	30 83       	st	Z, r19
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	22 e2       	ldi	r18, 0x22	; 34
     39a:	20 83       	st	Z, r18
     39c:	31 97       	sbiw	r30, 0x01	; 1
     39e:	a3 e3       	ldi	r26, 0x33	; 51
     3a0:	a0 83       	st	Z, r26
     3a2:	31 97       	sbiw	r30, 0x01	; 1
     3a4:	60 83       	st	Z, r22
     3a6:	31 97       	sbiw	r30, 0x01	; 1
     3a8:	70 83       	st	Z, r23
     3aa:	31 97       	sbiw	r30, 0x01	; 1
     3ac:	10 82       	st	Z, r1
     3ae:	31 97       	sbiw	r30, 0x01	; 1
     3b0:	10 82       	st	Z, r1
     3b2:	31 97       	sbiw	r30, 0x01	; 1
     3b4:	60 e8       	ldi	r22, 0x80	; 128
     3b6:	60 83       	st	Z, r22
     3b8:	31 97       	sbiw	r30, 0x01	; 1
     3ba:	10 82       	st	Z, r1
     3bc:	31 97       	sbiw	r30, 0x01	; 1
     3be:	62 e0       	ldi	r22, 0x02	; 2
     3c0:	60 83       	st	Z, r22
     3c2:	31 97       	sbiw	r30, 0x01	; 1
     3c4:	63 e0       	ldi	r22, 0x03	; 3
     3c6:	60 83       	st	Z, r22
     3c8:	31 97       	sbiw	r30, 0x01	; 1
     3ca:	64 e0       	ldi	r22, 0x04	; 4
     3cc:	60 83       	st	Z, r22
     3ce:	31 97       	sbiw	r30, 0x01	; 1
     3d0:	65 e0       	ldi	r22, 0x05	; 5
     3d2:	60 83       	st	Z, r22
     3d4:	31 97       	sbiw	r30, 0x01	; 1
     3d6:	66 e0       	ldi	r22, 0x06	; 6
     3d8:	60 83       	st	Z, r22
     3da:	31 97       	sbiw	r30, 0x01	; 1
     3dc:	67 e0       	ldi	r22, 0x07	; 7
     3de:	60 83       	st	Z, r22
     3e0:	31 97       	sbiw	r30, 0x01	; 1
     3e2:	68 e0       	ldi	r22, 0x08	; 8
     3e4:	60 83       	st	Z, r22
     3e6:	31 97       	sbiw	r30, 0x01	; 1
     3e8:	69 e0       	ldi	r22, 0x09	; 9
     3ea:	60 83       	st	Z, r22
     3ec:	31 97       	sbiw	r30, 0x01	; 1
     3ee:	60 e1       	ldi	r22, 0x10	; 16
     3f0:	60 83       	st	Z, r22
     3f2:	31 97       	sbiw	r30, 0x01	; 1
     3f4:	30 83       	st	Z, r19
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	32 e1       	ldi	r19, 0x12	; 18
     3fa:	30 83       	st	Z, r19
     3fc:	31 97       	sbiw	r30, 0x01	; 1
     3fe:	33 e1       	ldi	r19, 0x13	; 19
     400:	30 83       	st	Z, r19
     402:	31 97       	sbiw	r30, 0x01	; 1
     404:	34 e1       	ldi	r19, 0x14	; 20
     406:	30 83       	st	Z, r19
     408:	31 97       	sbiw	r30, 0x01	; 1
     40a:	35 e1       	ldi	r19, 0x15	; 21
     40c:	30 83       	st	Z, r19
     40e:	31 97       	sbiw	r30, 0x01	; 1
     410:	36 e1       	ldi	r19, 0x16	; 22
     412:	30 83       	st	Z, r19
     414:	31 97       	sbiw	r30, 0x01	; 1
     416:	37 e1       	ldi	r19, 0x17	; 23
     418:	30 83       	st	Z, r19
     41a:	31 97       	sbiw	r30, 0x01	; 1
     41c:	38 e1       	ldi	r19, 0x18	; 24
     41e:	30 83       	st	Z, r19
     420:	31 97       	sbiw	r30, 0x01	; 1
     422:	39 e1       	ldi	r19, 0x19	; 25
     424:	30 83       	st	Z, r19
     426:	31 97       	sbiw	r30, 0x01	; 1
     428:	30 e2       	ldi	r19, 0x20	; 32
     42a:	30 83       	st	Z, r19
     42c:	31 97       	sbiw	r30, 0x01	; 1
     42e:	31 e2       	ldi	r19, 0x21	; 33
     430:	30 83       	st	Z, r19
     432:	31 97       	sbiw	r30, 0x01	; 1
     434:	20 83       	st	Z, r18
     436:	31 97       	sbiw	r30, 0x01	; 1
     438:	23 e2       	ldi	r18, 0x23	; 35
     43a:	20 83       	st	Z, r18
     43c:	31 97       	sbiw	r30, 0x01	; 1
     43e:	40 83       	st	Z, r20
     440:	31 97       	sbiw	r30, 0x01	; 1
     442:	50 83       	st	Z, r21
     444:	31 97       	sbiw	r30, 0x01	; 1
     446:	26 e2       	ldi	r18, 0x26	; 38
     448:	20 83       	st	Z, r18
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	27 e2       	ldi	r18, 0x27	; 39
     44e:	20 83       	st	Z, r18
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	28 e2       	ldi	r18, 0x28	; 40
     454:	20 83       	st	Z, r18
     456:	31 97       	sbiw	r30, 0x01	; 1
     458:	29 e2       	ldi	r18, 0x29	; 41
     45a:	20 83       	st	Z, r18
     45c:	31 97       	sbiw	r30, 0x01	; 1
     45e:	20 e3       	ldi	r18, 0x30	; 48
     460:	20 83       	st	Z, r18
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	21 e3       	ldi	r18, 0x31	; 49
     466:	20 83       	st	Z, r18
     468:	87 97       	sbiw	r24, 0x27	; 39
     46a:	08 95       	ret

0000046c <xPortStartScheduler>:
     46c:	65 e0       	ldi	r22, 0x05	; 5
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	98 e0       	ldi	r25, 0x08	; 8
     472:	0e 94 07 13 	call	0x260e	; 0x260e <TC0_ConfigClockSource>
     476:	83 ef       	ldi	r24, 0xF3	; 243
     478:	91 e0       	ldi	r25, 0x01	; 1
     47a:	80 93 26 08 	sts	0x0826, r24
     47e:	90 93 27 08 	sts	0x0827, r25
     482:	61 e0       	ldi	r22, 0x01	; 1
     484:	80 e0       	ldi	r24, 0x00	; 0
     486:	98 e0       	ldi	r25, 0x08	; 8
     488:	0e 94 0d 13 	call	0x261a	; 0x261a <TC0_SetOverflowIntLevel>
     48c:	e0 ea       	ldi	r30, 0xA0	; 160
     48e:	f0 e0       	ldi	r31, 0x00	; 0
     490:	82 81       	ldd	r24, Z+2	; 0x02
     492:	81 60       	ori	r24, 0x01	; 1
     494:	82 83       	std	Z+2, r24	; 0x02
     496:	a0 91 27 93 	lds	r26, 0x9327
     49a:	b0 91 28 93 	lds	r27, 0x9328
     49e:	cd 91       	ld	r28, X+
     4a0:	cd bf       	out	0x3d, r28	; 61
     4a2:	dd 91       	ld	r29, X+
     4a4:	de bf       	out	0x3e, r29	; 62
     4a6:	ff 91       	pop	r31
     4a8:	ef 91       	pop	r30
     4aa:	df 91       	pop	r29
     4ac:	cf 91       	pop	r28
     4ae:	bf 91       	pop	r27
     4b0:	af 91       	pop	r26
     4b2:	9f 91       	pop	r25
     4b4:	8f 91       	pop	r24
     4b6:	7f 91       	pop	r23
     4b8:	6f 91       	pop	r22
     4ba:	5f 91       	pop	r21
     4bc:	4f 91       	pop	r20
     4be:	3f 91       	pop	r19
     4c0:	2f 91       	pop	r18
     4c2:	1f 91       	pop	r17
     4c4:	0f 91       	pop	r16
     4c6:	ff 90       	pop	r15
     4c8:	ef 90       	pop	r14
     4ca:	df 90       	pop	r13
     4cc:	cf 90       	pop	r12
     4ce:	bf 90       	pop	r11
     4d0:	af 90       	pop	r10
     4d2:	9f 90       	pop	r9
     4d4:	8f 90       	pop	r8
     4d6:	7f 90       	pop	r7
     4d8:	6f 90       	pop	r6
     4da:	5f 90       	pop	r5
     4dc:	4f 90       	pop	r4
     4de:	3f 90       	pop	r3
     4e0:	2f 90       	pop	r2
     4e2:	1f 90       	pop	r1
     4e4:	0f 90       	pop	r0
     4e6:	0f be       	out	0x3f, r0	; 63
     4e8:	0f 90       	pop	r0
     4ea:	08 95       	ret
     4ec:	81 e0       	ldi	r24, 0x01	; 1
     4ee:	08 95       	ret

000004f0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     4f0:	0f 92       	push	r0
     4f2:	0f b6       	in	r0, 0x3f	; 63
     4f4:	f8 94       	cli
     4f6:	0f 92       	push	r0
     4f8:	1f 92       	push	r1
     4fa:	11 24       	eor	r1, r1
     4fc:	2f 92       	push	r2
     4fe:	3f 92       	push	r3
     500:	4f 92       	push	r4
     502:	5f 92       	push	r5
     504:	6f 92       	push	r6
     506:	7f 92       	push	r7
     508:	8f 92       	push	r8
     50a:	9f 92       	push	r9
     50c:	af 92       	push	r10
     50e:	bf 92       	push	r11
     510:	cf 92       	push	r12
     512:	df 92       	push	r13
     514:	ef 92       	push	r14
     516:	ff 92       	push	r15
     518:	0f 93       	push	r16
     51a:	1f 93       	push	r17
     51c:	2f 93       	push	r18
     51e:	3f 93       	push	r19
     520:	4f 93       	push	r20
     522:	5f 93       	push	r21
     524:	6f 93       	push	r22
     526:	7f 93       	push	r23
     528:	8f 93       	push	r24
     52a:	9f 93       	push	r25
     52c:	af 93       	push	r26
     52e:	bf 93       	push	r27
     530:	cf 93       	push	r28
     532:	df 93       	push	r29
     534:	ef 93       	push	r30
     536:	ff 93       	push	r31
     538:	a0 91 27 93 	lds	r26, 0x9327
     53c:	b0 91 28 93 	lds	r27, 0x9328
     540:	0d b6       	in	r0, 0x3d	; 61
     542:	0d 92       	st	X+, r0
     544:	0e b6       	in	r0, 0x3e	; 62
     546:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     548:	0e 94 17 07 	call	0xe2e	; 0xe2e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     54c:	a0 91 27 93 	lds	r26, 0x9327
     550:	b0 91 28 93 	lds	r27, 0x9328
     554:	cd 91       	ld	r28, X+
     556:	cd bf       	out	0x3d, r28	; 61
     558:	dd 91       	ld	r29, X+
     55a:	de bf       	out	0x3e, r29	; 62
     55c:	ff 91       	pop	r31
     55e:	ef 91       	pop	r30
     560:	df 91       	pop	r29
     562:	cf 91       	pop	r28
     564:	bf 91       	pop	r27
     566:	af 91       	pop	r26
     568:	9f 91       	pop	r25
     56a:	8f 91       	pop	r24
     56c:	7f 91       	pop	r23
     56e:	6f 91       	pop	r22
     570:	5f 91       	pop	r21
     572:	4f 91       	pop	r20
     574:	3f 91       	pop	r19
     576:	2f 91       	pop	r18
     578:	1f 91       	pop	r17
     57a:	0f 91       	pop	r16
     57c:	ff 90       	pop	r15
     57e:	ef 90       	pop	r14
     580:	df 90       	pop	r13
     582:	cf 90       	pop	r12
     584:	bf 90       	pop	r11
     586:	af 90       	pop	r10
     588:	9f 90       	pop	r9
     58a:	8f 90       	pop	r8
     58c:	7f 90       	pop	r7
     58e:	6f 90       	pop	r6
     590:	5f 90       	pop	r5
     592:	4f 90       	pop	r4
     594:	3f 90       	pop	r3
     596:	2f 90       	pop	r2
     598:	1f 90       	pop	r1
     59a:	0f 90       	pop	r0
     59c:	0f be       	out	0x3f, r0	; 63
     59e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5a0:	08 95       	ret

000005a2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5a2:	0f 92       	push	r0
     5a4:	0f b6       	in	r0, 0x3f	; 63
     5a6:	f8 94       	cli
     5a8:	0f 92       	push	r0
     5aa:	1f 92       	push	r1
     5ac:	11 24       	eor	r1, r1
     5ae:	2f 92       	push	r2
     5b0:	3f 92       	push	r3
     5b2:	4f 92       	push	r4
     5b4:	5f 92       	push	r5
     5b6:	6f 92       	push	r6
     5b8:	7f 92       	push	r7
     5ba:	8f 92       	push	r8
     5bc:	9f 92       	push	r9
     5be:	af 92       	push	r10
     5c0:	bf 92       	push	r11
     5c2:	cf 92       	push	r12
     5c4:	df 92       	push	r13
     5c6:	ef 92       	push	r14
     5c8:	ff 92       	push	r15
     5ca:	0f 93       	push	r16
     5cc:	1f 93       	push	r17
     5ce:	2f 93       	push	r18
     5d0:	3f 93       	push	r19
     5d2:	4f 93       	push	r20
     5d4:	5f 93       	push	r21
     5d6:	6f 93       	push	r22
     5d8:	7f 93       	push	r23
     5da:	8f 93       	push	r24
     5dc:	9f 93       	push	r25
     5de:	af 93       	push	r26
     5e0:	bf 93       	push	r27
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	ef 93       	push	r30
     5e8:	ff 93       	push	r31
     5ea:	a0 91 27 93 	lds	r26, 0x9327
     5ee:	b0 91 28 93 	lds	r27, 0x9328
     5f2:	0d b6       	in	r0, 0x3d	; 61
     5f4:	0d 92       	st	X+, r0
     5f6:	0e b6       	in	r0, 0x3e	; 62
     5f8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     5fa:	0e 94 8a 05 	call	0xb14	; 0xb14 <xTaskIncrementTick>
     5fe:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     600:	0e 94 17 07 	call	0xe2e	; 0xe2e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     604:	a0 91 27 93 	lds	r26, 0x9327
     608:	b0 91 28 93 	lds	r27, 0x9328
     60c:	cd 91       	ld	r28, X+
     60e:	cd bf       	out	0x3d, r28	; 61
     610:	dd 91       	ld	r29, X+
     612:	de bf       	out	0x3e, r29	; 62
     614:	ff 91       	pop	r31
     616:	ef 91       	pop	r30
     618:	df 91       	pop	r29
     61a:	cf 91       	pop	r28
     61c:	bf 91       	pop	r27
     61e:	af 91       	pop	r26
     620:	9f 91       	pop	r25
     622:	8f 91       	pop	r24
     624:	7f 91       	pop	r23
     626:	6f 91       	pop	r22
     628:	5f 91       	pop	r21
     62a:	4f 91       	pop	r20
     62c:	3f 91       	pop	r19
     62e:	2f 91       	pop	r18
     630:	1f 91       	pop	r17
     632:	0f 91       	pop	r16
     634:	ff 90       	pop	r15
     636:	ef 90       	pop	r14
     638:	df 90       	pop	r13
     63a:	cf 90       	pop	r12
     63c:	bf 90       	pop	r11
     63e:	af 90       	pop	r10
     640:	9f 90       	pop	r9
     642:	8f 90       	pop	r8
     644:	7f 90       	pop	r7
     646:	6f 90       	pop	r6
     648:	5f 90       	pop	r5
     64a:	4f 90       	pop	r4
     64c:	3f 90       	pop	r3
     64e:	2f 90       	pop	r2
     650:	1f 90       	pop	r1
     652:	0f 90       	pop	r0
     654:	0f be       	out	0x3f, r0	; 63
     656:	0f 90       	pop	r0

	asm volatile ( "ret" );
     658:	08 95       	ret

0000065a <__vector_14>:
	 */
	
	void TCC0_OVF_vect( void ) __attribute__ ( ( signal, naked ) );
	void TCC0_OVF_vect( void )
	{
		vPortYieldFromTick();
     65a:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     65e:	18 95       	reti

00000660 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     660:	cf 93       	push	r28
     662:	df 93       	push	r29
     664:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     666:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     66a:	80 91 cc 22 	lds	r24, 0x22CC
     66e:	90 91 cd 22 	lds	r25, 0x22CD
     672:	89 2b       	or	r24, r25
     674:	31 f4       	brne	.+12     	; 0x682 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     676:	81 ed       	ldi	r24, 0xD1	; 209
     678:	92 e2       	ldi	r25, 0x22	; 34
     67a:	80 93 cc 22 	sts	0x22CC, r24
     67e:	90 93 cd 22 	sts	0x22CD, r25
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     682:	20 91 ce 22 	lds	r18, 0x22CE
     686:	30 91 cf 22 	lds	r19, 0x22CF
     68a:	ce 01       	movw	r24, r28
     68c:	82 0f       	add	r24, r18
     68e:	93 1f       	adc	r25, r19
     690:	8f 3f       	cpi	r24, 0xFF	; 255
     692:	4f e6       	ldi	r20, 0x6F	; 111
     694:	94 07       	cpc	r25, r20
     696:	70 f4       	brcc	.+28     	; 0x6b4 <pvPortMalloc+0x54>
     698:	28 17       	cp	r18, r24
     69a:	39 07       	cpc	r19, r25
     69c:	70 f4       	brcc	.+28     	; 0x6ba <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     69e:	c0 91 cc 22 	lds	r28, 0x22CC
     6a2:	d0 91 cd 22 	lds	r29, 0x22CD
     6a6:	c2 0f       	add	r28, r18
     6a8:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     6aa:	80 93 ce 22 	sts	0x22CE, r24
     6ae:	90 93 cf 22 	sts	0x22CF, r25
     6b2:	05 c0       	rjmp	.+10     	; 0x6be <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6b4:	c0 e0       	ldi	r28, 0x00	; 0
     6b6:	d0 e0       	ldi	r29, 0x00	; 0
     6b8:	02 c0       	rjmp	.+4      	; 0x6be <pvPortMalloc+0x5e>
     6ba:	c0 e0       	ldi	r28, 0x00	; 0
     6bc:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6be:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6c2:	ce 01       	movw	r24, r28
     6c4:	df 91       	pop	r29
     6c6:	cf 91       	pop	r28
     6c8:	08 95       	ret

000006ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6ca:	08 95       	ret

000006cc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6cc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ce:	03 96       	adiw	r24, 0x03	; 3
     6d0:	81 83       	std	Z+1, r24	; 0x01
     6d2:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6d4:	2f ef       	ldi	r18, 0xFF	; 255
     6d6:	3f ef       	ldi	r19, 0xFF	; 255
     6d8:	23 83       	std	Z+3, r18	; 0x03
     6da:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6dc:	85 83       	std	Z+5, r24	; 0x05
     6de:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6e0:	87 83       	std	Z+7, r24	; 0x07
     6e2:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6e4:	10 82       	st	Z, r1
     6e6:	08 95       	ret

000006e8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6e8:	fc 01       	movw	r30, r24
     6ea:	10 86       	std	Z+8, r1	; 0x08
     6ec:	11 86       	std	Z+9, r1	; 0x09
     6ee:	08 95       	ret

000006f0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	9c 01       	movw	r18, r24
     6f6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6f8:	dc 01       	movw	r26, r24
     6fa:	11 96       	adiw	r26, 0x01	; 1
     6fc:	cd 91       	ld	r28, X+
     6fe:	dc 91       	ld	r29, X
     700:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     702:	c2 83       	std	Z+2, r28	; 0x02
     704:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     706:	8c 81       	ldd	r24, Y+4	; 0x04
     708:	9d 81       	ldd	r25, Y+5	; 0x05
     70a:	84 83       	std	Z+4, r24	; 0x04
     70c:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     70e:	8c 81       	ldd	r24, Y+4	; 0x04
     710:	9d 81       	ldd	r25, Y+5	; 0x05
     712:	dc 01       	movw	r26, r24
     714:	12 96       	adiw	r26, 0x02	; 2
     716:	6d 93       	st	X+, r22
     718:	7c 93       	st	X, r23
     71a:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
     71c:	6c 83       	std	Y+4, r22	; 0x04
     71e:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     720:	20 87       	std	Z+8, r18	; 0x08
     722:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
     724:	f9 01       	movw	r30, r18
     726:	80 81       	ld	r24, Z
     728:	8f 5f       	subi	r24, 0xFF	; 255
     72a:	80 83       	st	Z, r24
}
     72c:	df 91       	pop	r29
     72e:	cf 91       	pop	r28
     730:	08 95       	ret

00000732 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     738:	48 81       	ld	r20, Y
     73a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     73c:	4f 3f       	cpi	r20, 0xFF	; 255
     73e:	2f ef       	ldi	r18, 0xFF	; 255
     740:	52 07       	cpc	r21, r18
     742:	21 f4       	brne	.+8      	; 0x74c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     744:	fc 01       	movw	r30, r24
     746:	a7 81       	ldd	r26, Z+7	; 0x07
     748:	b0 85       	ldd	r27, Z+8	; 0x08
     74a:	0d c0       	rjmp	.+26     	; 0x766 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     74c:	dc 01       	movw	r26, r24
     74e:	13 96       	adiw	r26, 0x03	; 3
     750:	01 c0       	rjmp	.+2      	; 0x754 <vListInsert+0x22>
     752:	df 01       	movw	r26, r30
     754:	12 96       	adiw	r26, 0x02	; 2
     756:	ed 91       	ld	r30, X+
     758:	fc 91       	ld	r31, X
     75a:	13 97       	sbiw	r26, 0x03	; 3
     75c:	20 81       	ld	r18, Z
     75e:	31 81       	ldd	r19, Z+1	; 0x01
     760:	42 17       	cp	r20, r18
     762:	53 07       	cpc	r21, r19
     764:	b0 f7       	brcc	.-20     	; 0x752 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     766:	12 96       	adiw	r26, 0x02	; 2
     768:	ed 91       	ld	r30, X+
     76a:	fc 91       	ld	r31, X
     76c:	13 97       	sbiw	r26, 0x03	; 3
     76e:	ea 83       	std	Y+2, r30	; 0x02
     770:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     772:	c4 83       	std	Z+4, r28	; 0x04
     774:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
     776:	ac 83       	std	Y+4, r26	; 0x04
     778:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
     77a:	12 96       	adiw	r26, 0x02	; 2
     77c:	cd 93       	st	X+, r28
     77e:	dc 93       	st	X, r29
     780:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     782:	88 87       	std	Y+8, r24	; 0x08
     784:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
     786:	fc 01       	movw	r30, r24
     788:	20 81       	ld	r18, Z
     78a:	2f 5f       	subi	r18, 0xFF	; 255
     78c:	20 83       	st	Z, r18
}
     78e:	df 91       	pop	r29
     790:	cf 91       	pop	r28
     792:	08 95       	ret

00000794 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
     798:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     79a:	a0 85       	ldd	r26, Z+8	; 0x08
     79c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     79e:	c2 81       	ldd	r28, Z+2	; 0x02
     7a0:	d3 81       	ldd	r29, Z+3	; 0x03
     7a2:	84 81       	ldd	r24, Z+4	; 0x04
     7a4:	95 81       	ldd	r25, Z+5	; 0x05
     7a6:	8c 83       	std	Y+4, r24	; 0x04
     7a8:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7aa:	c4 81       	ldd	r28, Z+4	; 0x04
     7ac:	d5 81       	ldd	r29, Z+5	; 0x05
     7ae:	82 81       	ldd	r24, Z+2	; 0x02
     7b0:	93 81       	ldd	r25, Z+3	; 0x03
     7b2:	8a 83       	std	Y+2, r24	; 0x02
     7b4:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7b6:	11 96       	adiw	r26, 0x01	; 1
     7b8:	cd 91       	ld	r28, X+
     7ba:	dc 91       	ld	r29, X
     7bc:	12 97       	sbiw	r26, 0x02	; 2
     7be:	ce 17       	cp	r28, r30
     7c0:	df 07       	cpc	r29, r31
     7c2:	31 f4       	brne	.+12     	; 0x7d0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7c4:	8c 81       	ldd	r24, Y+4	; 0x04
     7c6:	9d 81       	ldd	r25, Y+5	; 0x05
     7c8:	11 96       	adiw	r26, 0x01	; 1
     7ca:	8d 93       	st	X+, r24
     7cc:	9c 93       	st	X, r25
     7ce:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7d0:	10 86       	std	Z+8, r1	; 0x08
     7d2:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
     7d4:	8c 91       	ld	r24, X
     7d6:	81 50       	subi	r24, 0x01	; 1
     7d8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7da:	df 91       	pop	r29
     7dc:	cf 91       	pop	r28
     7de:	08 95       	ret

000007e0 <prvResetNextTaskUnblockTime>:
			}
		}
		( void ) xTaskResumeAll();

		return uxTask;
	}
     7e0:	e0 91 ef 92 	lds	r30, 0x92EF
     7e4:	f0 91 f0 92 	lds	r31, 0x92F0
     7e8:	80 81       	ld	r24, Z
     7ea:	81 11       	cpse	r24, r1
     7ec:	07 c0       	rjmp	.+14     	; 0x7fc <prvResetNextTaskUnblockTime+0x1c>
     7ee:	8f ef       	ldi	r24, 0xFF	; 255
     7f0:	9f ef       	ldi	r25, 0xFF	; 255
     7f2:	80 93 89 22 	sts	0x2289, r24
     7f6:	90 93 8a 22 	sts	0x228A, r25
     7fa:	08 95       	ret
     7fc:	e0 91 ef 92 	lds	r30, 0x92EF
     800:	f0 91 f0 92 	lds	r31, 0x92F0
     804:	05 80       	ldd	r0, Z+5	; 0x05
     806:	f6 81       	ldd	r31, Z+6	; 0x06
     808:	e0 2d       	mov	r30, r0
     80a:	06 80       	ldd	r0, Z+6	; 0x06
     80c:	f7 81       	ldd	r31, Z+7	; 0x07
     80e:	e0 2d       	mov	r30, r0
     810:	82 81       	ldd	r24, Z+2	; 0x02
     812:	93 81       	ldd	r25, Z+3	; 0x03
     814:	80 93 89 22 	sts	0x2289, r24
     818:	90 93 8a 22 	sts	0x228A, r25
     81c:	08 95       	ret

0000081e <prvAddCurrentTaskToDelayedList>:
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	ec 01       	movw	r28, r24
     824:	e0 91 27 93 	lds	r30, 0x9327
     828:	f0 91 28 93 	lds	r31, 0x9328
     82c:	82 83       	std	Z+2, r24	; 0x02
     82e:	93 83       	std	Z+3, r25	; 0x03
     830:	80 91 d7 92 	lds	r24, 0x92D7
     834:	90 91 d8 92 	lds	r25, 0x92D8
     838:	c8 17       	cp	r28, r24
     83a:	d9 07       	cpc	r29, r25
     83c:	68 f4       	brcc	.+26     	; 0x858 <prvAddCurrentTaskToDelayedList+0x3a>
     83e:	60 91 27 93 	lds	r22, 0x9327
     842:	70 91 28 93 	lds	r23, 0x9328
     846:	80 91 ed 92 	lds	r24, 0x92ED
     84a:	90 91 ee 92 	lds	r25, 0x92EE
     84e:	6e 5f       	subi	r22, 0xFE	; 254
     850:	7f 4f       	sbci	r23, 0xFF	; 255
     852:	0e 94 99 03 	call	0x732	; 0x732 <vListInsert>
     856:	17 c0       	rjmp	.+46     	; 0x886 <prvAddCurrentTaskToDelayedList+0x68>
     858:	60 91 27 93 	lds	r22, 0x9327
     85c:	70 91 28 93 	lds	r23, 0x9328
     860:	80 91 ef 92 	lds	r24, 0x92EF
     864:	90 91 f0 92 	lds	r25, 0x92F0
     868:	6e 5f       	subi	r22, 0xFE	; 254
     86a:	7f 4f       	sbci	r23, 0xFF	; 255
     86c:	0e 94 99 03 	call	0x732	; 0x732 <vListInsert>
     870:	80 91 89 22 	lds	r24, 0x2289
     874:	90 91 8a 22 	lds	r25, 0x228A
     878:	c8 17       	cp	r28, r24
     87a:	d9 07       	cpc	r29, r25
     87c:	20 f4       	brcc	.+8      	; 0x886 <prvAddCurrentTaskToDelayedList+0x68>
     87e:	c0 93 89 22 	sts	0x2289, r28
     882:	d0 93 8a 22 	sts	0x228A, r29
     886:	df 91       	pop	r29
     888:	cf 91       	pop	r28
     88a:	08 95       	ret

0000088c <xTaskGenericCreate>:
     88c:	4f 92       	push	r4
     88e:	5f 92       	push	r5
     890:	6f 92       	push	r6
     892:	7f 92       	push	r7
     894:	8f 92       	push	r8
     896:	9f 92       	push	r9
     898:	af 92       	push	r10
     89a:	bf 92       	push	r11
     89c:	cf 92       	push	r12
     89e:	df 92       	push	r13
     8a0:	ef 92       	push	r14
     8a2:	ff 92       	push	r15
     8a4:	0f 93       	push	r16
     8a6:	1f 93       	push	r17
     8a8:	cf 93       	push	r28
     8aa:	df 93       	push	r29
     8ac:	4c 01       	movw	r8, r24
     8ae:	eb 01       	movw	r28, r22
     8b0:	5a 01       	movw	r10, r20
     8b2:	29 01       	movw	r4, r18
     8b4:	83 e2       	ldi	r24, 0x23	; 35
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	0e 94 30 03 	call	0x660	; 0x660 <pvPortMalloc>
     8bc:	3c 01       	movw	r6, r24
     8be:	00 97       	sbiw	r24, 0x00	; 0
     8c0:	09 f4       	brne	.+2      	; 0x8c4 <xTaskGenericCreate+0x38>
     8c2:	e5 c0       	rjmp	.+458    	; 0xa8e <xTaskGenericCreate+0x202>
     8c4:	c1 14       	cp	r12, r1
     8c6:	d1 04       	cpc	r13, r1
     8c8:	09 f0       	breq	.+2      	; 0x8cc <xTaskGenericCreate+0x40>
     8ca:	dc c0       	rjmp	.+440    	; 0xa84 <xTaskGenericCreate+0x1f8>
     8cc:	c5 01       	movw	r24, r10
     8ce:	0e 94 30 03 	call	0x660	; 0x660 <pvPortMalloc>
     8d2:	f3 01       	movw	r30, r6
     8d4:	87 8b       	std	Z+23, r24	; 0x17
     8d6:	90 8f       	std	Z+24, r25	; 0x18
     8d8:	00 97       	sbiw	r24, 0x00	; 0
     8da:	21 f4       	brne	.+8      	; 0x8e4 <xTaskGenericCreate+0x58>
     8dc:	c3 01       	movw	r24, r6
     8de:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
     8e2:	d5 c0       	rjmp	.+426    	; 0xa8e <xTaskGenericCreate+0x202>
     8e4:	a5 01       	movw	r20, r10
     8e6:	65 ea       	ldi	r22, 0xA5	; 165
     8e8:	70 e0       	ldi	r23, 0x00	; 0
     8ea:	0e 94 a0 13 	call	0x2740	; 0x2740 <memset>
     8ee:	f1 e0       	ldi	r31, 0x01	; 1
     8f0:	af 1a       	sub	r10, r31
     8f2:	b1 08       	sbc	r11, r1
     8f4:	f3 01       	movw	r30, r6
     8f6:	87 89       	ldd	r24, Z+23	; 0x17
     8f8:	90 8d       	ldd	r25, Z+24	; 0x18
     8fa:	a8 0e       	add	r10, r24
     8fc:	b9 1e       	adc	r11, r25
     8fe:	88 81       	ld	r24, Y
     900:	81 8f       	std	Z+25, r24	; 0x19
     902:	88 81       	ld	r24, Y
     904:	88 23       	and	r24, r24
     906:	81 f0       	breq	.+32     	; 0x928 <xTaskGenericCreate+0x9c>
     908:	d3 01       	movw	r26, r6
     90a:	5a 96       	adiw	r26, 0x1a	; 26
     90c:	fe 01       	movw	r30, r28
     90e:	31 96       	adiw	r30, 0x01	; 1
     910:	9e 01       	movw	r18, r28
     912:	28 5f       	subi	r18, 0xF8	; 248
     914:	3f 4f       	sbci	r19, 0xFF	; 255
     916:	ef 01       	movw	r28, r30
     918:	81 91       	ld	r24, Z+
     91a:	8d 93       	st	X+, r24
     91c:	88 81       	ld	r24, Y
     91e:	88 23       	and	r24, r24
     920:	19 f0       	breq	.+6      	; 0x928 <xTaskGenericCreate+0x9c>
     922:	e2 17       	cp	r30, r18
     924:	f3 07       	cpc	r31, r19
     926:	b9 f7       	brne	.-18     	; 0x916 <xTaskGenericCreate+0x8a>
     928:	f3 01       	movw	r30, r6
     92a:	10 a2       	std	Z+32, r1	; 0x20
     92c:	10 2f       	mov	r17, r16
     92e:	04 30       	cpi	r16, 0x04	; 4
     930:	08 f0       	brcs	.+2      	; 0x934 <xTaskGenericCreate+0xa8>
     932:	13 e0       	ldi	r17, 0x03	; 3
     934:	f3 01       	movw	r30, r6
     936:	16 8b       	std	Z+22, r17	; 0x16
     938:	e3 01       	movw	r28, r6
     93a:	22 96       	adiw	r28, 0x02	; 2
     93c:	ce 01       	movw	r24, r28
     93e:	0e 94 74 03 	call	0x6e8	; 0x6e8 <vListInitialiseItem>
     942:	c3 01       	movw	r24, r6
     944:	0c 96       	adiw	r24, 0x0c	; 12
     946:	0e 94 74 03 	call	0x6e8	; 0x6e8 <vListInitialiseItem>
     94a:	f3 01       	movw	r30, r6
     94c:	60 86       	std	Z+8, r6	; 0x08
     94e:	71 86       	std	Z+9, r7	; 0x09
     950:	84 e0       	ldi	r24, 0x04	; 4
     952:	90 e0       	ldi	r25, 0x00	; 0
     954:	81 1b       	sub	r24, r17
     956:	91 09       	sbc	r25, r1
     958:	84 87       	std	Z+12, r24	; 0x0c
     95a:	95 87       	std	Z+13, r25	; 0x0d
     95c:	62 8a       	std	Z+18, r6	; 0x12
     95e:	73 8a       	std	Z+19, r7	; 0x13
     960:	a2 01       	movw	r20, r4
     962:	b4 01       	movw	r22, r8
     964:	c5 01       	movw	r24, r10
     966:	0e 94 c8 01 	call	0x390	; 0x390 <pxPortInitialiseStack>
     96a:	f3 01       	movw	r30, r6
     96c:	80 83       	st	Z, r24
     96e:	91 83       	std	Z+1, r25	; 0x01
     970:	e1 14       	cp	r14, r1
     972:	f1 04       	cpc	r15, r1
     974:	19 f0       	breq	.+6      	; 0x97c <xTaskGenericCreate+0xf0>
     976:	f7 01       	movw	r30, r14
     978:	60 82       	st	Z, r6
     97a:	71 82       	std	Z+1, r7	; 0x01
     97c:	0f b6       	in	r0, 0x3f	; 63
     97e:	f8 94       	cli
     980:	0f 92       	push	r0
     982:	80 91 d9 92 	lds	r24, 0x92D9
     986:	8f 5f       	subi	r24, 0xFF	; 255
     988:	80 93 d9 92 	sts	0x92D9, r24
     98c:	80 91 27 93 	lds	r24, 0x9327
     990:	90 91 28 93 	lds	r25, 0x9328
     994:	89 2b       	or	r24, r25
     996:	a9 f5       	brne	.+106    	; 0xa02 <xTaskGenericCreate+0x176>
     998:	60 92 27 93 	sts	0x9327, r6
     99c:	70 92 28 93 	sts	0x9328, r7
     9a0:	80 91 d9 92 	lds	r24, 0x92D9
     9a4:	81 30       	cpi	r24, 0x01	; 1
     9a6:	e1 f5       	brne	.+120    	; 0xa20 <xTaskGenericCreate+0x194>
     9a8:	83 e0       	ldi	r24, 0x03	; 3
     9aa:	93 e9       	ldi	r25, 0x93	; 147
     9ac:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9b0:	8c e0       	ldi	r24, 0x0C	; 12
     9b2:	93 e9       	ldi	r25, 0x93	; 147
     9b4:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9b8:	85 e1       	ldi	r24, 0x15	; 21
     9ba:	93 e9       	ldi	r25, 0x93	; 147
     9bc:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9c0:	8e e1       	ldi	r24, 0x1E	; 30
     9c2:	93 e9       	ldi	r25, 0x93	; 147
     9c4:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9c8:	8a ef       	ldi	r24, 0xFA	; 250
     9ca:	92 e9       	ldi	r25, 0x92	; 146
     9cc:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9d0:	81 ef       	ldi	r24, 0xF1	; 241
     9d2:	92 e9       	ldi	r25, 0x92	; 146
     9d4:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9d8:	84 ee       	ldi	r24, 0xE4	; 228
     9da:	92 e9       	ldi	r25, 0x92	; 146
     9dc:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9e0:	8b ed       	ldi	r24, 0xDB	; 219
     9e2:	92 e9       	ldi	r25, 0x92	; 146
     9e4:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9e8:	8a ef       	ldi	r24, 0xFA	; 250
     9ea:	92 e9       	ldi	r25, 0x92	; 146
     9ec:	80 93 ef 92 	sts	0x92EF, r24
     9f0:	90 93 f0 92 	sts	0x92F0, r25
     9f4:	81 ef       	ldi	r24, 0xF1	; 241
     9f6:	92 e9       	ldi	r25, 0x92	; 146
     9f8:	80 93 ed 92 	sts	0x92ED, r24
     9fc:	90 93 ee 92 	sts	0x92EE, r25
     a00:	0f c0       	rjmp	.+30     	; 0xa20 <xTaskGenericCreate+0x194>
     a02:	80 91 d5 92 	lds	r24, 0x92D5
     a06:	81 11       	cpse	r24, r1
     a08:	0b c0       	rjmp	.+22     	; 0xa20 <xTaskGenericCreate+0x194>
     a0a:	e0 91 27 93 	lds	r30, 0x9327
     a0e:	f0 91 28 93 	lds	r31, 0x9328
     a12:	86 89       	ldd	r24, Z+22	; 0x16
     a14:	08 17       	cp	r16, r24
     a16:	20 f0       	brcs	.+8      	; 0xa20 <xTaskGenericCreate+0x194>
     a18:	60 92 27 93 	sts	0x9327, r6
     a1c:	70 92 28 93 	sts	0x9328, r7
     a20:	80 91 d1 92 	lds	r24, 0x92D1
     a24:	8f 5f       	subi	r24, 0xFF	; 255
     a26:	80 93 d1 92 	sts	0x92D1, r24
     a2a:	f3 01       	movw	r30, r6
     a2c:	81 a3       	std	Z+33, r24	; 0x21
     a2e:	86 89       	ldd	r24, Z+22	; 0x16
     a30:	90 91 d6 92 	lds	r25, 0x92D6
     a34:	98 17       	cp	r25, r24
     a36:	10 f4       	brcc	.+4      	; 0xa3c <xTaskGenericCreate+0x1b0>
     a38:	80 93 d6 92 	sts	0x92D6, r24
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	9c 01       	movw	r18, r24
     a40:	22 0f       	add	r18, r18
     a42:	33 1f       	adc	r19, r19
     a44:	22 0f       	add	r18, r18
     a46:	33 1f       	adc	r19, r19
     a48:	22 0f       	add	r18, r18
     a4a:	33 1f       	adc	r19, r19
     a4c:	82 0f       	add	r24, r18
     a4e:	93 1f       	adc	r25, r19
     a50:	be 01       	movw	r22, r28
     a52:	8d 5f       	subi	r24, 0xFD	; 253
     a54:	9c 46       	sbci	r25, 0x6C	; 108
     a56:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vListInsertEnd>
     a5a:	0f 90       	pop	r0
     a5c:	0f be       	out	0x3f, r0	; 63
     a5e:	80 91 d5 92 	lds	r24, 0x92D5
     a62:	88 23       	and	r24, r24
     a64:	59 f0       	breq	.+22     	; 0xa7c <xTaskGenericCreate+0x1f0>
     a66:	e0 91 27 93 	lds	r30, 0x9327
     a6a:	f0 91 28 93 	lds	r31, 0x9328
     a6e:	86 89       	ldd	r24, Z+22	; 0x16
     a70:	80 17       	cp	r24, r16
     a72:	30 f4       	brcc	.+12     	; 0xa80 <xTaskGenericCreate+0x1f4>
     a74:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYield>
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	0a c0       	rjmp	.+20     	; 0xa90 <xTaskGenericCreate+0x204>
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	08 c0       	rjmp	.+16     	; 0xa90 <xTaskGenericCreate+0x204>
     a80:	81 e0       	ldi	r24, 0x01	; 1
     a82:	06 c0       	rjmp	.+12     	; 0xa90 <xTaskGenericCreate+0x204>
     a84:	fc 01       	movw	r30, r24
     a86:	c7 8a       	std	Z+23, r12	; 0x17
     a88:	d0 8e       	std	Z+24, r13	; 0x18
     a8a:	c6 01       	movw	r24, r12
     a8c:	2b cf       	rjmp	.-426    	; 0x8e4 <xTaskGenericCreate+0x58>
     a8e:	8f ef       	ldi	r24, 0xFF	; 255
     a90:	df 91       	pop	r29
     a92:	cf 91       	pop	r28
     a94:	1f 91       	pop	r17
     a96:	0f 91       	pop	r16
     a98:	ff 90       	pop	r15
     a9a:	ef 90       	pop	r14
     a9c:	df 90       	pop	r13
     a9e:	cf 90       	pop	r12
     aa0:	bf 90       	pop	r11
     aa2:	af 90       	pop	r10
     aa4:	9f 90       	pop	r9
     aa6:	8f 90       	pop	r8
     aa8:	7f 90       	pop	r7
     aaa:	6f 90       	pop	r6
     aac:	5f 90       	pop	r5
     aae:	4f 90       	pop	r4
     ab0:	08 95       	ret

00000ab2 <vTaskStartScheduler>:
     ab2:	af 92       	push	r10
     ab4:	bf 92       	push	r11
     ab6:	cf 92       	push	r12
     ab8:	df 92       	push	r13
     aba:	ef 92       	push	r14
     abc:	ff 92       	push	r15
     abe:	0f 93       	push	r16
     ac0:	a1 2c       	mov	r10, r1
     ac2:	b1 2c       	mov	r11, r1
     ac4:	c1 2c       	mov	r12, r1
     ac6:	d1 2c       	mov	r13, r1
     ac8:	e1 2c       	mov	r14, r1
     aca:	f1 2c       	mov	r15, r1
     acc:	00 e0       	ldi	r16, 0x00	; 0
     ace:	20 e0       	ldi	r18, 0x00	; 0
     ad0:	30 e0       	ldi	r19, 0x00	; 0
     ad2:	45 e5       	ldi	r20, 0x55	; 85
     ad4:	50 e0       	ldi	r21, 0x00	; 0
     ad6:	6c ea       	ldi	r22, 0xAC	; 172
     ad8:	72 e2       	ldi	r23, 0x22	; 34
     ada:	86 ee       	ldi	r24, 0xE6	; 230
     adc:	96 e0       	ldi	r25, 0x06	; 6
     ade:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
     ae2:	81 30       	cpi	r24, 0x01	; 1
     ae4:	49 f4       	brne	.+18     	; 0xaf8 <vTaskStartScheduler+0x46>
     ae6:	f8 94       	cli
     ae8:	80 93 d5 92 	sts	0x92D5, r24
     aec:	10 92 d7 92 	sts	0x92D7, r1
     af0:	10 92 d8 92 	sts	0x92D8, r1
     af4:	0e 94 36 02 	call	0x46c	; 0x46c <xPortStartScheduler>
     af8:	0f 91       	pop	r16
     afa:	ff 90       	pop	r15
     afc:	ef 90       	pop	r14
     afe:	df 90       	pop	r13
     b00:	cf 90       	pop	r12
     b02:	bf 90       	pop	r11
     b04:	af 90       	pop	r10
     b06:	08 95       	ret

00000b08 <vTaskSuspendAll>:
     b08:	80 91 d0 92 	lds	r24, 0x92D0
     b0c:	8f 5f       	subi	r24, 0xFF	; 255
     b0e:	80 93 d0 92 	sts	0x92D0, r24
     b12:	08 95       	ret

00000b14 <xTaskIncrementTick>:
     b14:	df 92       	push	r13
     b16:	ef 92       	push	r14
     b18:	ff 92       	push	r15
     b1a:	0f 93       	push	r16
     b1c:	1f 93       	push	r17
     b1e:	cf 93       	push	r28
     b20:	df 93       	push	r29
     b22:	80 91 d0 92 	lds	r24, 0x92D0
     b26:	81 11       	cpse	r24, r1
     b28:	9a c0       	rjmp	.+308    	; 0xc5e <xTaskIncrementTick+0x14a>
     b2a:	80 91 d7 92 	lds	r24, 0x92D7
     b2e:	90 91 d8 92 	lds	r25, 0x92D8
     b32:	01 96       	adiw	r24, 0x01	; 1
     b34:	80 93 d7 92 	sts	0x92D7, r24
     b38:	90 93 d8 92 	sts	0x92D8, r25
     b3c:	e0 90 d7 92 	lds	r14, 0x92D7
     b40:	f0 90 d8 92 	lds	r15, 0x92D8
     b44:	e1 14       	cp	r14, r1
     b46:	f1 04       	cpc	r15, r1
     b48:	b9 f4       	brne	.+46     	; 0xb78 <xTaskIncrementTick+0x64>
     b4a:	80 91 ef 92 	lds	r24, 0x92EF
     b4e:	90 91 f0 92 	lds	r25, 0x92F0
     b52:	20 91 ed 92 	lds	r18, 0x92ED
     b56:	30 91 ee 92 	lds	r19, 0x92EE
     b5a:	20 93 ef 92 	sts	0x92EF, r18
     b5e:	30 93 f0 92 	sts	0x92F0, r19
     b62:	80 93 ed 92 	sts	0x92ED, r24
     b66:	90 93 ee 92 	sts	0x92EE, r25
     b6a:	80 91 d2 92 	lds	r24, 0x92D2
     b6e:	8f 5f       	subi	r24, 0xFF	; 255
     b70:	80 93 d2 92 	sts	0x92D2, r24
     b74:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvResetNextTaskUnblockTime>
     b78:	80 91 89 22 	lds	r24, 0x2289
     b7c:	90 91 8a 22 	lds	r25, 0x228A
     b80:	e8 16       	cp	r14, r24
     b82:	f9 06       	cpc	r15, r25
     b84:	10 f4       	brcc	.+4      	; 0xb8a <xTaskIncrementTick+0x76>
     b86:	d1 2c       	mov	r13, r1
     b88:	52 c0       	rjmp	.+164    	; 0xc2e <xTaskIncrementTick+0x11a>
     b8a:	d1 2c       	mov	r13, r1
     b8c:	e0 91 ef 92 	lds	r30, 0x92EF
     b90:	f0 91 f0 92 	lds	r31, 0x92F0
     b94:	90 81       	ld	r25, Z
     b96:	91 11       	cpse	r25, r1
     b98:	07 c0       	rjmp	.+14     	; 0xba8 <xTaskIncrementTick+0x94>
     b9a:	8f ef       	ldi	r24, 0xFF	; 255
     b9c:	9f ef       	ldi	r25, 0xFF	; 255
     b9e:	80 93 89 22 	sts	0x2289, r24
     ba2:	90 93 8a 22 	sts	0x228A, r25
     ba6:	43 c0       	rjmp	.+134    	; 0xc2e <xTaskIncrementTick+0x11a>
     ba8:	e0 91 ef 92 	lds	r30, 0x92EF
     bac:	f0 91 f0 92 	lds	r31, 0x92F0
     bb0:	05 80       	ldd	r0, Z+5	; 0x05
     bb2:	f6 81       	ldd	r31, Z+6	; 0x06
     bb4:	e0 2d       	mov	r30, r0
     bb6:	c6 81       	ldd	r28, Z+6	; 0x06
     bb8:	d7 81       	ldd	r29, Z+7	; 0x07
     bba:	2a 81       	ldd	r18, Y+2	; 0x02
     bbc:	3b 81       	ldd	r19, Y+3	; 0x03
     bbe:	e2 16       	cp	r14, r18
     bc0:	f3 06       	cpc	r15, r19
     bc2:	28 f4       	brcc	.+10     	; 0xbce <xTaskIncrementTick+0xba>
     bc4:	20 93 89 22 	sts	0x2289, r18
     bc8:	30 93 8a 22 	sts	0x228A, r19
     bcc:	30 c0       	rjmp	.+96     	; 0xc2e <xTaskIncrementTick+0x11a>
     bce:	8e 01       	movw	r16, r28
     bd0:	0e 5f       	subi	r16, 0xFE	; 254
     bd2:	1f 4f       	sbci	r17, 0xFF	; 255
     bd4:	c8 01       	movw	r24, r16
     bd6:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     bda:	8c 89       	ldd	r24, Y+20	; 0x14
     bdc:	9d 89       	ldd	r25, Y+21	; 0x15
     bde:	89 2b       	or	r24, r25
     be0:	21 f0       	breq	.+8      	; 0xbea <xTaskIncrementTick+0xd6>
     be2:	ce 01       	movw	r24, r28
     be4:	0c 96       	adiw	r24, 0x0c	; 12
     be6:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     bea:	2e 89       	ldd	r18, Y+22	; 0x16
     bec:	80 91 d6 92 	lds	r24, 0x92D6
     bf0:	82 17       	cp	r24, r18
     bf2:	10 f4       	brcc	.+4      	; 0xbf8 <xTaskIncrementTick+0xe4>
     bf4:	20 93 d6 92 	sts	0x92D6, r18
     bf8:	30 e0       	ldi	r19, 0x00	; 0
     bfa:	c9 01       	movw	r24, r18
     bfc:	88 0f       	add	r24, r24
     bfe:	99 1f       	adc	r25, r25
     c00:	88 0f       	add	r24, r24
     c02:	99 1f       	adc	r25, r25
     c04:	88 0f       	add	r24, r24
     c06:	99 1f       	adc	r25, r25
     c08:	82 0f       	add	r24, r18
     c0a:	93 1f       	adc	r25, r19
     c0c:	b8 01       	movw	r22, r16
     c0e:	8d 5f       	subi	r24, 0xFD	; 253
     c10:	9c 46       	sbci	r25, 0x6C	; 108
     c12:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vListInsertEnd>
     c16:	e0 91 27 93 	lds	r30, 0x9327
     c1a:	f0 91 28 93 	lds	r31, 0x9328
     c1e:	9e 89       	ldd	r25, Y+22	; 0x16
     c20:	86 89       	ldd	r24, Z+22	; 0x16
     c22:	98 17       	cp	r25, r24
     c24:	08 f4       	brcc	.+2      	; 0xc28 <xTaskIncrementTick+0x114>
     c26:	b2 cf       	rjmp	.-156    	; 0xb8c <xTaskIncrementTick+0x78>
     c28:	dd 24       	eor	r13, r13
     c2a:	d3 94       	inc	r13
     c2c:	af cf       	rjmp	.-162    	; 0xb8c <xTaskIncrementTick+0x78>
     c2e:	e0 91 27 93 	lds	r30, 0x9327
     c32:	f0 91 28 93 	lds	r31, 0x9328
     c36:	86 89       	ldd	r24, Z+22	; 0x16
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	fc 01       	movw	r30, r24
     c3c:	ee 0f       	add	r30, r30
     c3e:	ff 1f       	adc	r31, r31
     c40:	ee 0f       	add	r30, r30
     c42:	ff 1f       	adc	r31, r31
     c44:	ee 0f       	add	r30, r30
     c46:	ff 1f       	adc	r31, r31
     c48:	8e 0f       	add	r24, r30
     c4a:	9f 1f       	adc	r25, r31
     c4c:	fc 01       	movw	r30, r24
     c4e:	ed 5f       	subi	r30, 0xFD	; 253
     c50:	fc 46       	sbci	r31, 0x6C	; 108
     c52:	80 81       	ld	r24, Z
     c54:	82 30       	cpi	r24, 0x02	; 2
     c56:	48 f0       	brcs	.+18     	; 0xc6a <xTaskIncrementTick+0x156>
     c58:	dd 24       	eor	r13, r13
     c5a:	d3 94       	inc	r13
     c5c:	06 c0       	rjmp	.+12     	; 0xc6a <xTaskIncrementTick+0x156>
     c5e:	80 91 d4 92 	lds	r24, 0x92D4
     c62:	8f 5f       	subi	r24, 0xFF	; 255
     c64:	80 93 d4 92 	sts	0x92D4, r24
     c68:	d1 2c       	mov	r13, r1
     c6a:	80 91 d3 92 	lds	r24, 0x92D3
     c6e:	88 23       	and	r24, r24
     c70:	11 f0       	breq	.+4      	; 0xc76 <xTaskIncrementTick+0x162>
     c72:	dd 24       	eor	r13, r13
     c74:	d3 94       	inc	r13
     c76:	8d 2d       	mov	r24, r13
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	1f 91       	pop	r17
     c7e:	0f 91       	pop	r16
     c80:	ff 90       	pop	r15
     c82:	ef 90       	pop	r14
     c84:	df 90       	pop	r13
     c86:	08 95       	ret

00000c88 <xTaskResumeAll>:
     c88:	df 92       	push	r13
     c8a:	ef 92       	push	r14
     c8c:	ff 92       	push	r15
     c8e:	0f 93       	push	r16
     c90:	1f 93       	push	r17
     c92:	cf 93       	push	r28
     c94:	df 93       	push	r29
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	0f 92       	push	r0
     c9c:	80 91 d0 92 	lds	r24, 0x92D0
     ca0:	81 50       	subi	r24, 0x01	; 1
     ca2:	80 93 d0 92 	sts	0x92D0, r24
     ca6:	80 91 d0 92 	lds	r24, 0x92D0
     caa:	81 11       	cpse	r24, r1
     cac:	62 c0       	rjmp	.+196    	; 0xd72 <xTaskResumeAll+0xea>
     cae:	80 91 d9 92 	lds	r24, 0x92D9
     cb2:	81 11       	cpse	r24, r1
     cb4:	33 c0       	rjmp	.+102    	; 0xd1c <xTaskResumeAll+0x94>
     cb6:	60 c0       	rjmp	.+192    	; 0xd78 <xTaskResumeAll+0xf0>
     cb8:	d7 01       	movw	r26, r14
     cba:	15 96       	adiw	r26, 0x05	; 5
     cbc:	ed 91       	ld	r30, X+
     cbe:	fc 91       	ld	r31, X
     cc0:	16 97       	sbiw	r26, 0x06	; 6
     cc2:	c6 81       	ldd	r28, Z+6	; 0x06
     cc4:	d7 81       	ldd	r29, Z+7	; 0x07
     cc6:	ce 01       	movw	r24, r28
     cc8:	0c 96       	adiw	r24, 0x0c	; 12
     cca:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     cce:	8e 01       	movw	r16, r28
     cd0:	0e 5f       	subi	r16, 0xFE	; 254
     cd2:	1f 4f       	sbci	r17, 0xFF	; 255
     cd4:	c8 01       	movw	r24, r16
     cd6:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     cda:	2e 89       	ldd	r18, Y+22	; 0x16
     cdc:	80 91 d6 92 	lds	r24, 0x92D6
     ce0:	82 17       	cp	r24, r18
     ce2:	10 f4       	brcc	.+4      	; 0xce8 <xTaskResumeAll+0x60>
     ce4:	20 93 d6 92 	sts	0x92D6, r18
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	c9 01       	movw	r24, r18
     cec:	88 0f       	add	r24, r24
     cee:	99 1f       	adc	r25, r25
     cf0:	88 0f       	add	r24, r24
     cf2:	99 1f       	adc	r25, r25
     cf4:	88 0f       	add	r24, r24
     cf6:	99 1f       	adc	r25, r25
     cf8:	82 0f       	add	r24, r18
     cfa:	93 1f       	adc	r25, r19
     cfc:	b8 01       	movw	r22, r16
     cfe:	8d 5f       	subi	r24, 0xFD	; 253
     d00:	9c 46       	sbci	r25, 0x6C	; 108
     d02:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vListInsertEnd>
     d06:	e0 91 27 93 	lds	r30, 0x9327
     d0a:	f0 91 28 93 	lds	r31, 0x9328
     d0e:	9e 89       	ldd	r25, Y+22	; 0x16
     d10:	86 89       	ldd	r24, Z+22	; 0x16
     d12:	98 17       	cp	r25, r24
     d14:	58 f0       	brcs	.+22     	; 0xd2c <xTaskResumeAll+0xa4>
     d16:	d0 92 d3 92 	sts	0x92D3, r13
     d1a:	08 c0       	rjmp	.+16     	; 0xd2c <xTaskResumeAll+0xa4>
     d1c:	0f 2e       	mov	r0, r31
     d1e:	f4 ee       	ldi	r31, 0xE4	; 228
     d20:	ef 2e       	mov	r14, r31
     d22:	f2 e9       	ldi	r31, 0x92	; 146
     d24:	ff 2e       	mov	r15, r31
     d26:	f0 2d       	mov	r31, r0
     d28:	dd 24       	eor	r13, r13
     d2a:	d3 94       	inc	r13
     d2c:	f7 01       	movw	r30, r14
     d2e:	80 81       	ld	r24, Z
     d30:	81 11       	cpse	r24, r1
     d32:	c2 cf       	rjmp	.-124    	; 0xcb8 <xTaskResumeAll+0x30>
     d34:	80 91 d4 92 	lds	r24, 0x92D4
     d38:	88 23       	and	r24, r24
     d3a:	99 f0       	breq	.+38     	; 0xd62 <xTaskResumeAll+0xda>
     d3c:	80 91 d4 92 	lds	r24, 0x92D4
     d40:	88 23       	and	r24, r24
     d42:	79 f0       	breq	.+30     	; 0xd62 <xTaskResumeAll+0xda>
     d44:	c1 e0       	ldi	r28, 0x01	; 1
     d46:	0e 94 8a 05 	call	0xb14	; 0xb14 <xTaskIncrementTick>
     d4a:	81 11       	cpse	r24, r1
     d4c:	c0 93 d3 92 	sts	0x92D3, r28
     d50:	80 91 d4 92 	lds	r24, 0x92D4
     d54:	81 50       	subi	r24, 0x01	; 1
     d56:	80 93 d4 92 	sts	0x92D4, r24
     d5a:	80 91 d4 92 	lds	r24, 0x92D4
     d5e:	81 11       	cpse	r24, r1
     d60:	f2 cf       	rjmp	.-28     	; 0xd46 <xTaskResumeAll+0xbe>
     d62:	80 91 d3 92 	lds	r24, 0x92D3
     d66:	81 30       	cpi	r24, 0x01	; 1
     d68:	31 f4       	brne	.+12     	; 0xd76 <xTaskResumeAll+0xee>
     d6a:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYield>
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	03 c0       	rjmp	.+6      	; 0xd78 <xTaskResumeAll+0xf0>
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	01 c0       	rjmp	.+2      	; 0xd78 <xTaskResumeAll+0xf0>
     d76:	80 e0       	ldi	r24, 0x00	; 0
     d78:	0f 90       	pop	r0
     d7a:	0f be       	out	0x3f, r0	; 63
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	ff 90       	pop	r15
     d86:	ef 90       	pop	r14
     d88:	df 90       	pop	r13
     d8a:	08 95       	ret

00000d8c <vTaskDelay>:
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	ec 01       	movw	r28, r24
     d92:	89 2b       	or	r24, r25
     d94:	b1 f0       	breq	.+44     	; 0xdc2 <vTaskDelay+0x36>
     d96:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
     d9a:	80 91 d7 92 	lds	r24, 0x92D7
     d9e:	90 91 d8 92 	lds	r25, 0x92D8
     da2:	c8 0f       	add	r28, r24
     da4:	d9 1f       	adc	r29, r25
     da6:	80 91 27 93 	lds	r24, 0x9327
     daa:	90 91 28 93 	lds	r25, 0x9328
     dae:	02 96       	adiw	r24, 0x02	; 2
     db0:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     db4:	ce 01       	movw	r24, r28
     db6:	0e 94 0f 04 	call	0x81e	; 0x81e <prvAddCurrentTaskToDelayedList>
     dba:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
     dbe:	81 11       	cpse	r24, r1
     dc0:	02 c0       	rjmp	.+4      	; 0xdc6 <vTaskDelay+0x3a>
     dc2:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYield>
     dc6:	df 91       	pop	r29
     dc8:	cf 91       	pop	r28
     dca:	08 95       	ret

00000dcc <prvIdleTask>:
     dcc:	0b ed       	ldi	r16, 0xDB	; 219
     dce:	12 e9       	ldi	r17, 0x92	; 146
     dd0:	29 c0       	rjmp	.+82     	; 0xe24 <prvIdleTask+0x58>
     dd2:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
     dd6:	d8 01       	movw	r26, r16
     dd8:	cc 91       	ld	r28, X
     dda:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
     dde:	cc 23       	and	r28, r28
     de0:	09 f1       	breq	.+66     	; 0xe24 <prvIdleTask+0x58>
     de2:	0f b6       	in	r0, 0x3f	; 63
     de4:	f8 94       	cli
     de6:	0f 92       	push	r0
     de8:	d8 01       	movw	r26, r16
     dea:	15 96       	adiw	r26, 0x05	; 5
     dec:	ed 91       	ld	r30, X+
     dee:	fc 91       	ld	r31, X
     df0:	16 97       	sbiw	r26, 0x06	; 6
     df2:	c6 81       	ldd	r28, Z+6	; 0x06
     df4:	d7 81       	ldd	r29, Z+7	; 0x07
     df6:	ce 01       	movw	r24, r28
     df8:	02 96       	adiw	r24, 0x02	; 2
     dfa:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     dfe:	80 91 d9 92 	lds	r24, 0x92D9
     e02:	81 50       	subi	r24, 0x01	; 1
     e04:	80 93 d9 92 	sts	0x92D9, r24
     e08:	80 91 da 92 	lds	r24, 0x92DA
     e0c:	81 50       	subi	r24, 0x01	; 1
     e0e:	80 93 da 92 	sts	0x92DA, r24
     e12:	0f 90       	pop	r0
     e14:	0f be       	out	0x3f, r0	; 63
     e16:	8f 89       	ldd	r24, Y+23	; 0x17
     e18:	98 8d       	ldd	r25, Y+24	; 0x18
     e1a:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
     e1e:	ce 01       	movw	r24, r28
     e20:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
     e24:	80 91 da 92 	lds	r24, 0x92DA
     e28:	81 11       	cpse	r24, r1
     e2a:	d3 cf       	rjmp	.-90     	; 0xdd2 <prvIdleTask+0x6>
     e2c:	fb cf       	rjmp	.-10     	; 0xe24 <prvIdleTask+0x58>

00000e2e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     e2e:	80 91 d0 92 	lds	r24, 0x92D0
     e32:	88 23       	and	r24, r24
     e34:	21 f0       	breq	.+8      	; 0xe3e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     e36:	81 e0       	ldi	r24, 0x01	; 1
     e38:	80 93 d3 92 	sts	0x92D3, r24
     e3c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     e3e:	10 92 d3 92 	sts	0x92D3, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     e42:	80 91 d6 92 	lds	r24, 0x92D6
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	fc 01       	movw	r30, r24
     e4a:	ee 0f       	add	r30, r30
     e4c:	ff 1f       	adc	r31, r31
     e4e:	ee 0f       	add	r30, r30
     e50:	ff 1f       	adc	r31, r31
     e52:	ee 0f       	add	r30, r30
     e54:	ff 1f       	adc	r31, r31
     e56:	8e 0f       	add	r24, r30
     e58:	9f 1f       	adc	r25, r31
     e5a:	fc 01       	movw	r30, r24
     e5c:	ed 5f       	subi	r30, 0xFD	; 253
     e5e:	fc 46       	sbci	r31, 0x6C	; 108
     e60:	80 81       	ld	r24, Z
     e62:	81 11       	cpse	r24, r1
     e64:	17 c0       	rjmp	.+46     	; 0xe94 <vTaskSwitchContext+0x66>
     e66:	80 91 d6 92 	lds	r24, 0x92D6
     e6a:	81 50       	subi	r24, 0x01	; 1
     e6c:	80 93 d6 92 	sts	0x92D6, r24
     e70:	80 91 d6 92 	lds	r24, 0x92D6
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	fc 01       	movw	r30, r24
     e78:	ee 0f       	add	r30, r30
     e7a:	ff 1f       	adc	r31, r31
     e7c:	ee 0f       	add	r30, r30
     e7e:	ff 1f       	adc	r31, r31
     e80:	ee 0f       	add	r30, r30
     e82:	ff 1f       	adc	r31, r31
     e84:	8e 0f       	add	r24, r30
     e86:	9f 1f       	adc	r25, r31
     e88:	fc 01       	movw	r30, r24
     e8a:	ed 5f       	subi	r30, 0xFD	; 253
     e8c:	fc 46       	sbci	r31, 0x6C	; 108
     e8e:	80 81       	ld	r24, Z
     e90:	88 23       	and	r24, r24
     e92:	49 f3       	breq	.-46     	; 0xe66 <vTaskSwitchContext+0x38>
     e94:	80 91 d6 92 	lds	r24, 0x92D6
     e98:	90 e0       	ldi	r25, 0x00	; 0
     e9a:	9c 01       	movw	r18, r24
     e9c:	22 0f       	add	r18, r18
     e9e:	33 1f       	adc	r19, r19
     ea0:	22 0f       	add	r18, r18
     ea2:	33 1f       	adc	r19, r19
     ea4:	22 0f       	add	r18, r18
     ea6:	33 1f       	adc	r19, r19
     ea8:	28 0f       	add	r18, r24
     eaa:	39 1f       	adc	r19, r25
     eac:	d9 01       	movw	r26, r18
     eae:	ad 5f       	subi	r26, 0xFD	; 253
     eb0:	bc 46       	sbci	r27, 0x6C	; 108
     eb2:	11 96       	adiw	r26, 0x01	; 1
     eb4:	ed 91       	ld	r30, X+
     eb6:	fc 91       	ld	r31, X
     eb8:	12 97       	sbiw	r26, 0x02	; 2
     eba:	02 80       	ldd	r0, Z+2	; 0x02
     ebc:	f3 81       	ldd	r31, Z+3	; 0x03
     ebe:	e0 2d       	mov	r30, r0
     ec0:	11 96       	adiw	r26, 0x01	; 1
     ec2:	ed 93       	st	X+, r30
     ec4:	fc 93       	st	X, r31
     ec6:	12 97       	sbiw	r26, 0x02	; 2
     ec8:	2a 5f       	subi	r18, 0xFA	; 250
     eca:	3c 46       	sbci	r19, 0x6C	; 108
     ecc:	e2 17       	cp	r30, r18
     ece:	f3 07       	cpc	r31, r19
     ed0:	29 f4       	brne	.+10     	; 0xedc <vTaskSwitchContext+0xae>
     ed2:	22 81       	ldd	r18, Z+2	; 0x02
     ed4:	33 81       	ldd	r19, Z+3	; 0x03
     ed6:	fd 01       	movw	r30, r26
     ed8:	21 83       	std	Z+1, r18	; 0x01
     eda:	32 83       	std	Z+2, r19	; 0x02
     edc:	fc 01       	movw	r30, r24
     ede:	ee 0f       	add	r30, r30
     ee0:	ff 1f       	adc	r31, r31
     ee2:	ee 0f       	add	r30, r30
     ee4:	ff 1f       	adc	r31, r31
     ee6:	ee 0f       	add	r30, r30
     ee8:	ff 1f       	adc	r31, r31
     eea:	8e 0f       	add	r24, r30
     eec:	9f 1f       	adc	r25, r31
     eee:	fc 01       	movw	r30, r24
     ef0:	ed 5f       	subi	r30, 0xFD	; 253
     ef2:	fc 46       	sbci	r31, 0x6C	; 108
     ef4:	01 80       	ldd	r0, Z+1	; 0x01
     ef6:	f2 81       	ldd	r31, Z+2	; 0x02
     ef8:	e0 2d       	mov	r30, r0
     efa:	86 81       	ldd	r24, Z+6	; 0x06
     efc:	97 81       	ldd	r25, Z+7	; 0x07
     efe:	80 93 27 93 	sts	0x9327, r24
     f02:	90 93 28 93 	sts	0x9328, r25
     f06:	08 95       	ret

00000f08 <USBThread>:
		temp ^= pixel_mask;
		break;
	}

	gfx_mono_put_byte(page, column, temp);
}
     f08:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
     f0c:	8b e8       	ldi	r24, 0x8B	; 139
     f0e:	92 e2       	ldi	r25, 0x22	; 34
     f10:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <CDC_Device_USBTask>
     f14:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <USB_USBTask>
     f18:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
     f1c:	81 e0       	ldi	r24, 0x01	; 1
     f1e:	90 e0       	ldi	r25, 0x00	; 0
     f20:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vTaskDelay>
     f24:	f1 cf       	rjmp	.-30     	; 0xf08 <USBThread>

00000f26 <thread_2>:
     f26:	84 e6       	ldi	r24, 0x64	; 100
     f28:	90 e0       	ldi	r25, 0x00	; 0
     f2a:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vTaskDelay>
     f2e:	86 ea       	ldi	r24, 0xA6	; 166
     f30:	92 e2       	ldi	r25, 0x22	; 34
     f32:	0e 94 76 0a 	call	0x14ec	; 0x14ec <DigitalPin_ToggleValue>
     f36:	f7 cf       	rjmp	.-18     	; 0xf26 <thread_2>

00000f38 <thread_1>:
     f38:	84 ef       	ldi	r24, 0xF4	; 244
     f3a:	91 e0       	ldi	r25, 0x01	; 1
     f3c:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vTaskDelay>
     f40:	89 ea       	ldi	r24, 0xA9	; 169
     f42:	92 e2       	ldi	r25, 0x22	; 34
     f44:	0e 94 76 0a 	call	0x14ec	; 0x14ec <DigitalPin_ToggleValue>
     f48:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
     f4c:	29 e2       	ldi	r18, 0x29	; 41
     f4e:	33 e9       	ldi	r19, 0x93	; 147
     f50:	4a e0       	ldi	r20, 0x0A	; 10
     f52:	50 e0       	ldi	r21, 0x00	; 0
     f54:	61 e0       	ldi	r22, 0x01	; 1
     f56:	70 e0       	ldi	r23, 0x00	; 0
     f58:	81 eb       	ldi	r24, 0xB1	; 177
     f5a:	92 e2       	ldi	r25, 0x22	; 34
     f5c:	0e 94 a7 13 	call	0x274e	; 0x274e <fwrite>
     f60:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
     f64:	e9 cf       	rjmp	.-46     	; 0xf38 <thread_1>

00000f66 <usart_spi_transmit_receive>:
     f66:	fc 01       	movw	r30, r24
     f68:	81 81       	ldd	r24, Z+1	; 0x01
     f6a:	85 ff       	sbrs	r24, 5
     f6c:	fd cf       	rjmp	.-6      	; 0xf68 <usart_spi_transmit_receive+0x2>
     f6e:	60 83       	st	Z, r22
     f70:	81 81       	ldd	r24, Z+1	; 0x01
     f72:	86 ff       	sbrs	r24, 6
     f74:	fd cf       	rjmp	.-6      	; 0xf70 <usart_spi_transmit_receive+0xa>
     f76:	80 e4       	ldi	r24, 0x40	; 64
     f78:	81 83       	std	Z+1, r24	; 0x01
     f7a:	80 81       	ld	r24, Z
     f7c:	08 95       	ret

00000f7e <ssd1306_write_command>:
     f7e:	1f 93       	push	r17
     f80:	cf 93       	push	r28
     f82:	df 93       	push	r29
     f84:	c0 ea       	ldi	r28, 0xA0	; 160
     f86:	d6 e0       	ldi	r29, 0x06	; 6
     f88:	18 e0       	ldi	r17, 0x08	; 8
     f8a:	1e 83       	std	Y+6, r17	; 0x06
     f8c:	e0 e6       	ldi	r30, 0x60	; 96
     f8e:	f6 e0       	ldi	r31, 0x06	; 6
     f90:	91 e0       	ldi	r25, 0x01	; 1
     f92:	96 83       	std	Z+6, r25	; 0x06
     f94:	96 83       	std	Z+6, r25	; 0x06
     f96:	68 2f       	mov	r22, r24
     f98:	80 ea       	ldi	r24, 0xA0	; 160
     f9a:	99 e0       	ldi	r25, 0x09	; 9
     f9c:	0e 94 b3 07 	call	0xf66	; 0xf66 <usart_spi_transmit_receive>
     fa0:	1d 83       	std	Y+5, r17	; 0x05
     fa2:	df 91       	pop	r29
     fa4:	cf 91       	pop	r28
     fa6:	1f 91       	pop	r17
     fa8:	08 95       	ret

00000faa <ssd1306_write_data>:
     faa:	ef 92       	push	r14
     fac:	ff 92       	push	r15
     fae:	0f 93       	push	r16
     fb0:	1f 93       	push	r17
     fb2:	cf 93       	push	r28
     fb4:	df 93       	push	r29
     fb6:	c0 ea       	ldi	r28, 0xA0	; 160
     fb8:	d6 e0       	ldi	r29, 0x06	; 6
     fba:	18 e0       	ldi	r17, 0x08	; 8
     fbc:	1e 83       	std	Y+6, r17	; 0x06
     fbe:	0f 2e       	mov	r0, r31
     fc0:	f0 e6       	ldi	r31, 0x60	; 96
     fc2:	ef 2e       	mov	r14, r31
     fc4:	f6 e0       	ldi	r31, 0x06	; 6
     fc6:	ff 2e       	mov	r15, r31
     fc8:	f0 2d       	mov	r31, r0
     fca:	01 e0       	ldi	r16, 0x01	; 1
     fcc:	f7 01       	movw	r30, r14
     fce:	05 83       	std	Z+5, r16	; 0x05
     fd0:	68 2f       	mov	r22, r24
     fd2:	80 ea       	ldi	r24, 0xA0	; 160
     fd4:	99 e0       	ldi	r25, 0x09	; 9
     fd6:	0e 94 b3 07 	call	0xf66	; 0xf66 <usart_spi_transmit_receive>
     fda:	f7 01       	movw	r30, r14
     fdc:	06 83       	std	Z+6, r16	; 0x06
     fde:	1d 83       	std	Y+5, r17	; 0x05
     fe0:	df 91       	pop	r29
     fe2:	cf 91       	pop	r28
     fe4:	1f 91       	pop	r17
     fe6:	0f 91       	pop	r16
     fe8:	ff 90       	pop	r15
     fea:	ef 90       	pop	r14
     fec:	08 95       	ret

00000fee <ssd1306_set_page_address>:
     fee:	87 70       	andi	r24, 0x07	; 7
     ff0:	80 6b       	ori	r24, 0xB0	; 176
     ff2:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
     ff6:	08 95       	ret

00000ff8 <ssd1306_set_column_address>:
     ff8:	cf 93       	push	r28
     ffa:	c8 2f       	mov	r28, r24
     ffc:	98 2f       	mov	r25, r24
     ffe:	9f 77       	andi	r25, 0x7F	; 127
    1000:	89 2f       	mov	r24, r25
    1002:	82 95       	swap	r24
    1004:	8f 70       	andi	r24, 0x0F	; 15
    1006:	80 61       	ori	r24, 0x10	; 16
    1008:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    100c:	8c 2f       	mov	r24, r28
    100e:	8f 70       	andi	r24, 0x0F	; 15
    1010:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1014:	cf 91       	pop	r28
    1016:	08 95       	ret

00001018 <usart_init_spi>:
    1018:	cf 93       	push	r28
    101a:	df 93       	push	r29
    101c:	ec 01       	movw	r28, r24
    101e:	fb 01       	movw	r30, r22
    1020:	8c 81       	ldd	r24, Y+4	; 0x04
    1022:	8f 7e       	andi	r24, 0xEF	; 239
    1024:	8c 83       	std	Y+4, r24	; 0x04
    1026:	a0 e6       	ldi	r26, 0x60	; 96
    1028:	b6 e0       	ldi	r27, 0x06	; 6
    102a:	82 e0       	ldi	r24, 0x02	; 2
    102c:	11 96       	adiw	r26, 0x01	; 1
    102e:	8c 93       	st	X, r24
    1030:	11 97       	sbiw	r26, 0x01	; 1
    1032:	15 96       	adiw	r26, 0x05	; 5
    1034:	8c 93       	st	X, r24
    1036:	8d 81       	ldd	r24, Y+5	; 0x05
    1038:	80 6c       	ori	r24, 0xC0	; 192
    103a:	8d 83       	std	Y+5, r24	; 0x05
    103c:	84 81       	ldd	r24, Z+4	; 0x04
    103e:	8d 7f       	andi	r24, 0xFD	; 253
    1040:	81 30       	cpi	r24, 0x01	; 1
    1042:	21 f4       	brne	.+8      	; 0x104c <usart_init_spi+0x34>
    1044:	8d 81       	ldd	r24, Y+5	; 0x05
    1046:	82 60       	ori	r24, 0x02	; 2
    1048:	8d 83       	std	Y+5, r24	; 0x05
    104a:	03 c0       	rjmp	.+6      	; 0x1052 <usart_init_spi+0x3a>
    104c:	8d 81       	ldd	r24, Y+5	; 0x05
    104e:	8d 7f       	andi	r24, 0xFD	; 253
    1050:	8d 83       	std	Y+5, r24	; 0x05
    1052:	85 81       	ldd	r24, Z+5	; 0x05
    1054:	88 23       	and	r24, r24
    1056:	21 f0       	breq	.+8      	; 0x1060 <usart_init_spi+0x48>
    1058:	8d 81       	ldd	r24, Y+5	; 0x05
    105a:	84 60       	ori	r24, 0x04	; 4
    105c:	8d 83       	std	Y+5, r24	; 0x05
    105e:	03 c0       	rjmp	.+6      	; 0x1066 <usart_init_spi+0x4e>
    1060:	8d 81       	ldd	r24, Y+5	; 0x05
    1062:	8b 7f       	andi	r24, 0xFB	; 251
    1064:	8d 83       	std	Y+5, r24	; 0x05
    1066:	80 81       	ld	r24, Z
    1068:	91 81       	ldd	r25, Z+1	; 0x01
    106a:	a2 81       	ldd	r26, Z+2	; 0x02
    106c:	b3 81       	ldd	r27, Z+3	; 0x03
    106e:	9c 01       	movw	r18, r24
    1070:	ad 01       	movw	r20, r26
    1072:	22 0f       	add	r18, r18
    1074:	33 1f       	adc	r19, r19
    1076:	44 1f       	adc	r20, r20
    1078:	55 1f       	adc	r21, r21
    107a:	60 e0       	ldi	r22, 0x00	; 0
    107c:	78 e4       	ldi	r23, 0x48	; 72
    107e:	88 ee       	ldi	r24, 0xE8	; 232
    1080:	91 e0       	ldi	r25, 0x01	; 1
    1082:	0e 94 76 13 	call	0x26ec	; 0x26ec <__udivmodsi4>
    1086:	21 50       	subi	r18, 0x01	; 1
    1088:	31 09       	sbc	r19, r1
    108a:	83 2f       	mov	r24, r19
    108c:	8f 70       	andi	r24, 0x0F	; 15
    108e:	8f 83       	std	Y+7, r24	; 0x07
    1090:	2e 83       	std	Y+6, r18	; 0x06
    1092:	8c 81       	ldd	r24, Y+4	; 0x04
    1094:	88 60       	ori	r24, 0x08	; 8
    1096:	8c 83       	std	Y+4, r24	; 0x04
    1098:	df 91       	pop	r29
    109a:	cf 91       	pop	r28
    109c:	08 95       	ret

0000109e <ssd1306_init>:
    109e:	cf 93       	push	r28
    10a0:	df 93       	push	r29
    10a2:	00 d0       	rcall	.+0      	; 0x10a4 <ssd1306_init+0x6>
    10a4:	00 d0       	rcall	.+0      	; 0x10a6 <ssd1306_init+0x8>
    10a6:	cd b7       	in	r28, 0x3d	; 61
    10a8:	de b7       	in	r29, 0x3e	; 62
    10aa:	20 ea       	ldi	r18, 0xA0	; 160
    10ac:	36 e0       	ldi	r19, 0x06	; 6
    10ae:	88 e0       	ldi	r24, 0x08	; 8
    10b0:	d9 01       	movw	r26, r18
    10b2:	11 96       	adiw	r26, 0x01	; 1
    10b4:	8c 93       	st	X, r24
    10b6:	a0 e6       	ldi	r26, 0x60	; 96
    10b8:	b6 e0       	ldi	r27, 0x06	; 6
    10ba:	91 e0       	ldi	r25, 0x01	; 1
    10bc:	11 96       	adiw	r26, 0x01	; 1
    10be:	9c 93       	st	X, r25
    10c0:	11 97       	sbiw	r26, 0x01	; 1
    10c2:	e0 e0       	ldi	r30, 0x00	; 0
    10c4:	f6 e0       	ldi	r31, 0x06	; 6
    10c6:	81 83       	std	Z+1, r24	; 0x01
    10c8:	92 e0       	ldi	r25, 0x02	; 2
    10ca:	11 96       	adiw	r26, 0x01	; 1
    10cc:	9c 93       	st	X, r25
    10ce:	11 97       	sbiw	r26, 0x01	; 1
    10d0:	11 96       	adiw	r26, 0x01	; 1
    10d2:	8c 93       	st	X, r24
    10d4:	d9 01       	movw	r26, r18
    10d6:	15 96       	adiw	r26, 0x05	; 5
    10d8:	8c 93       	st	X, r24
    10da:	86 83       	std	Z+6, r24	; 0x06
    10dc:	ba e6       	ldi	r27, 0x6A	; 106
    10de:	ba 95       	dec	r27
    10e0:	f1 f7       	brne	.-4      	; 0x10de <ssd1306_init+0x40>
    10e2:	00 c0       	rjmp	.+0      	; 0x10e4 <ssd1306_init+0x46>
    10e4:	85 83       	std	Z+5, r24	; 0x05
    10e6:	ea e6       	ldi	r30, 0x6A	; 106
    10e8:	ea 95       	dec	r30
    10ea:	f1 f7       	brne	.-4      	; 0x10e8 <ssd1306_init+0x4a>
    10ec:	00 c0       	rjmp	.+0      	; 0x10ee <ssd1306_init+0x50>
    10ee:	e0 e7       	ldi	r30, 0x70	; 112
    10f0:	f0 e0       	ldi	r31, 0x00	; 0
    10f2:	84 81       	ldd	r24, Z+4	; 0x04
    10f4:	8f 7e       	andi	r24, 0xEF	; 239
    10f6:	84 83       	std	Z+4, r24	; 0x04
    10f8:	80 e0       	ldi	r24, 0x00	; 0
    10fa:	9b e1       	ldi	r25, 0x1B	; 27
    10fc:	a7 eb       	ldi	r26, 0xB7	; 183
    10fe:	b0 e0       	ldi	r27, 0x00	; 0
    1100:	89 83       	std	Y+1, r24	; 0x01
    1102:	9a 83       	std	Y+2, r25	; 0x02
    1104:	ab 83       	std	Y+3, r26	; 0x03
    1106:	bc 83       	std	Y+4, r27	; 0x04
    1108:	1d 82       	std	Y+5, r1	; 0x05
    110a:	1e 82       	std	Y+6, r1	; 0x06
    110c:	be 01       	movw	r22, r28
    110e:	6f 5f       	subi	r22, 0xFF	; 255
    1110:	7f 4f       	sbci	r23, 0xFF	; 255
    1112:	80 ea       	ldi	r24, 0xA0	; 160
    1114:	99 e0       	ldi	r25, 0x09	; 9
    1116:	0e 94 0c 08 	call	0x1018	; 0x1018 <usart_init_spi>
    111a:	88 ea       	ldi	r24, 0xA8	; 168
    111c:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1120:	8f e1       	ldi	r24, 0x1F	; 31
    1122:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1126:	83 ed       	ldi	r24, 0xD3	; 211
    1128:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    112c:	80 e0       	ldi	r24, 0x00	; 0
    112e:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1132:	80 e4       	ldi	r24, 0x40	; 64
    1134:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1138:	81 ea       	ldi	r24, 0xA1	; 161
    113a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    113e:	88 ec       	ldi	r24, 0xC8	; 200
    1140:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1144:	8a ed       	ldi	r24, 0xDA	; 218
    1146:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    114a:	82 e0       	ldi	r24, 0x02	; 2
    114c:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1150:	81 e8       	ldi	r24, 0x81	; 129
    1152:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1156:	8f e8       	ldi	r24, 0x8F	; 143
    1158:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    115c:	84 ea       	ldi	r24, 0xA4	; 164
    115e:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1162:	86 ea       	ldi	r24, 0xA6	; 166
    1164:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1168:	85 ed       	ldi	r24, 0xD5	; 213
    116a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    116e:	80 e8       	ldi	r24, 0x80	; 128
    1170:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1174:	8d e8       	ldi	r24, 0x8D	; 141
    1176:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    117a:	84 e1       	ldi	r24, 0x14	; 20
    117c:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1180:	8b ed       	ldi	r24, 0xDB	; 219
    1182:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1186:	80 e4       	ldi	r24, 0x40	; 64
    1188:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    118c:	89 ed       	ldi	r24, 0xD9	; 217
    118e:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1192:	81 ef       	ldi	r24, 0xF1	; 241
    1194:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    1198:	8f ea       	ldi	r24, 0xAF	; 175
    119a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
    119e:	26 96       	adiw	r28, 0x06	; 6
    11a0:	cd bf       	out	0x3d, r28	; 61
    11a2:	de bf       	out	0x3e, r29	; 62
    11a4:	df 91       	pop	r29
    11a6:	cf 91       	pop	r28
    11a8:	08 95       	ret

000011aa <ssd1306_write_text>:
    11aa:	ef 92       	push	r14
    11ac:	ff 92       	push	r15
    11ae:	0f 93       	push	r16
    11b0:	1f 93       	push	r17
    11b2:	cf 93       	push	r28
    11b4:	dc 01       	movw	r26, r24
    11b6:	ec 91       	ld	r30, X
    11b8:	ee 23       	and	r30, r30
    11ba:	29 f1       	breq	.+74     	; 0x1206 <ssd1306_write_text+0x5c>
    11bc:	7c 01       	movw	r14, r24
    11be:	bf ef       	ldi	r27, 0xFF	; 255
    11c0:	eb 1a       	sub	r14, r27
    11c2:	fb 0a       	sbc	r15, r27
    11c4:	ef 37       	cpi	r30, 0x7F	; 127
    11c6:	d0 f4       	brcc	.+52     	; 0x11fc <ssd1306_write_text+0x52>
    11c8:	f0 e0       	ldi	r31, 0x00	; 0
    11ca:	ee 0f       	add	r30, r30
    11cc:	ff 1f       	adc	r31, r31
    11ce:	e5 57       	subi	r30, 0x75	; 117
    11d0:	fe 4d       	sbci	r31, 0xDE	; 222
    11d2:	00 81       	ld	r16, Z
    11d4:	11 81       	ldd	r17, Z+1	; 0x01
    11d6:	f8 01       	movw	r30, r16
    11d8:	80 81       	ld	r24, Z
    11da:	88 23       	and	r24, r24
    11dc:	61 f0       	breq	.+24     	; 0x11f6 <ssd1306_write_text+0x4c>
    11de:	c1 e0       	ldi	r28, 0x01	; 1
    11e0:	f8 01       	movw	r30, r16
    11e2:	ec 0f       	add	r30, r28
    11e4:	f1 1d       	adc	r31, r1
    11e6:	80 81       	ld	r24, Z
    11e8:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ssd1306_write_data>
    11ec:	cf 5f       	subi	r28, 0xFF	; 255
    11ee:	d8 01       	movw	r26, r16
    11f0:	9c 91       	ld	r25, X
    11f2:	9c 17       	cp	r25, r28
    11f4:	a8 f7       	brcc	.-22     	; 0x11e0 <ssd1306_write_text+0x36>
    11f6:	80 e0       	ldi	r24, 0x00	; 0
    11f8:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ssd1306_write_data>
    11fc:	d7 01       	movw	r26, r14
    11fe:	ed 91       	ld	r30, X+
    1200:	7d 01       	movw	r14, r26
    1202:	e1 11       	cpse	r30, r1
    1204:	df cf       	rjmp	.-66     	; 0x11c4 <ssd1306_write_text+0x1a>
    1206:	cf 91       	pop	r28
    1208:	1f 91       	pop	r17
    120a:	0f 91       	pop	r16
    120c:	ff 90       	pop	r15
    120e:	ef 90       	pop	r14
    1210:	08 95       	ret

00001212 <gfx_mono_framebuffer_put_byte>:
    1212:	20 e8       	ldi	r18, 0x80	; 128
    1214:	82 9f       	mul	r24, r18
    1216:	c0 01       	movw	r24, r0
    1218:	11 24       	eor	r1, r1
    121a:	86 0f       	add	r24, r22
    121c:	91 1d       	adc	r25, r1
    121e:	e0 91 37 93 	lds	r30, 0x9337
    1222:	f0 91 38 93 	lds	r31, 0x9338
    1226:	e8 0f       	add	r30, r24
    1228:	f9 1f       	adc	r31, r25
    122a:	40 83       	st	Z, r20
    122c:	08 95       	ret

0000122e <gfx_mono_framebuffer_get_byte>:
    122e:	20 e8       	ldi	r18, 0x80	; 128
    1230:	82 9f       	mul	r24, r18
    1232:	c0 01       	movw	r24, r0
    1234:	11 24       	eor	r1, r1
    1236:	86 0f       	add	r24, r22
    1238:	91 1d       	adc	r25, r1
    123a:	e0 91 37 93 	lds	r30, 0x9337
    123e:	f0 91 38 93 	lds	r31, 0x9338
    1242:	e8 0f       	add	r30, r24
    1244:	f9 1f       	adc	r31, r25
    1246:	80 81       	ld	r24, Z
    1248:	08 95       	ret

0000124a <gfx_mono_ssd1306_put_byte>:
    124a:	1f 93       	push	r17
    124c:	cf 93       	push	r28
    124e:	df 93       	push	r29
    1250:	18 2f       	mov	r17, r24
    1252:	d6 2f       	mov	r29, r22
    1254:	c4 2f       	mov	r28, r20
    1256:	21 11       	cpse	r18, r1
    1258:	04 c0       	rjmp	.+8      	; 0x1262 <gfx_mono_ssd1306_put_byte+0x18>
    125a:	0e 94 17 09 	call	0x122e	; 0x122e <gfx_mono_framebuffer_get_byte>
    125e:	8c 17       	cp	r24, r28
    1260:	71 f0       	breq	.+28     	; 0x127e <gfx_mono_ssd1306_put_byte+0x34>
    1262:	4c 2f       	mov	r20, r28
    1264:	6d 2f       	mov	r22, r29
    1266:	81 2f       	mov	r24, r17
    1268:	0e 94 09 09 	call	0x1212	; 0x1212 <gfx_mono_framebuffer_put_byte>
    126c:	81 2f       	mov	r24, r17
    126e:	0e 94 f7 07 	call	0xfee	; 0xfee <ssd1306_set_page_address>
    1272:	8d 2f       	mov	r24, r29
    1274:	0e 94 fc 07 	call	0xff8	; 0xff8 <ssd1306_set_column_address>
    1278:	8c 2f       	mov	r24, r28
    127a:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ssd1306_write_data>
    127e:	df 91       	pop	r29
    1280:	cf 91       	pop	r28
    1282:	1f 91       	pop	r17
    1284:	08 95       	ret

00001286 <SetupHardware>:
}


/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
				  return false;

				switch (Source)
				{
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.PLLCTRL = (OSC_PLLSRC_RC2M_gc  | MulFactor);
    128a:	e0 e5       	ldi	r30, 0x50	; 80
    128c:	f0 e0       	ldi	r31, 0x00	; 0
    128e:	80 e1       	ldi	r24, 0x10	; 16
    1290:	85 83       	std	Z+5, r24	; 0x05
						break;
					default:
						return false;
				}

				OSC.CTRL |= OSC_PLLEN_bm;
    1292:	80 81       	ld	r24, Z
    1294:	80 61       	ori	r24, 0x10	; 16
    1296:	80 83       	st	Z, r24

				while (!(OSC.STATUS & OSC_PLLRDY_bm));
    1298:	81 81       	ldd	r24, Z+1	; 0x01
    129a:	84 ff       	sbrs	r24, 4
    129c:	fd cf       	rjmp	.-6      	; 0x1298 <SetupHardware+0x12>
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    129e:	8f b7       	in	r24, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    12a0:	f8 94       	cli
			 *  \param[in] Value    Value to write to the protected location
			 */
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value) ATTR_NON_NULL_PTR_ARG(1) ATTR_ALWAYS_INLINE;
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value)
			{
				__asm__ __volatile__ (
    12a2:	a0 e4       	ldi	r26, 0x40	; 64
    12a4:	b0 e0       	ldi	r27, 0x00	; 0
    12a6:	94 e0       	ldi	r25, 0x04	; 4
    12a8:	28 ed       	ldi	r18, 0xD8	; 216
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	1b be       	out	0x3b, r1	; 59
    12ae:	fd 01       	movw	r30, r26
    12b0:	24 bf       	out	0x34, r18	; 52
    12b2:	90 83       	st	Z, r25
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    12b4:	8f bf       	out	0x3f, r24	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    12b6:	8f e3       	ldi	r24, 0x3F	; 63
    12b8:	9f e1       	ldi	r25, 0x1F	; 31
    12ba:	01 97       	sbiw	r24, 0x01	; 1
    12bc:	f1 f7       	brne	.-4      	; 0x12ba <SetupHardware+0x34>
    12be:	00 c0       	rjmp	.+0      	; 0x12c0 <SetupHardware+0x3a>
    12c0:	00 00       	nop
				XMEGACLK_CCP_Write(&CLK.CTRL, ClockSourceMask);

				SetGlobalInterruptMask(CurrentGlobalInt);

				Delay_MS(1);
				return (CLK.CTRL == ClockSourceMask);
    12c2:	8c 91       	ld	r24, X
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.CTRL |= OSC_RC2MEN_bm;
						while (!(OSC.STATUS & OSC_RC2MRDY_bm));
						return true;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.CTRL |= OSC_RC32MEN_bm;
    12c4:	e0 e5       	ldi	r30, 0x50	; 80
    12c6:	f0 e0       	ldi	r31, 0x00	; 0
    12c8:	80 81       	ld	r24, Z
    12ca:	82 60       	ori	r24, 0x02	; 2
    12cc:	80 83       	st	Z, r24
						while (!(OSC.STATUS & OSC_RC32MRDY_bm));
    12ce:	81 81       	ldd	r24, Z+1	; 0x01
    12d0:	81 ff       	sbrs	r24, 1
    12d2:	fd cf       	rjmp	.-6      	; 0x12ce <SetupHardware+0x48>
						DFLLRC2M.COMP1  = (DFLLCompare & 0xFF);
						DFLLRC2M.COMP2  = (DFLLCompare >> 8);
						DFLLRC2M.CTRL   = DFLL_ENABLE_bm;
						break;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.DFLLCTRL   |= (Reference << OSC_RC32MCREF_gp);
    12d4:	e0 e5       	ldi	r30, 0x50	; 80
    12d6:	f0 e0       	ldi	r31, 0x00	; 0
    12d8:	86 81       	ldd	r24, Z+6	; 0x06
    12da:	84 60       	ori	r24, 0x04	; 4
    12dc:	86 83       	std	Z+6, r24	; 0x06
						DFLLRC32M.COMP1 = (DFLLCompare & 0xFF);
    12de:	a0 e6       	ldi	r26, 0x60	; 96
    12e0:	b0 e0       	ldi	r27, 0x00	; 0
    12e2:	8b e1       	ldi	r24, 0x1B	; 27
    12e4:	15 96       	adiw	r26, 0x05	; 5
    12e6:	8c 93       	st	X, r24
    12e8:	15 97       	sbiw	r26, 0x05	; 5
						DFLLRC32M.COMP2 = (DFLLCompare >> 8);
    12ea:	87 eb       	ldi	r24, 0xB7	; 183
    12ec:	16 96       	adiw	r26, 0x06	; 6
    12ee:	8c 93       	st	X, r24
    12f0:	16 97       	sbiw	r26, 0x06	; 6

						if (Reference == DFLL_REF_INT_USBSOF)
						{
							NVM.CMD        = NVM_CMD_READ_CALIB_ROW_gc;
    12f2:	c0 ec       	ldi	r28, 0xC0	; 192
    12f4:	d1 e0       	ldi	r29, 0x01	; 1
    12f6:	82 e0       	ldi	r24, 0x02	; 2
    12f8:	8a 87       	std	Y+10, r24	; 0x0a
							DFLLRC32M.CALA = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSCA));
    12fa:	ed e1       	ldi	r30, 0x1D	; 29
    12fc:	f0 e0       	ldi	r31, 0x00	; 0
    12fe:	e4 91       	lpm	r30, Z
    1300:	12 96       	adiw	r26, 0x02	; 2
    1302:	ec 93       	st	X, r30
    1304:	12 97       	sbiw	r26, 0x02	; 2
							DFLLRC32M.CALB = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSC));
    1306:	ec e1       	ldi	r30, 0x1C	; 28
    1308:	f0 e0       	ldi	r31, 0x00	; 0
    130a:	e4 91       	lpm	r30, Z
    130c:	13 96       	adiw	r26, 0x03	; 3
    130e:	ec 93       	st	X, r30
    1310:	13 97       	sbiw	r26, 0x03	; 3
							NVM.CMD        = 0;
    1312:	1a 86       	std	Y+10, r1	; 0x0a
						}

						DFLLRC32M.CTRL  = DFLL_ENABLE_bm;
    1314:	81 e0       	ldi	r24, 0x01	; 1
    1316:	8c 93       	st	X, r24

	/* Start the 32MHz internal RC oscillator and start the DFLL to increase it to 48MHz using the USB SOF as a reference */
	XMEGACLK_StartInternalOscillator(CLOCK_SRC_INT_RC32MHZ);
	XMEGACLK_StartDFLL(CLOCK_SRC_INT_RC32MHZ, DFLL_REF_INT_USBSOF, F_USB);

	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
    1318:	87 e0       	ldi	r24, 0x07	; 7
    131a:	80 93 a2 00 	sts	0x00A2, r24

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				PORTR.DIRSET    = LEDS_PORTR_LEDS;
    131e:	e0 ee       	ldi	r30, 0xE0	; 224
    1320:	f7 e0       	ldi	r31, 0x07	; 7
    1322:	83 e0       	ldi	r24, 0x03	; 3
    1324:	81 83       	std	Z+1, r24	; 0x01
				PORTR.OUTCLR    = LEDS_PORTR_LEDS;
    1326:	86 83       	std	Z+6, r24	; 0x06

				PORTCFG.MPCMASK = LEDS_PORTR_LEDS;
    1328:	80 93 b0 00 	sts	0x00B0, r24
				PORTR.PIN0CTRL  = PORT_INVEN_bm;
    132c:	80 e4       	ldi	r24, 0x40	; 64
    132e:	80 8b       	std	Z+16, r24	; 0x10

				PORTD.DIRSET    = LEDS_PORTD_LEDS;
    1330:	e0 e6       	ldi	r30, 0x60	; 96
    1332:	f6 e0       	ldi	r31, 0x06	; 6
    1334:	90 e3       	ldi	r25, 0x30	; 48
    1336:	91 83       	std	Z+1, r25	; 0x01
				PORTD.OUTCLR    = LEDS_PORTD_LEDS;
    1338:	96 83       	std	Z+6, r25	; 0x06

				PORTD.PIN4CTRL  = PORT_INVEN_bm;
    133a:	84 8b       	std	Z+20, r24	; 0x14
#endif

	/* Hardware Initialization */
	LEDs_Init();
	USB_Init();
    133c:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <USB_Init>
}
    1340:	df 91       	pop	r29
    1342:	cf 91       	pop	r28
    1344:	08 95       	ret

00001346 <main>:
 */
int main(void)
{

	
	SetupHardware();
    1346:	0e 94 43 09 	call	0x1286	; 0x1286 <SetupHardware>

	rtc_initialize();
    134a:	0e 94 13 13 	call	0x2626	; 0x2626 <rtc_initialize>
	gfx_mono_set_framebuffer(framebuffer);
\endcode
 */
void gfx_mono_set_framebuffer(uint8_t *framebuffer)
{
	fbpointer = framebuffer;
    134e:	89 e3       	ldi	r24, 0x39	; 57
    1350:	93 e9       	ldi	r25, 0x93	; 147
    1352:	80 93 37 93 	sts	0x9337, r24
    1356:	90 93 38 93 	sts	0x9338, r25
	uint8_t page;
	uint8_t column;

	gfx_mono_set_framebuffer(framebuffer);

	ssd1306_init();
    135a:	0e 94 4f 08 	call	0x109e	; 0x109e <ssd1306_init>
	asm("nop");
    135e:	00 00       	nop
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    1360:	d0 e0       	ldi	r29, 0x00	; 0
    1362:	0f c0       	rjmp	.+30     	; 0x1382 <main+0x3c>
	{
		for (col = 0; col < 128; ++col)
		{
			ssd1306_set_page_address(page);
    1364:	8d 2f       	mov	r24, r29
    1366:	0e 94 f7 07 	call	0xfee	; 0xfee <ssd1306_set_page_address>
			ssd1306_set_column_address(col);
    136a:	8c 2f       	mov	r24, r28
    136c:	0e 94 fc 07 	call	0xff8	; 0xff8 <ssd1306_set_column_address>
			ssd1306_write_data(0x00);
    1370:	80 e0       	ldi	r24, 0x00	; 0
    1372:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ssd1306_write_data>
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
	{
		for (col = 0; col < 128; ++col)
    1376:	cf 5f       	subi	r28, 0xFF	; 255
    1378:	c0 38       	cpi	r28, 0x80	; 128
    137a:	a1 f7       	brne	.-24     	; 0x1364 <main+0x1e>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    137c:	df 5f       	subi	r29, 0xFF	; 255
    137e:	d4 30       	cpi	r29, 0x04	; 4
    1380:	11 f0       	breq	.+4      	; 0x1386 <main+0x40>

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
    1382:	c0 e0       	ldi	r28, 0x00	; 0
    1384:	ef cf       	rjmp	.-34     	; 0x1364 <main+0x1e>
 */
static inline void ssd1306_set_display_start_line_address(uint8_t address)
{
	// Make sure address is 6 bits
	address &= 0x3F;
	ssd1306_write_command(SSD1306_CMD_SET_START_LINE(address));
    1386:	80 e4       	ldi	r24, 0x40	; 64
    1388:	0e 94 bf 07 	call	0xf7e	; 0xf7e <ssd1306_write_command>
	ssd1306_clear();

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    138c:	d0 e0       	ldi	r29, 0x00	; 0
    138e:	0c c0       	rjmp	.+24     	; 0x13a8 <main+0x62>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
    1390:	21 e0       	ldi	r18, 0x01	; 1
    1392:	40 e0       	ldi	r20, 0x00	; 0
    1394:	6c 2f       	mov	r22, r28
    1396:	8d 2f       	mov	r24, r29
    1398:	0e 94 25 09 	call	0x124a	; 0x124a <gfx_mono_ssd1306_put_byte>

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    139c:	cf 5f       	subi	r28, 0xFF	; 255
    139e:	c0 38       	cpi	r28, 0x80	; 128
    13a0:	b9 f7       	brne	.-18     	; 0x1390 <main+0x4a>
	ssd1306_clear();

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    13a2:	df 5f       	subi	r29, 0xFF	; 255
    13a4:	d4 30       	cpi	r29, 0x04	; 4
    13a6:	11 f0       	breq	.+4      	; 0x13ac <main+0x66>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    13a8:	c0 e0       	ldi	r28, 0x00	; 0
    13aa:	f2 cf       	rjmp	.-28     	; 0x1390 <main+0x4a>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
		}
	}

	asm("nop");
    13ac:	00 00       	nop
	ssd1306_set_page_address(0);
    13ae:	80 e0       	ldi	r24, 0x00	; 0
    13b0:	0e 94 f7 07 	call	0xfee	; 0xfee <ssd1306_set_page_address>
	ssd1306_write_text("EMON");
    13b4:	8c eb       	ldi	r24, 0xBC	; 188
    13b6:	92 e2       	ldi	r25, 0x22	; 34
    13b8:	0e 94 d5 08 	call	0x11aa	; 0x11aa <ssd1306_write_text>



	DigitalPin_SetDIr(&led,1);
    13bc:	61 e0       	ldi	r22, 0x01	; 1
    13be:	89 ea       	ldi	r24, 0xA9	; 169
    13c0:	92 e2       	ldi	r25, 0x22	; 34
    13c2:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <DigitalPin_SetDIr>
	DigitalPin_SetDIr(&led2,1);
    13c6:	61 e0       	ldi	r22, 0x01	; 1
    13c8:	86 ea       	ldi	r24, 0xA6	; 166
    13ca:	92 e2       	ldi	r25, 0x22	; 34
    13cc:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <DigitalPin_SetDIr>
	//PORT_SetDirection(&PORTR,(1<<0));

	CLKSYS_Enable( OSC_RC32MEN_bm );
    13d0:	e0 e5       	ldi	r30, 0x50	; 80
    13d2:	f0 e0       	ldi	r31, 0x00	; 0
    13d4:	80 81       	ld	r24, Z
    13d6:	82 60       	ori	r24, 0x02	; 2
    13d8:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC32MRDY_bm ) == 0 );
    13da:	81 81       	ldd	r24, Z+1	; 0x01
    13dc:	81 ff       	sbrs	r24, 1
    13de:	fd cf       	rjmp	.-6      	; 0x13da <main+0x94>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    13e0:	81 e0       	ldi	r24, 0x01	; 1
    13e2:	0e 94 1d 0b 	call	0x163a	; 0x163a <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    13e6:	81 e0       	ldi	r24, 0x01	; 1
    13e8:	0e 94 13 0b 	call	0x1626	; 0x1626 <CLKSYS_Disable>

	char time_string[20];
	uint8_t rxData[33];


	PORTR.DIRSET = (1<<0);
    13ec:	e0 ee       	ldi	r30, 0xE0	; 224
    13ee:	f7 e0       	ldi	r31, 0x07	; 7
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	81 83       	std	Z+1, r24	; 0x01
	PORTR.DIRSET = (1<<1);
    13f4:	82 e0       	ldi	r24, 0x02	; 2
    13f6:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = (1<<4);
    13f8:	80 e1       	ldi	r24, 0x10	; 16
    13fa:	80 93 61 06 	sts	0x0661, r24


	CDC_Device_CreateStream(&VirtualSerial_CDC_Interface, &USBSerialStream);
    13fe:	69 e2       	ldi	r22, 0x29	; 41
    1400:	73 e9       	ldi	r23, 0x93	; 147
    1402:	8b e8       	ldi	r24, 0x8B	; 139
    1404:	92 e2       	ldi	r25, 0x22	; 34
    1406:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <CDC_Device_CreateStream>
				#if (ARCH == ARCH_AVR8)
				sei();
				#elif (ARCH == ARCH_UC3)
				__builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				sei();
    140a:	78 94       	sei
	//creating the threads
	//xTaskCreate(thread_1, (const char*) "t1", 100, NULL, tskIDLE_PRIORITY, NULL );
	//xTaskCreate(thread_2,(const char *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
	//
	
	xTaskCreate(thread_1,(signed portCHAR *) "t1", 100, NULL, tskIDLE_PRIORITY, NULL );
    140c:	a1 2c       	mov	r10, r1
    140e:	b1 2c       	mov	r11, r1
    1410:	c1 2c       	mov	r12, r1
    1412:	d1 2c       	mov	r13, r1
    1414:	e1 2c       	mov	r14, r1
    1416:	f1 2c       	mov	r15, r1
    1418:	00 e0       	ldi	r16, 0x00	; 0
    141a:	20 e0       	ldi	r18, 0x00	; 0
    141c:	30 e0       	ldi	r19, 0x00	; 0
    141e:	44 e6       	ldi	r20, 0x64	; 100
    1420:	50 e0       	ldi	r21, 0x00	; 0
    1422:	61 ec       	ldi	r22, 0xC1	; 193
    1424:	72 e2       	ldi	r23, 0x22	; 34
    1426:	8c e9       	ldi	r24, 0x9C	; 156
    1428:	97 e0       	ldi	r25, 0x07	; 7
    142a:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	xTaskCreate(thread_2,(signed portCHAR *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
    142e:	20 e0       	ldi	r18, 0x00	; 0
    1430:	30 e0       	ldi	r19, 0x00	; 0
    1432:	44 e6       	ldi	r20, 0x64	; 100
    1434:	50 e0       	ldi	r21, 0x00	; 0
    1436:	64 ec       	ldi	r22, 0xC4	; 196
    1438:	72 e2       	ldi	r23, 0x22	; 34
    143a:	83 e9       	ldi	r24, 0x93	; 147
    143c:	97 e0       	ldi	r25, 0x07	; 7
    143e:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	xTaskCreate(USBThread,(signed portCHAR *) "usb", 200, NULL, tskIDLE_PRIORITY, NULL );
    1442:	20 e0       	ldi	r18, 0x00	; 0
    1444:	30 e0       	ldi	r19, 0x00	; 0
    1446:	48 ec       	ldi	r20, 0xC8	; 200
    1448:	50 e0       	ldi	r21, 0x00	; 0
    144a:	67 ec       	ldi	r22, 0xC7	; 199
    144c:	72 e2       	ldi	r23, 0x22	; 34
    144e:	84 e8       	ldi	r24, 0x84	; 132
    1450:	97 e0       	ldi	r25, 0x07	; 7
    1452:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	

	//starting the scheduler
	vTaskStartScheduler();
    1456:	0e 94 59 05 	call	0xab2	; 0xab2 <vTaskStartScheduler>

	for (;;)
	{
// 		CDC_Device_USBTask(&VirtualSerial_CDC_Interface);
// 		USB_USBTask();
	}
    145a:	ff cf       	rjmp	.-2      	; 0x145a <main+0x114>

0000145c <EVENT_USB_Device_Connect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    145c:	83 e0       	ldi	r24, 0x03	; 3
    145e:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    1462:	80 e3       	ldi	r24, 0x30	; 48
    1464:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    1468:	82 e0       	ldi	r24, 0x02	; 2
    146a:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    146e:	80 e1       	ldi	r24, 0x10	; 16
    1470:	80 93 65 06 	sts	0x0665, r24
    1474:	08 95       	ret

00001476 <EVENT_USB_Device_Disconnect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    1476:	83 e0       	ldi	r24, 0x03	; 3
    1478:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    147c:	80 e3       	ldi	r24, 0x30	; 48
    147e:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    1482:	81 e0       	ldi	r24, 0x01	; 1
    1484:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    1488:	10 92 65 06 	sts	0x0665, r1
    148c:	08 95       	ret

0000148e <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= CDC_Device_ConfigureEndpoints(&VirtualSerial_CDC_Interface);
    148e:	8b e8       	ldi	r24, 0x8B	; 139
    1490:	92 e2       	ldi	r25, 0x22	; 34
    1492:	0e 94 32 0b 	call	0x1664	; 0x1664 <CDC_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
    1496:	81 11       	cpse	r24, r1
    1498:	02 c0       	rjmp	.+4      	; 0x149e <EVENT_USB_Device_ConfigurationChanged+0x10>
    149a:	81 e1       	ldi	r24, 0x11	; 17
    149c:	01 c0       	rjmp	.+2      	; 0x14a0 <EVENT_USB_Device_ConfigurationChanged+0x12>
    149e:	82 e2       	ldi	r24, 0x22	; 34
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    14a0:	93 e0       	ldi	r25, 0x03	; 3
    14a2:	90 93 e6 07 	sts	0x07E6, r25
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    14a6:	90 e3       	ldi	r25, 0x30	; 48
    14a8:	90 93 66 06 	sts	0x0666, r25

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    14ac:	98 2f       	mov	r25, r24
    14ae:	93 70       	andi	r25, 0x03	; 3
    14b0:	90 93 e5 07 	sts	0x07E5, r25
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    14b4:	80 73       	andi	r24, 0x30	; 48
    14b6:	80 93 65 06 	sts	0x0665, r24
    14ba:	08 95       	ret

000014bc <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	CDC_Device_ProcessControlRequest(&VirtualSerial_CDC_Interface);
    14bc:	8b e8       	ldi	r24, 0x8B	; 139
    14be:	92 e2       	ldi	r25, 0x22	; 34
    14c0:	0e 94 8c 0c 	call	0x1918	; 0x1918 <CDC_Device_ProcessControlRequest>
    14c4:	08 95       	ret

000014c6 <EVENT_CDC_Device_ControLineStateChanged>:
 *  control lines sent from the host..
 *
 *  \param[in] CDCInterfaceInfo  Pointer to the CDC class interface configuration structure being referenced
 */
void EVENT_CDC_Device_ControLineStateChanged(USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo)
{
    14c6:	08 95       	ret

000014c8 <DigitalPin_SetDIr>:
void DigitalPin_SetValue(DigitalPin_t *pin){
	pin->_port->OUTSET = (1<< pin->_pin);
}

void DigitalPin_ClearValue(DigitalPin_t *pin){
	pin->_port->OUTCLR = (1<< pin->_pin);
    14c8:	66 23       	and	r22, r22
    14ca:	79 f0       	breq	.+30     	; 0x14ea <DigitalPin_SetDIr+0x22>
    14cc:	dc 01       	movw	r26, r24
    14ce:	ed 91       	ld	r30, X+
    14d0:	fc 91       	ld	r31, X
    14d2:	11 97       	sbiw	r26, 0x01	; 1
    14d4:	21 e0       	ldi	r18, 0x01	; 1
    14d6:	30 e0       	ldi	r19, 0x00	; 0
    14d8:	a9 01       	movw	r20, r18
    14da:	12 96       	adiw	r26, 0x02	; 2
    14dc:	0c 90       	ld	r0, X
    14de:	02 c0       	rjmp	.+4      	; 0x14e4 <DigitalPin_SetDIr+0x1c>
    14e0:	44 0f       	add	r20, r20
    14e2:	55 1f       	adc	r21, r21
    14e4:	0a 94       	dec	r0
    14e6:	e2 f7       	brpl	.-8      	; 0x14e0 <DigitalPin_SetDIr+0x18>
    14e8:	41 83       	std	Z+1, r20	; 0x01
    14ea:	08 95       	ret

000014ec <DigitalPin_ToggleValue>:
}

void DigitalPin_ToggleValue(DigitalPin_t *pin){
	pin->_port->OUTTGL = (1<< pin->_pin);
    14ec:	dc 01       	movw	r26, r24
    14ee:	ed 91       	ld	r30, X+
    14f0:	fc 91       	ld	r31, X
    14f2:	11 97       	sbiw	r26, 0x01	; 1
    14f4:	21 e0       	ldi	r18, 0x01	; 1
    14f6:	30 e0       	ldi	r19, 0x00	; 0
    14f8:	a9 01       	movw	r20, r18
    14fa:	12 96       	adiw	r26, 0x02	; 2
    14fc:	0c 90       	ld	r0, X
    14fe:	02 c0       	rjmp	.+4      	; 0x1504 <DigitalPin_ToggleValue+0x18>
    1500:	44 0f       	add	r20, r20
    1502:	55 1f       	adc	r21, r21
    1504:	0a 94       	dec	r0
    1506:	e2 f7       	brpl	.-8      	; 0x1500 <DigitalPin_ToggleValue+0x14>
    1508:	47 83       	std	Z+7, r20	; 0x07
    150a:	08 95       	ret

0000150c <__vector_25>:


}

#if defined(USARTC0)
ISR(USARTC0_RXC_vect){
    150c:	1f 92       	push	r1
    150e:	0f 92       	push	r0
    1510:	0f b6       	in	r0, 0x3f	; 63
    1512:	0f 92       	push	r0
    1514:	11 24       	eor	r1, r1

}
    1516:	0f 90       	pop	r0
    1518:	0f be       	out	0x3f, r0	; 63
    151a:	0f 90       	pop	r0
    151c:	1f 90       	pop	r1
    151e:	18 95       	reti

00001520 <__vector_27>:

ISR(USARTC0_TXC_vect){
    1520:	1f 92       	push	r1
    1522:	0f 92       	push	r0
    1524:	0f b6       	in	r0, 0x3f	; 63
    1526:	0f 92       	push	r0
    1528:	11 24       	eor	r1, r1
	
}
    152a:	0f 90       	pop	r0
    152c:	0f be       	out	0x3f, r0	; 63
    152e:	0f 90       	pop	r0
    1530:	1f 90       	pop	r1
    1532:	18 95       	reti

00001534 <__vector_26>:

ISR(USARTC0_DRE_vect){
    1534:	1f 92       	push	r1
    1536:	0f 92       	push	r0
    1538:	0f b6       	in	r0, 0x3f	; 63
    153a:	0f 92       	push	r0
    153c:	11 24       	eor	r1, r1
	
}
    153e:	0f 90       	pop	r0
    1540:	0f be       	out	0x3f, r0	; 63
    1542:	0f 90       	pop	r0
    1544:	1f 90       	pop	r1
    1546:	18 95       	reti

00001548 <__vector_28>:
#endif


#if defined(USARTC1)
ISR(USARTC1_RXC_vect){
    1548:	1f 92       	push	r1
    154a:	0f 92       	push	r0
    154c:	0f b6       	in	r0, 0x3f	; 63
    154e:	0f 92       	push	r0
    1550:	11 24       	eor	r1, r1
	
}
    1552:	0f 90       	pop	r0
    1554:	0f be       	out	0x3f, r0	; 63
    1556:	0f 90       	pop	r0
    1558:	1f 90       	pop	r1
    155a:	18 95       	reti

0000155c <__vector_30>:

ISR(USARTC1_TXC_vect){
    155c:	1f 92       	push	r1
    155e:	0f 92       	push	r0
    1560:	0f b6       	in	r0, 0x3f	; 63
    1562:	0f 92       	push	r0
    1564:	11 24       	eor	r1, r1
	
}
    1566:	0f 90       	pop	r0
    1568:	0f be       	out	0x3f, r0	; 63
    156a:	0f 90       	pop	r0
    156c:	1f 90       	pop	r1
    156e:	18 95       	reti

00001570 <__vector_29>:

ISR(USARTC1_DRE_vect){
    1570:	1f 92       	push	r1
    1572:	0f 92       	push	r0
    1574:	0f b6       	in	r0, 0x3f	; 63
    1576:	0f 92       	push	r0
    1578:	11 24       	eor	r1, r1
	
}
    157a:	0f 90       	pop	r0
    157c:	0f be       	out	0x3f, r0	; 63
    157e:	0f 90       	pop	r0
    1580:	1f 90       	pop	r1
    1582:	18 95       	reti

00001584 <__vector_88>:
#endif


#if defined(USARTD0)
ISR(USARTD0_RXC_vect){
    1584:	1f 92       	push	r1
    1586:	0f 92       	push	r0
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	0f 92       	push	r0
    158c:	11 24       	eor	r1, r1
	
}
    158e:	0f 90       	pop	r0
    1590:	0f be       	out	0x3f, r0	; 63
    1592:	0f 90       	pop	r0
    1594:	1f 90       	pop	r1
    1596:	18 95       	reti

00001598 <__vector_90>:

ISR(USARTD0_TXC_vect){
    1598:	1f 92       	push	r1
    159a:	0f 92       	push	r0
    159c:	0f b6       	in	r0, 0x3f	; 63
    159e:	0f 92       	push	r0
    15a0:	11 24       	eor	r1, r1
	
}
    15a2:	0f 90       	pop	r0
    15a4:	0f be       	out	0x3f, r0	; 63
    15a6:	0f 90       	pop	r0
    15a8:	1f 90       	pop	r1
    15aa:	18 95       	reti

000015ac <__vector_89>:

ISR(USARTD0_DRE_vect){
    15ac:	1f 92       	push	r1
    15ae:	0f 92       	push	r0
    15b0:	0f b6       	in	r0, 0x3f	; 63
    15b2:	0f 92       	push	r0
    15b4:	11 24       	eor	r1, r1
	
}
    15b6:	0f 90       	pop	r0
    15b8:	0f be       	out	0x3f, r0	; 63
    15ba:	0f 90       	pop	r0
    15bc:	1f 90       	pop	r1
    15be:	18 95       	reti

000015c0 <__vector_58>:
	
}
#endif

#if defined(USARTE0)
ISR(USARTE0_RXC_vect){
    15c0:	1f 92       	push	r1
    15c2:	0f 92       	push	r0
    15c4:	0f b6       	in	r0, 0x3f	; 63
    15c6:	0f 92       	push	r0
    15c8:	11 24       	eor	r1, r1
	
}
    15ca:	0f 90       	pop	r0
    15cc:	0f be       	out	0x3f, r0	; 63
    15ce:	0f 90       	pop	r0
    15d0:	1f 90       	pop	r1
    15d2:	18 95       	reti

000015d4 <__vector_60>:

ISR(USARTE0_TXC_vect){
    15d4:	1f 92       	push	r1
    15d6:	0f 92       	push	r0
    15d8:	0f b6       	in	r0, 0x3f	; 63
    15da:	0f 92       	push	r0
    15dc:	11 24       	eor	r1, r1
	
}
    15de:	0f 90       	pop	r0
    15e0:	0f be       	out	0x3f, r0	; 63
    15e2:	0f 90       	pop	r0
    15e4:	1f 90       	pop	r1
    15e6:	18 95       	reti

000015e8 <__vector_59>:

ISR(USARTE0_DRE_vect){
    15e8:	1f 92       	push	r1
    15ea:	0f 92       	push	r0
    15ec:	0f b6       	in	r0, 0x3f	; 63
    15ee:	0f 92       	push	r0
    15f0:	11 24       	eor	r1, r1
	
}
    15f2:	0f 90       	pop	r0
    15f4:	0f be       	out	0x3f, r0	; 63
    15f6:	0f 90       	pop	r0
    15f8:	1f 90       	pop	r1
    15fa:	18 95       	reti

000015fc <CCPWrite>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
    15fc:	0f 93       	push	r16
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	1f 92       	push	r1
    1604:	cd b7       	in	r28, 0x3d	; 61
    1606:	de b7       	in	r29, 0x3e	; 62
    1608:	2f b7       	in	r18, 0x3f	; 63
    160a:	29 83       	std	Y+1, r18	; 0x01
    160c:	f8 94       	cli
    160e:	1b be       	out	0x3b, r1	; 59
    1610:	fc 01       	movw	r30, r24
    1612:	08 ed       	ldi	r16, 0xD8	; 216
    1614:	04 bf       	out	0x34, r16	; 52
    1616:	60 83       	st	Z, r22
    1618:	89 81       	ldd	r24, Y+1	; 0x01
    161a:	8f bf       	out	0x3f, r24	; 63
    161c:	0f 90       	pop	r0
    161e:	df 91       	pop	r29
    1620:	cf 91       	pop	r28
    1622:	0f 91       	pop	r16
    1624:	08 95       	ret

00001626 <CLKSYS_Disable>:
    1626:	e0 e5       	ldi	r30, 0x50	; 80
    1628:	f0 e0       	ldi	r31, 0x00	; 0
    162a:	90 81       	ld	r25, Z
    162c:	28 2f       	mov	r18, r24
    162e:	20 95       	com	r18
    1630:	92 23       	and	r25, r18
    1632:	90 83       	st	Z, r25
    1634:	90 81       	ld	r25, Z
    1636:	89 23       	and	r24, r25
    1638:	08 95       	ret

0000163a <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    163a:	0f 93       	push	r16
    163c:	1f 93       	push	r17
    163e:	cf 93       	push	r28
    1640:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    1642:	00 e4       	ldi	r16, 0x40	; 64
    1644:	10 e0       	ldi	r17, 0x00	; 0
    1646:	f8 01       	movw	r30, r16
    1648:	60 81       	ld	r22, Z
    164a:	68 7f       	andi	r22, 0xF8	; 248
    164c:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    164e:	80 e4       	ldi	r24, 0x40	; 64
    1650:	90 e0       	ldi	r25, 0x00	; 0
    1652:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    1656:	f8 01       	movw	r30, r16
    1658:	80 81       	ld	r24, Z
	return clkCtrl;
}
    165a:	8c 23       	and	r24, r28
    165c:	cf 91       	pop	r28
    165e:	1f 91       	pop	r17
    1660:	0f 91       	pop	r16
    1662:	08 95       	ret

00001664 <CDC_Device_ConfigureEndpoints>:

void CDC_Device_CreateBlockingStream(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                                     FILE* const Stream)
{
	*Stream = (FILE)FDEV_SETUP_STREAM(CDC_Device_putchar, CDC_Device_getchar_Blocking, _FDEV_SETUP_RW);
	fdev_set_udata(Stream, CDCInterfaceInfo);
    1664:	cf 93       	push	r28
    1666:	df 93       	push	r29
    1668:	ec 01       	movw	r28, r24
    166a:	fc 01       	movw	r30, r24
    166c:	70 96       	adiw	r30, 0x10	; 16
    166e:	8b e0       	ldi	r24, 0x0B	; 11
    1670:	df 01       	movw	r26, r30
    1672:	1d 92       	st	X+, r1
    1674:	8a 95       	dec	r24
    1676:	e9 f7       	brne	.-6      	; 0x1672 <CDC_Device_ConfigureEndpoints+0xe>
    1678:	82 e0       	ldi	r24, 0x02	; 2
    167a:	8c 83       	std	Y+4, r24	; 0x04
    167c:	89 87       	std	Y+9, r24	; 0x09
    167e:	83 e0       	ldi	r24, 0x03	; 3
    1680:	8e 87       	std	Y+14, r24	; 0x0e
    1682:	61 e0       	ldi	r22, 0x01	; 1
    1684:	ce 01       	movw	r24, r28
    1686:	01 96       	adiw	r24, 0x01	; 1
    1688:	0e 94 28 11 	call	0x2250	; 0x2250 <Endpoint_ConfigureEndpointTable>
    168c:	88 23       	and	r24, r24
    168e:	61 f0       	breq	.+24     	; 0x16a8 <CDC_Device_ConfigureEndpoints+0x44>
    1690:	61 e0       	ldi	r22, 0x01	; 1
    1692:	ce 01       	movw	r24, r28
    1694:	06 96       	adiw	r24, 0x06	; 6
    1696:	0e 94 28 11 	call	0x2250	; 0x2250 <Endpoint_ConfigureEndpointTable>
    169a:	88 23       	and	r24, r24
    169c:	29 f0       	breq	.+10     	; 0x16a8 <CDC_Device_ConfigureEndpoints+0x44>
    169e:	61 e0       	ldi	r22, 0x01	; 1
    16a0:	ce 01       	movw	r24, r28
    16a2:	0b 96       	adiw	r24, 0x0b	; 11
    16a4:	0e 94 28 11 	call	0x2250	; 0x2250 <Endpoint_ConfigureEndpointTable>
    16a8:	df 91       	pop	r29
    16aa:	cf 91       	pop	r28
    16ac:	08 95       	ret

000016ae <CDC_Device_SendByte>:
    16ae:	cf 93       	push	r28
    16b0:	fc 01       	movw	r30, r24
    16b2:	90 91 3f 95 	lds	r25, 0x953F
    16b6:	94 30       	cpi	r25, 0x04	; 4
    16b8:	19 f5       	brne	.+70     	; 0x1700 <CDC_Device_SendByte+0x52>
    16ba:	84 89       	ldd	r24, Z+20	; 0x14
    16bc:	95 89       	ldd	r25, Z+21	; 0x15
    16be:	a6 89       	ldd	r26, Z+22	; 0x16
    16c0:	b7 89       	ldd	r27, Z+23	; 0x17
    16c2:	89 2b       	or	r24, r25
    16c4:	8a 2b       	or	r24, r26
    16c6:	8b 2b       	or	r24, r27
    16c8:	e9 f0       	breq	.+58     	; 0x1704 <CDC_Device_SendByte+0x56>
    16ca:	c6 2f       	mov	r28, r22
    16cc:	81 81       	ldd	r24, Z+1	; 0x01
    16ce:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
    16d2:	80 91 48 95 	lds	r24, 0x9548
    16d6:	90 91 49 95 	lds	r25, 0x9549
    16da:	fc 01       	movw	r30, r24
    16dc:	ef 5b       	subi	r30, 0xBF	; 191
    16de:	ff 4f       	sbci	r31, 0xFF	; 255
    16e0:	20 81       	ld	r18, Z
    16e2:	31 97       	sbiw	r30, 0x01	; 1
    16e4:	80 81       	ld	r24, Z
    16e6:	28 17       	cp	r18, r24
    16e8:	30 f0       	brcs	.+12     	; 0x16f6 <CDC_Device_SendByte+0x48>
    16ea:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>
    16ee:	0e 94 d7 11 	call	0x23ae	; 0x23ae <Endpoint_WaitUntilReady>
    16f2:	81 11       	cpse	r24, r1
    16f4:	08 c0       	rjmp	.+16     	; 0x1706 <CDC_Device_SendByte+0x58>
    16f6:	8c 2f       	mov	r24, r28
    16f8:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
    16fc:	80 e0       	ldi	r24, 0x00	; 0
    16fe:	03 c0       	rjmp	.+6      	; 0x1706 <CDC_Device_SendByte+0x58>
    1700:	82 e0       	ldi	r24, 0x02	; 2
    1702:	01 c0       	rjmp	.+2      	; 0x1706 <CDC_Device_SendByte+0x58>
    1704:	82 e0       	ldi	r24, 0x02	; 2
    1706:	cf 91       	pop	r28
    1708:	08 95       	ret

0000170a <CDC_Device_putchar>:
    170a:	fb 01       	movw	r30, r22
    170c:	68 2f       	mov	r22, r24
    170e:	84 85       	ldd	r24, Z+12	; 0x0c
    1710:	95 85       	ldd	r25, Z+13	; 0x0d
    1712:	0e 94 57 0b 	call	0x16ae	; 0x16ae <CDC_Device_SendByte>
    1716:	21 e0       	ldi	r18, 0x01	; 1
    1718:	30 e0       	ldi	r19, 0x00	; 0
    171a:	81 11       	cpse	r24, r1
    171c:	02 c0       	rjmp	.+4      	; 0x1722 <CDC_Device_putchar+0x18>
    171e:	20 e0       	ldi	r18, 0x00	; 0
    1720:	30 e0       	ldi	r19, 0x00	; 0
    1722:	88 27       	eor	r24, r24
    1724:	99 27       	eor	r25, r25
    1726:	82 1b       	sub	r24, r18
    1728:	93 0b       	sbc	r25, r19
    172a:	08 95       	ret

0000172c <CDC_Device_Flush>:
    172c:	cf 93       	push	r28
    172e:	df 93       	push	r29
    1730:	fc 01       	movw	r30, r24
    1732:	90 91 3f 95 	lds	r25, 0x953F
    1736:	94 30       	cpi	r25, 0x04	; 4
    1738:	f1 f5       	brne	.+124    	; 0x17b6 <CDC_Device_Flush+0x8a>
    173a:	84 89       	ldd	r24, Z+20	; 0x14
    173c:	95 89       	ldd	r25, Z+21	; 0x15
    173e:	a6 89       	ldd	r26, Z+22	; 0x16
    1740:	b7 89       	ldd	r27, Z+23	; 0x17
    1742:	89 2b       	or	r24, r25
    1744:	8a 2b       	or	r24, r26
    1746:	8b 2b       	or	r24, r27
    1748:	c1 f1       	breq	.+112    	; 0x17ba <CDC_Device_Flush+0x8e>
    174a:	81 81       	ldd	r24, Z+1	; 0x01
    174c:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
    1750:	80 91 4c 95 	lds	r24, 0x954C
    1754:	88 23       	and	r24, r24
    1756:	4c f4       	brge	.+18     	; 0x176a <CDC_Device_Flush+0x3e>
    1758:	e0 91 48 95 	lds	r30, 0x9548
    175c:	f0 91 49 95 	lds	r31, 0x9549
    1760:	ef 5b       	subi	r30, 0xBF	; 191
    1762:	ff 4f       	sbci	r31, 0xFF	; 255
    1764:	80 81       	ld	r24, Z
    1766:	90 e0       	ldi	r25, 0x00	; 0
    1768:	0d c0       	rjmp	.+26     	; 0x1784 <CDC_Device_Flush+0x58>
    176a:	20 91 48 95 	lds	r18, 0x9548
    176e:	30 91 49 95 	lds	r19, 0x9549
    1772:	f9 01       	movw	r30, r18
    1774:	e0 5c       	subi	r30, 0xC0	; 192
    1776:	ff 4f       	sbci	r31, 0xFF	; 255
    1778:	80 81       	ld	r24, Z
    177a:	31 96       	adiw	r30, 0x01	; 1
    177c:	20 81       	ld	r18, Z
    177e:	90 e0       	ldi	r25, 0x00	; 0
    1780:	82 1b       	sub	r24, r18
    1782:	91 09       	sbc	r25, r1
    1784:	89 2b       	or	r24, r25
    1786:	d9 f0       	breq	.+54     	; 0x17be <CDC_Device_Flush+0x92>
    1788:	80 91 48 95 	lds	r24, 0x9548
    178c:	90 91 49 95 	lds	r25, 0x9549
    1790:	fc 01       	movw	r30, r24
    1792:	ef 5b       	subi	r30, 0xBF	; 191
    1794:	ff 4f       	sbci	r31, 0xFF	; 255
    1796:	d0 81       	ld	r29, Z
    1798:	31 97       	sbiw	r30, 0x01	; 1
    179a:	c0 81       	ld	r28, Z
    179c:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>
    17a0:	dc 17       	cp	r29, r28
    17a2:	78 f0       	brcs	.+30     	; 0x17c2 <CDC_Device_Flush+0x96>
    17a4:	0e 94 d7 11 	call	0x23ae	; 0x23ae <Endpoint_WaitUntilReady>
    17a8:	c8 2f       	mov	r28, r24
    17aa:	81 11       	cpse	r24, r1
    17ac:	0c c0       	rjmp	.+24     	; 0x17c6 <CDC_Device_Flush+0x9a>
    17ae:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>
    17b2:	8c 2f       	mov	r24, r28
    17b4:	08 c0       	rjmp	.+16     	; 0x17c6 <CDC_Device_Flush+0x9a>
    17b6:	82 e0       	ldi	r24, 0x02	; 2
    17b8:	06 c0       	rjmp	.+12     	; 0x17c6 <CDC_Device_Flush+0x9a>
    17ba:	82 e0       	ldi	r24, 0x02	; 2
    17bc:	04 c0       	rjmp	.+8      	; 0x17c6 <CDC_Device_Flush+0x9a>
    17be:	80 e0       	ldi	r24, 0x00	; 0
    17c0:	02 c0       	rjmp	.+4      	; 0x17c6 <CDC_Device_Flush+0x9a>
    17c2:	80 e0       	ldi	r24, 0x00	; 0
    17c4:	00 c0       	rjmp	.+0      	; 0x17c6 <CDC_Device_Flush+0x9a>
    17c6:	df 91       	pop	r29
    17c8:	cf 91       	pop	r28
    17ca:	08 95       	ret

000017cc <CDC_Device_USBTask>:
    17cc:	cf 93       	push	r28
    17ce:	df 93       	push	r29
    17d0:	fc 01       	movw	r30, r24
    17d2:	90 91 3f 95 	lds	r25, 0x953F
    17d6:	94 30       	cpi	r25, 0x04	; 4
    17d8:	99 f4       	brne	.+38     	; 0x1800 <CDC_Device_USBTask+0x34>
    17da:	84 89       	ldd	r24, Z+20	; 0x14
    17dc:	95 89       	ldd	r25, Z+21	; 0x15
    17de:	a6 89       	ldd	r26, Z+22	; 0x16
    17e0:	b7 89       	ldd	r27, Z+23	; 0x17
    17e2:	89 2b       	or	r24, r25
    17e4:	8a 2b       	or	r24, r26
    17e6:	8b 2b       	or	r24, r27
    17e8:	59 f0       	breq	.+22     	; 0x1800 <CDC_Device_USBTask+0x34>
    17ea:	ef 01       	movw	r28, r30
    17ec:	81 81       	ldd	r24, Z+1	; 0x01
    17ee:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
    17f2:	0e 94 57 10 	call	0x20ae	; 0x20ae <Endpoint_IsINReady>
    17f6:	88 23       	and	r24, r24
    17f8:	19 f0       	breq	.+6      	; 0x1800 <CDC_Device_USBTask+0x34>
    17fa:	ce 01       	movw	r24, r28
    17fc:	0e 94 96 0b 	call	0x172c	; 0x172c <CDC_Device_Flush>
    1800:	df 91       	pop	r29
    1802:	cf 91       	pop	r28
    1804:	08 95       	ret

00001806 <CDC_Device_ReceiveByte>:
    1806:	cf 93       	push	r28
    1808:	df 93       	push	r29
    180a:	20 91 3f 95 	lds	r18, 0x953F
    180e:	24 30       	cpi	r18, 0x04	; 4
    1810:	09 f0       	breq	.+2      	; 0x1814 <CDC_Device_ReceiveByte+0xe>
    1812:	56 c0       	rjmp	.+172    	; 0x18c0 <CDC_Device_ReceiveByte+0xba>
    1814:	fc 01       	movw	r30, r24
    1816:	44 89       	ldd	r20, Z+20	; 0x14
    1818:	55 89       	ldd	r21, Z+21	; 0x15
    181a:	66 89       	ldd	r22, Z+22	; 0x16
    181c:	77 89       	ldd	r23, Z+23	; 0x17
    181e:	45 2b       	or	r20, r21
    1820:	46 2b       	or	r20, r22
    1822:	47 2b       	or	r20, r23
    1824:	09 f4       	brne	.+2      	; 0x1828 <CDC_Device_ReceiveByte+0x22>
    1826:	4f c0       	rjmp	.+158    	; 0x18c6 <CDC_Device_ReceiveByte+0xc0>
    1828:	86 81       	ldd	r24, Z+6	; 0x06
    182a:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
    182e:	0e 94 64 10 	call	0x20c8	; 0x20c8 <Endpoint_IsOUTReceived>
    1832:	88 23       	and	r24, r24
    1834:	09 f4       	brne	.+2      	; 0x1838 <CDC_Device_ReceiveByte+0x32>
    1836:	4a c0       	rjmp	.+148    	; 0x18cc <CDC_Device_ReceiveByte+0xc6>
    1838:	80 91 4c 95 	lds	r24, 0x954C
    183c:	88 23       	and	r24, r24
    183e:	4c f4       	brge	.+18     	; 0x1852 <CDC_Device_ReceiveByte+0x4c>
    1840:	e0 91 48 95 	lds	r30, 0x9548
    1844:	f0 91 49 95 	lds	r31, 0x9549
    1848:	ef 5b       	subi	r30, 0xBF	; 191
    184a:	ff 4f       	sbci	r31, 0xFF	; 255
    184c:	80 81       	ld	r24, Z
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	0d c0       	rjmp	.+26     	; 0x186c <CDC_Device_ReceiveByte+0x66>
    1852:	20 91 48 95 	lds	r18, 0x9548
    1856:	30 91 49 95 	lds	r19, 0x9549
    185a:	f9 01       	movw	r30, r18
    185c:	e0 5c       	subi	r30, 0xC0	; 192
    185e:	ff 4f       	sbci	r31, 0xFF	; 255
    1860:	80 81       	ld	r24, Z
    1862:	31 96       	adiw	r30, 0x01	; 1
    1864:	20 81       	ld	r18, Z
    1866:	90 e0       	ldi	r25, 0x00	; 0
    1868:	82 1b       	sub	r24, r18
    186a:	91 09       	sbc	r25, r1
    186c:	89 2b       	or	r24, r25
    186e:	29 f0       	breq	.+10     	; 0x187a <CDC_Device_ReceiveByte+0x74>
    1870:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Endpoint_Read_8>
    1874:	c8 2f       	mov	r28, r24
    1876:	d0 e0       	ldi	r29, 0x00	; 0
    1878:	02 c0       	rjmp	.+4      	; 0x187e <CDC_Device_ReceiveByte+0x78>
    187a:	cf ef       	ldi	r28, 0xFF	; 255
    187c:	df ef       	ldi	r29, 0xFF	; 255
    187e:	80 91 4c 95 	lds	r24, 0x954C
    1882:	88 23       	and	r24, r24
    1884:	4c f4       	brge	.+18     	; 0x1898 <CDC_Device_ReceiveByte+0x92>
    1886:	e0 91 48 95 	lds	r30, 0x9548
    188a:	f0 91 49 95 	lds	r31, 0x9549
    188e:	ef 5b       	subi	r30, 0xBF	; 191
    1890:	ff 4f       	sbci	r31, 0xFF	; 255
    1892:	20 81       	ld	r18, Z
    1894:	30 e0       	ldi	r19, 0x00	; 0
    1896:	0d c0       	rjmp	.+26     	; 0x18b2 <CDC_Device_ReceiveByte+0xac>
    1898:	40 91 48 95 	lds	r20, 0x9548
    189c:	50 91 49 95 	lds	r21, 0x9549
    18a0:	fa 01       	movw	r30, r20
    18a2:	e0 5c       	subi	r30, 0xC0	; 192
    18a4:	ff 4f       	sbci	r31, 0xFF	; 255
    18a6:	20 81       	ld	r18, Z
    18a8:	31 96       	adiw	r30, 0x01	; 1
    18aa:	80 81       	ld	r24, Z
    18ac:	30 e0       	ldi	r19, 0x00	; 0
    18ae:	28 1b       	sub	r18, r24
    18b0:	31 09       	sbc	r19, r1
    18b2:	23 2b       	or	r18, r19
    18b4:	71 f4       	brne	.+28     	; 0x18d2 <CDC_Device_ReceiveByte+0xcc>
    18b6:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <Endpoint_ClearOUT>
    18ba:	8c 2f       	mov	r24, r28
    18bc:	9d 2f       	mov	r25, r29
    18be:	0b c0       	rjmp	.+22     	; 0x18d6 <CDC_Device_ReceiveByte+0xd0>
    18c0:	8f ef       	ldi	r24, 0xFF	; 255
    18c2:	9f ef       	ldi	r25, 0xFF	; 255
    18c4:	08 c0       	rjmp	.+16     	; 0x18d6 <CDC_Device_ReceiveByte+0xd0>
    18c6:	8f ef       	ldi	r24, 0xFF	; 255
    18c8:	9f ef       	ldi	r25, 0xFF	; 255
    18ca:	05 c0       	rjmp	.+10     	; 0x18d6 <CDC_Device_ReceiveByte+0xd0>
    18cc:	8f ef       	ldi	r24, 0xFF	; 255
    18ce:	9f ef       	ldi	r25, 0xFF	; 255
    18d0:	02 c0       	rjmp	.+4      	; 0x18d6 <CDC_Device_ReceiveByte+0xd0>
    18d2:	8c 2f       	mov	r24, r28
    18d4:	9d 2f       	mov	r25, r29
    18d6:	df 91       	pop	r29
    18d8:	cf 91       	pop	r28
    18da:	08 95       	ret

000018dc <CDC_Device_getchar>:
    18dc:	fc 01       	movw	r30, r24
    18de:	84 85       	ldd	r24, Z+12	; 0x0c
    18e0:	95 85       	ldd	r25, Z+13	; 0x0d
    18e2:	0e 94 03 0c 	call	0x1806	; 0x1806 <CDC_Device_ReceiveByte>
    18e6:	99 23       	and	r25, r25
    18e8:	14 f4       	brge	.+4      	; 0x18ee <CDC_Device_getchar+0x12>
    18ea:	8e ef       	ldi	r24, 0xFE	; 254
    18ec:	9f ef       	ldi	r25, 0xFF	; 255
    18ee:	08 95       	ret

000018f0 <CDC_Device_CreateStream>:
    18f0:	fb 01       	movw	r30, r22
    18f2:	2e e0       	ldi	r18, 0x0E	; 14
    18f4:	db 01       	movw	r26, r22
    18f6:	1d 92       	st	X+, r1
    18f8:	2a 95       	dec	r18
    18fa:	e9 f7       	brne	.-6      	; 0x18f6 <CDC_Device_CreateStream+0x6>
    18fc:	23 e0       	ldi	r18, 0x03	; 3
    18fe:	23 83       	std	Z+3, r18	; 0x03
    1900:	25 e8       	ldi	r18, 0x85	; 133
    1902:	3b e0       	ldi	r19, 0x0B	; 11
    1904:	20 87       	std	Z+8, r18	; 0x08
    1906:	31 87       	std	Z+9, r19	; 0x09
    1908:	2e e6       	ldi	r18, 0x6E	; 110
    190a:	3c e0       	ldi	r19, 0x0C	; 12
    190c:	22 87       	std	Z+10, r18	; 0x0a
    190e:	33 87       	std	Z+11, r19	; 0x0b
    1910:	84 87       	std	Z+12, r24	; 0x0c
    1912:	95 87       	std	Z+13, r25	; 0x0d
    1914:	08 95       	ret

00001916 <CDC_Device_Event_Stub>:
	return ReceivedByte;
}
#endif

void CDC_Device_Event_Stub(void)
{
    1916:	08 95       	ret

00001918 <CDC_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_CDC_DRIVER
#define  __INCLUDE_FROM_CDC_DEVICE_C
#include "CDCClassDevice.h"

void CDC_Device_ProcessControlRequest(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    1918:	ff 92       	push	r15
    191a:	0f 93       	push	r16
    191c:	1f 93       	push	r17
    191e:	cf 93       	push	r28
    1920:	df 93       	push	r29
    1922:	ec 01       	movw	r28, r24
	if (!(Endpoint_IsSETUPReceived()))
    1924:	0e 94 7e 10 	call	0x20fc	; 0x20fc <Endpoint_IsSETUPReceived>
    1928:	88 23       	and	r24, r24
    192a:	09 f4       	brne	.+2      	; 0x192e <CDC_Device_ProcessControlRequest+0x16>
    192c:	9b c0       	rjmp	.+310    	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
	  return;

	if (USB_ControlRequest.wIndex != CDCInterfaceInfo->Config.ControlInterfaceNumber)
    192e:	28 81       	ld	r18, Y
    1930:	30 e0       	ldi	r19, 0x00	; 0
    1932:	80 91 44 95 	lds	r24, 0x9544
    1936:	90 91 45 95 	lds	r25, 0x9545
    193a:	82 17       	cp	r24, r18
    193c:	93 07       	cpc	r25, r19
    193e:	09 f0       	breq	.+2      	; 0x1942 <CDC_Device_ProcessControlRequest+0x2a>
    1940:	91 c0       	rjmp	.+290    	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
	  return;

	switch (USB_ControlRequest.bRequest)
    1942:	80 91 41 95 	lds	r24, 0x9541
    1946:	81 32       	cpi	r24, 0x21	; 33
    1948:	59 f0       	breq	.+22     	; 0x1960 <CDC_Device_ProcessControlRequest+0x48>
    194a:	18 f4       	brcc	.+6      	; 0x1952 <CDC_Device_ProcessControlRequest+0x3a>
    194c:	80 32       	cpi	r24, 0x20	; 32
    194e:	81 f1       	breq	.+96     	; 0x19b0 <CDC_Device_ProcessControlRequest+0x98>
    1950:	89 c0       	rjmp	.+274    	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
    1952:	82 32       	cpi	r24, 0x22	; 34
    1954:	09 f4       	brne	.+2      	; 0x1958 <CDC_Device_ProcessControlRequest+0x40>
    1956:	67 c0       	rjmp	.+206    	; 0x1a26 <CDC_Device_ProcessControlRequest+0x10e>
    1958:	83 32       	cpi	r24, 0x23	; 35
    195a:	09 f4       	brne	.+2      	; 0x195e <CDC_Device_ProcessControlRequest+0x46>
    195c:	76 c0       	rjmp	.+236    	; 0x1a4a <CDC_Device_ProcessControlRequest+0x132>
    195e:	82 c0       	rjmp	.+260    	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
	{
		case CDC_REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    1960:	80 91 40 95 	lds	r24, 0x9540
    1964:	81 3a       	cpi	r24, 0xA1	; 161
    1966:	09 f0       	breq	.+2      	; 0x196a <CDC_Device_ProcessControlRequest+0x52>
    1968:	7d c0       	rjmp	.+250    	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    196a:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>

				while (!(Endpoint_IsINReady()));
    196e:	0e 94 57 10 	call	0x20ae	; 0x20ae <Endpoint_IsINReady>
    1972:	88 23       	and	r24, r24
    1974:	e1 f3       	breq	.-8      	; 0x196e <CDC_Device_ProcessControlRequest+0x56>

				Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
    1976:	8c 89       	ldd	r24, Y+20	; 0x14
    1978:	fd 88       	ldd	r15, Y+21	; 0x15
    197a:	0e 89       	ldd	r16, Y+22	; 0x16
    197c:	1f 89       	ldd	r17, Y+23	; 0x17
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_32_LE(const uint32_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_32_LE(const uint32_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    197e:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    1982:	8f 2d       	mov	r24, r15
    1984:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 16);
    1988:	80 2f       	mov	r24, r16
    198a:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 24);
    198e:	81 2f       	mov	r24, r17
    1990:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
    1994:	88 8d       	ldd	r24, Y+24	; 0x18
    1996:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
    199a:	89 8d       	ldd	r24, Y+25	; 0x19
    199c:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
    19a0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19a2:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>

				Endpoint_ClearIN();
    19a6:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>
				Endpoint_ClearStatusStage();
    19aa:	0e 94 bc 11 	call	0x2378	; 0x2378 <Endpoint_ClearStatusStage>
    19ae:	5a c0       	rjmp	.+180    	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    19b0:	80 91 40 95 	lds	r24, 0x9540
    19b4:	81 32       	cpi	r24, 0x21	; 33
    19b6:	09 f0       	breq	.+2      	; 0x19ba <CDC_Device_ProcessControlRequest+0xa2>
    19b8:	55 c0       	rjmp	.+170    	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    19ba:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>

				while (!(Endpoint_IsOUTReceived()))
    19be:	05 c0       	rjmp	.+10     	; 0x19ca <CDC_Device_ProcessControlRequest+0xb2>
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    19c0:	80 91 3f 95 	lds	r24, 0x953F
    19c4:	88 23       	and	r24, r24
    19c6:	09 f4       	brne	.+2      	; 0x19ca <CDC_Device_ProcessControlRequest+0xb2>
    19c8:	4d c0       	rjmp	.+154    	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSETUP();

				while (!(Endpoint_IsOUTReceived()))
    19ca:	0e 94 64 10 	call	0x20c8	; 0x20c8 <Endpoint_IsOUTReceived>
    19ce:	88 23       	and	r24, r24
    19d0:	b9 f3       	breq	.-18     	; 0x19c0 <CDC_Device_ProcessControlRequest+0xa8>
			 *  \return Next four bytes in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
    19d2:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Endpoint_Read_8>
    19d6:	f8 2e       	mov	r15, r24
				uint32_t Byte1 = Endpoint_Read_8();
    19d8:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Endpoint_Read_8>
    19dc:	18 2f       	mov	r17, r24
				uint32_t Byte2 = Endpoint_Read_8();
    19de:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Endpoint_Read_8>
    19e2:	08 2f       	mov	r16, r24
				uint32_t Byte3 = Endpoint_Read_8();
    19e4:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Endpoint_Read_8>
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
				uint32_t Byte1 = Endpoint_Read_8();
				uint32_t Byte2 = Endpoint_Read_8();
    19e8:	40 2f       	mov	r20, r16
    19ea:	50 e0       	ldi	r21, 0x00	; 0
    19ec:	60 e0       	ldi	r22, 0x00	; 0
    19ee:	70 e0       	ldi	r23, 0x00	; 0
				uint32_t Byte3 = Endpoint_Read_8();

				return ((Byte3 << 24) | (Byte2 << 16) | (Byte1 << 8) | Byte0);
    19f0:	ba 01       	movw	r22, r20
    19f2:	55 27       	eor	r21, r21
    19f4:	44 27       	eor	r20, r20
    19f6:	78 2b       	or	r23, r24
    19f8:	4f 29       	or	r20, r15
    19fa:	51 2b       	or	r21, r17
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
					  return;
				}

				CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
    19fc:	4c 8b       	std	Y+20, r20	; 0x14
    19fe:	5d 8b       	std	Y+21, r21	; 0x15
    1a00:	6e 8b       	std	Y+22, r22	; 0x16
    1a02:	7f 8b       	std	Y+23, r23	; 0x17
				CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
    1a04:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Endpoint_Read_8>
    1a08:	88 8f       	std	Y+24, r24	; 0x18
				CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
    1a0a:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Endpoint_Read_8>
    1a0e:	89 8f       	std	Y+25, r24	; 0x19
				CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
    1a10:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Endpoint_Read_8>
    1a14:	8a 8f       	std	Y+26, r24	; 0x1a

				Endpoint_ClearOUT();
    1a16:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <Endpoint_ClearOUT>
				Endpoint_ClearStatusStage();
    1a1a:	0e 94 bc 11 	call	0x2378	; 0x2378 <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_LineEncodingChanged(CDCInterfaceInfo);
    1a1e:	ce 01       	movw	r24, r28
    1a20:	0e 94 8b 0c 	call	0x1916	; 0x1916 <CDC_Device_Event_Stub>
    1a24:	1f c0       	rjmp	.+62     	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SetControlLineState:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    1a26:	80 91 40 95 	lds	r24, 0x9540
    1a2a:	81 32       	cpi	r24, 0x21	; 33
    1a2c:	d9 f4       	brne	.+54     	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    1a2e:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    1a32:	0e 94 bc 11 	call	0x2378	; 0x2378 <Endpoint_ClearStatusStage>

				CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
    1a36:	80 91 42 95 	lds	r24, 0x9542
    1a3a:	90 91 43 95 	lds	r25, 0x9543
    1a3e:	88 8b       	std	Y+16, r24	; 0x10
    1a40:	99 8b       	std	Y+17, r25	; 0x11

				EVENT_CDC_Device_ControLineStateChanged(CDCInterfaceInfo);
    1a42:	ce 01       	movw	r24, r28
    1a44:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <EVENT_CDC_Device_ControLineStateChanged>
    1a48:	0d c0       	rjmp	.+26     	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SendBreak:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    1a4a:	80 91 40 95 	lds	r24, 0x9540
    1a4e:	81 32       	cpi	r24, 0x21	; 33
    1a50:	49 f4       	brne	.+18     	; 0x1a64 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    1a52:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    1a56:	0e 94 bc 11 	call	0x2378	; 0x2378 <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
    1a5a:	60 91 42 95 	lds	r22, 0x9542
    1a5e:	ce 01       	movw	r24, r28
    1a60:	0e 94 8b 0c 	call	0x1916	; 0x1916 <CDC_Device_Event_Stub>
			}

			break;
	}
}
    1a64:	df 91       	pop	r29
    1a66:	cf 91       	pop	r28
    1a68:	1f 91       	pop	r17
    1a6a:	0f 91       	pop	r16
    1a6c:	ff 90       	pop	r15
    1a6e:	08 95       	ret

00001a70 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1a70:	ef 92       	push	r14
    1a72:	ff 92       	push	r15
    1a74:	0f 93       	push	r16
    1a76:	1f 93       	push	r17
    1a78:	cf 93       	push	r28
    1a7a:	df 93       	push	r29
    1a7c:	cd b7       	in	r28, 0x3d	; 61
    1a7e:	de b7       	in	r29, 0x3e	; 62
    1a80:	ea 97       	sbiw	r28, 0x3a	; 58
    1a82:	cd bf       	out	0x3d, r28	; 61
    1a84:	de bf       	out	0x3e, r29	; 62
    1a86:	00 e4       	ldi	r16, 0x40	; 64
    1a88:	15 e9       	ldi	r17, 0x95	; 149
    1a8a:	0f 2e       	mov	r0, r31
    1a8c:	f8 e4       	ldi	r31, 0x48	; 72
    1a8e:	ef 2e       	mov	r14, r31
    1a90:	f5 e9       	ldi	r31, 0x95	; 149
    1a92:	ff 2e       	mov	r15, r31
    1a94:	f0 2d       	mov	r31, r0
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    1a96:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Endpoint_Read_8>
    1a9a:	f8 01       	movw	r30, r16
    1a9c:	81 93       	st	Z+, r24
    1a9e:	8f 01       	movw	r16, r30
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1aa0:	ee 15       	cp	r30, r14
    1aa2:	ff 05       	cpc	r31, r15
    1aa4:	c1 f7       	brne	.-16     	; 0x1a96 <USB_Device_ProcessControlRequest+0x26>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    1aa6:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <EVENT_USB_Device_ControlRequest>

	if (Endpoint_IsSETUPReceived())
    1aaa:	0e 94 7e 10 	call	0x20fc	; 0x20fc <Endpoint_IsSETUPReceived>
    1aae:	88 23       	and	r24, r24
    1ab0:	09 f4       	brne	.+2      	; 0x1ab4 <USB_Device_ProcessControlRequest+0x44>
    1ab2:	13 c1       	rjmp	.+550    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1ab4:	e0 e4       	ldi	r30, 0x40	; 64
    1ab6:	f5 e9       	ldi	r31, 0x95	; 149
    1ab8:	20 81       	ld	r18, Z

		switch (USB_ControlRequest.bRequest)
    1aba:	31 81       	ldd	r19, Z+1	; 0x01
    1abc:	83 2f       	mov	r24, r19
    1abe:	90 e0       	ldi	r25, 0x00	; 0
    1ac0:	8a 30       	cpi	r24, 0x0A	; 10
    1ac2:	91 05       	cpc	r25, r1
    1ac4:	08 f0       	brcs	.+2      	; 0x1ac8 <USB_Device_ProcessControlRequest+0x58>
    1ac6:	09 c1       	rjmp	.+530    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
    1ac8:	fc 01       	movw	r30, r24
    1aca:	88 27       	eor	r24, r24
    1acc:	e2 50       	subi	r30, 0x02	; 2
    1ace:	ff 4f       	sbci	r31, 0xFF	; 255
    1ad0:	8f 4f       	sbci	r24, 0xFF	; 255
    1ad2:	0c 94 98 13 	jmp	0x2730	; 0x2730 <__tablejump2__>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1ad6:	20 38       	cpi	r18, 0x80	; 128
    1ad8:	21 f0       	breq	.+8      	; 0x1ae2 <USB_Device_ProcessControlRequest+0x72>
    1ada:	22 38       	cpi	r18, 0x82	; 130
    1adc:	09 f0       	breq	.+2      	; 0x1ae0 <USB_Device_ProcessControlRequest+0x70>
    1ade:	fd c0       	rjmp	.+506    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
    1ae0:	08 c0       	rjmp	.+16     	; 0x1af2 <USB_Device_ProcessControlRequest+0x82>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    1ae2:	10 91 3c 95 	lds	r17, 0x953C
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    1ae6:	80 91 3d 95 	lds	r24, 0x953D
    1aea:	88 23       	and	r24, r24
    1aec:	91 f0       	breq	.+36     	; 0x1b12 <USB_Device_ProcessControlRequest+0xa2>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    1aee:	12 60       	ori	r17, 0x02	; 2
    1af0:	10 c0       	rjmp	.+32     	; 0x1b12 <USB_Device_ProcessControlRequest+0xa2>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1af2:	80 91 44 95 	lds	r24, 0x9544
    1af6:	8f 70       	andi	r24, 0x0F	; 15
    1af8:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    1afc:	e0 91 4a 95 	lds	r30, 0x954A
    1b00:	f0 91 4b 95 	lds	r31, 0x954B
    1b04:	11 81       	ldd	r17, Z+1	; 0x01
    1b06:	12 fb       	bst	r17, 2
    1b08:	11 27       	eor	r17, r17
    1b0a:	10 f9       	bld	r17, 0

			CurrentStatus = Endpoint_IsStalled();

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    1b0c:	80 e0       	ldi	r24, 0x00	; 0
    1b0e:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
			break;
		default:
			return;
	}

	Endpoint_ClearSETUP();
    1b12:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    1b16:	81 2f       	mov	r24, r17
    1b18:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    1b1c:	80 e0       	ldi	r24, 0x00	; 0
    1b1e:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();
    1b22:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>

	Endpoint_ClearStatusStage();
    1b26:	0e 94 bc 11 	call	0x2378	; 0x2378 <Endpoint_ClearStatusStage>
    1b2a:	d7 c0       	rjmp	.+430    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1b2c:	22 23       	and	r18, r18
    1b2e:	09 f4       	brne	.+2      	; 0x1b32 <USB_Device_ProcessControlRequest+0xc2>
    1b30:	dd c0       	rjmp	.+442    	; 0x1cec <USB_Device_ProcessControlRequest+0x27c>
    1b32:	22 30       	cpi	r18, 0x02	; 2
    1b34:	09 f0       	breq	.+2      	; 0x1b38 <USB_Device_ProcessControlRequest+0xc8>
    1b36:	d1 c0       	rjmp	.+418    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
    1b38:	de c0       	rjmp	.+444    	; 0x1cf6 <USB_Device_ProcessControlRequest+0x286>
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    1b3a:	81 e0       	ldi	r24, 0x01	; 1
    1b3c:	33 30       	cpi	r19, 0x03	; 3
    1b3e:	09 f0       	breq	.+2      	; 0x1b42 <USB_Device_ProcessControlRequest+0xd2>
    1b40:	80 e0       	ldi	r24, 0x00	; 0
    1b42:	80 93 3d 95 	sts	0x953D, r24
    1b46:	25 c0       	rjmp	.+74     	; 0x1b92 <USB_Device_ProcessControlRequest+0x122>
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1b48:	e0 91 44 95 	lds	r30, 0x9544
    1b4c:	1e 2f       	mov	r17, r30
    1b4e:	1f 70       	andi	r17, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    1b50:	09 f4       	brne	.+2      	; 0x1b54 <USB_Device_ProcessControlRequest+0xe4>
    1b52:	c3 c0       	rjmp	.+390    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
    1b54:	81 2f       	mov	r24, r17
    1b56:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>

				if (Endpoint_IsEnabled())
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    1b5a:	80 91 41 95 	lds	r24, 0x9541
    1b5e:	83 30       	cpi	r24, 0x03	; 3
    1b60:	19 f4       	brne	.+6      	; 0x1b68 <USB_Device_ProcessControlRequest+0xf8>
					{
						Endpoint_StallTransaction();
    1b62:	0e 94 c6 10 	call	0x218c	; 0x218c <Endpoint_StallTransaction>
    1b66:	15 c0       	rjmp	.+42     	; 0x1b92 <USB_Device_ProcessControlRequest+0x122>
			 *  \ingroup Group_EndpointPacketManagement_XMEGA
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				USB_Endpoint_SelectedHandle->CTRL &= ~USB_EP_STALL_bm;
    1b68:	e0 91 4a 95 	lds	r30, 0x954A
    1b6c:	f0 91 4b 95 	lds	r31, 0x954B
    1b70:	81 81       	ldd	r24, Z+1	; 0x01
    1b72:	8b 7f       	andi	r24, 0xFB	; 251
    1b74:	81 83       	std	Z+1, r24	; 0x01
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				if (Address & ENDPOINT_DIR_IN)
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].IN.Position  = 0;
				else
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].OUT.Position = 0;
    1b76:	24 e8       	ldi	r18, 0x84	; 132
    1b78:	12 9f       	mul	r17, r18
    1b7a:	f0 01       	movw	r30, r0
    1b7c:	11 24       	eor	r1, r1
    1b7e:	e2 57       	subi	r30, 0x72	; 114
    1b80:	fa 46       	sbci	r31, 0x6A	; 106
    1b82:	10 82       	st	Z, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				USB_Endpoint_SelectedHandle->STATUS &= ~USB_EP_TOGGLE_bm;
    1b84:	e0 91 4a 95 	lds	r30, 0x954A
    1b88:	f0 91 4b 95 	lds	r31, 0x954B
    1b8c:	80 81       	ld	r24, Z
    1b8e:	8e 7f       	andi	r24, 0xFE	; 254
    1b90:	80 83       	st	Z, r24
		#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    1b92:	80 e0       	ldi	r24, 0x00	; 0
    1b94:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>

	Endpoint_ClearSETUP();
    1b98:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    1b9c:	0e 94 bc 11 	call	0x2378	; 0x2378 <Endpoint_ClearStatusStage>
    1ba0:	9c c0       	rjmp	.+312    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    1ba2:	21 11       	cpse	r18, r1
    1ba4:	9a c0       	rjmp	.+308    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    1ba6:	10 91 42 95 	lds	r17, 0x9542
    1baa:	1f 77       	andi	r17, 0x7F	; 127

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();
    1bac:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    1bb0:	0e 94 bc 11 	call	0x2378	; 0x2378 <Endpoint_ClearStatusStage>

	while (!(Endpoint_IsINReady()));
    1bb4:	0e 94 57 10 	call	0x20ae	; 0x20ae <Endpoint_IsINReady>
    1bb8:	88 23       	and	r24, r24
    1bba:	e1 f3       	breq	.-8      	; 0x1bb4 <USB_Device_ProcessControlRequest+0x144>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    1bbc:	10 93 c3 04 	sts	0x04C3, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    1bc0:	11 11       	cpse	r17, r1
    1bc2:	02 c0       	rjmp	.+4      	; 0x1bc8 <USB_Device_ProcessControlRequest+0x158>
    1bc4:	82 e0       	ldi	r24, 0x02	; 2
    1bc6:	01 c0       	rjmp	.+2      	; 0x1bca <USB_Device_ProcessControlRequest+0x15a>
    1bc8:	83 e0       	ldi	r24, 0x03	; 3
    1bca:	80 93 3f 95 	sts	0x953F, r24
    1bce:	85 c0       	rjmp	.+266    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1bd0:	20 58       	subi	r18, 0x80	; 128
    1bd2:	22 30       	cpi	r18, 0x02	; 2
    1bd4:	08 f0       	brcs	.+2      	; 0x1bd8 <USB_Device_ProcessControlRequest+0x168>
    1bd6:	81 c0       	rjmp	.+258    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    1bd8:	80 91 42 95 	lds	r24, 0x9542
    1bdc:	90 91 43 95 	lds	r25, 0x9543
    1be0:	8c 3d       	cpi	r24, 0xDC	; 220
    1be2:	e3 e0       	ldi	r30, 0x03	; 3
    1be4:	9e 07       	cpc	r25, r30
    1be6:	b9 f5       	brne	.+110    	; 0x1c56 <USB_Device_ProcessControlRequest+0x1e6>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    1be8:	83 e0       	ldi	r24, 0x03	; 3
    1bea:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    1bec:	8a e3       	ldi	r24, 0x3A	; 58
    1bee:	89 83       	std	Y+1, r24	; 0x01
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    1bf0:	7f b7       	in	r23, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    1bf2:	f8 94       	cli
				#endif

				GCC_MEMORY_BARRIER();
    1bf4:	ae 01       	movw	r20, r28
    1bf6:	4d 5f       	subi	r20, 0xFD	; 253
    1bf8:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1bfa:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    1bfc:	38 e0       	ldi	r19, 0x08	; 8

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte;

					NVM.CMD    = NVM_CMD_READ_CALIB_ROW_gc;
    1bfe:	a0 ec       	ldi	r26, 0xC0	; 192
    1c00:	b1 e0       	ldi	r27, 0x01	; 1
    1c02:	62 e0       	ldi	r22, 0x02	; 2
    1c04:	1a 96       	adiw	r26, 0x0a	; 10
    1c06:	6c 93       	st	X, r22
    1c08:	1a 97       	sbiw	r26, 0x0a	; 10
					SerialByte = pgm_read_byte(SigReadAddress);
    1c0a:	e3 2f       	mov	r30, r19
    1c0c:	f0 e0       	ldi	r31, 0x00	; 0
    1c0e:	84 91       	lpm	r24, Z
					NVM.CMD    = 0;
    1c10:	1a 96       	adiw	r26, 0x0a	; 10
    1c12:	1c 92       	st	X, r1
    1c14:	1a 97       	sbiw	r26, 0x0a	; 10

					if (SerialCharNum & 0x01)
    1c16:	20 ff       	sbrs	r18, 0
    1c18:	03 c0       	rjmp	.+6      	; 0x1c20 <USB_Device_ProcessControlRequest+0x1b0>
					{
						SerialByte >>= 4;
    1c1a:	82 95       	swap	r24
    1c1c:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    1c1e:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    1c20:	8f 70       	andi	r24, 0x0F	; 15

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    1c22:	8a 30       	cpi	r24, 0x0A	; 10
    1c24:	18 f0       	brcs	.+6      	; 0x1c2c <USB_Device_ProcessControlRequest+0x1bc>
    1c26:	90 e0       	ldi	r25, 0x00	; 0
    1c28:	c7 96       	adiw	r24, 0x37	; 55
    1c2a:	02 c0       	rjmp	.+4      	; 0x1c30 <USB_Device_ProcessControlRequest+0x1c0>
    1c2c:	90 e0       	ldi	r25, 0x00	; 0
    1c2e:	c0 96       	adiw	r24, 0x30	; 48
    1c30:	fa 01       	movw	r30, r20
    1c32:	81 93       	st	Z+, r24
    1c34:	91 93       	st	Z+, r25
    1c36:	af 01       	movw	r20, r30
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1c38:	2f 5f       	subi	r18, 0xFF	; 255
    1c3a:	2c 31       	cpi	r18, 0x1C	; 28
    1c3c:	19 f7       	brne	.-58     	; 0x1c04 <USB_Device_ProcessControlRequest+0x194>
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    1c3e:	7f bf       	out	0x3f, r23	; 63

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();
    1c40:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    1c44:	6a e3       	ldi	r22, 0x3A	; 58
    1c46:	70 e0       	ldi	r23, 0x00	; 0
    1c48:	ce 01       	movw	r24, r28
    1c4a:	01 96       	adiw	r24, 0x01	; 1
    1c4c:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <Endpoint_Write_Control_Stream_LE>
	Endpoint_ClearOUT();
    1c50:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <Endpoint_ClearOUT>
    1c54:	42 c0       	rjmp	.+132    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    1c56:	ae 01       	movw	r20, r28
    1c58:	4f 5f       	subi	r20, 0xFF	; 255
    1c5a:	5f 4f       	sbci	r21, 0xFF	; 255
    1c5c:	60 91 44 95 	lds	r22, 0x9544
    1c60:	0e 94 8b 01 	call	0x316	; 0x316 <CALLBACK_USB_GetDescriptor>
    1c64:	8c 01       	movw	r16, r24
    1c66:	89 2b       	or	r24, r25
    1c68:	c1 f1       	breq	.+112    	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
													 )) == NO_DESCRIPTOR)
	{
		return;
	}

	Endpoint_ClearSETUP();
    1c6a:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    1c6e:	b8 01       	movw	r22, r16
    1c70:	89 81       	ldd	r24, Y+1	; 0x01
    1c72:	9a 81       	ldd	r25, Y+2	; 0x02
    1c74:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <Endpoint_Write_Control_PStream_LE>
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
    1c78:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <Endpoint_ClearOUT>
    1c7c:	2e c0       	rjmp	.+92     	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    1c7e:	20 38       	cpi	r18, 0x80	; 128
    1c80:	61 f5       	brne	.+88     	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
	EVENT_USB_Device_ConfigurationChanged();
}

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
    1c82:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    1c86:	80 91 3b 95 	lds	r24, 0x953B
    1c8a:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
	Endpoint_ClearIN();
    1c8e:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>

	Endpoint_ClearStatusStage();
    1c92:	0e 94 bc 11 	call	0x2378	; 0x2378 <Endpoint_ClearStatusStage>
    1c96:	21 c0       	rjmp	.+66     	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    1c98:	21 11       	cpse	r18, r1
    1c9a:	1f c0       	rjmp	.+62     	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    1c9c:	80 91 42 95 	lds	r24, 0x9542
    1ca0:	82 30       	cpi	r24, 0x02	; 2
    1ca2:	d8 f4       	brcc	.+54     	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
	if ((uint8_t)USB_ControlRequest.wValue > DevDescriptorPtr->NumberOfConfigurations)
	  return;
	#endif
	#endif

	Endpoint_ClearSETUP();
    1ca4:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    1ca8:	80 91 42 95 	lds	r24, 0x9542
    1cac:	80 93 3b 95 	sts	0x953B, r24

	Endpoint_ClearStatusStage();
    1cb0:	0e 94 bc 11 	call	0x2378	; 0x2378 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    1cb4:	80 91 3b 95 	lds	r24, 0x953B
    1cb8:	88 23       	and	r24, r24
    1cba:	21 f0       	breq	.+8      	; 0x1cc4 <USB_Device_ProcessControlRequest+0x254>
	  USB_DeviceState = DEVICE_STATE_Configured;
    1cbc:	84 e0       	ldi	r24, 0x04	; 4
    1cbe:	80 93 3f 95 	sts	0x953F, r24
    1cc2:	09 c0       	rjmp	.+18     	; 0x1cd6 <USB_Device_ProcessControlRequest+0x266>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    1cc4:	80 91 c3 04 	lds	r24, 0x04C3
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1cc8:	81 11       	cpse	r24, r1
    1cca:	02 c0       	rjmp	.+4      	; 0x1cd0 <USB_Device_ProcessControlRequest+0x260>
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	01 c0       	rjmp	.+2      	; 0x1cd2 <USB_Device_ProcessControlRequest+0x262>
    1cd0:	84 e0       	ldi	r24, 0x04	; 4
    1cd2:	80 93 3f 95 	sts	0x953F, r24

	EVENT_USB_Device_ConfigurationChanged();
    1cd6:	0e 94 47 0a 	call	0x148e	; 0x148e <EVENT_USB_Device_ConfigurationChanged>
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    1cda:	0e 94 7e 10 	call	0x20fc	; 0x20fc <Endpoint_IsSETUPReceived>
    1cde:	88 23       	and	r24, r24
    1ce0:	81 f0       	breq	.+32     	; 0x1d02 <USB_Device_ProcessControlRequest+0x292>
	{
		Endpoint_ClearSETUP();
    1ce2:	0e 94 98 10 	call	0x2130	; 0x2130 <Endpoint_ClearSETUP>
		Endpoint_StallTransaction();
    1ce6:	0e 94 c6 10 	call	0x218c	; 0x218c <Endpoint_StallTransaction>
    1cea:	0b c0       	rjmp	.+22     	; 0x1d02 <USB_Device_ProcessControlRequest+0x292>
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    1cec:	80 91 42 95 	lds	r24, 0x9542
    1cf0:	81 30       	cpi	r24, 0x01	; 1
    1cf2:	99 f7       	brne	.-26     	; 0x1cda <USB_Device_ProcessControlRequest+0x26a>
    1cf4:	22 cf       	rjmp	.-444    	; 0x1b3a <USB_Device_ProcessControlRequest+0xca>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    1cf6:	80 91 42 95 	lds	r24, 0x9542
    1cfa:	88 23       	and	r24, r24
    1cfc:	09 f4       	brne	.+2      	; 0x1d00 <USB_Device_ProcessControlRequest+0x290>
    1cfe:	24 cf       	rjmp	.-440    	; 0x1b48 <USB_Device_ProcessControlRequest+0xd8>
    1d00:	48 cf       	rjmp	.-368    	; 0x1b92 <USB_Device_ProcessControlRequest+0x122>
	if (Endpoint_IsSETUPReceived())
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    1d02:	ea 96       	adiw	r28, 0x3a	; 58
    1d04:	cd bf       	out	0x3d, r28	; 61
    1d06:	de bf       	out	0x3e, r29	; 62
    1d08:	df 91       	pop	r29
    1d0a:	cf 91       	pop	r28
    1d0c:	1f 91       	pop	r17
    1d0e:	0f 91       	pop	r16
    1d10:	ff 90       	pop	r15
    1d12:	ef 90       	pop	r14
    1d14:	08 95       	ret

00001d16 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    1d16:	08 95       	ret

00001d18 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    1d18:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    1d1a:	80 91 3f 95 	lds	r24, 0x953F
    1d1e:	88 23       	and	r24, r24
    1d20:	69 f0       	breq	.+26     	; 0x1d3c <USB_USBTask+0x24>
			 *  \return Index of the currently selected endpoint.
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				return USB_Endpoint_SelectedEndpoint;
    1d22:	c0 91 4c 95 	lds	r28, 0x954C
	  return;

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    1d26:	80 e0       	ldi	r24, 0x00	; 0
    1d28:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>

	if (Endpoint_IsSETUPReceived())
    1d2c:	0e 94 7e 10 	call	0x20fc	; 0x20fc <Endpoint_IsSETUPReceived>
    1d30:	81 11       	cpse	r24, r1
	  USB_Device_ProcessControlRequest();
    1d32:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <USB_Device_ProcessControlRequest>

	Endpoint_SelectEndpoint(PrevEndpoint);
    1d36:	8c 2f       	mov	r24, r28
    1d38:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    1d3c:	cf 91       	pop	r28
    1d3e:	08 95       	ret

00001d40 <Endpoint_Write_Control_Stream_LE>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1d40:	cf 92       	push	r12
    1d42:	df 92       	push	r13
    1d44:	ef 92       	push	r14
    1d46:	ff 92       	push	r15
    1d48:	0f 93       	push	r16
    1d4a:	1f 93       	push	r17
    1d4c:	cf 93       	push	r28
    1d4e:	df 93       	push	r29
    1d50:	c8 2e       	mov	r12, r24
    1d52:	d9 2e       	mov	r13, r25
    1d54:	8b 01       	movw	r16, r22
    1d56:	80 91 4c 95 	lds	r24, 0x954C
    1d5a:	80 68       	ori	r24, 0x80	; 128
    1d5c:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
    1d60:	c0 91 46 95 	lds	r28, 0x9546
    1d64:	d0 91 47 95 	lds	r29, 0x9547
    1d68:	c0 17       	cp	r28, r16
    1d6a:	d1 07       	cpc	r29, r17
    1d6c:	40 f0       	brcs	.+16     	; 0x1d7e <Endpoint_Write_Control_Stream_LE+0x3e>
    1d6e:	01 15       	cp	r16, r1
    1d70:	11 05       	cpc	r17, r1
    1d72:	21 f4       	brne	.+8      	; 0x1d7c <Endpoint_Write_Control_Stream_LE+0x3c>
    1d74:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>
    1d78:	e8 01       	movw	r28, r16
    1d7a:	01 c0       	rjmp	.+2      	; 0x1d7e <Endpoint_Write_Control_Stream_LE+0x3e>
    1d7c:	e8 01       	movw	r28, r16
    1d7e:	ec 2c       	mov	r14, r12
    1d80:	fd 2c       	mov	r15, r13
    1d82:	d1 2c       	mov	r13, r1
    1d84:	49 c0       	rjmp	.+146    	; 0x1e18 <Endpoint_Write_Control_Stream_LE+0xd8>
    1d86:	80 91 3f 95 	lds	r24, 0x953F
    1d8a:	88 23       	and	r24, r24
    1d8c:	09 f4       	brne	.+2      	; 0x1d90 <Endpoint_Write_Control_Stream_LE+0x50>
    1d8e:	5a c0       	rjmp	.+180    	; 0x1e44 <Endpoint_Write_Control_Stream_LE+0x104>
    1d90:	85 30       	cpi	r24, 0x05	; 5
    1d92:	09 f4       	brne	.+2      	; 0x1d96 <Endpoint_Write_Control_Stream_LE+0x56>
    1d94:	59 c0       	rjmp	.+178    	; 0x1e48 <Endpoint_Write_Control_Stream_LE+0x108>
    1d96:	0e 94 7e 10 	call	0x20fc	; 0x20fc <Endpoint_IsSETUPReceived>
    1d9a:	81 11       	cpse	r24, r1
    1d9c:	57 c0       	rjmp	.+174    	; 0x1e4c <Endpoint_Write_Control_Stream_LE+0x10c>
    1d9e:	0e 94 64 10 	call	0x20c8	; 0x20c8 <Endpoint_IsOUTReceived>
    1da2:	81 11       	cpse	r24, r1
    1da4:	49 c0       	rjmp	.+146    	; 0x1e38 <Endpoint_Write_Control_Stream_LE+0xf8>
    1da6:	0e 94 57 10 	call	0x20ae	; 0x20ae <Endpoint_IsINReady>
    1daa:	88 23       	and	r24, r24
    1dac:	a9 f1       	breq	.+106    	; 0x1e18 <Endpoint_Write_Control_Stream_LE+0xd8>
    1dae:	80 91 4c 95 	lds	r24, 0x954C
    1db2:	88 23       	and	r24, r24
    1db4:	74 f4       	brge	.+28     	; 0x1dd2 <Endpoint_Write_Control_Stream_LE+0x92>
    1db6:	e0 91 48 95 	lds	r30, 0x9548
    1dba:	f0 91 49 95 	lds	r31, 0x9549
    1dbe:	ef 5b       	subi	r30, 0xBF	; 191
    1dc0:	ff 4f       	sbci	r31, 0xFF	; 255
    1dc2:	00 81       	ld	r16, Z
    1dc4:	10 e0       	ldi	r17, 0x00	; 0
    1dc6:	20 97       	sbiw	r28, 0x00	; 0
    1dc8:	f9 f0       	breq	.+62     	; 0x1e08 <Endpoint_Write_Control_Stream_LE+0xc8>
    1dca:	08 30       	cpi	r16, 0x08	; 8
    1dcc:	11 05       	cpc	r17, r1
    1dce:	78 f0       	brcs	.+30     	; 0x1dee <Endpoint_Write_Control_Stream_LE+0xae>
    1dd0:	1b c0       	rjmp	.+54     	; 0x1e08 <Endpoint_Write_Control_Stream_LE+0xc8>
    1dd2:	80 91 48 95 	lds	r24, 0x9548
    1dd6:	90 91 49 95 	lds	r25, 0x9549
    1dda:	fc 01       	movw	r30, r24
    1ddc:	e0 5c       	subi	r30, 0xC0	; 192
    1dde:	ff 4f       	sbci	r31, 0xFF	; 255
    1de0:	00 81       	ld	r16, Z
    1de2:	31 96       	adiw	r30, 0x01	; 1
    1de4:	80 81       	ld	r24, Z
    1de6:	10 e0       	ldi	r17, 0x00	; 0
    1de8:	08 1b       	sub	r16, r24
    1dea:	11 09       	sbc	r17, r1
    1dec:	ec cf       	rjmp	.-40     	; 0x1dc6 <Endpoint_Write_Control_Stream_LE+0x86>
    1dee:	f7 01       	movw	r30, r14
    1df0:	81 91       	ld	r24, Z+
    1df2:	7f 01       	movw	r14, r30
    1df4:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
    1df8:	21 97       	sbiw	r28, 0x01	; 1
    1dfa:	0f 5f       	subi	r16, 0xFF	; 255
    1dfc:	1f 4f       	sbci	r17, 0xFF	; 255
    1dfe:	20 97       	sbiw	r28, 0x00	; 0
    1e00:	19 f0       	breq	.+6      	; 0x1e08 <Endpoint_Write_Control_Stream_LE+0xc8>
    1e02:	08 30       	cpi	r16, 0x08	; 8
    1e04:	11 05       	cpc	r17, r1
    1e06:	99 f7       	brne	.-26     	; 0x1dee <Endpoint_Write_Control_Stream_LE+0xae>
    1e08:	dd 24       	eor	r13, r13
    1e0a:	d3 94       	inc	r13
    1e0c:	08 30       	cpi	r16, 0x08	; 8
    1e0e:	11 05       	cpc	r17, r1
    1e10:	09 f0       	breq	.+2      	; 0x1e14 <Endpoint_Write_Control_Stream_LE+0xd4>
    1e12:	d1 2c       	mov	r13, r1
    1e14:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>
    1e18:	20 97       	sbiw	r28, 0x00	; 0
    1e1a:	09 f0       	breq	.+2      	; 0x1e1e <Endpoint_Write_Control_Stream_LE+0xde>
    1e1c:	b4 cf       	rjmp	.-152    	; 0x1d86 <Endpoint_Write_Control_Stream_LE+0x46>
    1e1e:	d1 10       	cpse	r13, r1
    1e20:	b2 cf       	rjmp	.-156    	; 0x1d86 <Endpoint_Write_Control_Stream_LE+0x46>
    1e22:	0a c0       	rjmp	.+20     	; 0x1e38 <Endpoint_Write_Control_Stream_LE+0xf8>
    1e24:	80 91 3f 95 	lds	r24, 0x953F
    1e28:	88 23       	and	r24, r24
    1e2a:	91 f0       	breq	.+36     	; 0x1e50 <Endpoint_Write_Control_Stream_LE+0x110>
    1e2c:	85 30       	cpi	r24, 0x05	; 5
    1e2e:	91 f0       	breq	.+36     	; 0x1e54 <Endpoint_Write_Control_Stream_LE+0x114>
    1e30:	0e 94 7e 10 	call	0x20fc	; 0x20fc <Endpoint_IsSETUPReceived>
    1e34:	81 11       	cpse	r24, r1
    1e36:	10 c0       	rjmp	.+32     	; 0x1e58 <Endpoint_Write_Control_Stream_LE+0x118>
    1e38:	0e 94 64 10 	call	0x20c8	; 0x20c8 <Endpoint_IsOUTReceived>
    1e3c:	88 23       	and	r24, r24
    1e3e:	91 f3       	breq	.-28     	; 0x1e24 <Endpoint_Write_Control_Stream_LE+0xe4>
    1e40:	80 e0       	ldi	r24, 0x00	; 0
    1e42:	0b c0       	rjmp	.+22     	; 0x1e5a <Endpoint_Write_Control_Stream_LE+0x11a>
    1e44:	82 e0       	ldi	r24, 0x02	; 2
    1e46:	09 c0       	rjmp	.+18     	; 0x1e5a <Endpoint_Write_Control_Stream_LE+0x11a>
    1e48:	83 e0       	ldi	r24, 0x03	; 3
    1e4a:	07 c0       	rjmp	.+14     	; 0x1e5a <Endpoint_Write_Control_Stream_LE+0x11a>
    1e4c:	81 e0       	ldi	r24, 0x01	; 1
    1e4e:	05 c0       	rjmp	.+10     	; 0x1e5a <Endpoint_Write_Control_Stream_LE+0x11a>
    1e50:	82 e0       	ldi	r24, 0x02	; 2
    1e52:	03 c0       	rjmp	.+6      	; 0x1e5a <Endpoint_Write_Control_Stream_LE+0x11a>
    1e54:	83 e0       	ldi	r24, 0x03	; 3
    1e56:	01 c0       	rjmp	.+2      	; 0x1e5a <Endpoint_Write_Control_Stream_LE+0x11a>
    1e58:	81 e0       	ldi	r24, 0x01	; 1
    1e5a:	df 91       	pop	r29
    1e5c:	cf 91       	pop	r28
    1e5e:	1f 91       	pop	r17
    1e60:	0f 91       	pop	r16
    1e62:	ff 90       	pop	r15
    1e64:	ef 90       	pop	r14
    1e66:	df 90       	pop	r13
    1e68:	cf 90       	pop	r12
    1e6a:	08 95       	ret

00001e6c <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    1e6c:	df 92       	push	r13
    1e6e:	ef 92       	push	r14
    1e70:	ff 92       	push	r15
    1e72:	0f 93       	push	r16
    1e74:	1f 93       	push	r17
    1e76:	cf 93       	push	r28
    1e78:	df 93       	push	r29
    1e7a:	e8 2e       	mov	r14, r24
    1e7c:	f9 2e       	mov	r15, r25
    1e7e:	8b 01       	movw	r16, r22
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    1e80:	80 91 4c 95 	lds	r24, 0x954C
    1e84:	80 68       	ori	r24, 0x80	; 128
    1e86:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>

	if (Length > USB_ControlRequest.wLength)
    1e8a:	c0 91 46 95 	lds	r28, 0x9546
    1e8e:	d0 91 47 95 	lds	r29, 0x9547
    1e92:	c0 17       	cp	r28, r16
    1e94:	d1 07       	cpc	r29, r17
    1e96:	40 f0       	brcs	.+16     	; 0x1ea8 <Endpoint_Write_Control_PStream_LE+0x3c>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1e98:	01 15       	cp	r16, r1
    1e9a:	11 05       	cpc	r17, r1
    1e9c:	21 f4       	brne	.+8      	; 0x1ea6 <Endpoint_Write_Control_PStream_LE+0x3a>
	  Endpoint_ClearIN();
    1e9e:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>
    1ea2:	e8 01       	movw	r28, r16
    1ea4:	01 c0       	rjmp	.+2      	; 0x1ea8 <Endpoint_Write_Control_PStream_LE+0x3c>
    1ea6:	e8 01       	movw	r28, r16
    1ea8:	0e 2d       	mov	r16, r14
    1eaa:	1f 2d       	mov	r17, r15
    1eac:	d1 2c       	mov	r13, r1
    1eae:	4e c0       	rjmp	.+156    	; 0x1f4c <Endpoint_Write_Control_PStream_LE+0xe0>

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1eb0:	80 91 3f 95 	lds	r24, 0x953F

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1eb4:	88 23       	and	r24, r24
    1eb6:	09 f4       	brne	.+2      	; 0x1eba <Endpoint_Write_Control_PStream_LE+0x4e>
    1eb8:	5f c0       	rjmp	.+190    	; 0x1f78 <Endpoint_Write_Control_PStream_LE+0x10c>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1eba:	85 30       	cpi	r24, 0x05	; 5
    1ebc:	09 f4       	brne	.+2      	; 0x1ec0 <Endpoint_Write_Control_PStream_LE+0x54>
    1ebe:	5e c0       	rjmp	.+188    	; 0x1f7c <Endpoint_Write_Control_PStream_LE+0x110>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1ec0:	0e 94 7e 10 	call	0x20fc	; 0x20fc <Endpoint_IsSETUPReceived>
    1ec4:	81 11       	cpse	r24, r1
    1ec6:	5c c0       	rjmp	.+184    	; 0x1f80 <Endpoint_Write_Control_PStream_LE+0x114>
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1ec8:	0e 94 64 10 	call	0x20c8	; 0x20c8 <Endpoint_IsOUTReceived>
    1ecc:	81 11       	cpse	r24, r1
    1ece:	4e c0       	rjmp	.+156    	; 0x1f6c <Endpoint_Write_Control_PStream_LE+0x100>
		  break;

		if (Endpoint_IsINReady())
    1ed0:	0e 94 57 10 	call	0x20ae	; 0x20ae <Endpoint_IsINReady>
    1ed4:	88 23       	and	r24, r24
    1ed6:	d1 f1       	breq	.+116    	; 0x1f4c <Endpoint_Write_Control_PStream_LE+0xe0>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    1ed8:	80 91 4c 95 	lds	r24, 0x954C
    1edc:	88 23       	and	r24, r24
    1ede:	7c f4       	brge	.+30     	; 0x1efe <Endpoint_Write_Control_PStream_LE+0x92>
				  return USB_Endpoint_SelectedFIFO->Position;
    1ee0:	e0 91 48 95 	lds	r30, 0x9548
    1ee4:	f0 91 49 95 	lds	r31, 0x9549
    1ee8:	ef 5b       	subi	r30, 0xBF	; 191
    1eea:	ff 4f       	sbci	r31, 0xFF	; 255
    1eec:	e0 80       	ld	r14, Z
    1eee:	f1 2c       	mov	r15, r1
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1ef0:	20 97       	sbiw	r28, 0x00	; 0
    1ef2:	19 f1       	breq	.+70     	; 0x1f3a <Endpoint_Write_Control_PStream_LE+0xce>
    1ef4:	88 e0       	ldi	r24, 0x08	; 8
    1ef6:	e8 16       	cp	r14, r24
    1ef8:	f1 04       	cpc	r15, r1
    1efa:	78 f0       	brcs	.+30     	; 0x1f1a <Endpoint_Write_Control_PStream_LE+0xae>
    1efc:	1e c0       	rjmp	.+60     	; 0x1f3a <Endpoint_Write_Control_PStream_LE+0xce>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    1efe:	80 91 48 95 	lds	r24, 0x9548
    1f02:	90 91 49 95 	lds	r25, 0x9549
    1f06:	fc 01       	movw	r30, r24
    1f08:	e0 5c       	subi	r30, 0xC0	; 192
    1f0a:	ff 4f       	sbci	r31, 0xFF	; 255
    1f0c:	e0 80       	ld	r14, Z
    1f0e:	31 96       	adiw	r30, 0x01	; 1
    1f10:	80 81       	ld	r24, Z
    1f12:	f1 2c       	mov	r15, r1
    1f14:	e8 1a       	sub	r14, r24
    1f16:	f1 08       	sbc	r15, r1
    1f18:	eb cf       	rjmp	.-42     	; 0x1ef0 <Endpoint_Write_Control_PStream_LE+0x84>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1f1a:	f8 01       	movw	r30, r16
    1f1c:	84 91       	lpm	r24, Z
    1f1e:	0e 94 07 10 	call	0x200e	; 0x200e <Endpoint_Write_8>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1f22:	0f 5f       	subi	r16, 0xFF	; 255
    1f24:	1f 4f       	sbci	r17, 0xFF	; 255
				Length--;
    1f26:	21 97       	sbiw	r28, 0x01	; 1
				BytesInEndpoint++;
    1f28:	ff ef       	ldi	r31, 0xFF	; 255
    1f2a:	ef 1a       	sub	r14, r31
    1f2c:	ff 0a       	sbc	r15, r31

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1f2e:	20 97       	sbiw	r28, 0x00	; 0
    1f30:	21 f0       	breq	.+8      	; 0x1f3a <Endpoint_Write_Control_PStream_LE+0xce>
    1f32:	88 e0       	ldi	r24, 0x08	; 8
    1f34:	e8 16       	cp	r14, r24
    1f36:	f1 04       	cpc	r15, r1
    1f38:	81 f7       	brne	.-32     	; 0x1f1a <Endpoint_Write_Control_PStream_LE+0xae>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1f3a:	dd 24       	eor	r13, r13
    1f3c:	d3 94       	inc	r13
    1f3e:	e8 e0       	ldi	r30, 0x08	; 8
    1f40:	ee 16       	cp	r14, r30
    1f42:	f1 04       	cpc	r15, r1
    1f44:	09 f0       	breq	.+2      	; 0x1f48 <Endpoint_Write_Control_PStream_LE+0xdc>
    1f46:	d1 2c       	mov	r13, r1
			Endpoint_ClearIN();
    1f48:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1f4c:	20 97       	sbiw	r28, 0x00	; 0
    1f4e:	09 f0       	breq	.+2      	; 0x1f52 <Endpoint_Write_Control_PStream_LE+0xe6>
    1f50:	af cf       	rjmp	.-162    	; 0x1eb0 <Endpoint_Write_Control_PStream_LE+0x44>
    1f52:	d1 10       	cpse	r13, r1
    1f54:	ad cf       	rjmp	.-166    	; 0x1eb0 <Endpoint_Write_Control_PStream_LE+0x44>
    1f56:	0a c0       	rjmp	.+20     	; 0x1f6c <Endpoint_Write_Control_PStream_LE+0x100>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1f58:	80 91 3f 95 	lds	r24, 0x953F

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1f5c:	88 23       	and	r24, r24
    1f5e:	91 f0       	breq	.+36     	; 0x1f84 <Endpoint_Write_Control_PStream_LE+0x118>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1f60:	85 30       	cpi	r24, 0x05	; 5
    1f62:	91 f0       	breq	.+36     	; 0x1f88 <Endpoint_Write_Control_PStream_LE+0x11c>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1f64:	0e 94 7e 10 	call	0x20fc	; 0x20fc <Endpoint_IsSETUPReceived>
    1f68:	81 11       	cpse	r24, r1
    1f6a:	10 c0       	rjmp	.+32     	; 0x1f8c <Endpoint_Write_Control_PStream_LE+0x120>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1f6c:	0e 94 64 10 	call	0x20c8	; 0x20c8 <Endpoint_IsOUTReceived>
    1f70:	88 23       	and	r24, r24
    1f72:	91 f3       	breq	.-28     	; 0x1f58 <Endpoint_Write_Control_PStream_LE+0xec>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1f74:	80 e0       	ldi	r24, 0x00	; 0
    1f76:	0b c0       	rjmp	.+22     	; 0x1f8e <Endpoint_Write_Control_PStream_LE+0x122>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1f78:	82 e0       	ldi	r24, 0x02	; 2
    1f7a:	09 c0       	rjmp	.+18     	; 0x1f8e <Endpoint_Write_Control_PStream_LE+0x122>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1f7c:	83 e0       	ldi	r24, 0x03	; 3
    1f7e:	07 c0       	rjmp	.+14     	; 0x1f8e <Endpoint_Write_Control_PStream_LE+0x122>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1f80:	81 e0       	ldi	r24, 0x01	; 1
    1f82:	05 c0       	rjmp	.+10     	; 0x1f8e <Endpoint_Write_Control_PStream_LE+0x122>
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1f84:	82 e0       	ldi	r24, 0x02	; 2
    1f86:	03 c0       	rjmp	.+6      	; 0x1f8e <Endpoint_Write_Control_PStream_LE+0x122>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1f88:	83 e0       	ldi	r24, 0x03	; 3
    1f8a:	01 c0       	rjmp	.+2      	; 0x1f8e <Endpoint_Write_Control_PStream_LE+0x122>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1f8c:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1f8e:	df 91       	pop	r29
    1f90:	cf 91       	pop	r28
    1f92:	1f 91       	pop	r17
    1f94:	0f 91       	pop	r16
    1f96:	ff 90       	pop	r15
    1f98:	ef 90       	pop	r14
    1f9a:	df 90       	pop	r13
    1f9c:	08 95       	ret

00001f9e <Endpoint_ClearIN>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_ClearIN(void)
{
	USB_Endpoint_SelectedHandle->CNT     = USB_Endpoint_SelectedFIFO->Position;
    1f9e:	e0 91 4a 95 	lds	r30, 0x954A
    1fa2:	f0 91 4b 95 	lds	r31, 0x954B
    1fa6:	a0 91 48 95 	lds	r26, 0x9548
    1faa:	b0 91 49 95 	lds	r27, 0x9549
    1fae:	af 5b       	subi	r26, 0xBF	; 191
    1fb0:	bf 4f       	sbci	r27, 0xFF	; 255
    1fb2:	8c 91       	ld	r24, X
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	82 83       	std	Z+2, r24	; 0x02
    1fb8:	93 83       	std	Z+3, r25	; 0x03
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    1fba:	80 81       	ld	r24, Z
    1fbc:	8d 79       	andi	r24, 0x9D	; 157
    1fbe:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1fc0:	e0 91 48 95 	lds	r30, 0x9548
    1fc4:	f0 91 49 95 	lds	r31, 0x9549
    1fc8:	ef 5b       	subi	r30, 0xBF	; 191
    1fca:	ff 4f       	sbci	r31, 0xFF	; 255
    1fcc:	10 82       	st	Z, r1
    1fce:	08 95       	ret

00001fd0 <Endpoint_ClearOUT>:
}

void Endpoint_ClearOUT(void)
{
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    1fd0:	e0 91 4a 95 	lds	r30, 0x954A
    1fd4:	f0 91 4b 95 	lds	r31, 0x954B
    1fd8:	80 81       	ld	r24, Z
    1fda:	8d 79       	andi	r24, 0x9D	; 157
    1fdc:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1fde:	e0 91 48 95 	lds	r30, 0x9548
    1fe2:	f0 91 49 95 	lds	r31, 0x9549
    1fe6:	ef 5b       	subi	r30, 0xBF	; 191
    1fe8:	ff 4f       	sbci	r31, 0xFF	; 255
    1fea:	10 82       	st	Z, r1
    1fec:	08 95       	ret

00001fee <Endpoint_Read_8>:
	}
}

uint8_t Endpoint_Read_8(void)
{
	return USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++];
    1fee:	80 91 48 95 	lds	r24, 0x9548
    1ff2:	90 91 49 95 	lds	r25, 0x9549
    1ff6:	fc 01       	movw	r30, r24
    1ff8:	ef 5b       	subi	r30, 0xBF	; 191
    1ffa:	ff 4f       	sbci	r31, 0xFF	; 255
    1ffc:	20 81       	ld	r18, Z
    1ffe:	31 e0       	ldi	r19, 0x01	; 1
    2000:	32 0f       	add	r19, r18
    2002:	30 83       	st	Z, r19
    2004:	fc 01       	movw	r30, r24
    2006:	e2 0f       	add	r30, r18
    2008:	f1 1d       	adc	r31, r1
    200a:	80 81       	ld	r24, Z
}
    200c:	08 95       	ret

0000200e <Endpoint_Write_8>:

void Endpoint_Write_8(const uint8_t Data)
{
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
    200e:	20 91 48 95 	lds	r18, 0x9548
    2012:	30 91 49 95 	lds	r19, 0x9549
    2016:	f9 01       	movw	r30, r18
    2018:	ef 5b       	subi	r30, 0xBF	; 191
    201a:	ff 4f       	sbci	r31, 0xFF	; 255
    201c:	90 81       	ld	r25, Z
    201e:	41 e0       	ldi	r20, 0x01	; 1
    2020:	49 0f       	add	r20, r25
    2022:	40 83       	st	Z, r20
    2024:	f9 01       	movw	r30, r18
    2026:	e9 0f       	add	r30, r25
    2028:	f1 1d       	adc	r31, r1
    202a:	80 83       	st	Z, r24
    202c:	08 95       	ret

0000202e <Endpoint_SelectEndpoint>:

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);

	USB_Endpoint_SelectedEndpoint = Address;
    202e:	80 93 4c 95 	sts	0x954C, r24
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
}

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);
    2032:	28 2f       	mov	r18, r24
    2034:	2f 70       	andi	r18, 0x0F	; 15

	USB_Endpoint_SelectedEndpoint = Address;

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
    2036:	30 e0       	ldi	r19, 0x00	; 0
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;
    2038:	40 91 c6 04 	lds	r20, 0x04C6
    203c:	50 91 c7 04 	lds	r21, 0x04C7

	if (Address & ENDPOINT_DIR_IN)
    2040:	88 23       	and	r24, r24
    2042:	e4 f4       	brge	.+56     	; 0x207c <Endpoint_SelectEndpoint+0x4e>
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
    2044:	64 e8       	ldi	r22, 0x84	; 132
    2046:	62 9f       	mul	r22, r18
    2048:	c0 01       	movw	r24, r0
    204a:	63 9f       	mul	r22, r19
    204c:	90 0d       	add	r25, r0
    204e:	11 24       	eor	r1, r1
    2050:	81 57       	subi	r24, 0x71	; 113
    2052:	9a 46       	sbci	r25, 0x6A	; 106
    2054:	80 93 48 95 	sts	0x9548, r24
    2058:	90 93 49 95 	sts	0x9549, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].IN;
    205c:	c9 01       	movw	r24, r18
    205e:	82 95       	swap	r24
    2060:	92 95       	swap	r25
    2062:	90 7f       	andi	r25, 0xF0	; 240
    2064:	98 27       	eor	r25, r24
    2066:	80 7f       	andi	r24, 0xF0	; 240
    2068:	98 27       	eor	r25, r24
    206a:	08 96       	adiw	r24, 0x08	; 8
    206c:	9a 01       	movw	r18, r20
    206e:	28 0f       	add	r18, r24
    2070:	39 1f       	adc	r19, r25
    2072:	20 93 4a 95 	sts	0x954A, r18
    2076:	30 93 4b 95 	sts	0x954B, r19
    207a:	08 95       	ret
	}
	else
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->OUT;
    207c:	64 e8       	ldi	r22, 0x84	; 132
    207e:	62 9f       	mul	r22, r18
    2080:	c0 01       	movw	r24, r0
    2082:	63 9f       	mul	r22, r19
    2084:	90 0d       	add	r25, r0
    2086:	11 24       	eor	r1, r1
    2088:	83 5b       	subi	r24, 0xB3	; 179
    208a:	9a 46       	sbci	r25, 0x6A	; 106
    208c:	80 93 48 95 	sts	0x9548, r24
    2090:	90 93 49 95 	sts	0x9549, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].OUT;
    2094:	22 95       	swap	r18
    2096:	32 95       	swap	r19
    2098:	30 7f       	andi	r19, 0xF0	; 240
    209a:	32 27       	eor	r19, r18
    209c:	20 7f       	andi	r18, 0xF0	; 240
    209e:	32 27       	eor	r19, r18
    20a0:	24 0f       	add	r18, r20
    20a2:	35 1f       	adc	r19, r21
    20a4:	20 93 4a 95 	sts	0x954A, r18
    20a8:	30 93 4b 95 	sts	0x954B, r19
    20ac:	08 95       	ret

000020ae <Endpoint_IsINReady>:
volatile USB_EP_t*        USB_Endpoint_SelectedHandle;
volatile Endpoint_FIFO_t* USB_Endpoint_SelectedFIFO;

bool Endpoint_IsINReady(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    20ae:	80 91 4c 95 	lds	r24, 0x954C
    20b2:	80 68       	ori	r24, 0x80	; 128
    20b4:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>

	return ((USB_Endpoint_SelectedHandle->STATUS & USB_EP_BUSNACK0_bm) ? true : false);
    20b8:	e0 91 4a 95 	lds	r30, 0x954A
    20bc:	f0 91 4b 95 	lds	r31, 0x954B
    20c0:	80 81       	ld	r24, Z
}
    20c2:	86 95       	lsr	r24
    20c4:	81 70       	andi	r24, 0x01	; 1
    20c6:	08 95       	ret

000020c8 <Endpoint_IsOUTReceived>:

bool Endpoint_IsOUTReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    20c8:	80 91 4c 95 	lds	r24, 0x954C
    20cc:	8f 77       	andi	r24, 0x7F	; 127
    20ce:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_TRNCOMPL0_bm)
    20d2:	e0 91 4a 95 	lds	r30, 0x954A
    20d6:	f0 91 4b 95 	lds	r31, 0x954B
    20da:	80 81       	ld	r24, Z
    20dc:	85 ff       	sbrs	r24, 5
    20de:	0c c0       	rjmp	.+24     	; 0x20f8 <Endpoint_IsOUTReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    20e0:	80 91 48 95 	lds	r24, 0x9548
    20e4:	90 91 49 95 	lds	r25, 0x9549
    20e8:	22 81       	ldd	r18, Z+2	; 0x02
    20ea:	33 81       	ldd	r19, Z+3	; 0x03
    20ec:	fc 01       	movw	r30, r24
    20ee:	e0 5c       	subi	r30, 0xC0	; 192
    20f0:	ff 4f       	sbci	r31, 0xFF	; 255
    20f2:	20 83       	st	Z, r18
		return true;
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	08 95       	ret
	}

	return false;
    20f8:	80 e0       	ldi	r24, 0x00	; 0
}
    20fa:	08 95       	ret

000020fc <Endpoint_IsSETUPReceived>:

bool Endpoint_IsSETUPReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    20fc:	80 91 4c 95 	lds	r24, 0x954C
    2100:	8f 77       	andi	r24, 0x7F	; 127
    2102:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_SETUP_bm)
    2106:	e0 91 4a 95 	lds	r30, 0x954A
    210a:	f0 91 4b 95 	lds	r31, 0x954B
    210e:	80 81       	ld	r24, Z
    2110:	84 ff       	sbrs	r24, 4
    2112:	0c c0       	rjmp	.+24     	; 0x212c <Endpoint_IsSETUPReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    2114:	80 91 48 95 	lds	r24, 0x9548
    2118:	90 91 49 95 	lds	r25, 0x9549
    211c:	22 81       	ldd	r18, Z+2	; 0x02
    211e:	33 81       	ldd	r19, Z+3	; 0x03
    2120:	fc 01       	movw	r30, r24
    2122:	e0 5c       	subi	r30, 0xC0	; 192
    2124:	ff 4f       	sbci	r31, 0xFF	; 255
    2126:	20 83       	st	Z, r18
		return true;
    2128:	81 e0       	ldi	r24, 0x01	; 1
    212a:	08 95       	ret
	}

	return false;
    212c:	80 e0       	ldi	r24, 0x00	; 0
}
    212e:	08 95       	ret

00002130 <Endpoint_ClearSETUP>:

void Endpoint_ClearSETUP(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    2130:	80 91 4c 95 	lds	r24, 0x954C
    2134:	8f 77       	andi	r24, 0x7F	; 127
    2136:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_SETUP_bm | USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    213a:	e0 91 4a 95 	lds	r30, 0x954A
    213e:	f0 91 4b 95 	lds	r31, 0x954B
    2142:	80 81       	ld	r24, Z
    2144:	8d 78       	andi	r24, 0x8D	; 141
    2146:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    2148:	e0 91 4a 95 	lds	r30, 0x954A
    214c:	f0 91 4b 95 	lds	r31, 0x954B
    2150:	80 81       	ld	r24, Z
    2152:	81 60       	ori	r24, 0x01	; 1
    2154:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    2156:	e0 91 48 95 	lds	r30, 0x9548
    215a:	f0 91 49 95 	lds	r31, 0x9549
    215e:	ef 5b       	subi	r30, 0xBF	; 191
    2160:	ff 4f       	sbci	r31, 0xFF	; 255
    2162:	10 82       	st	Z, r1

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    2164:	80 91 4c 95 	lds	r24, 0x954C
    2168:	80 68       	ori	r24, 0x80	; 128
    216a:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    216e:	e0 91 4a 95 	lds	r30, 0x954A
    2172:	f0 91 4b 95 	lds	r31, 0x954B
    2176:	80 81       	ld	r24, Z
    2178:	81 60       	ori	r24, 0x01	; 1
    217a:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    217c:	e0 91 48 95 	lds	r30, 0x9548
    2180:	f0 91 49 95 	lds	r31, 0x9549
    2184:	ef 5b       	subi	r30, 0xBF	; 191
    2186:	ff 4f       	sbci	r31, 0xFF	; 255
    2188:	10 82       	st	Z, r1
    218a:	08 95       	ret

0000218c <Endpoint_StallTransaction>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_StallTransaction(void)
{
	USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    218c:	e0 91 4a 95 	lds	r30, 0x954A
    2190:	f0 91 4b 95 	lds	r31, 0x954B
    2194:	81 81       	ldd	r24, Z+1	; 0x01
    2196:	84 60       	ori	r24, 0x04	; 4
    2198:	81 83       	std	Z+1, r24	; 0x01

	if ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_TYPE_gm) == USB_EP_TYPE_CONTROL_gc)
    219a:	e0 91 4a 95 	lds	r30, 0x954A
    219e:	f0 91 4b 95 	lds	r31, 0x954B
    21a2:	81 81       	ldd	r24, Z+1	; 0x01
    21a4:	80 7c       	andi	r24, 0xC0	; 192
    21a6:	80 34       	cpi	r24, 0x40	; 64
    21a8:	61 f4       	brne	.+24     	; 0x21c2 <Endpoint_StallTransaction+0x36>
	{
		Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint ^ ENDPOINT_DIR_IN);
    21aa:	80 91 4c 95 	lds	r24, 0x954C
    21ae:	80 58       	subi	r24, 0x80	; 128
    21b0:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>
		USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    21b4:	e0 91 4a 95 	lds	r30, 0x954A
    21b8:	f0 91 4b 95 	lds	r31, 0x954B
    21bc:	81 81       	ldd	r24, Z+1	; 0x01
    21be:	84 60       	ori	r24, 0x04	; 4
    21c0:	81 83       	std	Z+1, r24	; 0x01
    21c2:	08 95       	ret

000021c4 <Endpoint_ConfigureEndpoint_PRV>:
}

bool Endpoint_ConfigureEndpoint_PRV(const uint8_t Address,
                                    const uint8_t Config,
                                    const uint8_t Size)
{
    21c4:	1f 93       	push	r17
    21c6:	cf 93       	push	r28
    21c8:	df 93       	push	r29
    21ca:	d8 2f       	mov	r29, r24
    21cc:	16 2f       	mov	r17, r22
    21ce:	c4 2f       	mov	r28, r20
	Endpoint_SelectEndpoint(Address);
    21d0:	0e 94 17 10 	call	0x202e	; 0x202e <Endpoint_SelectEndpoint>

	USB_Endpoint_SelectedHandle->CTRL    = 0;
    21d4:	e0 91 4a 95 	lds	r30, 0x954A
    21d8:	f0 91 4b 95 	lds	r31, 0x954B
    21dc:	11 82       	std	Z+1, r1	; 0x01
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    21de:	e0 91 4a 95 	lds	r30, 0x954A
    21e2:	f0 91 4b 95 	lds	r31, 0x954B
    21e6:	dd 23       	and	r29, r29
    21e8:	a4 f0       	brlt	.+40     	; 0x2212 <Endpoint_ConfigureEndpoint_PRV+0x4e>
    21ea:	10 82       	st	Z, r1
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    21ec:	e0 91 4a 95 	lds	r30, 0x954A
    21f0:	f0 91 4b 95 	lds	r31, 0x954B
    21f4:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    21f6:	e0 91 4a 95 	lds	r30, 0x954A
    21fa:	f0 91 4b 95 	lds	r31, 0x954B
    21fe:	12 82       	std	Z+2, r1	; 0x02
    2200:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    2202:	80 91 48 95 	lds	r24, 0x9548
    2206:	90 91 49 95 	lds	r25, 0x9549
    220a:	84 83       	std	Z+4, r24	; 0x04
    220c:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    220e:	40 e0       	ldi	r20, 0x00	; 0
    2210:	14 c0       	rjmp	.+40     	; 0x223a <Endpoint_ConfigureEndpoint_PRV+0x76>
                                    const uint8_t Size)
{
	Endpoint_SelectEndpoint(Address);

	USB_Endpoint_SelectedHandle->CTRL    = 0;
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    2212:	82 e0       	ldi	r24, 0x02	; 2
    2214:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    2216:	e0 91 4a 95 	lds	r30, 0x954A
    221a:	f0 91 4b 95 	lds	r31, 0x954B
    221e:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    2220:	e0 91 4a 95 	lds	r30, 0x954A
    2224:	f0 91 4b 95 	lds	r31, 0x954B
    2228:	12 82       	std	Z+2, r1	; 0x02
    222a:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    222c:	80 91 48 95 	lds	r24, 0x9548
    2230:	90 91 49 95 	lds	r25, 0x9549
    2234:	84 83       	std	Z+4, r24	; 0x04
    2236:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    2238:	4c 2f       	mov	r20, r28
    223a:	fc 01       	movw	r30, r24
    223c:	e0 5c       	subi	r30, 0xC0	; 192
    223e:	ff 4f       	sbci	r31, 0xFF	; 255
    2240:	40 83       	st	Z, r20
	USB_Endpoint_SelectedFIFO->Position  = 0;
    2242:	31 96       	adiw	r30, 0x01	; 1
    2244:	10 82       	st	Z, r1

	return true;
}
    2246:	81 e0       	ldi	r24, 0x01	; 1
    2248:	df 91       	pop	r29
    224a:	cf 91       	pop	r28
    224c:	1f 91       	pop	r17
    224e:	08 95       	ret

00002250 <Endpoint_ConfigureEndpointTable>:
	}
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    2250:	af 92       	push	r10
    2252:	bf 92       	push	r11
    2254:	cf 92       	push	r12
    2256:	df 92       	push	r13
    2258:	ef 92       	push	r14
    225a:	ff 92       	push	r15
    225c:	0f 93       	push	r16
    225e:	1f 93       	push	r17
    2260:	cf 93       	push	r28
    2262:	df 93       	push	r29
	for (uint8_t i = 0; i < Entries; i++)
    2264:	66 23       	and	r22, r22
    2266:	09 f4       	brne	.+2      	; 0x226a <Endpoint_ConfigureEndpointTable+0x1a>
    2268:	57 c0       	rjmp	.+174    	; 0x2318 <Endpoint_ConfigureEndpointTable+0xc8>
    226a:	a6 2e       	mov	r10, r22
    226c:	7c 01       	movw	r14, r24
    226e:	8c 01       	movw	r16, r24
    2270:	84 e0       	ldi	r24, 0x04	; 4
    2272:	e8 0e       	add	r14, r24
    2274:	f1 1c       	adc	r15, r1
    2276:	b1 2c       	mov	r11, r1
	{
		if (!(Table[i].Address))
    2278:	f8 01       	movw	r30, r16
    227a:	c0 80       	ld	r12, Z
    227c:	cc 20       	and	r12, r12
    227e:	09 f4       	brne	.+2      	; 0x2282 <Endpoint_ConfigureEndpointTable+0x32>
    2280:	41 c0       	rjmp	.+130    	; 0x2304 <Endpoint_ConfigureEndpointTable+0xb4>
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    2282:	c1 81       	ldd	r28, Z+1	; 0x01
    2284:	d2 81       	ldd	r29, Z+2	; 0x02
    2286:	f7 01       	movw	r30, r14
    2288:	31 97       	sbiw	r30, 0x01	; 1
    228a:	80 81       	ld	r24, Z
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    228c:	f7 01       	movw	r30, r14
    228e:	90 81       	ld	r25, Z
    2290:	92 30       	cpi	r25, 0x02	; 2
    2292:	10 f4       	brcc	.+4      	; 0x2298 <Endpoint_ConfigureEndpointTable+0x48>
    2294:	48 e0       	ldi	r20, 0x08	; 8
    2296:	01 c0       	rjmp	.+2      	; 0x229a <Endpoint_ConfigureEndpointTable+0x4a>
    2298:	48 e1       	ldi	r20, 0x18	; 24
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    229a:	c9 30       	cpi	r28, 0x09	; 9
    229c:	d1 05       	cpc	r29, r1
    229e:	50 f0       	brcs	.+20     	; 0x22b4 <Endpoint_ConfigureEndpointTable+0x64>
    22a0:	28 e0       	ldi	r18, 0x08	; 8
    22a2:	30 e0       	ldi	r19, 0x00	; 0
    22a4:	90 e0       	ldi	r25, 0x00	; 0
				{
					MaskVal++;
    22a6:	9f 5f       	subi	r25, 0xFF	; 255
					CheckBytes <<= 1;
    22a8:	22 0f       	add	r18, r18
    22aa:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    22ac:	2c 17       	cp	r18, r28
    22ae:	3d 07       	cpc	r19, r29
    22b0:	d0 f3       	brcs	.-12     	; 0x22a6 <Endpoint_ConfigureEndpointTable+0x56>
    22b2:	01 c0       	rjmp	.+2      	; 0x22b6 <Endpoint_ConfigureEndpointTable+0x66>
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    22b4:	90 e0       	ldi	r25, 0x00	; 0
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    22b6:	94 2b       	or	r25, r20

				if ((Address & ENDPOINT_EPNUM_MASK) >= ENDPOINT_TOTAL_ENDPOINTS)
    22b8:	2c 2d       	mov	r18, r12
    22ba:	2f 70       	andi	r18, 0x0F	; 15
    22bc:	30 e0       	ldi	r19, 0x00	; 0
    22be:	25 30       	cpi	r18, 0x05	; 5
    22c0:	31 05       	cpc	r19, r1
    22c2:	64 f5       	brge	.+88     	; 0x231c <Endpoint_ConfigureEndpointTable+0xcc>
				  return false;

				// TODO - Fix once limitations are lifted
				EPConfigMask &= ~USB_EP_PINGPONG_bm;
    22c4:	9f 7e       	andi	r25, 0xEF	; 239
				if (Size > 64)
    22c6:	c1 34       	cpi	r28, 0x41	; 65
    22c8:	d1 05       	cpc	r29, r1
    22ca:	50 f5       	brcc	.+84     	; 0x2320 <Endpoint_ConfigureEndpointTable+0xd0>
				  return false;

				switch (Type)
    22cc:	88 23       	and	r24, r24
    22ce:	19 f0       	breq	.+6      	; 0x22d6 <Endpoint_ConfigureEndpointTable+0x86>
    22d0:	81 30       	cpi	r24, 0x01	; 1
    22d2:	21 f0       	breq	.+8      	; 0x22dc <Endpoint_ConfigureEndpointTable+0x8c>
    22d4:	06 c0       	rjmp	.+12     	; 0x22e2 <Endpoint_ConfigureEndpointTable+0x92>
				{
					case EP_TYPE_CONTROL:
						EPConfigMask |= USB_EP_TYPE_CONTROL_gc;
    22d6:	90 64       	ori	r25, 0x40	; 64
    22d8:	d9 2e       	mov	r13, r25
    22da:	07 c0       	rjmp	.+14     	; 0x22ea <Endpoint_ConfigureEndpointTable+0x9a>
						break;
					case EP_TYPE_ISOCHRONOUS:
						EPConfigMask |= USB_EP_TYPE_ISOCHRONOUS_gc;
    22dc:	90 6c       	ori	r25, 0xC0	; 192
    22de:	d9 2e       	mov	r13, r25
    22e0:	0a c0       	rjmp	.+20     	; 0x22f6 <Endpoint_ConfigureEndpointTable+0xa6>
						break;
					default:
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
    22e2:	90 68       	ori	r25, 0x80	; 128
    22e4:	d9 2e       	mov	r13, r25
						break;
				}

				if (Type == EP_TYPE_CONTROL)
    22e6:	81 11       	cpse	r24, r1
    22e8:	06 c0       	rjmp	.+12     	; 0x22f6 <Endpoint_ConfigureEndpointTable+0xa6>
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    22ea:	4c 2f       	mov	r20, r28
    22ec:	6d 2d       	mov	r22, r13
    22ee:	80 e8       	ldi	r24, 0x80	; 128
    22f0:	8c 0d       	add	r24, r12
    22f2:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    22f6:	4c 2f       	mov	r20, r28
    22f8:	6d 2d       	mov	r22, r13
    22fa:	8c 2d       	mov	r24, r12
    22fc:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <Endpoint_ConfigureEndpoint_PRV>
    2300:	88 23       	and	r24, r24
    2302:	79 f0       	breq	.+30     	; 0x2322 <Endpoint_ConfigureEndpointTable+0xd2>
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    2304:	b3 94       	inc	r11
    2306:	0b 5f       	subi	r16, 0xFB	; 251
    2308:	1f 4f       	sbci	r17, 0xFF	; 255
    230a:	f5 e0       	ldi	r31, 0x05	; 5
    230c:	ef 0e       	add	r14, r31
    230e:	f1 1c       	adc	r15, r1
    2310:	ba 10       	cpse	r11, r10
    2312:	b2 cf       	rjmp	.-156    	; 0x2278 <Endpoint_ConfigureEndpointTable+0x28>
		{
			return false;
		}
	}

	return true;
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	05 c0       	rjmp	.+10     	; 0x2322 <Endpoint_ConfigureEndpointTable+0xd2>
    2318:	81 e0       	ldi	r24, 0x01	; 1
    231a:	03 c0       	rjmp	.+6      	; 0x2322 <Endpoint_ConfigureEndpointTable+0xd2>
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		{
			return false;
    231c:	80 e0       	ldi	r24, 0x00	; 0
    231e:	01 c0       	rjmp	.+2      	; 0x2322 <Endpoint_ConfigureEndpointTable+0xd2>
    2320:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return true;
}
    2322:	df 91       	pop	r29
    2324:	cf 91       	pop	r28
    2326:	1f 91       	pop	r17
    2328:	0f 91       	pop	r16
    232a:	ff 90       	pop	r15
    232c:	ef 90       	pop	r14
    232e:	df 90       	pop	r13
    2330:	cf 90       	pop	r12
    2332:	bf 90       	pop	r11
    2334:	af 90       	pop	r10
    2336:	08 95       	ret

00002338 <Endpoint_ClearEndpoints>:

	return true;
}

void Endpoint_ClearEndpoints(void)
{
    2338:	20 e0       	ldi	r18, 0x00	; 0
    233a:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
    233c:	a0 ec       	ldi	r26, 0xC0	; 192
    233e:	b4 e0       	ldi	r27, 0x04	; 4
    2340:	16 96       	adiw	r26, 0x06	; 6
    2342:	ed 91       	ld	r30, X+
    2344:	fc 91       	ld	r31, X
    2346:	17 97       	sbiw	r26, 0x07	; 7
    2348:	c9 01       	movw	r24, r18
    234a:	82 95       	swap	r24
    234c:	92 95       	swap	r25
    234e:	90 7f       	andi	r25, 0xF0	; 240
    2350:	98 27       	eor	r25, r24
    2352:	80 7f       	andi	r24, 0xF0	; 240
    2354:	98 27       	eor	r25, r24
    2356:	e8 0f       	add	r30, r24
    2358:	f9 1f       	adc	r31, r25
    235a:	11 86       	std	Z+9, r1	; 0x09
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
    235c:	16 96       	adiw	r26, 0x06	; 6
    235e:	4d 91       	ld	r20, X+
    2360:	5c 91       	ld	r21, X
    2362:	17 97       	sbiw	r26, 0x07	; 7
    2364:	fa 01       	movw	r30, r20
    2366:	e8 0f       	add	r30, r24
    2368:	f9 1f       	adc	r31, r25
    236a:	11 82       	std	Z+1, r1	; 0x01
    236c:	2f 5f       	subi	r18, 0xFF	; 255
    236e:	3f 4f       	sbci	r19, 0xFF	; 255
	return true;
}

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    2370:	25 30       	cpi	r18, 0x05	; 5
    2372:	31 05       	cpc	r19, r1
    2374:	29 f7       	brne	.-54     	; 0x2340 <Endpoint_ClearEndpoints+0x8>
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
	}
}
    2376:	08 95       	ret

00002378 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    2378:	80 91 40 95 	lds	r24, 0x9540
    237c:	88 23       	and	r24, r24
    237e:	84 f4       	brge	.+32     	; 0x23a0 <Endpoint_ClearStatusStage+0x28>
    2380:	04 c0       	rjmp	.+8      	; 0x238a <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2382:	80 91 3f 95 	lds	r24, 0x953F
    2386:	88 23       	and	r24, r24
    2388:	89 f0       	breq	.+34     	; 0x23ac <Endpoint_ClearStatusStage+0x34>

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    238a:	0e 94 64 10 	call	0x20c8	; 0x20c8 <Endpoint_IsOUTReceived>
    238e:	88 23       	and	r24, r24
    2390:	c1 f3       	breq	.-16     	; 0x2382 <Endpoint_ClearStatusStage+0xa>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearOUT();
    2392:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <Endpoint_ClearOUT>
    2396:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2398:	80 91 3f 95 	lds	r24, 0x953F
    239c:	88 23       	and	r24, r24
    239e:	31 f0       	breq	.+12     	; 0x23ac <Endpoint_ClearStatusStage+0x34>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    23a0:	0e 94 57 10 	call	0x20ae	; 0x20ae <Endpoint_IsINReady>
    23a4:	88 23       	and	r24, r24
    23a6:	c1 f3       	breq	.-16     	; 0x2398 <Endpoint_ClearStatusStage+0x20>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearIN();
    23a8:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <Endpoint_ClearIN>
    23ac:	08 95       	ret

000023ae <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    23ae:	ff 92       	push	r15
    23b0:	0f 93       	push	r16
    23b2:	1f 93       	push	r17
    23b4:	cf 93       	push	r28
    23b6:	df 93       	push	r29
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return ((USB_EndpointTable_t*)USB.EPPTR)->FrameNum;
    23b8:	e0 91 c6 04 	lds	r30, 0x04C6
    23bc:	f0 91 c7 04 	lds	r31, 0x04C7
    23c0:	e0 5b       	subi	r30, 0xB0	; 176
    23c2:	ff 4f       	sbci	r31, 0xFF	; 255
    23c4:	c0 81       	ld	r28, Z
    23c6:	d1 81       	ldd	r29, Z+1	; 0x01
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    23c8:	0f 2e       	mov	r0, r31
    23ca:	f4 e6       	ldi	r31, 0x64	; 100
    23cc:	ff 2e       	mov	r15, r31
    23ce:	f0 2d       	mov	r31, r0
    23d0:	00 ec       	ldi	r16, 0xC0	; 192
    23d2:	14 e0       	ldi	r17, 0x04	; 4
    23d4:	02 c0       	rjmp	.+4      	; 0x23da <Endpoint_WaitUntilReady+0x2c>

		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    23d6:	f2 2e       	mov	r15, r18
    23d8:	ec 01       	movw	r28, r24
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN);
    23da:	80 91 4c 95 	lds	r24, 0x954C

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    23de:	88 23       	and	r24, r24
    23e0:	2c f4       	brge	.+10     	; 0x23ec <Endpoint_WaitUntilReady+0x3e>
		{
			if (Endpoint_IsINReady())
    23e2:	0e 94 57 10 	call	0x20ae	; 0x20ae <Endpoint_IsINReady>
    23e6:	88 23       	and	r24, r24
    23e8:	29 f0       	breq	.+10     	; 0x23f4 <Endpoint_WaitUntilReady+0x46>
    23ea:	23 c0       	rjmp	.+70     	; 0x2432 <Endpoint_WaitUntilReady+0x84>
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    23ec:	0e 94 64 10 	call	0x20c8	; 0x20c8 <Endpoint_IsOUTReceived>
    23f0:	81 11       	cpse	r24, r1
    23f2:	21 c0       	rjmp	.+66     	; 0x2436 <Endpoint_WaitUntilReady+0x88>
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    23f4:	80 91 3f 95 	lds	r24, 0x953F

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    23f8:	88 23       	and	r24, r24
    23fa:	f9 f0       	breq	.+62     	; 0x243a <Endpoint_WaitUntilReady+0x8c>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    23fc:	85 30       	cpi	r24, 0x05	; 5
    23fe:	f9 f0       	breq	.+62     	; 0x243e <Endpoint_WaitUntilReady+0x90>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    2400:	e0 91 4a 95 	lds	r30, 0x954A
    2404:	f0 91 4b 95 	lds	r31, 0x954B
    2408:	81 81       	ldd	r24, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    240a:	82 fd       	sbrc	r24, 2
    240c:	1a c0       	rjmp	.+52     	; 0x2442 <Endpoint_WaitUntilReady+0x94>
    240e:	d8 01       	movw	r26, r16
    2410:	16 96       	adiw	r26, 0x06	; 6
    2412:	ed 91       	ld	r30, X+
    2414:	fc 91       	ld	r31, X
    2416:	17 97       	sbiw	r26, 0x07	; 7
    2418:	e0 5b       	subi	r30, 0xB0	; 176
    241a:	ff 4f       	sbci	r31, 0xFF	; 255
    241c:	80 81       	ld	r24, Z
    241e:	91 81       	ldd	r25, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    2420:	c8 17       	cp	r28, r24
    2422:	d9 07       	cpc	r29, r25
    2424:	c9 f2       	breq	.-78     	; 0x23d8 <Endpoint_WaitUntilReady+0x2a>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    2426:	2f ef       	ldi	r18, 0xFF	; 255
    2428:	2f 0d       	add	r18, r15
    242a:	f1 10       	cpse	r15, r1
    242c:	d4 cf       	rjmp	.-88     	; 0x23d6 <Endpoint_WaitUntilReady+0x28>
			  return ENDPOINT_READYWAIT_Timeout;
    242e:	84 e0       	ldi	r24, 0x04	; 4
    2430:	09 c0       	rjmp	.+18     	; 0x2444 <Endpoint_WaitUntilReady+0x96>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    2432:	80 e0       	ldi	r24, 0x00	; 0
    2434:	07 c0       	rjmp	.+14     	; 0x2444 <Endpoint_WaitUntilReady+0x96>
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    2436:	80 e0       	ldi	r24, 0x00	; 0
    2438:	05 c0       	rjmp	.+10     	; 0x2444 <Endpoint_WaitUntilReady+0x96>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    243a:	82 e0       	ldi	r24, 0x02	; 2
    243c:	03 c0       	rjmp	.+6      	; 0x2444 <Endpoint_WaitUntilReady+0x96>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    243e:	83 e0       	ldi	r24, 0x03	; 3
    2440:	01 c0       	rjmp	.+2      	; 0x2444 <Endpoint_WaitUntilReady+0x96>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    2442:	81 e0       	ldi	r24, 0x01	; 1

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    2444:	df 91       	pop	r29
    2446:	cf 91       	pop	r28
    2448:	1f 91       	pop	r17
    244a:	0f 91       	pop	r16
    244c:	ff 90       	pop	r15
    244e:	08 95       	ret

00002450 <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    2450:	cf 93       	push	r28
    2452:	df 93       	push	r29
	{
		DividerIndex++;
		PrescalerNeeded >>= 1;
	}

	CLK.USBCTRL = (DividerIndex - 1) << CLK_USBPSDIV_gp;
    2454:	e0 e4       	ldi	r30, 0x40	; 64
    2456:	f0 e0       	ldi	r31, 0x00	; 0
    2458:	14 82       	std	Z+4, r1	; 0x04

	if (USB_Options & USB_OPT_PLLCLKSRC)
	  CLK.USBCTRL |= (CLK_USBSRC_PLL_gc   | CLK_USBSEN_bm);
	else
	  CLK.USBCTRL |= (CLK_USBSRC_RC32M_gc | CLK_USBSEN_bm);
    245a:	84 81       	ldd	r24, Z+4	; 0x04
    245c:	83 60       	ori	r24, 0x03	; 3
    245e:	84 83       	std	Z+4, r24	; 0x04

	USB_Device_SetDeviceAddress(0);

	USB_INT_DisableAllInterrupts();
    2460:	0e 94 86 12 	call	0x250c	; 0x250c <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    2464:	0e 94 8d 12 	call	0x251a	; 0x251a <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USB.CTRLA &= ~USB_ENABLE_bm;
    2468:	c0 ec       	ldi	r28, 0xC0	; 192
    246a:	d4 e0       	ldi	r29, 0x04	; 4
    246c:	88 81       	ld	r24, Y
    246e:	8f 77       	andi	r24, 0x7F	; 127
    2470:	88 83       	st	Y, r24
				USB.CTRLA |=  USB_ENABLE_bm;
    2472:	88 81       	ld	r24, Y
    2474:	80 68       	ori	r24, 0x80	; 128
    2476:	88 83       	st	Y, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    2478:	10 92 3f 95 	sts	0x953F, r1
	USB_Device_ConfigurationNumber  = 0;
    247c:	10 92 3b 95 	sts	0x953B, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    2480:	10 92 3d 95 	sts	0x953D, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    2484:	10 92 3c 95 	sts	0x953C, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				USB.CTRLA |=  USB_SPEED_bm;
    2488:	88 81       	ld	r24, Y
    248a:	80 64       	ori	r24, 0x40	; 64
    248c:	88 83       	st	Y, r24
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    248e:	48 e0       	ldi	r20, 0x08	; 8
    2490:	68 e4       	ldi	r22, 0x48	; 72
    2492:	80 e8       	ldi	r24, 0x80	; 128
    2494:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    2498:	48 e0       	ldi	r20, 0x08	; 8
    249a:	68 e4       	ldi	r22, 0x48	; 72
    249c:	80 e0       	ldi	r24, 0x00	; 0
    249e:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <Endpoint_ConfigureEndpoint_PRV>
			static inline void USB_INT_Enable(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						USB.INTCTRLA |= USB_BUSEVIE_bm;
    24a2:	88 85       	ldd	r24, Y+8	; 0x08
    24a4:	80 64       	ori	r24, 0x40	; 64
    24a6:	88 87       	std	Y+8, r24	; 0x08
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				USB.CTRLB |= USB_ATTACH_bm;
    24a8:	89 81       	ldd	r24, Y+1	; 0x01
    24aa:	81 60       	ori	r24, 0x01	; 1
    24ac:	89 83       	std	Y+1, r24	; 0x01
	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();

	USB_Controller_Reset();
	USB_Init_Device();
}
    24ae:	df 91       	pop	r29
    24b0:	cf 91       	pop	r28
    24b2:	08 95       	ret

000024b4 <USB_Init>:

               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
    24b4:	cf 93       	push	r28
    24b6:	df 93       	push	r29
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    24b8:	2f b7       	in	r18, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    24ba:	f8 94       	cli
	#endif

	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();

	NVM.CMD  = NVM_CMD_READ_CALIB_ROW_gc;
    24bc:	c0 ec       	ldi	r28, 0xC0	; 192
    24be:	d1 e0       	ldi	r29, 0x01	; 1
    24c0:	82 e0       	ldi	r24, 0x02	; 2
    24c2:	8a 87       	std	Y+10, r24	; 0x0a
	USB.CAL0 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL0));
    24c4:	ea e1       	ldi	r30, 0x1A	; 26
    24c6:	f0 e0       	ldi	r31, 0x00	; 0
    24c8:	e4 91       	lpm	r30, Z
    24ca:	a0 ec       	ldi	r26, 0xC0	; 192
    24cc:	b4 e0       	ldi	r27, 0x04	; 4
    24ce:	da 96       	adiw	r26, 0x3a	; 58
    24d0:	ec 93       	st	X, r30
    24d2:	da 97       	sbiw	r26, 0x3a	; 58
	USB.CAL1 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL1));
    24d4:	eb e1       	ldi	r30, 0x1B	; 27
    24d6:	f0 e0       	ldi	r31, 0x00	; 0
    24d8:	e4 91       	lpm	r30, Z
    24da:	db 96       	adiw	r26, 0x3b	; 59
    24dc:	ec 93       	st	X, r30
    24de:	db 97       	sbiw	r26, 0x3b	; 59
	NVM.CMD  = NVM_CMD_NO_OPERATION_gc;
    24e0:	1a 86       	std	Y+10, r1	; 0x0a

	/* Ugly workaround to ensure an aligned table, since __BIGGEST_ALIGNMENT__ == 1 for the 8-bit AVR-GCC toolchain */
	USB.EPPTR = ((intptr_t)&USB_EndpointTable[1] & ~(1 << 0));
    24e2:	82 ee       	ldi	r24, 0xE2	; 226
    24e4:	97 e9       	ldi	r25, 0x97	; 151
    24e6:	8e 7f       	andi	r24, 0xFE	; 254
    24e8:	16 96       	adiw	r26, 0x06	; 6
    24ea:	8d 93       	st	X+, r24
    24ec:	9c 93       	st	X, r25
    24ee:	17 97       	sbiw	r26, 0x07	; 7
	USB.CTRLA = (USB_STFRNUM_bm | ((ENDPOINT_TOTAL_ENDPOINTS - 1) << USB_MAXEP_gp));
    24f0:	84 e1       	ldi	r24, 0x14	; 20
    24f2:	8c 93       	st	X, r24

	if ((USB_Options & USB_OPT_BUSEVENT_PRIHIGH) == USB_OPT_BUSEVENT_PRIHIGH)
	  USB.INTCTRLA = (3 << USB_INTLVL_gp);
    24f4:	83 e0       	ldi	r24, 0x03	; 3
    24f6:	18 96       	adiw	r26, 0x08	; 8
    24f8:	8c 93       	st	X, r24
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    24fa:	2f bf       	out	0x3f, r18	; 63

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;
    24fc:	81 e0       	ldi	r24, 0x01	; 1
    24fe:	80 93 3e 95 	sts	0x953E, r24

	USB_ResetInterface();
    2502:	0e 94 28 12 	call	0x2450	; 0x2450 <USB_ResetInterface>
}
    2506:	df 91       	pop	r29
    2508:	cf 91       	pop	r28
    250a:	08 95       	ret

0000250c <USB_INT_DisableAllInterrupts>:
#define  __INCLUDE_FROM_USB_DRIVER
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	USB.INTCTRLA    &= USB_INTLVL_gm;
    250c:	e0 ec       	ldi	r30, 0xC0	; 192
    250e:	f4 e0       	ldi	r31, 0x04	; 4
    2510:	80 85       	ldd	r24, Z+8	; 0x08
    2512:	83 70       	andi	r24, 0x03	; 3
    2514:	80 87       	std	Z+8, r24	; 0x08
	USB.INTCTRLB     = 0;
    2516:	11 86       	std	Z+9, r1	; 0x09
    2518:	08 95       	ret

0000251a <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	USB.INTFLAGSACLR = 0xFF;
    251a:	e0 ec       	ldi	r30, 0xC0	; 192
    251c:	f4 e0       	ldi	r31, 0x04	; 4
    251e:	8f ef       	ldi	r24, 0xFF	; 255
    2520:	82 87       	std	Z+10, r24	; 0x0a
	USB.INTFLAGSBCLR = 0xFF;
    2522:	84 87       	std	Z+12, r24	; 0x0c
    2524:	08 95       	ret

00002526 <__vector_125>:
}

ISR(USB_BUSEVENT_vect)
{
    2526:	1f 92       	push	r1
    2528:	0f 92       	push	r0
    252a:	0f b6       	in	r0, 0x3f	; 63
    252c:	0f 92       	push	r0
    252e:	11 24       	eor	r1, r1
    2530:	0b b6       	in	r0, 0x3b	; 59
    2532:	0f 92       	push	r0
    2534:	2f 93       	push	r18
    2536:	3f 93       	push	r19
    2538:	4f 93       	push	r20
    253a:	5f 93       	push	r21
    253c:	6f 93       	push	r22
    253e:	7f 93       	push	r23
    2540:	8f 93       	push	r24
    2542:	9f 93       	push	r25
    2544:	af 93       	push	r26
    2546:	bf 93       	push	r27
    2548:	ef 93       	push	r30
    254a:	ff 93       	push	r31
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTFLAGSACLR & USB_SOFIF_bm) ? true : false);
    254c:	80 91 ca 04 	lds	r24, 0x04CA
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    2550:	88 23       	and	r24, r24
    2552:	4c f4       	brge	.+18     	; 0x2566 <__vector_125+0x40>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						return ((USB.INTCTRLA & USB_BUSEVIE_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTCTRLA & USB_SOFIE_bm) ? true : false);
    2554:	80 91 c8 04 	lds	r24, 0x04C8
    2558:	88 23       	and	r24, r24
    255a:	2c f4       	brge	.+10     	; 0x2566 <__vector_125+0x40>
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
						break;
					case USB_INT_SOFI:
						USB.INTFLAGSACLR = USB_SOFIF_bm;
    255c:	80 e8       	ldi	r24, 0x80	; 128
    255e:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    2562:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <USB_Event_Stub>
			static inline bool USB_INT_HasOccurred(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
    2566:	80 91 ca 04 	lds	r24, 0x04CA
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Suspend))
    256a:	86 ff       	sbrs	r24, 6
    256c:	07 c0       	rjmp	.+14     	; 0x257c <__vector_125+0x56>
			static inline void USB_INT_Clear(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
    256e:	80 e4       	ldi	r24, 0x40	; 64
    2570:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Suspend);

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    2574:	10 92 3f 95 	sts	0x953F, r1
		EVENT_USB_Device_Disconnect();
    2578:	0e 94 3b 0a 	call	0x1476	; 0x1476 <EVENT_USB_Device_Disconnect>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
    257c:	80 91 ca 04 	lds	r24, 0x04CA
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Resume))
    2580:	85 ff       	sbrs	r24, 5
    2582:	16 c0       	rjmp	.+44     	; 0x25b0 <__vector_125+0x8a>
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
    2584:	80 e2       	ldi	r24, 0x20	; 32
    2586:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Resume);

		if (USB_Device_ConfigurationNumber)
    258a:	80 91 3b 95 	lds	r24, 0x953B
    258e:	88 23       	and	r24, r24
    2590:	21 f0       	breq	.+8      	; 0x259a <__vector_125+0x74>
		  USB_DeviceState = DEVICE_STATE_Configured;
    2592:	84 e0       	ldi	r24, 0x04	; 4
    2594:	80 93 3f 95 	sts	0x953F, r24
    2598:	09 c0       	rjmp	.+18     	; 0x25ac <__vector_125+0x86>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    259a:	80 91 c3 04 	lds	r24, 0x04C3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    259e:	81 11       	cpse	r24, r1
    25a0:	02 c0       	rjmp	.+4      	; 0x25a6 <__vector_125+0x80>
    25a2:	81 e0       	ldi	r24, 0x01	; 1
    25a4:	01 c0       	rjmp	.+2      	; 0x25a8 <__vector_125+0x82>
    25a6:	83 e0       	ldi	r24, 0x03	; 3
    25a8:	80 93 3f 95 	sts	0x953F, r24

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
    25ac:	0e 94 2e 0a 	call	0x145c	; 0x145c <EVENT_USB_Device_Connect>
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
    25b0:	80 91 ca 04 	lds	r24, 0x04CA
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Reset))
    25b4:	84 ff       	sbrs	r24, 4
    25b6:	18 c0       	rjmp	.+48     	; 0x25e8 <__vector_125+0xc2>
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
    25b8:	e0 ec       	ldi	r30, 0xC0	; 192
    25ba:	f4 e0       	ldi	r31, 0x04	; 4
    25bc:	80 e1       	ldi	r24, 0x10	; 16
    25be:	82 87       	std	Z+10, r24	; 0x0a
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Reset);

		USB_DeviceState                = DEVICE_STATE_Default;
    25c0:	82 e0       	ldi	r24, 0x02	; 2
    25c2:	80 93 3f 95 	sts	0x953F, r24
		USB_Device_ConfigurationNumber = 0;
    25c6:	10 92 3b 95 	sts	0x953B, r1
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    25ca:	13 82       	std	Z+3, r1	; 0x03

		USB_Device_EnableDeviceAddress(0);

		Endpoint_ClearEndpoints();
    25cc:	0e 94 9c 11 	call	0x2338	; 0x2338 <Endpoint_ClearEndpoints>
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    25d0:	48 e0       	ldi	r20, 0x08	; 8
    25d2:	68 e4       	ldi	r22, 0x48	; 72
    25d4:	80 e8       	ldi	r24, 0x80	; 128
    25d6:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    25da:	48 e0       	ldi	r20, 0x08	; 8
    25dc:	68 e4       	ldi	r22, 0x48	; 72
    25de:	80 e0       	ldi	r24, 0x00	; 0
    25e0:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <Endpoint_ConfigureEndpoint_PRV>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           USB_Device_ControlEndpointSize, 1);

		EVENT_USB_Device_Reset();
    25e4:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <USB_Event_Stub>
	}
}
    25e8:	ff 91       	pop	r31
    25ea:	ef 91       	pop	r30
    25ec:	bf 91       	pop	r27
    25ee:	af 91       	pop	r26
    25f0:	9f 91       	pop	r25
    25f2:	8f 91       	pop	r24
    25f4:	7f 91       	pop	r23
    25f6:	6f 91       	pop	r22
    25f8:	5f 91       	pop	r21
    25fa:	4f 91       	pop	r20
    25fc:	3f 91       	pop	r19
    25fe:	2f 91       	pop	r18
    2600:	0f 90       	pop	r0
    2602:	0b be       	out	0x3b, r0	; 59
    2604:	0f 90       	pop	r0
    2606:	0f be       	out	0x3f, r0	; 63
    2608:	0f 90       	pop	r0
    260a:	1f 90       	pop	r1
    260c:	18 95       	reti

0000260e <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
    260e:	fc 01       	movw	r30, r24
    2610:	90 81       	ld	r25, Z
    2612:	90 7f       	andi	r25, 0xF0	; 240
    2614:	69 2b       	or	r22, r25
    2616:	60 83       	st	Z, r22
    2618:	08 95       	ret

0000261a <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
    261a:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    261c:	96 81       	ldd	r25, Z+6	; 0x06
    261e:	9c 7f       	andi	r25, 0xFC	; 252
    2620:	69 2b       	or	r22, r25
    2622:	66 83       	std	Z+6, r22	; 0x06
    2624:	08 95       	ret

00002626 <rtc_initialize>:
/*
 *	initialize the rtc
 */
void rtc_initialize(){
	//enabling interrupt all three level, high, mid, and low
	OSC.RC32KCAL = 0x10;//smaller, the faster the clock
    2626:	80 e1       	ldi	r24, 0x10	; 16
    2628:	80 93 54 00 	sts	0x0054, r24
	PMIC_CTRL |= (7<<0);
    262c:	e2 ea       	ldi	r30, 0xA2	; 162
    262e:	f0 e0       	ldi	r31, 0x00	; 0
    2630:	80 81       	ld	r24, Z
    2632:	87 60       	ori	r24, 0x07	; 7
    2634:	80 83       	st	Z, r24
	//selecting clock source 32.768kHz from 32.768kHz crystal oscillator on TOSC, enabling RTC clock source
	CLK_RTCCTRL = (5<<1) | (1<<0);//crystal oscillator on TOSC| enabling clock
    2636:	8b e0       	ldi	r24, 0x0B	; 11
    2638:	80 93 43 00 	sts	0x0043, r24
	//enabling interrupts for overflow
	RTC_INTCTRL	|= (0b00000001);
    263c:	e2 e0       	ldi	r30, 0x02	; 2
    263e:	f4 e0       	ldi	r31, 0x04	; 4
    2640:	80 81       	ld	r24, Z
    2642:	81 60       	ori	r24, 0x01	; 1
    2644:	80 83       	st	Z, r24
	RTC_PER = RTC_PER_VAL; //period_val  = 2
    2646:	80 e8       	ldi	r24, 0x80	; 128
    2648:	90 e0       	ldi	r25, 0x00	; 0
    264a:	80 93 0a 04 	sts	0x040A, r24
    264e:	90 93 0b 04 	sts	0x040B, r25
	//selecting clock prescaling
	RTC_CTRL = (1<<0);//no prescaling
    2652:	81 e0       	ldi	r24, 0x01	; 1
    2654:	80 93 00 04 	sts	0x0400, r24
	sei();
    2658:	78 94       	sei
    265a:	08 95       	ret

0000265c <__vector_10>:

/*
 *	interrupt service routine for overflow interrupt event
 */
ISR(RTC_OVF_vect)
{
    265c:	1f 92       	push	r1
    265e:	0f 92       	push	r0
    2660:	0f b6       	in	r0, 0x3f	; 63
    2662:	0f 92       	push	r0
    2664:	11 24       	eor	r1, r1
    2666:	0b b6       	in	r0, 0x3b	; 59
    2668:	0f 92       	push	r0
    266a:	2f 93       	push	r18
    266c:	3f 93       	push	r19
    266e:	4f 93       	push	r20
    2670:	5f 93       	push	r21
    2672:	6f 93       	push	r22
    2674:	7f 93       	push	r23
    2676:	8f 93       	push	r24
    2678:	9f 93       	push	r25
    267a:	af 93       	push	r26
    267c:	bf 93       	push	r27
    267e:	ef 93       	push	r30
    2680:	ff 93       	push	r31
	#if (USE_RTC_TICK == 1)
	rtc_tick_global++;
    2682:	80 91 39 95 	lds	r24, 0x9539
    2686:	90 91 3a 95 	lds	r25, 0x953A
    268a:	01 96       	adiw	r24, 0x01	; 1
    268c:	80 93 39 95 	sts	0x9539, r24
    2690:	90 93 3a 95 	sts	0x953A, r25
	if(rtc_tick_global>=256){
    2694:	80 91 39 95 	lds	r24, 0x9539
    2698:	90 91 3a 95 	lds	r25, 0x953A
    269c:	8f 3f       	cpi	r24, 0xFF	; 255
    269e:	91 05       	cpc	r25, r1
    26a0:	39 f0       	breq	.+14     	; 0x26b0 <__vector_10+0x54>
    26a2:	34 f0       	brlt	.+12     	; 0x26b0 <__vector_10+0x54>
		rtc_tick_global = 0;
    26a4:	10 92 39 95 	sts	0x9539, r1
    26a8:	10 92 3a 95 	sts	0x953A, r1
		system_tick();
    26ac:	0e 94 75 13 	call	0x26ea	; 0x26ea <system_tick>
	#endif
	
	
	
	
}
    26b0:	ff 91       	pop	r31
    26b2:	ef 91       	pop	r30
    26b4:	bf 91       	pop	r27
    26b6:	af 91       	pop	r26
    26b8:	9f 91       	pop	r25
    26ba:	8f 91       	pop	r24
    26bc:	7f 91       	pop	r23
    26be:	6f 91       	pop	r22
    26c0:	5f 91       	pop	r21
    26c2:	4f 91       	pop	r20
    26c4:	3f 91       	pop	r19
    26c6:	2f 91       	pop	r18
    26c8:	0f 90       	pop	r0
    26ca:	0b be       	out	0x3b, r0	; 59
    26cc:	0f 90       	pop	r0
    26ce:	0f be       	out	0x3f, r0	; 63
    26d0:	0f 90       	pop	r0
    26d2:	1f 90       	pop	r1
    26d4:	18 95       	reti

000026d6 <__vector_11>:

/*
 *	interrupt service routine for compare interrupt event
 */
ISR(RTC_COMP_vect)
{
    26d6:	1f 92       	push	r1
    26d8:	0f 92       	push	r0
    26da:	0f b6       	in	r0, 0x3f	; 63
    26dc:	0f 92       	push	r0
    26de:	11 24       	eor	r1, r1


}
    26e0:	0f 90       	pop	r0
    26e2:	0f be       	out	0x3f, r0	; 63
    26e4:	0f 90       	pop	r0
    26e6:	1f 90       	pop	r1
    26e8:	18 95       	reti

000026ea <system_tick>:

	
static char ascTimeBuffer[32];


void  system_tick(void){
    26ea:	08 95       	ret

000026ec <__udivmodsi4>:
    26ec:	a1 e2       	ldi	r26, 0x21	; 33
    26ee:	1a 2e       	mov	r1, r26
    26f0:	aa 1b       	sub	r26, r26
    26f2:	bb 1b       	sub	r27, r27
    26f4:	fd 01       	movw	r30, r26
    26f6:	0d c0       	rjmp	.+26     	; 0x2712 <__udivmodsi4_ep>

000026f8 <__udivmodsi4_loop>:
    26f8:	aa 1f       	adc	r26, r26
    26fa:	bb 1f       	adc	r27, r27
    26fc:	ee 1f       	adc	r30, r30
    26fe:	ff 1f       	adc	r31, r31
    2700:	a2 17       	cp	r26, r18
    2702:	b3 07       	cpc	r27, r19
    2704:	e4 07       	cpc	r30, r20
    2706:	f5 07       	cpc	r31, r21
    2708:	20 f0       	brcs	.+8      	; 0x2712 <__udivmodsi4_ep>
    270a:	a2 1b       	sub	r26, r18
    270c:	b3 0b       	sbc	r27, r19
    270e:	e4 0b       	sbc	r30, r20
    2710:	f5 0b       	sbc	r31, r21

00002712 <__udivmodsi4_ep>:
    2712:	66 1f       	adc	r22, r22
    2714:	77 1f       	adc	r23, r23
    2716:	88 1f       	adc	r24, r24
    2718:	99 1f       	adc	r25, r25
    271a:	1a 94       	dec	r1
    271c:	69 f7       	brne	.-38     	; 0x26f8 <__udivmodsi4_loop>
    271e:	60 95       	com	r22
    2720:	70 95       	com	r23
    2722:	80 95       	com	r24
    2724:	90 95       	com	r25
    2726:	9b 01       	movw	r18, r22
    2728:	ac 01       	movw	r20, r24
    272a:	bd 01       	movw	r22, r26
    272c:	cf 01       	movw	r24, r30
    272e:	08 95       	ret

00002730 <__tablejump2__>:
    2730:	ee 0f       	add	r30, r30
    2732:	ff 1f       	adc	r31, r31
    2734:	88 1f       	adc	r24, r24
    2736:	8b bf       	out	0x3b, r24	; 59
    2738:	07 90       	elpm	r0, Z+
    273a:	f6 91       	elpm	r31, Z
    273c:	e0 2d       	mov	r30, r0
    273e:	19 94       	eijmp

00002740 <memset>:
    2740:	dc 01       	movw	r26, r24
    2742:	01 c0       	rjmp	.+2      	; 0x2746 <memset+0x6>
    2744:	6d 93       	st	X+, r22
    2746:	41 50       	subi	r20, 0x01	; 1
    2748:	50 40       	sbci	r21, 0x00	; 0
    274a:	e0 f7       	brcc	.-8      	; 0x2744 <memset+0x4>
    274c:	08 95       	ret

0000274e <fwrite>:
    274e:	8f 92       	push	r8
    2750:	9f 92       	push	r9
    2752:	af 92       	push	r10
    2754:	bf 92       	push	r11
    2756:	cf 92       	push	r12
    2758:	df 92       	push	r13
    275a:	ef 92       	push	r14
    275c:	ff 92       	push	r15
    275e:	0f 93       	push	r16
    2760:	1f 93       	push	r17
    2762:	cf 93       	push	r28
    2764:	df 93       	push	r29
    2766:	5b 01       	movw	r10, r22
    2768:	4a 01       	movw	r8, r20
    276a:	79 01       	movw	r14, r18
    276c:	d9 01       	movw	r26, r18
    276e:	13 96       	adiw	r26, 0x03	; 3
    2770:	2c 91       	ld	r18, X
    2772:	21 ff       	sbrs	r18, 1
    2774:	1d c0       	rjmp	.+58     	; 0x27b0 <fwrite+0x62>
    2776:	c0 e0       	ldi	r28, 0x00	; 0
    2778:	d0 e0       	ldi	r29, 0x00	; 0
    277a:	c8 15       	cp	r28, r8
    277c:	d9 05       	cpc	r29, r9
    277e:	d9 f0       	breq	.+54     	; 0x27b6 <fwrite+0x68>
    2780:	8c 01       	movw	r16, r24
    2782:	6c 01       	movw	r12, r24
    2784:	ca 0c       	add	r12, r10
    2786:	db 1c       	adc	r13, r11
    2788:	c8 01       	movw	r24, r16
    278a:	0c 15       	cp	r16, r12
    278c:	1d 05       	cpc	r17, r13
    278e:	71 f0       	breq	.+28     	; 0x27ac <fwrite+0x5e>
    2790:	0f 5f       	subi	r16, 0xFF	; 255
    2792:	1f 4f       	sbci	r17, 0xFF	; 255
    2794:	d7 01       	movw	r26, r14
    2796:	18 96       	adiw	r26, 0x08	; 8
    2798:	ed 91       	ld	r30, X+
    279a:	fc 91       	ld	r31, X
    279c:	19 97       	sbiw	r26, 0x09	; 9
    279e:	b7 01       	movw	r22, r14
    27a0:	dc 01       	movw	r26, r24
    27a2:	8c 91       	ld	r24, X
    27a4:	19 95       	eicall
    27a6:	89 2b       	or	r24, r25
    27a8:	79 f3       	breq	.-34     	; 0x2788 <fwrite+0x3a>
    27aa:	05 c0       	rjmp	.+10     	; 0x27b6 <fwrite+0x68>
    27ac:	21 96       	adiw	r28, 0x01	; 1
    27ae:	e5 cf       	rjmp	.-54     	; 0x277a <fwrite+0x2c>
    27b0:	80 e0       	ldi	r24, 0x00	; 0
    27b2:	90 e0       	ldi	r25, 0x00	; 0
    27b4:	01 c0       	rjmp	.+2      	; 0x27b8 <fwrite+0x6a>
    27b6:	ce 01       	movw	r24, r28
    27b8:	df 91       	pop	r29
    27ba:	cf 91       	pop	r28
    27bc:	1f 91       	pop	r17
    27be:	0f 91       	pop	r16
    27c0:	ff 90       	pop	r15
    27c2:	ef 90       	pop	r14
    27c4:	df 90       	pop	r13
    27c6:	cf 90       	pop	r12
    27c8:	bf 90       	pop	r11
    27ca:	af 90       	pop	r10
    27cc:	9f 90       	pop	r9
    27ce:	8f 90       	pop	r8
    27d0:	08 95       	ret

000027d2 <_exit>:
    27d2:	f8 94       	cli

000027d4 <__stop_program>:
    27d4:	ff cf       	rjmp	.-2      	; 0x27d4 <__stop_program>
