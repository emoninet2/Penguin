
penguin.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000028d2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002cc  00802000  000028d2  00002966  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00007581  008022cc  008022cc  00002c32  2**0
                  ALLOC
  3 .comment      00000041  00000000  00000000  00002c32  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002c74  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a10  00000000  00000000  00002cb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000107e1  00000000  00000000  000036c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002fbb  00000000  00000000  00013ea5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006d8a  00000000  00000000  00016e60  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001b90  00000000  00000000  0001dbec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006447  00000000  00000000  0001f77c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008376  00000000  00000000  00025bc3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000c40  00000000  00000000  0002df39  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 68 01 	jmp	0x2d0	; 0x2d0 <__ctors_end>
       4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
       8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
       c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      10:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      14:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      18:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      1c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      20:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      24:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      28:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      2c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      30:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      34:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      38:	0c 94 68 03 	jmp	0x6d0	; 0x6d0 <__vector_14>
      3c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      40:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      44:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      48:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      4c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      50:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      54:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      58:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      5c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      60:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      64:	0c 94 af 12 	jmp	0x255e	; 0x255e <__vector_25>
      68:	0c 94 c3 12 	jmp	0x2586	; 0x2586 <__vector_26>
      6c:	0c 94 b9 12 	jmp	0x2572	; 0x2572 <__vector_27>
      70:	0c 94 cd 12 	jmp	0x259a	; 0x259a <__vector_28>
      74:	0c 94 e1 12 	jmp	0x25c2	; 0x25c2 <__vector_29>
      78:	0c 94 d7 12 	jmp	0x25ae	; 0x25ae <__vector_30>
      7c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      80:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      84:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      88:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      8c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      90:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      94:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      98:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      9c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      ac:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      bc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      cc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      dc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e8:	0c 94 09 13 	jmp	0x2612	; 0x2612 <__vector_58>
      ec:	0c 94 1d 13 	jmp	0x263a	; 0x263a <__vector_59>
      f0:	0c 94 13 13 	jmp	0x2626	; 0x2626 <__vector_60>
      f4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      f8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      fc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     100:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     104:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     108:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     10c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     110:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     114:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     118:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     11c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     120:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     124:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     128:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     12c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     130:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     134:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     138:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     13c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     140:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     144:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     148:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     14c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     150:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     154:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     158:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     15c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     160:	0c 94 eb 12 	jmp	0x25d6	; 0x25d6 <__vector_88>
     164:	0c 94 ff 12 	jmp	0x25fe	; 0x25fe <__vector_89>
     168:	0c 94 f5 12 	jmp	0x25ea	; 0x25ea <__vector_90>
     16c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     170:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     174:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     178:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     17c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     180:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     184:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     188:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     18c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     190:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     194:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     198:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     19c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1ac:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1bc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1cc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1dc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1ec:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1f0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1f4:	0c 94 20 0f 	jmp	0x1e40	; 0x1e40 <__vector_125>
     1f8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1fc:	f8 09       	sbc	r31, r8
     1fe:	23 0a       	sbc	r2, r19
     200:	fa 0a       	sbc	r15, r26
     202:	23 0a       	sbc	r2, r19
     204:	fa 0a       	sbc	r15, r26
     206:	5e 0a       	sbc	r5, r30
     208:	75 0a       	sbc	r7, r21
     20a:	fa 0a       	sbc	r15, r26
     20c:	cc 0a       	sbc	r12, r28
     20e:	d9 0a       	sbc	r13, r25

00000210 <__trampolines_start>:
     210:	0c 94 a3 0f 	jmp	0x1f46	; 0x1f46 <thread_2>
     214:	0c 94 5e 0a 	jmp	0x14bc	; 0x14bc <USB_Device_ProcessControlRequest+0x132>
     218:	0c 94 fa 0a 	jmp	0x15f4	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
     21c:	0c 94 21 07 	jmp	0xe42	; 0xe42 <prvIdleTask>
     220:	0c 94 23 0a 	jmp	0x1446	; 0x1446 <USB_Device_ProcessControlRequest+0xbc>
     224:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <USB_Device_ProcessControlRequest+0x66>
     228:	0c 94 94 0f 	jmp	0x1f28	; 0x1f28 <USBThread>
     22c:	0c 94 d9 0a 	jmp	0x15b2	; 0x15b2 <USB_Device_ProcessControlRequest+0x228>
     230:	0c 94 ac 0f 	jmp	0x1f58	; 0x1f58 <thread_1>
     234:	0c 94 75 0a 	jmp	0x14ea	; 0x14ea <USB_Device_ProcessControlRequest+0x160>
     238:	0c 94 cc 0a 	jmp	0x1598	; 0x1598 <USB_Device_ProcessControlRequest+0x20e>
     23c:	0c 94 fb 08 	jmp	0x11f6	; 0x11f6 <CDC_Device_getchar>
     240:	0c 94 12 08 	jmp	0x1024	; 0x1024 <CDC_Device_putchar>

00000244 <ProductString>:
     244:	1c 03 4c 00 55 00 46 00 41 00 20 00 43 00 44 00     ..L.U.F.A. .C.D.
     254:	43 00 20 00 44 00 65 00 6d 00 6f 00 00 00           C. .D.e.m.o...

00000262 <ManufacturerString>:
     262:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
     272:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

0000027c <LanguageString>:
     27c:	04 03 09 04                                         ....

00000280 <ConfigurationDescriptor>:
     280:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
     290:	01 00 05 24 00 10 01 04 24 02 06 05 24 06 00 01     ...$....$...$...
     2a0:	07 05 82 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     2b0:	07 05 04 02 10 00 05 07 05 83 02 10 00 05           ..............

000002be <DeviceDescriptor>:
     2be:	12 01 10 01 02 00 00 08 eb 03 44 20 01 00 01 02     ..........D ....
     2ce:	dc 01                                               ..

000002d0 <__ctors_end>:
     2d0:	11 24       	eor	r1, r1
     2d2:	1f be       	out	0x3f, r1	; 63
     2d4:	cf ef       	ldi	r28, 0xFF	; 255
     2d6:	cd bf       	out	0x3d, r28	; 61
     2d8:	df e9       	ldi	r29, 0x9F	; 159
     2da:	de bf       	out	0x3e, r29	; 62
     2dc:	00 e0       	ldi	r16, 0x00	; 0
     2de:	0c bf       	out	0x3c, r16	; 60

000002e0 <__do_copy_data>:
     2e0:	12 e2       	ldi	r17, 0x22	; 34
     2e2:	a0 e0       	ldi	r26, 0x00	; 0
     2e4:	b0 e2       	ldi	r27, 0x20	; 32
     2e6:	e2 ed       	ldi	r30, 0xD2	; 210
     2e8:	f8 e2       	ldi	r31, 0x28	; 40
     2ea:	00 e0       	ldi	r16, 0x00	; 0
     2ec:	0b bf       	out	0x3b, r16	; 59
     2ee:	02 c0       	rjmp	.+4      	; 0x2f4 <__do_copy_data+0x14>
     2f0:	07 90       	elpm	r0, Z+
     2f2:	0d 92       	st	X+, r0
     2f4:	ac 3c       	cpi	r26, 0xCC	; 204
     2f6:	b1 07       	cpc	r27, r17
     2f8:	d9 f7       	brne	.-10     	; 0x2f0 <__do_copy_data+0x10>

000002fa <__do_clear_bss>:
     2fa:	28 e9       	ldi	r18, 0x98	; 152
     2fc:	ac ec       	ldi	r26, 0xCC	; 204
     2fe:	b2 e2       	ldi	r27, 0x22	; 34
     300:	01 c0       	rjmp	.+2      	; 0x304 <.do_clear_bss_start>

00000302 <.do_clear_bss_loop>:
     302:	1d 92       	st	X+, r1

00000304 <.do_clear_bss_start>:
     304:	ad 34       	cpi	r26, 0x4D	; 77
     306:	b2 07       	cpc	r27, r18
     308:	e1 f7       	brne	.-8      	; 0x302 <.do_clear_bss_loop>
     30a:	0e 94 b9 11 	call	0x2372	; 0x2372 <main>
     30e:	0c 94 67 14 	jmp	0x28ce	; 0x28ce <_exit>

00000312 <__bad_interrupt>:
     312:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000316 <lcd03_arch_i2c_send>:
	lcd03_send_command(LCD03_CMD_CLEAR_COLUMN);
}
void lcd03_tab_set_size(uint8_t size){
	lcd03_send_command(LCD03_CMD_TAB_SET);
	lcd03_send_data(size);
}
     316:	0f 93       	push	r16
     318:	1f 93       	push	r17
     31a:	cf 93       	push	r28
     31c:	df 93       	push	r29
     31e:	1f 92       	push	r1
     320:	1f 92       	push	r1
     322:	cd b7       	in	r28, 0x3d	; 61
     324:	de b7       	in	r29, 0x3e	; 62
     326:	19 82       	std	Y+1, r1	; 0x01
     328:	8a 83       	std	Y+2, r24	; 0x02
     32a:	22 e0       	ldi	r18, 0x02	; 2
     32c:	ae 01       	movw	r20, r28
     32e:	4f 5f       	subi	r20, 0xFF	; 255
     330:	5f 4f       	sbci	r21, 0xFF	; 255
     332:	89 e3       	ldi	r24, 0x39	; 57
     334:	95 e9       	ldi	r25, 0x95	; 149
     336:	0e 94 bc 13 	call	0x2778	; 0x2778 <TWI_MasterWrite>
     33a:	00 00       	nop
     33c:	80 91 51 95 	lds	r24, 0x9551
     340:	81 30       	cpi	r24, 0x01	; 1
     342:	71 f0       	breq	.+28     	; 0x360 <lcd03_arch_i2c_send+0x4a>
     344:	00 ea       	ldi	r16, 0xA0	; 160
     346:	14 e0       	ldi	r17, 0x04	; 4
     348:	f8 01       	movw	r30, r16
     34a:	84 81       	ldd	r24, Z+4	; 0x04
     34c:	86 ff       	sbrs	r24, 6
     34e:	fc cf       	rjmp	.-8      	; 0x348 <lcd03_arch_i2c_send+0x32>
     350:	89 e3       	ldi	r24, 0x39	; 57
     352:	95 e9       	ldi	r25, 0x95	; 149
     354:	0e 94 c2 13 	call	0x2784	; 0x2784 <TWI_MasterWriteHandler>
     358:	80 91 51 95 	lds	r24, 0x9551
     35c:	81 30       	cpi	r24, 0x01	; 1
     35e:	a1 f7       	brne	.-24     	; 0x348 <lcd03_arch_i2c_send+0x32>
     360:	00 00       	nop
     362:	0f 90       	pop	r0
     364:	0f 90       	pop	r0
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	1f 91       	pop	r17
     36c:	0f 91       	pop	r16
     36e:	08 95       	ret

00000370 <lcd03_send_command>:
     370:	64 e6       	ldi	r22, 0x64	; 100
     372:	0e 94 8b 01 	call	0x316	; 0x316 <lcd03_arch_i2c_send>
     376:	08 95       	ret

00000378 <lcd03_backlight>:
void lcd03_backlight(bool mode){
	if(mode) {lcd03_send_command(LCD03_CMD_BACKLIGHT_ON);}
     378:	88 23       	and	r24, r24
     37a:	21 f0       	breq	.+8      	; 0x384 <lcd03_backlight+0xc>
     37c:	83 e1       	ldi	r24, 0x13	; 19
     37e:	0e 94 b8 01 	call	0x370	; 0x370 <lcd03_send_command>
     382:	08 95       	ret
	else {lcd03_send_command(LCD03_CMD_BACKLIGHT_OFF);}
     384:	84 e1       	ldi	r24, 0x14	; 20
     386:	0e 94 b8 01 	call	0x370	; 0x370 <lcd03_send_command>
     38a:	08 95       	ret

0000038c <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
     38c:	29 2f       	mov	r18, r25
     38e:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     390:	22 30       	cpi	r18, 0x02	; 2
     392:	31 05       	cpc	r19, r1
     394:	59 f0       	breq	.+22     	; 0x3ac <CALLBACK_USB_GetDescriptor+0x20>
     396:	23 30       	cpi	r18, 0x03	; 3
     398:	31 05       	cpc	r19, r1
     39a:	69 f0       	breq	.+26     	; 0x3b6 <CALLBACK_USB_GetDescriptor+0x2a>
     39c:	21 30       	cpi	r18, 0x01	; 1
     39e:	31 05       	cpc	r19, r1
     3a0:	29 f5       	brne	.+74     	; 0x3ec <CALLBACK_USB_GetDescriptor+0x60>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     3a2:	82 e1       	ldi	r24, 0x12	; 18
     3a4:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     3a6:	2e eb       	ldi	r18, 0xBE	; 190
     3a8:	32 e0       	ldi	r19, 0x02	; 2
     3aa:	29 c0       	rjmp	.+82     	; 0x3fe <CALLBACK_USB_GetDescriptor+0x72>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     3ac:	8e e3       	ldi	r24, 0x3E	; 62
     3ae:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     3b0:	20 e8       	ldi	r18, 0x80	; 128
     3b2:	32 e0       	ldi	r19, 0x02	; 2
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     3b4:	24 c0       	rjmp	.+72     	; 0x3fe <CALLBACK_USB_GetDescriptor+0x72>
     3b6:	99 27       	eor	r25, r25
		case DTYPE_String:
			switch (DescriptorNumber)
     3b8:	81 30       	cpi	r24, 0x01	; 1
     3ba:	91 05       	cpc	r25, r1
     3bc:	59 f0       	breq	.+22     	; 0x3d4 <CALLBACK_USB_GetDescriptor+0x48>
     3be:	82 30       	cpi	r24, 0x02	; 2
     3c0:	91 05       	cpc	r25, r1
     3c2:	71 f0       	breq	.+28     	; 0x3e0 <CALLBACK_USB_GetDescriptor+0x54>
     3c4:	89 2b       	or	r24, r25
     3c6:	b9 f4       	brne	.+46     	; 0x3f6 <CALLBACK_USB_GetDescriptor+0x6a>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     3c8:	ec e7       	ldi	r30, 0x7C	; 124
     3ca:	f2 e0       	ldi	r31, 0x02	; 2
     3cc:	84 91       	lpm	r24, Z
     3ce:	90 e0       	ldi	r25, 0x00	; 0
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case STRING_ID_Language:
					Address = &LanguageString;
     3d0:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
     3d2:	15 c0       	rjmp	.+42     	; 0x3fe <CALLBACK_USB_GetDescriptor+0x72>
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     3d4:	e2 e6       	ldi	r30, 0x62	; 98
     3d6:	f2 e0       	ldi	r31, 0x02	; 2
     3d8:	84 91       	lpm	r24, Z
     3da:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
     3dc:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
     3de:	0f c0       	rjmp	.+30     	; 0x3fe <CALLBACK_USB_GetDescriptor+0x72>
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     3e0:	e4 e4       	ldi	r30, 0x44	; 68
     3e2:	f2 e0       	ldi	r31, 0x02	; 2
     3e4:	84 91       	lpm	r24, Z
     3e6:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
     3e8:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
     3ea:	09 c0       	rjmp	.+18     	; 0x3fe <CALLBACK_USB_GetDescriptor+0x72>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     3ec:	80 e0       	ldi	r24, 0x00	; 0
     3ee:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     3f0:	20 e0       	ldi	r18, 0x00	; 0
     3f2:	30 e0       	ldi	r19, 0x00	; 0
     3f4:	04 c0       	rjmp	.+8      	; 0x3fe <CALLBACK_USB_GetDescriptor+0x72>
	uint16_t    Size    = NO_DESCRIPTOR;
     3f6:	80 e0       	ldi	r24, 0x00	; 0
     3f8:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     3fa:	20 e0       	ldi	r18, 0x00	; 0
     3fc:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     3fe:	fa 01       	movw	r30, r20
     400:	20 83       	st	Z, r18
     402:	31 83       	std	Z+1, r19	; 0x01
	return Size;
}
     404:	08 95       	ret

00000406 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     406:	31 e1       	ldi	r19, 0x11	; 17
     408:	fc 01       	movw	r30, r24
     40a:	30 83       	st	Z, r19
     40c:	31 97       	sbiw	r30, 0x01	; 1
     40e:	22 e2       	ldi	r18, 0x22	; 34
     410:	20 83       	st	Z, r18
     412:	31 97       	sbiw	r30, 0x01	; 1
     414:	a3 e3       	ldi	r26, 0x33	; 51
     416:	a0 83       	st	Z, r26
     418:	31 97       	sbiw	r30, 0x01	; 1
     41a:	60 83       	st	Z, r22
     41c:	31 97       	sbiw	r30, 0x01	; 1
     41e:	70 83       	st	Z, r23
     420:	31 97       	sbiw	r30, 0x01	; 1
     422:	10 82       	st	Z, r1
     424:	31 97       	sbiw	r30, 0x01	; 1
     426:	10 82       	st	Z, r1
     428:	31 97       	sbiw	r30, 0x01	; 1
     42a:	60 e8       	ldi	r22, 0x80	; 128
     42c:	60 83       	st	Z, r22
     42e:	31 97       	sbiw	r30, 0x01	; 1
     430:	10 82       	st	Z, r1
     432:	31 97       	sbiw	r30, 0x01	; 1
     434:	62 e0       	ldi	r22, 0x02	; 2
     436:	60 83       	st	Z, r22
     438:	31 97       	sbiw	r30, 0x01	; 1
     43a:	63 e0       	ldi	r22, 0x03	; 3
     43c:	60 83       	st	Z, r22
     43e:	31 97       	sbiw	r30, 0x01	; 1
     440:	64 e0       	ldi	r22, 0x04	; 4
     442:	60 83       	st	Z, r22
     444:	31 97       	sbiw	r30, 0x01	; 1
     446:	65 e0       	ldi	r22, 0x05	; 5
     448:	60 83       	st	Z, r22
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	66 e0       	ldi	r22, 0x06	; 6
     44e:	60 83       	st	Z, r22
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	67 e0       	ldi	r22, 0x07	; 7
     454:	60 83       	st	Z, r22
     456:	31 97       	sbiw	r30, 0x01	; 1
     458:	68 e0       	ldi	r22, 0x08	; 8
     45a:	60 83       	st	Z, r22
     45c:	31 97       	sbiw	r30, 0x01	; 1
     45e:	69 e0       	ldi	r22, 0x09	; 9
     460:	60 83       	st	Z, r22
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	60 e1       	ldi	r22, 0x10	; 16
     466:	60 83       	st	Z, r22
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	30 83       	st	Z, r19
     46c:	31 97       	sbiw	r30, 0x01	; 1
     46e:	32 e1       	ldi	r19, 0x12	; 18
     470:	30 83       	st	Z, r19
     472:	31 97       	sbiw	r30, 0x01	; 1
     474:	33 e1       	ldi	r19, 0x13	; 19
     476:	30 83       	st	Z, r19
     478:	31 97       	sbiw	r30, 0x01	; 1
     47a:	34 e1       	ldi	r19, 0x14	; 20
     47c:	30 83       	st	Z, r19
     47e:	31 97       	sbiw	r30, 0x01	; 1
     480:	35 e1       	ldi	r19, 0x15	; 21
     482:	30 83       	st	Z, r19
     484:	31 97       	sbiw	r30, 0x01	; 1
     486:	36 e1       	ldi	r19, 0x16	; 22
     488:	30 83       	st	Z, r19
     48a:	31 97       	sbiw	r30, 0x01	; 1
     48c:	37 e1       	ldi	r19, 0x17	; 23
     48e:	30 83       	st	Z, r19
     490:	31 97       	sbiw	r30, 0x01	; 1
     492:	38 e1       	ldi	r19, 0x18	; 24
     494:	30 83       	st	Z, r19
     496:	31 97       	sbiw	r30, 0x01	; 1
     498:	39 e1       	ldi	r19, 0x19	; 25
     49a:	30 83       	st	Z, r19
     49c:	31 97       	sbiw	r30, 0x01	; 1
     49e:	30 e2       	ldi	r19, 0x20	; 32
     4a0:	30 83       	st	Z, r19
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	31 e2       	ldi	r19, 0x21	; 33
     4a6:	30 83       	st	Z, r19
     4a8:	31 97       	sbiw	r30, 0x01	; 1
     4aa:	20 83       	st	Z, r18
     4ac:	31 97       	sbiw	r30, 0x01	; 1
     4ae:	23 e2       	ldi	r18, 0x23	; 35
     4b0:	20 83       	st	Z, r18
     4b2:	31 97       	sbiw	r30, 0x01	; 1
     4b4:	40 83       	st	Z, r20
     4b6:	31 97       	sbiw	r30, 0x01	; 1
     4b8:	50 83       	st	Z, r21
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	26 e2       	ldi	r18, 0x26	; 38
     4be:	20 83       	st	Z, r18
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	27 e2       	ldi	r18, 0x27	; 39
     4c4:	20 83       	st	Z, r18
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	28 e2       	ldi	r18, 0x28	; 40
     4ca:	20 83       	st	Z, r18
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	29 e2       	ldi	r18, 0x29	; 41
     4d0:	20 83       	st	Z, r18
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	20 e3       	ldi	r18, 0x30	; 48
     4d6:	20 83       	st	Z, r18
     4d8:	31 97       	sbiw	r30, 0x01	; 1
     4da:	21 e3       	ldi	r18, 0x31	; 49
     4dc:	20 83       	st	Z, r18
     4de:	87 97       	sbiw	r24, 0x27	; 39
     4e0:	08 95       	ret

000004e2 <xPortStartScheduler>:
     4e2:	65 e0       	ldi	r22, 0x05	; 5
     4e4:	80 e0       	ldi	r24, 0x00	; 0
     4e6:	98 e0       	ldi	r25, 0x08	; 8
     4e8:	0e 94 5b 13 	call	0x26b6	; 0x26b6 <TC0_ConfigClockSource>
     4ec:	83 ef       	ldi	r24, 0xF3	; 243
     4ee:	91 e0       	ldi	r25, 0x01	; 1
     4f0:	80 93 26 08 	sts	0x0826, r24
     4f4:	90 93 27 08 	sts	0x0827, r25
     4f8:	61 e0       	ldi	r22, 0x01	; 1
     4fa:	80 e0       	ldi	r24, 0x00	; 0
     4fc:	98 e0       	ldi	r25, 0x08	; 8
     4fe:	0e 94 61 13 	call	0x26c2	; 0x26c2 <TC0_SetOverflowIntLevel>
     502:	e0 ea       	ldi	r30, 0xA0	; 160
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	82 81       	ldd	r24, Z+2	; 0x02
     508:	81 60       	ori	r24, 0x01	; 1
     50a:	82 83       	std	Z+2, r24	; 0x02
     50c:	a0 91 27 93 	lds	r26, 0x9327
     510:	b0 91 28 93 	lds	r27, 0x9328
     514:	cd 91       	ld	r28, X+
     516:	cd bf       	out	0x3d, r28	; 61
     518:	dd 91       	ld	r29, X+
     51a:	de bf       	out	0x3e, r29	; 62
     51c:	ff 91       	pop	r31
     51e:	ef 91       	pop	r30
     520:	df 91       	pop	r29
     522:	cf 91       	pop	r28
     524:	bf 91       	pop	r27
     526:	af 91       	pop	r26
     528:	9f 91       	pop	r25
     52a:	8f 91       	pop	r24
     52c:	7f 91       	pop	r23
     52e:	6f 91       	pop	r22
     530:	5f 91       	pop	r21
     532:	4f 91       	pop	r20
     534:	3f 91       	pop	r19
     536:	2f 91       	pop	r18
     538:	1f 91       	pop	r17
     53a:	0f 91       	pop	r16
     53c:	ff 90       	pop	r15
     53e:	ef 90       	pop	r14
     540:	df 90       	pop	r13
     542:	cf 90       	pop	r12
     544:	bf 90       	pop	r11
     546:	af 90       	pop	r10
     548:	9f 90       	pop	r9
     54a:	8f 90       	pop	r8
     54c:	7f 90       	pop	r7
     54e:	6f 90       	pop	r6
     550:	5f 90       	pop	r5
     552:	4f 90       	pop	r4
     554:	3f 90       	pop	r3
     556:	2f 90       	pop	r2
     558:	1f 90       	pop	r1
     55a:	0f 90       	pop	r0
     55c:	0f be       	out	0x3f, r0	; 63
     55e:	0f 90       	pop	r0
     560:	08 95       	ret
     562:	81 e0       	ldi	r24, 0x01	; 1
     564:	08 95       	ret

00000566 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     566:	0f 92       	push	r0
     568:	0f b6       	in	r0, 0x3f	; 63
     56a:	f8 94       	cli
     56c:	0f 92       	push	r0
     56e:	1f 92       	push	r1
     570:	11 24       	eor	r1, r1
     572:	2f 92       	push	r2
     574:	3f 92       	push	r3
     576:	4f 92       	push	r4
     578:	5f 92       	push	r5
     57a:	6f 92       	push	r6
     57c:	7f 92       	push	r7
     57e:	8f 92       	push	r8
     580:	9f 92       	push	r9
     582:	af 92       	push	r10
     584:	bf 92       	push	r11
     586:	cf 92       	push	r12
     588:	df 92       	push	r13
     58a:	ef 92       	push	r14
     58c:	ff 92       	push	r15
     58e:	0f 93       	push	r16
     590:	1f 93       	push	r17
     592:	2f 93       	push	r18
     594:	3f 93       	push	r19
     596:	4f 93       	push	r20
     598:	5f 93       	push	r21
     59a:	6f 93       	push	r22
     59c:	7f 93       	push	r23
     59e:	8f 93       	push	r24
     5a0:	9f 93       	push	r25
     5a2:	af 93       	push	r26
     5a4:	bf 93       	push	r27
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	ef 93       	push	r30
     5ac:	ff 93       	push	r31
     5ae:	a0 91 27 93 	lds	r26, 0x9327
     5b2:	b0 91 28 93 	lds	r27, 0x9328
     5b6:	0d b6       	in	r0, 0x3d	; 61
     5b8:	0d 92       	st	X+, r0
     5ba:	0e b6       	in	r0, 0x3e	; 62
     5bc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5be:	0e 94 52 07 	call	0xea4	; 0xea4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5c2:	a0 91 27 93 	lds	r26, 0x9327
     5c6:	b0 91 28 93 	lds	r27, 0x9328
     5ca:	cd 91       	ld	r28, X+
     5cc:	cd bf       	out	0x3d, r28	; 61
     5ce:	dd 91       	ld	r29, X+
     5d0:	de bf       	out	0x3e, r29	; 62
     5d2:	ff 91       	pop	r31
     5d4:	ef 91       	pop	r30
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	bf 91       	pop	r27
     5dc:	af 91       	pop	r26
     5de:	9f 91       	pop	r25
     5e0:	8f 91       	pop	r24
     5e2:	7f 91       	pop	r23
     5e4:	6f 91       	pop	r22
     5e6:	5f 91       	pop	r21
     5e8:	4f 91       	pop	r20
     5ea:	3f 91       	pop	r19
     5ec:	2f 91       	pop	r18
     5ee:	1f 91       	pop	r17
     5f0:	0f 91       	pop	r16
     5f2:	ff 90       	pop	r15
     5f4:	ef 90       	pop	r14
     5f6:	df 90       	pop	r13
     5f8:	cf 90       	pop	r12
     5fa:	bf 90       	pop	r11
     5fc:	af 90       	pop	r10
     5fe:	9f 90       	pop	r9
     600:	8f 90       	pop	r8
     602:	7f 90       	pop	r7
     604:	6f 90       	pop	r6
     606:	5f 90       	pop	r5
     608:	4f 90       	pop	r4
     60a:	3f 90       	pop	r3
     60c:	2f 90       	pop	r2
     60e:	1f 90       	pop	r1
     610:	0f 90       	pop	r0
     612:	0f be       	out	0x3f, r0	; 63
     614:	0f 90       	pop	r0

	asm volatile ( "ret" );
     616:	08 95       	ret

00000618 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     618:	0f 92       	push	r0
     61a:	0f b6       	in	r0, 0x3f	; 63
     61c:	f8 94       	cli
     61e:	0f 92       	push	r0
     620:	1f 92       	push	r1
     622:	11 24       	eor	r1, r1
     624:	2f 92       	push	r2
     626:	3f 92       	push	r3
     628:	4f 92       	push	r4
     62a:	5f 92       	push	r5
     62c:	6f 92       	push	r6
     62e:	7f 92       	push	r7
     630:	8f 92       	push	r8
     632:	9f 92       	push	r9
     634:	af 92       	push	r10
     636:	bf 92       	push	r11
     638:	cf 92       	push	r12
     63a:	df 92       	push	r13
     63c:	ef 92       	push	r14
     63e:	ff 92       	push	r15
     640:	0f 93       	push	r16
     642:	1f 93       	push	r17
     644:	2f 93       	push	r18
     646:	3f 93       	push	r19
     648:	4f 93       	push	r20
     64a:	5f 93       	push	r21
     64c:	6f 93       	push	r22
     64e:	7f 93       	push	r23
     650:	8f 93       	push	r24
     652:	9f 93       	push	r25
     654:	af 93       	push	r26
     656:	bf 93       	push	r27
     658:	cf 93       	push	r28
     65a:	df 93       	push	r29
     65c:	ef 93       	push	r30
     65e:	ff 93       	push	r31
     660:	a0 91 27 93 	lds	r26, 0x9327
     664:	b0 91 28 93 	lds	r27, 0x9328
     668:	0d b6       	in	r0, 0x3d	; 61
     66a:	0d 92       	st	X+, r0
     66c:	0e b6       	in	r0, 0x3e	; 62
     66e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     670:	0e 94 c5 05 	call	0xb8a	; 0xb8a <xTaskIncrementTick>
     674:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     676:	0e 94 52 07 	call	0xea4	; 0xea4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     67a:	a0 91 27 93 	lds	r26, 0x9327
     67e:	b0 91 28 93 	lds	r27, 0x9328
     682:	cd 91       	ld	r28, X+
     684:	cd bf       	out	0x3d, r28	; 61
     686:	dd 91       	ld	r29, X+
     688:	de bf       	out	0x3e, r29	; 62
     68a:	ff 91       	pop	r31
     68c:	ef 91       	pop	r30
     68e:	df 91       	pop	r29
     690:	cf 91       	pop	r28
     692:	bf 91       	pop	r27
     694:	af 91       	pop	r26
     696:	9f 91       	pop	r25
     698:	8f 91       	pop	r24
     69a:	7f 91       	pop	r23
     69c:	6f 91       	pop	r22
     69e:	5f 91       	pop	r21
     6a0:	4f 91       	pop	r20
     6a2:	3f 91       	pop	r19
     6a4:	2f 91       	pop	r18
     6a6:	1f 91       	pop	r17
     6a8:	0f 91       	pop	r16
     6aa:	ff 90       	pop	r15
     6ac:	ef 90       	pop	r14
     6ae:	df 90       	pop	r13
     6b0:	cf 90       	pop	r12
     6b2:	bf 90       	pop	r11
     6b4:	af 90       	pop	r10
     6b6:	9f 90       	pop	r9
     6b8:	8f 90       	pop	r8
     6ba:	7f 90       	pop	r7
     6bc:	6f 90       	pop	r6
     6be:	5f 90       	pop	r5
     6c0:	4f 90       	pop	r4
     6c2:	3f 90       	pop	r3
     6c4:	2f 90       	pop	r2
     6c6:	1f 90       	pop	r1
     6c8:	0f 90       	pop	r0
     6ca:	0f be       	out	0x3f, r0	; 63
     6cc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6ce:	08 95       	ret

000006d0 <__vector_14>:
	 */
	
	void TCC0_OVF_vect( void ) __attribute__ ( ( signal, naked ) );
	void TCC0_OVF_vect( void )
	{
		vPortYieldFromTick();
     6d0:	0e 94 0c 03 	call	0x618	; 0x618 <vPortYieldFromTick>
		asm volatile ( "reti" );
     6d4:	18 95       	reti

000006d6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     6d6:	cf 93       	push	r28
     6d8:	df 93       	push	r29
     6da:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     6dc:	0e 94 bf 05 	call	0xb7e	; 0xb7e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     6e0:	80 91 cc 22 	lds	r24, 0x22CC
     6e4:	90 91 cd 22 	lds	r25, 0x22CD
     6e8:	89 2b       	or	r24, r25
     6ea:	31 f4       	brne	.+12     	; 0x6f8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     6ec:	81 ed       	ldi	r24, 0xD1	; 209
     6ee:	92 e2       	ldi	r25, 0x22	; 34
     6f0:	80 93 cc 22 	sts	0x22CC, r24
     6f4:	90 93 cd 22 	sts	0x22CD, r25
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     6f8:	20 91 ce 22 	lds	r18, 0x22CE
     6fc:	30 91 cf 22 	lds	r19, 0x22CF
     700:	ce 01       	movw	r24, r28
     702:	82 0f       	add	r24, r18
     704:	93 1f       	adc	r25, r19
     706:	8f 3f       	cpi	r24, 0xFF	; 255
     708:	4f e6       	ldi	r20, 0x6F	; 111
     70a:	94 07       	cpc	r25, r20
     70c:	70 f4       	brcc	.+28     	; 0x72a <pvPortMalloc+0x54>
     70e:	28 17       	cp	r18, r24
     710:	39 07       	cpc	r19, r25
     712:	70 f4       	brcc	.+28     	; 0x730 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     714:	c0 91 cc 22 	lds	r28, 0x22CC
     718:	d0 91 cd 22 	lds	r29, 0x22CD
     71c:	c2 0f       	add	r28, r18
     71e:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     720:	80 93 ce 22 	sts	0x22CE, r24
     724:	90 93 cf 22 	sts	0x22CF, r25
     728:	05 c0       	rjmp	.+10     	; 0x734 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     72a:	c0 e0       	ldi	r28, 0x00	; 0
     72c:	d0 e0       	ldi	r29, 0x00	; 0
     72e:	02 c0       	rjmp	.+4      	; 0x734 <pvPortMalloc+0x5e>
     730:	c0 e0       	ldi	r28, 0x00	; 0
     732:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     734:	0e 94 7f 06 	call	0xcfe	; 0xcfe <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     738:	ce 01       	movw	r24, r28
     73a:	df 91       	pop	r29
     73c:	cf 91       	pop	r28
     73e:	08 95       	ret

00000740 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     740:	08 95       	ret

00000742 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     742:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     744:	03 96       	adiw	r24, 0x03	; 3
     746:	81 83       	std	Z+1, r24	; 0x01
     748:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     74a:	2f ef       	ldi	r18, 0xFF	; 255
     74c:	3f ef       	ldi	r19, 0xFF	; 255
     74e:	23 83       	std	Z+3, r18	; 0x03
     750:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     752:	85 83       	std	Z+5, r24	; 0x05
     754:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     756:	87 83       	std	Z+7, r24	; 0x07
     758:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     75a:	10 82       	st	Z, r1
     75c:	08 95       	ret

0000075e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     75e:	fc 01       	movw	r30, r24
     760:	10 86       	std	Z+8, r1	; 0x08
     762:	11 86       	std	Z+9, r1	; 0x09
     764:	08 95       	ret

00000766 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	9c 01       	movw	r18, r24
     76c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     76e:	dc 01       	movw	r26, r24
     770:	11 96       	adiw	r26, 0x01	; 1
     772:	cd 91       	ld	r28, X+
     774:	dc 91       	ld	r29, X
     776:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     778:	c2 83       	std	Z+2, r28	; 0x02
     77a:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     77c:	8c 81       	ldd	r24, Y+4	; 0x04
     77e:	9d 81       	ldd	r25, Y+5	; 0x05
     780:	84 83       	std	Z+4, r24	; 0x04
     782:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     784:	8c 81       	ldd	r24, Y+4	; 0x04
     786:	9d 81       	ldd	r25, Y+5	; 0x05
     788:	dc 01       	movw	r26, r24
     78a:	12 96       	adiw	r26, 0x02	; 2
     78c:	6d 93       	st	X+, r22
     78e:	7c 93       	st	X, r23
     790:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
     792:	6c 83       	std	Y+4, r22	; 0x04
     794:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     796:	20 87       	std	Z+8, r18	; 0x08
     798:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
     79a:	f9 01       	movw	r30, r18
     79c:	80 81       	ld	r24, Z
     79e:	8f 5f       	subi	r24, 0xFF	; 255
     7a0:	80 83       	st	Z, r24
}
     7a2:	df 91       	pop	r29
     7a4:	cf 91       	pop	r28
     7a6:	08 95       	ret

000007a8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     7ae:	48 81       	ld	r20, Y
     7b0:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     7b2:	4f 3f       	cpi	r20, 0xFF	; 255
     7b4:	2f ef       	ldi	r18, 0xFF	; 255
     7b6:	52 07       	cpc	r21, r18
     7b8:	21 f4       	brne	.+8      	; 0x7c2 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     7ba:	fc 01       	movw	r30, r24
     7bc:	a7 81       	ldd	r26, Z+7	; 0x07
     7be:	b0 85       	ldd	r27, Z+8	; 0x08
     7c0:	0d c0       	rjmp	.+26     	; 0x7dc <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7c2:	dc 01       	movw	r26, r24
     7c4:	13 96       	adiw	r26, 0x03	; 3
     7c6:	01 c0       	rjmp	.+2      	; 0x7ca <vListInsert+0x22>
     7c8:	df 01       	movw	r26, r30
     7ca:	12 96       	adiw	r26, 0x02	; 2
     7cc:	ed 91       	ld	r30, X+
     7ce:	fc 91       	ld	r31, X
     7d0:	13 97       	sbiw	r26, 0x03	; 3
     7d2:	20 81       	ld	r18, Z
     7d4:	31 81       	ldd	r19, Z+1	; 0x01
     7d6:	42 17       	cp	r20, r18
     7d8:	53 07       	cpc	r21, r19
     7da:	b0 f7       	brcc	.-20     	; 0x7c8 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     7dc:	12 96       	adiw	r26, 0x02	; 2
     7de:	ed 91       	ld	r30, X+
     7e0:	fc 91       	ld	r31, X
     7e2:	13 97       	sbiw	r26, 0x03	; 3
     7e4:	ea 83       	std	Y+2, r30	; 0x02
     7e6:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     7e8:	c4 83       	std	Z+4, r28	; 0x04
     7ea:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
     7ec:	ac 83       	std	Y+4, r26	; 0x04
     7ee:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
     7f0:	12 96       	adiw	r26, 0x02	; 2
     7f2:	cd 93       	st	X+, r28
     7f4:	dc 93       	st	X, r29
     7f6:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7f8:	88 87       	std	Y+8, r24	; 0x08
     7fa:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
     7fc:	fc 01       	movw	r30, r24
     7fe:	20 81       	ld	r18, Z
     800:	2f 5f       	subi	r18, 0xFF	; 255
     802:	20 83       	st	Z, r18
}
     804:	df 91       	pop	r29
     806:	cf 91       	pop	r28
     808:	08 95       	ret

0000080a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     80a:	cf 93       	push	r28
     80c:	df 93       	push	r29
     80e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     810:	a0 85       	ldd	r26, Z+8	; 0x08
     812:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     814:	c2 81       	ldd	r28, Z+2	; 0x02
     816:	d3 81       	ldd	r29, Z+3	; 0x03
     818:	84 81       	ldd	r24, Z+4	; 0x04
     81a:	95 81       	ldd	r25, Z+5	; 0x05
     81c:	8c 83       	std	Y+4, r24	; 0x04
     81e:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     820:	c4 81       	ldd	r28, Z+4	; 0x04
     822:	d5 81       	ldd	r29, Z+5	; 0x05
     824:	82 81       	ldd	r24, Z+2	; 0x02
     826:	93 81       	ldd	r25, Z+3	; 0x03
     828:	8a 83       	std	Y+2, r24	; 0x02
     82a:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     82c:	11 96       	adiw	r26, 0x01	; 1
     82e:	cd 91       	ld	r28, X+
     830:	dc 91       	ld	r29, X
     832:	12 97       	sbiw	r26, 0x02	; 2
     834:	ce 17       	cp	r28, r30
     836:	df 07       	cpc	r29, r31
     838:	31 f4       	brne	.+12     	; 0x846 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     83a:	8c 81       	ldd	r24, Y+4	; 0x04
     83c:	9d 81       	ldd	r25, Y+5	; 0x05
     83e:	11 96       	adiw	r26, 0x01	; 1
     840:	8d 93       	st	X+, r24
     842:	9c 93       	st	X, r25
     844:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     846:	10 86       	std	Z+8, r1	; 0x08
     848:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
     84a:	8c 91       	ld	r24, X
     84c:	81 50       	subi	r24, 0x01	; 1
     84e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     850:	df 91       	pop	r29
     852:	cf 91       	pop	r28
     854:	08 95       	ret

00000856 <prvResetNextTaskUnblockTime>:
			}
		}
		( void ) xTaskResumeAll();

		return uxTask;
	}
     856:	e0 91 ef 92 	lds	r30, 0x92EF
     85a:	f0 91 f0 92 	lds	r31, 0x92F0
     85e:	80 81       	ld	r24, Z
     860:	81 11       	cpse	r24, r1
     862:	07 c0       	rjmp	.+14     	; 0x872 <prvResetNextTaskUnblockTime+0x1c>
     864:	8f ef       	ldi	r24, 0xFF	; 255
     866:	9f ef       	ldi	r25, 0xFF	; 255
     868:	80 93 89 22 	sts	0x2289, r24
     86c:	90 93 8a 22 	sts	0x228A, r25
     870:	08 95       	ret
     872:	e0 91 ef 92 	lds	r30, 0x92EF
     876:	f0 91 f0 92 	lds	r31, 0x92F0
     87a:	05 80       	ldd	r0, Z+5	; 0x05
     87c:	f6 81       	ldd	r31, Z+6	; 0x06
     87e:	e0 2d       	mov	r30, r0
     880:	06 80       	ldd	r0, Z+6	; 0x06
     882:	f7 81       	ldd	r31, Z+7	; 0x07
     884:	e0 2d       	mov	r30, r0
     886:	82 81       	ldd	r24, Z+2	; 0x02
     888:	93 81       	ldd	r25, Z+3	; 0x03
     88a:	80 93 89 22 	sts	0x2289, r24
     88e:	90 93 8a 22 	sts	0x228A, r25
     892:	08 95       	ret

00000894 <prvAddCurrentTaskToDelayedList>:
     894:	cf 93       	push	r28
     896:	df 93       	push	r29
     898:	ec 01       	movw	r28, r24
     89a:	e0 91 27 93 	lds	r30, 0x9327
     89e:	f0 91 28 93 	lds	r31, 0x9328
     8a2:	82 83       	std	Z+2, r24	; 0x02
     8a4:	93 83       	std	Z+3, r25	; 0x03
     8a6:	80 91 d7 92 	lds	r24, 0x92D7
     8aa:	90 91 d8 92 	lds	r25, 0x92D8
     8ae:	c8 17       	cp	r28, r24
     8b0:	d9 07       	cpc	r29, r25
     8b2:	68 f4       	brcc	.+26     	; 0x8ce <prvAddCurrentTaskToDelayedList+0x3a>
     8b4:	60 91 27 93 	lds	r22, 0x9327
     8b8:	70 91 28 93 	lds	r23, 0x9328
     8bc:	80 91 ed 92 	lds	r24, 0x92ED
     8c0:	90 91 ee 92 	lds	r25, 0x92EE
     8c4:	6e 5f       	subi	r22, 0xFE	; 254
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vListInsert>
     8cc:	17 c0       	rjmp	.+46     	; 0x8fc <prvAddCurrentTaskToDelayedList+0x68>
     8ce:	60 91 27 93 	lds	r22, 0x9327
     8d2:	70 91 28 93 	lds	r23, 0x9328
     8d6:	80 91 ef 92 	lds	r24, 0x92EF
     8da:	90 91 f0 92 	lds	r25, 0x92F0
     8de:	6e 5f       	subi	r22, 0xFE	; 254
     8e0:	7f 4f       	sbci	r23, 0xFF	; 255
     8e2:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vListInsert>
     8e6:	80 91 89 22 	lds	r24, 0x2289
     8ea:	90 91 8a 22 	lds	r25, 0x228A
     8ee:	c8 17       	cp	r28, r24
     8f0:	d9 07       	cpc	r29, r25
     8f2:	20 f4       	brcc	.+8      	; 0x8fc <prvAddCurrentTaskToDelayedList+0x68>
     8f4:	c0 93 89 22 	sts	0x2289, r28
     8f8:	d0 93 8a 22 	sts	0x228A, r29
     8fc:	df 91       	pop	r29
     8fe:	cf 91       	pop	r28
     900:	08 95       	ret

00000902 <xTaskGenericCreate>:
     902:	4f 92       	push	r4
     904:	5f 92       	push	r5
     906:	6f 92       	push	r6
     908:	7f 92       	push	r7
     90a:	8f 92       	push	r8
     90c:	9f 92       	push	r9
     90e:	af 92       	push	r10
     910:	bf 92       	push	r11
     912:	cf 92       	push	r12
     914:	df 92       	push	r13
     916:	ef 92       	push	r14
     918:	ff 92       	push	r15
     91a:	0f 93       	push	r16
     91c:	1f 93       	push	r17
     91e:	cf 93       	push	r28
     920:	df 93       	push	r29
     922:	4c 01       	movw	r8, r24
     924:	eb 01       	movw	r28, r22
     926:	5a 01       	movw	r10, r20
     928:	29 01       	movw	r4, r18
     92a:	83 e2       	ldi	r24, 0x23	; 35
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <pvPortMalloc>
     932:	3c 01       	movw	r6, r24
     934:	00 97       	sbiw	r24, 0x00	; 0
     936:	09 f4       	brne	.+2      	; 0x93a <xTaskGenericCreate+0x38>
     938:	e5 c0       	rjmp	.+458    	; 0xb04 <xTaskGenericCreate+0x202>
     93a:	c1 14       	cp	r12, r1
     93c:	d1 04       	cpc	r13, r1
     93e:	09 f0       	breq	.+2      	; 0x942 <xTaskGenericCreate+0x40>
     940:	dc c0       	rjmp	.+440    	; 0xafa <xTaskGenericCreate+0x1f8>
     942:	c5 01       	movw	r24, r10
     944:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <pvPortMalloc>
     948:	f3 01       	movw	r30, r6
     94a:	87 8b       	std	Z+23, r24	; 0x17
     94c:	90 8f       	std	Z+24, r25	; 0x18
     94e:	00 97       	sbiw	r24, 0x00	; 0
     950:	21 f4       	brne	.+8      	; 0x95a <xTaskGenericCreate+0x58>
     952:	c3 01       	movw	r24, r6
     954:	0e 94 a0 03 	call	0x740	; 0x740 <vPortFree>
     958:	d5 c0       	rjmp	.+426    	; 0xb04 <xTaskGenericCreate+0x202>
     95a:	a5 01       	movw	r20, r10
     95c:	65 ea       	ldi	r22, 0xA5	; 165
     95e:	70 e0       	ldi	r23, 0x00	; 0
     960:	0e 94 1e 14 	call	0x283c	; 0x283c <memset>
     964:	f1 e0       	ldi	r31, 0x01	; 1
     966:	af 1a       	sub	r10, r31
     968:	b1 08       	sbc	r11, r1
     96a:	f3 01       	movw	r30, r6
     96c:	87 89       	ldd	r24, Z+23	; 0x17
     96e:	90 8d       	ldd	r25, Z+24	; 0x18
     970:	a8 0e       	add	r10, r24
     972:	b9 1e       	adc	r11, r25
     974:	88 81       	ld	r24, Y
     976:	81 8f       	std	Z+25, r24	; 0x19
     978:	88 81       	ld	r24, Y
     97a:	88 23       	and	r24, r24
     97c:	81 f0       	breq	.+32     	; 0x99e <xTaskGenericCreate+0x9c>
     97e:	d3 01       	movw	r26, r6
     980:	5a 96       	adiw	r26, 0x1a	; 26
     982:	fe 01       	movw	r30, r28
     984:	31 96       	adiw	r30, 0x01	; 1
     986:	9e 01       	movw	r18, r28
     988:	28 5f       	subi	r18, 0xF8	; 248
     98a:	3f 4f       	sbci	r19, 0xFF	; 255
     98c:	ef 01       	movw	r28, r30
     98e:	81 91       	ld	r24, Z+
     990:	8d 93       	st	X+, r24
     992:	88 81       	ld	r24, Y
     994:	88 23       	and	r24, r24
     996:	19 f0       	breq	.+6      	; 0x99e <xTaskGenericCreate+0x9c>
     998:	e2 17       	cp	r30, r18
     99a:	f3 07       	cpc	r31, r19
     99c:	b9 f7       	brne	.-18     	; 0x98c <xTaskGenericCreate+0x8a>
     99e:	f3 01       	movw	r30, r6
     9a0:	10 a2       	std	Z+32, r1	; 0x20
     9a2:	10 2f       	mov	r17, r16
     9a4:	04 30       	cpi	r16, 0x04	; 4
     9a6:	08 f0       	brcs	.+2      	; 0x9aa <xTaskGenericCreate+0xa8>
     9a8:	13 e0       	ldi	r17, 0x03	; 3
     9aa:	f3 01       	movw	r30, r6
     9ac:	16 8b       	std	Z+22, r17	; 0x16
     9ae:	e3 01       	movw	r28, r6
     9b0:	22 96       	adiw	r28, 0x02	; 2
     9b2:	ce 01       	movw	r24, r28
     9b4:	0e 94 af 03 	call	0x75e	; 0x75e <vListInitialiseItem>
     9b8:	c3 01       	movw	r24, r6
     9ba:	0c 96       	adiw	r24, 0x0c	; 12
     9bc:	0e 94 af 03 	call	0x75e	; 0x75e <vListInitialiseItem>
     9c0:	f3 01       	movw	r30, r6
     9c2:	60 86       	std	Z+8, r6	; 0x08
     9c4:	71 86       	std	Z+9, r7	; 0x09
     9c6:	84 e0       	ldi	r24, 0x04	; 4
     9c8:	90 e0       	ldi	r25, 0x00	; 0
     9ca:	81 1b       	sub	r24, r17
     9cc:	91 09       	sbc	r25, r1
     9ce:	84 87       	std	Z+12, r24	; 0x0c
     9d0:	95 87       	std	Z+13, r25	; 0x0d
     9d2:	62 8a       	std	Z+18, r6	; 0x12
     9d4:	73 8a       	std	Z+19, r7	; 0x13
     9d6:	a2 01       	movw	r20, r4
     9d8:	b4 01       	movw	r22, r8
     9da:	c5 01       	movw	r24, r10
     9dc:	0e 94 03 02 	call	0x406	; 0x406 <pxPortInitialiseStack>
     9e0:	f3 01       	movw	r30, r6
     9e2:	80 83       	st	Z, r24
     9e4:	91 83       	std	Z+1, r25	; 0x01
     9e6:	e1 14       	cp	r14, r1
     9e8:	f1 04       	cpc	r15, r1
     9ea:	19 f0       	breq	.+6      	; 0x9f2 <xTaskGenericCreate+0xf0>
     9ec:	f7 01       	movw	r30, r14
     9ee:	60 82       	st	Z, r6
     9f0:	71 82       	std	Z+1, r7	; 0x01
     9f2:	0f b6       	in	r0, 0x3f	; 63
     9f4:	f8 94       	cli
     9f6:	0f 92       	push	r0
     9f8:	80 91 d9 92 	lds	r24, 0x92D9
     9fc:	8f 5f       	subi	r24, 0xFF	; 255
     9fe:	80 93 d9 92 	sts	0x92D9, r24
     a02:	80 91 27 93 	lds	r24, 0x9327
     a06:	90 91 28 93 	lds	r25, 0x9328
     a0a:	89 2b       	or	r24, r25
     a0c:	a9 f5       	brne	.+106    	; 0xa78 <xTaskGenericCreate+0x176>
     a0e:	60 92 27 93 	sts	0x9327, r6
     a12:	70 92 28 93 	sts	0x9328, r7
     a16:	80 91 d9 92 	lds	r24, 0x92D9
     a1a:	81 30       	cpi	r24, 0x01	; 1
     a1c:	e1 f5       	brne	.+120    	; 0xa96 <xTaskGenericCreate+0x194>
     a1e:	83 e0       	ldi	r24, 0x03	; 3
     a20:	93 e9       	ldi	r25, 0x93	; 147
     a22:	0e 94 a1 03 	call	0x742	; 0x742 <vListInitialise>
     a26:	8c e0       	ldi	r24, 0x0C	; 12
     a28:	93 e9       	ldi	r25, 0x93	; 147
     a2a:	0e 94 a1 03 	call	0x742	; 0x742 <vListInitialise>
     a2e:	85 e1       	ldi	r24, 0x15	; 21
     a30:	93 e9       	ldi	r25, 0x93	; 147
     a32:	0e 94 a1 03 	call	0x742	; 0x742 <vListInitialise>
     a36:	8e e1       	ldi	r24, 0x1E	; 30
     a38:	93 e9       	ldi	r25, 0x93	; 147
     a3a:	0e 94 a1 03 	call	0x742	; 0x742 <vListInitialise>
     a3e:	8a ef       	ldi	r24, 0xFA	; 250
     a40:	92 e9       	ldi	r25, 0x92	; 146
     a42:	0e 94 a1 03 	call	0x742	; 0x742 <vListInitialise>
     a46:	81 ef       	ldi	r24, 0xF1	; 241
     a48:	92 e9       	ldi	r25, 0x92	; 146
     a4a:	0e 94 a1 03 	call	0x742	; 0x742 <vListInitialise>
     a4e:	84 ee       	ldi	r24, 0xE4	; 228
     a50:	92 e9       	ldi	r25, 0x92	; 146
     a52:	0e 94 a1 03 	call	0x742	; 0x742 <vListInitialise>
     a56:	8b ed       	ldi	r24, 0xDB	; 219
     a58:	92 e9       	ldi	r25, 0x92	; 146
     a5a:	0e 94 a1 03 	call	0x742	; 0x742 <vListInitialise>
     a5e:	8a ef       	ldi	r24, 0xFA	; 250
     a60:	92 e9       	ldi	r25, 0x92	; 146
     a62:	80 93 ef 92 	sts	0x92EF, r24
     a66:	90 93 f0 92 	sts	0x92F0, r25
     a6a:	81 ef       	ldi	r24, 0xF1	; 241
     a6c:	92 e9       	ldi	r25, 0x92	; 146
     a6e:	80 93 ed 92 	sts	0x92ED, r24
     a72:	90 93 ee 92 	sts	0x92EE, r25
     a76:	0f c0       	rjmp	.+30     	; 0xa96 <xTaskGenericCreate+0x194>
     a78:	80 91 d5 92 	lds	r24, 0x92D5
     a7c:	81 11       	cpse	r24, r1
     a7e:	0b c0       	rjmp	.+22     	; 0xa96 <xTaskGenericCreate+0x194>
     a80:	e0 91 27 93 	lds	r30, 0x9327
     a84:	f0 91 28 93 	lds	r31, 0x9328
     a88:	86 89       	ldd	r24, Z+22	; 0x16
     a8a:	08 17       	cp	r16, r24
     a8c:	20 f0       	brcs	.+8      	; 0xa96 <xTaskGenericCreate+0x194>
     a8e:	60 92 27 93 	sts	0x9327, r6
     a92:	70 92 28 93 	sts	0x9328, r7
     a96:	80 91 d1 92 	lds	r24, 0x92D1
     a9a:	8f 5f       	subi	r24, 0xFF	; 255
     a9c:	80 93 d1 92 	sts	0x92D1, r24
     aa0:	f3 01       	movw	r30, r6
     aa2:	81 a3       	std	Z+33, r24	; 0x21
     aa4:	86 89       	ldd	r24, Z+22	; 0x16
     aa6:	90 91 d6 92 	lds	r25, 0x92D6
     aaa:	98 17       	cp	r25, r24
     aac:	10 f4       	brcc	.+4      	; 0xab2 <xTaskGenericCreate+0x1b0>
     aae:	80 93 d6 92 	sts	0x92D6, r24
     ab2:	90 e0       	ldi	r25, 0x00	; 0
     ab4:	9c 01       	movw	r18, r24
     ab6:	22 0f       	add	r18, r18
     ab8:	33 1f       	adc	r19, r19
     aba:	22 0f       	add	r18, r18
     abc:	33 1f       	adc	r19, r19
     abe:	22 0f       	add	r18, r18
     ac0:	33 1f       	adc	r19, r19
     ac2:	82 0f       	add	r24, r18
     ac4:	93 1f       	adc	r25, r19
     ac6:	be 01       	movw	r22, r28
     ac8:	8d 5f       	subi	r24, 0xFD	; 253
     aca:	9c 46       	sbci	r25, 0x6C	; 108
     acc:	0e 94 b3 03 	call	0x766	; 0x766 <vListInsertEnd>
     ad0:	0f 90       	pop	r0
     ad2:	0f be       	out	0x3f, r0	; 63
     ad4:	80 91 d5 92 	lds	r24, 0x92D5
     ad8:	88 23       	and	r24, r24
     ada:	59 f0       	breq	.+22     	; 0xaf2 <xTaskGenericCreate+0x1f0>
     adc:	e0 91 27 93 	lds	r30, 0x9327
     ae0:	f0 91 28 93 	lds	r31, 0x9328
     ae4:	86 89       	ldd	r24, Z+22	; 0x16
     ae6:	80 17       	cp	r24, r16
     ae8:	30 f4       	brcc	.+12     	; 0xaf6 <xTaskGenericCreate+0x1f4>
     aea:	0e 94 b3 02 	call	0x566	; 0x566 <vPortYield>
     aee:	81 e0       	ldi	r24, 0x01	; 1
     af0:	0a c0       	rjmp	.+20     	; 0xb06 <xTaskGenericCreate+0x204>
     af2:	81 e0       	ldi	r24, 0x01	; 1
     af4:	08 c0       	rjmp	.+16     	; 0xb06 <xTaskGenericCreate+0x204>
     af6:	81 e0       	ldi	r24, 0x01	; 1
     af8:	06 c0       	rjmp	.+12     	; 0xb06 <xTaskGenericCreate+0x204>
     afa:	fc 01       	movw	r30, r24
     afc:	c7 8a       	std	Z+23, r12	; 0x17
     afe:	d0 8e       	std	Z+24, r13	; 0x18
     b00:	c6 01       	movw	r24, r12
     b02:	2b cf       	rjmp	.-426    	; 0x95a <xTaskGenericCreate+0x58>
     b04:	8f ef       	ldi	r24, 0xFF	; 255
     b06:	df 91       	pop	r29
     b08:	cf 91       	pop	r28
     b0a:	1f 91       	pop	r17
     b0c:	0f 91       	pop	r16
     b0e:	ff 90       	pop	r15
     b10:	ef 90       	pop	r14
     b12:	df 90       	pop	r13
     b14:	cf 90       	pop	r12
     b16:	bf 90       	pop	r11
     b18:	af 90       	pop	r10
     b1a:	9f 90       	pop	r9
     b1c:	8f 90       	pop	r8
     b1e:	7f 90       	pop	r7
     b20:	6f 90       	pop	r6
     b22:	5f 90       	pop	r5
     b24:	4f 90       	pop	r4
     b26:	08 95       	ret

00000b28 <vTaskStartScheduler>:
     b28:	af 92       	push	r10
     b2a:	bf 92       	push	r11
     b2c:	cf 92       	push	r12
     b2e:	df 92       	push	r13
     b30:	ef 92       	push	r14
     b32:	ff 92       	push	r15
     b34:	0f 93       	push	r16
     b36:	a1 2c       	mov	r10, r1
     b38:	b1 2c       	mov	r11, r1
     b3a:	c1 2c       	mov	r12, r1
     b3c:	d1 2c       	mov	r13, r1
     b3e:	e1 2c       	mov	r14, r1
     b40:	f1 2c       	mov	r15, r1
     b42:	00 e0       	ldi	r16, 0x00	; 0
     b44:	20 e0       	ldi	r18, 0x00	; 0
     b46:	30 e0       	ldi	r19, 0x00	; 0
     b48:	45 e5       	ldi	r20, 0x55	; 85
     b4a:	50 e0       	ldi	r21, 0x00	; 0
     b4c:	6c ea       	ldi	r22, 0xAC	; 172
     b4e:	72 e2       	ldi	r23, 0x22	; 34
     b50:	81 e2       	ldi	r24, 0x21	; 33
     b52:	97 e0       	ldi	r25, 0x07	; 7
     b54:	0e 94 81 04 	call	0x902	; 0x902 <xTaskGenericCreate>
     b58:	81 30       	cpi	r24, 0x01	; 1
     b5a:	49 f4       	brne	.+18     	; 0xb6e <vTaskStartScheduler+0x46>
     b5c:	f8 94       	cli
     b5e:	80 93 d5 92 	sts	0x92D5, r24
     b62:	10 92 d7 92 	sts	0x92D7, r1
     b66:	10 92 d8 92 	sts	0x92D8, r1
     b6a:	0e 94 71 02 	call	0x4e2	; 0x4e2 <xPortStartScheduler>
     b6e:	0f 91       	pop	r16
     b70:	ff 90       	pop	r15
     b72:	ef 90       	pop	r14
     b74:	df 90       	pop	r13
     b76:	cf 90       	pop	r12
     b78:	bf 90       	pop	r11
     b7a:	af 90       	pop	r10
     b7c:	08 95       	ret

00000b7e <vTaskSuspendAll>:
     b7e:	80 91 d0 92 	lds	r24, 0x92D0
     b82:	8f 5f       	subi	r24, 0xFF	; 255
     b84:	80 93 d0 92 	sts	0x92D0, r24
     b88:	08 95       	ret

00000b8a <xTaskIncrementTick>:
     b8a:	df 92       	push	r13
     b8c:	ef 92       	push	r14
     b8e:	ff 92       	push	r15
     b90:	0f 93       	push	r16
     b92:	1f 93       	push	r17
     b94:	cf 93       	push	r28
     b96:	df 93       	push	r29
     b98:	80 91 d0 92 	lds	r24, 0x92D0
     b9c:	81 11       	cpse	r24, r1
     b9e:	9a c0       	rjmp	.+308    	; 0xcd4 <xTaskIncrementTick+0x14a>
     ba0:	80 91 d7 92 	lds	r24, 0x92D7
     ba4:	90 91 d8 92 	lds	r25, 0x92D8
     ba8:	01 96       	adiw	r24, 0x01	; 1
     baa:	80 93 d7 92 	sts	0x92D7, r24
     bae:	90 93 d8 92 	sts	0x92D8, r25
     bb2:	e0 90 d7 92 	lds	r14, 0x92D7
     bb6:	f0 90 d8 92 	lds	r15, 0x92D8
     bba:	e1 14       	cp	r14, r1
     bbc:	f1 04       	cpc	r15, r1
     bbe:	b9 f4       	brne	.+46     	; 0xbee <xTaskIncrementTick+0x64>
     bc0:	80 91 ef 92 	lds	r24, 0x92EF
     bc4:	90 91 f0 92 	lds	r25, 0x92F0
     bc8:	20 91 ed 92 	lds	r18, 0x92ED
     bcc:	30 91 ee 92 	lds	r19, 0x92EE
     bd0:	20 93 ef 92 	sts	0x92EF, r18
     bd4:	30 93 f0 92 	sts	0x92F0, r19
     bd8:	80 93 ed 92 	sts	0x92ED, r24
     bdc:	90 93 ee 92 	sts	0x92EE, r25
     be0:	80 91 d2 92 	lds	r24, 0x92D2
     be4:	8f 5f       	subi	r24, 0xFF	; 255
     be6:	80 93 d2 92 	sts	0x92D2, r24
     bea:	0e 94 2b 04 	call	0x856	; 0x856 <prvResetNextTaskUnblockTime>
     bee:	80 91 89 22 	lds	r24, 0x2289
     bf2:	90 91 8a 22 	lds	r25, 0x228A
     bf6:	e8 16       	cp	r14, r24
     bf8:	f9 06       	cpc	r15, r25
     bfa:	10 f4       	brcc	.+4      	; 0xc00 <xTaskIncrementTick+0x76>
     bfc:	d1 2c       	mov	r13, r1
     bfe:	52 c0       	rjmp	.+164    	; 0xca4 <xTaskIncrementTick+0x11a>
     c00:	d1 2c       	mov	r13, r1
     c02:	e0 91 ef 92 	lds	r30, 0x92EF
     c06:	f0 91 f0 92 	lds	r31, 0x92F0
     c0a:	90 81       	ld	r25, Z
     c0c:	91 11       	cpse	r25, r1
     c0e:	07 c0       	rjmp	.+14     	; 0xc1e <xTaskIncrementTick+0x94>
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	9f ef       	ldi	r25, 0xFF	; 255
     c14:	80 93 89 22 	sts	0x2289, r24
     c18:	90 93 8a 22 	sts	0x228A, r25
     c1c:	43 c0       	rjmp	.+134    	; 0xca4 <xTaskIncrementTick+0x11a>
     c1e:	e0 91 ef 92 	lds	r30, 0x92EF
     c22:	f0 91 f0 92 	lds	r31, 0x92F0
     c26:	05 80       	ldd	r0, Z+5	; 0x05
     c28:	f6 81       	ldd	r31, Z+6	; 0x06
     c2a:	e0 2d       	mov	r30, r0
     c2c:	c6 81       	ldd	r28, Z+6	; 0x06
     c2e:	d7 81       	ldd	r29, Z+7	; 0x07
     c30:	2a 81       	ldd	r18, Y+2	; 0x02
     c32:	3b 81       	ldd	r19, Y+3	; 0x03
     c34:	e2 16       	cp	r14, r18
     c36:	f3 06       	cpc	r15, r19
     c38:	28 f4       	brcc	.+10     	; 0xc44 <xTaskIncrementTick+0xba>
     c3a:	20 93 89 22 	sts	0x2289, r18
     c3e:	30 93 8a 22 	sts	0x228A, r19
     c42:	30 c0       	rjmp	.+96     	; 0xca4 <xTaskIncrementTick+0x11a>
     c44:	8e 01       	movw	r16, r28
     c46:	0e 5f       	subi	r16, 0xFE	; 254
     c48:	1f 4f       	sbci	r17, 0xFF	; 255
     c4a:	c8 01       	movw	r24, r16
     c4c:	0e 94 05 04 	call	0x80a	; 0x80a <uxListRemove>
     c50:	8c 89       	ldd	r24, Y+20	; 0x14
     c52:	9d 89       	ldd	r25, Y+21	; 0x15
     c54:	89 2b       	or	r24, r25
     c56:	21 f0       	breq	.+8      	; 0xc60 <xTaskIncrementTick+0xd6>
     c58:	ce 01       	movw	r24, r28
     c5a:	0c 96       	adiw	r24, 0x0c	; 12
     c5c:	0e 94 05 04 	call	0x80a	; 0x80a <uxListRemove>
     c60:	2e 89       	ldd	r18, Y+22	; 0x16
     c62:	80 91 d6 92 	lds	r24, 0x92D6
     c66:	82 17       	cp	r24, r18
     c68:	10 f4       	brcc	.+4      	; 0xc6e <xTaskIncrementTick+0xe4>
     c6a:	20 93 d6 92 	sts	0x92D6, r18
     c6e:	30 e0       	ldi	r19, 0x00	; 0
     c70:	c9 01       	movw	r24, r18
     c72:	88 0f       	add	r24, r24
     c74:	99 1f       	adc	r25, r25
     c76:	88 0f       	add	r24, r24
     c78:	99 1f       	adc	r25, r25
     c7a:	88 0f       	add	r24, r24
     c7c:	99 1f       	adc	r25, r25
     c7e:	82 0f       	add	r24, r18
     c80:	93 1f       	adc	r25, r19
     c82:	b8 01       	movw	r22, r16
     c84:	8d 5f       	subi	r24, 0xFD	; 253
     c86:	9c 46       	sbci	r25, 0x6C	; 108
     c88:	0e 94 b3 03 	call	0x766	; 0x766 <vListInsertEnd>
     c8c:	e0 91 27 93 	lds	r30, 0x9327
     c90:	f0 91 28 93 	lds	r31, 0x9328
     c94:	9e 89       	ldd	r25, Y+22	; 0x16
     c96:	86 89       	ldd	r24, Z+22	; 0x16
     c98:	98 17       	cp	r25, r24
     c9a:	08 f4       	brcc	.+2      	; 0xc9e <xTaskIncrementTick+0x114>
     c9c:	b2 cf       	rjmp	.-156    	; 0xc02 <xTaskIncrementTick+0x78>
     c9e:	dd 24       	eor	r13, r13
     ca0:	d3 94       	inc	r13
     ca2:	af cf       	rjmp	.-162    	; 0xc02 <xTaskIncrementTick+0x78>
     ca4:	e0 91 27 93 	lds	r30, 0x9327
     ca8:	f0 91 28 93 	lds	r31, 0x9328
     cac:	86 89       	ldd	r24, Z+22	; 0x16
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	fc 01       	movw	r30, r24
     cb2:	ee 0f       	add	r30, r30
     cb4:	ff 1f       	adc	r31, r31
     cb6:	ee 0f       	add	r30, r30
     cb8:	ff 1f       	adc	r31, r31
     cba:	ee 0f       	add	r30, r30
     cbc:	ff 1f       	adc	r31, r31
     cbe:	8e 0f       	add	r24, r30
     cc0:	9f 1f       	adc	r25, r31
     cc2:	fc 01       	movw	r30, r24
     cc4:	ed 5f       	subi	r30, 0xFD	; 253
     cc6:	fc 46       	sbci	r31, 0x6C	; 108
     cc8:	80 81       	ld	r24, Z
     cca:	82 30       	cpi	r24, 0x02	; 2
     ccc:	48 f0       	brcs	.+18     	; 0xce0 <xTaskIncrementTick+0x156>
     cce:	dd 24       	eor	r13, r13
     cd0:	d3 94       	inc	r13
     cd2:	06 c0       	rjmp	.+12     	; 0xce0 <xTaskIncrementTick+0x156>
     cd4:	80 91 d4 92 	lds	r24, 0x92D4
     cd8:	8f 5f       	subi	r24, 0xFF	; 255
     cda:	80 93 d4 92 	sts	0x92D4, r24
     cde:	d1 2c       	mov	r13, r1
     ce0:	80 91 d3 92 	lds	r24, 0x92D3
     ce4:	88 23       	and	r24, r24
     ce6:	11 f0       	breq	.+4      	; 0xcec <xTaskIncrementTick+0x162>
     ce8:	dd 24       	eor	r13, r13
     cea:	d3 94       	inc	r13
     cec:	8d 2d       	mov	r24, r13
     cee:	df 91       	pop	r29
     cf0:	cf 91       	pop	r28
     cf2:	1f 91       	pop	r17
     cf4:	0f 91       	pop	r16
     cf6:	ff 90       	pop	r15
     cf8:	ef 90       	pop	r14
     cfa:	df 90       	pop	r13
     cfc:	08 95       	ret

00000cfe <xTaskResumeAll>:
     cfe:	df 92       	push	r13
     d00:	ef 92       	push	r14
     d02:	ff 92       	push	r15
     d04:	0f 93       	push	r16
     d06:	1f 93       	push	r17
     d08:	cf 93       	push	r28
     d0a:	df 93       	push	r29
     d0c:	0f b6       	in	r0, 0x3f	; 63
     d0e:	f8 94       	cli
     d10:	0f 92       	push	r0
     d12:	80 91 d0 92 	lds	r24, 0x92D0
     d16:	81 50       	subi	r24, 0x01	; 1
     d18:	80 93 d0 92 	sts	0x92D0, r24
     d1c:	80 91 d0 92 	lds	r24, 0x92D0
     d20:	81 11       	cpse	r24, r1
     d22:	62 c0       	rjmp	.+196    	; 0xde8 <xTaskResumeAll+0xea>
     d24:	80 91 d9 92 	lds	r24, 0x92D9
     d28:	81 11       	cpse	r24, r1
     d2a:	33 c0       	rjmp	.+102    	; 0xd92 <xTaskResumeAll+0x94>
     d2c:	60 c0       	rjmp	.+192    	; 0xdee <xTaskResumeAll+0xf0>
     d2e:	d7 01       	movw	r26, r14
     d30:	15 96       	adiw	r26, 0x05	; 5
     d32:	ed 91       	ld	r30, X+
     d34:	fc 91       	ld	r31, X
     d36:	16 97       	sbiw	r26, 0x06	; 6
     d38:	c6 81       	ldd	r28, Z+6	; 0x06
     d3a:	d7 81       	ldd	r29, Z+7	; 0x07
     d3c:	ce 01       	movw	r24, r28
     d3e:	0c 96       	adiw	r24, 0x0c	; 12
     d40:	0e 94 05 04 	call	0x80a	; 0x80a <uxListRemove>
     d44:	8e 01       	movw	r16, r28
     d46:	0e 5f       	subi	r16, 0xFE	; 254
     d48:	1f 4f       	sbci	r17, 0xFF	; 255
     d4a:	c8 01       	movw	r24, r16
     d4c:	0e 94 05 04 	call	0x80a	; 0x80a <uxListRemove>
     d50:	2e 89       	ldd	r18, Y+22	; 0x16
     d52:	80 91 d6 92 	lds	r24, 0x92D6
     d56:	82 17       	cp	r24, r18
     d58:	10 f4       	brcc	.+4      	; 0xd5e <xTaskResumeAll+0x60>
     d5a:	20 93 d6 92 	sts	0x92D6, r18
     d5e:	30 e0       	ldi	r19, 0x00	; 0
     d60:	c9 01       	movw	r24, r18
     d62:	88 0f       	add	r24, r24
     d64:	99 1f       	adc	r25, r25
     d66:	88 0f       	add	r24, r24
     d68:	99 1f       	adc	r25, r25
     d6a:	88 0f       	add	r24, r24
     d6c:	99 1f       	adc	r25, r25
     d6e:	82 0f       	add	r24, r18
     d70:	93 1f       	adc	r25, r19
     d72:	b8 01       	movw	r22, r16
     d74:	8d 5f       	subi	r24, 0xFD	; 253
     d76:	9c 46       	sbci	r25, 0x6C	; 108
     d78:	0e 94 b3 03 	call	0x766	; 0x766 <vListInsertEnd>
     d7c:	e0 91 27 93 	lds	r30, 0x9327
     d80:	f0 91 28 93 	lds	r31, 0x9328
     d84:	9e 89       	ldd	r25, Y+22	; 0x16
     d86:	86 89       	ldd	r24, Z+22	; 0x16
     d88:	98 17       	cp	r25, r24
     d8a:	58 f0       	brcs	.+22     	; 0xda2 <xTaskResumeAll+0xa4>
     d8c:	d0 92 d3 92 	sts	0x92D3, r13
     d90:	08 c0       	rjmp	.+16     	; 0xda2 <xTaskResumeAll+0xa4>
     d92:	0f 2e       	mov	r0, r31
     d94:	f4 ee       	ldi	r31, 0xE4	; 228
     d96:	ef 2e       	mov	r14, r31
     d98:	f2 e9       	ldi	r31, 0x92	; 146
     d9a:	ff 2e       	mov	r15, r31
     d9c:	f0 2d       	mov	r31, r0
     d9e:	dd 24       	eor	r13, r13
     da0:	d3 94       	inc	r13
     da2:	f7 01       	movw	r30, r14
     da4:	80 81       	ld	r24, Z
     da6:	81 11       	cpse	r24, r1
     da8:	c2 cf       	rjmp	.-124    	; 0xd2e <xTaskResumeAll+0x30>
     daa:	80 91 d4 92 	lds	r24, 0x92D4
     dae:	88 23       	and	r24, r24
     db0:	99 f0       	breq	.+38     	; 0xdd8 <xTaskResumeAll+0xda>
     db2:	80 91 d4 92 	lds	r24, 0x92D4
     db6:	88 23       	and	r24, r24
     db8:	79 f0       	breq	.+30     	; 0xdd8 <xTaskResumeAll+0xda>
     dba:	c1 e0       	ldi	r28, 0x01	; 1
     dbc:	0e 94 c5 05 	call	0xb8a	; 0xb8a <xTaskIncrementTick>
     dc0:	81 11       	cpse	r24, r1
     dc2:	c0 93 d3 92 	sts	0x92D3, r28
     dc6:	80 91 d4 92 	lds	r24, 0x92D4
     dca:	81 50       	subi	r24, 0x01	; 1
     dcc:	80 93 d4 92 	sts	0x92D4, r24
     dd0:	80 91 d4 92 	lds	r24, 0x92D4
     dd4:	81 11       	cpse	r24, r1
     dd6:	f2 cf       	rjmp	.-28     	; 0xdbc <xTaskResumeAll+0xbe>
     dd8:	80 91 d3 92 	lds	r24, 0x92D3
     ddc:	81 30       	cpi	r24, 0x01	; 1
     dde:	31 f4       	brne	.+12     	; 0xdec <xTaskResumeAll+0xee>
     de0:	0e 94 b3 02 	call	0x566	; 0x566 <vPortYield>
     de4:	81 e0       	ldi	r24, 0x01	; 1
     de6:	03 c0       	rjmp	.+6      	; 0xdee <xTaskResumeAll+0xf0>
     de8:	80 e0       	ldi	r24, 0x00	; 0
     dea:	01 c0       	rjmp	.+2      	; 0xdee <xTaskResumeAll+0xf0>
     dec:	80 e0       	ldi	r24, 0x00	; 0
     dee:	0f 90       	pop	r0
     df0:	0f be       	out	0x3f, r0	; 63
     df2:	df 91       	pop	r29
     df4:	cf 91       	pop	r28
     df6:	1f 91       	pop	r17
     df8:	0f 91       	pop	r16
     dfa:	ff 90       	pop	r15
     dfc:	ef 90       	pop	r14
     dfe:	df 90       	pop	r13
     e00:	08 95       	ret

00000e02 <vTaskDelay>:
     e02:	cf 93       	push	r28
     e04:	df 93       	push	r29
     e06:	ec 01       	movw	r28, r24
     e08:	89 2b       	or	r24, r25
     e0a:	b1 f0       	breq	.+44     	; 0xe38 <vTaskDelay+0x36>
     e0c:	0e 94 bf 05 	call	0xb7e	; 0xb7e <vTaskSuspendAll>
     e10:	80 91 d7 92 	lds	r24, 0x92D7
     e14:	90 91 d8 92 	lds	r25, 0x92D8
     e18:	c8 0f       	add	r28, r24
     e1a:	d9 1f       	adc	r29, r25
     e1c:	80 91 27 93 	lds	r24, 0x9327
     e20:	90 91 28 93 	lds	r25, 0x9328
     e24:	02 96       	adiw	r24, 0x02	; 2
     e26:	0e 94 05 04 	call	0x80a	; 0x80a <uxListRemove>
     e2a:	ce 01       	movw	r24, r28
     e2c:	0e 94 4a 04 	call	0x894	; 0x894 <prvAddCurrentTaskToDelayedList>
     e30:	0e 94 7f 06 	call	0xcfe	; 0xcfe <xTaskResumeAll>
     e34:	81 11       	cpse	r24, r1
     e36:	02 c0       	rjmp	.+4      	; 0xe3c <vTaskDelay+0x3a>
     e38:	0e 94 b3 02 	call	0x566	; 0x566 <vPortYield>
     e3c:	df 91       	pop	r29
     e3e:	cf 91       	pop	r28
     e40:	08 95       	ret

00000e42 <prvIdleTask>:
     e42:	0b ed       	ldi	r16, 0xDB	; 219
     e44:	12 e9       	ldi	r17, 0x92	; 146
     e46:	29 c0       	rjmp	.+82     	; 0xe9a <prvIdleTask+0x58>
     e48:	0e 94 bf 05 	call	0xb7e	; 0xb7e <vTaskSuspendAll>
     e4c:	d8 01       	movw	r26, r16
     e4e:	cc 91       	ld	r28, X
     e50:	0e 94 7f 06 	call	0xcfe	; 0xcfe <xTaskResumeAll>
     e54:	cc 23       	and	r28, r28
     e56:	09 f1       	breq	.+66     	; 0xe9a <prvIdleTask+0x58>
     e58:	0f b6       	in	r0, 0x3f	; 63
     e5a:	f8 94       	cli
     e5c:	0f 92       	push	r0
     e5e:	d8 01       	movw	r26, r16
     e60:	15 96       	adiw	r26, 0x05	; 5
     e62:	ed 91       	ld	r30, X+
     e64:	fc 91       	ld	r31, X
     e66:	16 97       	sbiw	r26, 0x06	; 6
     e68:	c6 81       	ldd	r28, Z+6	; 0x06
     e6a:	d7 81       	ldd	r29, Z+7	; 0x07
     e6c:	ce 01       	movw	r24, r28
     e6e:	02 96       	adiw	r24, 0x02	; 2
     e70:	0e 94 05 04 	call	0x80a	; 0x80a <uxListRemove>
     e74:	80 91 d9 92 	lds	r24, 0x92D9
     e78:	81 50       	subi	r24, 0x01	; 1
     e7a:	80 93 d9 92 	sts	0x92D9, r24
     e7e:	80 91 da 92 	lds	r24, 0x92DA
     e82:	81 50       	subi	r24, 0x01	; 1
     e84:	80 93 da 92 	sts	0x92DA, r24
     e88:	0f 90       	pop	r0
     e8a:	0f be       	out	0x3f, r0	; 63
     e8c:	8f 89       	ldd	r24, Y+23	; 0x17
     e8e:	98 8d       	ldd	r25, Y+24	; 0x18
     e90:	0e 94 a0 03 	call	0x740	; 0x740 <vPortFree>
     e94:	ce 01       	movw	r24, r28
     e96:	0e 94 a0 03 	call	0x740	; 0x740 <vPortFree>
     e9a:	80 91 da 92 	lds	r24, 0x92DA
     e9e:	81 11       	cpse	r24, r1
     ea0:	d3 cf       	rjmp	.-90     	; 0xe48 <prvIdleTask+0x6>
     ea2:	fb cf       	rjmp	.-10     	; 0xe9a <prvIdleTask+0x58>

00000ea4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     ea4:	80 91 d0 92 	lds	r24, 0x92D0
     ea8:	88 23       	and	r24, r24
     eaa:	21 f0       	breq	.+8      	; 0xeb4 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     eac:	81 e0       	ldi	r24, 0x01	; 1
     eae:	80 93 d3 92 	sts	0x92D3, r24
     eb2:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     eb4:	10 92 d3 92 	sts	0x92D3, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     eb8:	80 91 d6 92 	lds	r24, 0x92D6
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	fc 01       	movw	r30, r24
     ec0:	ee 0f       	add	r30, r30
     ec2:	ff 1f       	adc	r31, r31
     ec4:	ee 0f       	add	r30, r30
     ec6:	ff 1f       	adc	r31, r31
     ec8:	ee 0f       	add	r30, r30
     eca:	ff 1f       	adc	r31, r31
     ecc:	8e 0f       	add	r24, r30
     ece:	9f 1f       	adc	r25, r31
     ed0:	fc 01       	movw	r30, r24
     ed2:	ed 5f       	subi	r30, 0xFD	; 253
     ed4:	fc 46       	sbci	r31, 0x6C	; 108
     ed6:	80 81       	ld	r24, Z
     ed8:	81 11       	cpse	r24, r1
     eda:	17 c0       	rjmp	.+46     	; 0xf0a <vTaskSwitchContext+0x66>
     edc:	80 91 d6 92 	lds	r24, 0x92D6
     ee0:	81 50       	subi	r24, 0x01	; 1
     ee2:	80 93 d6 92 	sts	0x92D6, r24
     ee6:	80 91 d6 92 	lds	r24, 0x92D6
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	fc 01       	movw	r30, r24
     eee:	ee 0f       	add	r30, r30
     ef0:	ff 1f       	adc	r31, r31
     ef2:	ee 0f       	add	r30, r30
     ef4:	ff 1f       	adc	r31, r31
     ef6:	ee 0f       	add	r30, r30
     ef8:	ff 1f       	adc	r31, r31
     efa:	8e 0f       	add	r24, r30
     efc:	9f 1f       	adc	r25, r31
     efe:	fc 01       	movw	r30, r24
     f00:	ed 5f       	subi	r30, 0xFD	; 253
     f02:	fc 46       	sbci	r31, 0x6C	; 108
     f04:	80 81       	ld	r24, Z
     f06:	88 23       	and	r24, r24
     f08:	49 f3       	breq	.-46     	; 0xedc <vTaskSwitchContext+0x38>
     f0a:	80 91 d6 92 	lds	r24, 0x92D6
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	9c 01       	movw	r18, r24
     f12:	22 0f       	add	r18, r18
     f14:	33 1f       	adc	r19, r19
     f16:	22 0f       	add	r18, r18
     f18:	33 1f       	adc	r19, r19
     f1a:	22 0f       	add	r18, r18
     f1c:	33 1f       	adc	r19, r19
     f1e:	28 0f       	add	r18, r24
     f20:	39 1f       	adc	r19, r25
     f22:	d9 01       	movw	r26, r18
     f24:	ad 5f       	subi	r26, 0xFD	; 253
     f26:	bc 46       	sbci	r27, 0x6C	; 108
     f28:	11 96       	adiw	r26, 0x01	; 1
     f2a:	ed 91       	ld	r30, X+
     f2c:	fc 91       	ld	r31, X
     f2e:	12 97       	sbiw	r26, 0x02	; 2
     f30:	02 80       	ldd	r0, Z+2	; 0x02
     f32:	f3 81       	ldd	r31, Z+3	; 0x03
     f34:	e0 2d       	mov	r30, r0
     f36:	11 96       	adiw	r26, 0x01	; 1
     f38:	ed 93       	st	X+, r30
     f3a:	fc 93       	st	X, r31
     f3c:	12 97       	sbiw	r26, 0x02	; 2
     f3e:	2a 5f       	subi	r18, 0xFA	; 250
     f40:	3c 46       	sbci	r19, 0x6C	; 108
     f42:	e2 17       	cp	r30, r18
     f44:	f3 07       	cpc	r31, r19
     f46:	29 f4       	brne	.+10     	; 0xf52 <vTaskSwitchContext+0xae>
     f48:	22 81       	ldd	r18, Z+2	; 0x02
     f4a:	33 81       	ldd	r19, Z+3	; 0x03
     f4c:	fd 01       	movw	r30, r26
     f4e:	21 83       	std	Z+1, r18	; 0x01
     f50:	32 83       	std	Z+2, r19	; 0x02
     f52:	fc 01       	movw	r30, r24
     f54:	ee 0f       	add	r30, r30
     f56:	ff 1f       	adc	r31, r31
     f58:	ee 0f       	add	r30, r30
     f5a:	ff 1f       	adc	r31, r31
     f5c:	ee 0f       	add	r30, r30
     f5e:	ff 1f       	adc	r31, r31
     f60:	8e 0f       	add	r24, r30
     f62:	9f 1f       	adc	r25, r31
     f64:	fc 01       	movw	r30, r24
     f66:	ed 5f       	subi	r30, 0xFD	; 253
     f68:	fc 46       	sbci	r31, 0x6C	; 108
     f6a:	01 80       	ldd	r0, Z+1	; 0x01
     f6c:	f2 81       	ldd	r31, Z+2	; 0x02
     f6e:	e0 2d       	mov	r30, r0
     f70:	86 81       	ldd	r24, Z+6	; 0x06
     f72:	97 81       	ldd	r25, Z+7	; 0x07
     f74:	80 93 27 93 	sts	0x9327, r24
     f78:	90 93 28 93 	sts	0x9328, r25
     f7c:	08 95       	ret

00000f7e <CDC_Device_ConfigureEndpoints>:

void CDC_Device_CreateBlockingStream(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                                     FILE* const Stream)
{
	*Stream = (FILE)FDEV_SETUP_STREAM(CDC_Device_putchar, CDC_Device_getchar_Blocking, _FDEV_SETUP_RW);
	fdev_set_udata(Stream, CDCInterfaceInfo);
     f7e:	cf 93       	push	r28
     f80:	df 93       	push	r29
     f82:	ec 01       	movw	r28, r24
     f84:	fc 01       	movw	r30, r24
     f86:	70 96       	adiw	r30, 0x10	; 16
     f88:	8b e0       	ldi	r24, 0x0B	; 11
     f8a:	df 01       	movw	r26, r30
     f8c:	1d 92       	st	X+, r1
     f8e:	8a 95       	dec	r24
     f90:	e9 f7       	brne	.-6      	; 0xf8c <CDC_Device_ConfigureEndpoints+0xe>
     f92:	82 e0       	ldi	r24, 0x02	; 2
     f94:	8c 83       	std	Y+4, r24	; 0x04
     f96:	89 87       	std	Y+9, r24	; 0x09
     f98:	83 e0       	ldi	r24, 0x03	; 3
     f9a:	8e 87       	std	Y+14, r24	; 0x0e
     f9c:	61 e0       	ldi	r22, 0x01	; 1
     f9e:	ce 01       	movw	r24, r28
     fa0:	01 96       	adiw	r24, 0x01	; 1
     fa2:	0e 94 b5 0d 	call	0x1b6a	; 0x1b6a <Endpoint_ConfigureEndpointTable>
     fa6:	88 23       	and	r24, r24
     fa8:	61 f0       	breq	.+24     	; 0xfc2 <CDC_Device_ConfigureEndpoints+0x44>
     faa:	61 e0       	ldi	r22, 0x01	; 1
     fac:	ce 01       	movw	r24, r28
     fae:	06 96       	adiw	r24, 0x06	; 6
     fb0:	0e 94 b5 0d 	call	0x1b6a	; 0x1b6a <Endpoint_ConfigureEndpointTable>
     fb4:	88 23       	and	r24, r24
     fb6:	29 f0       	breq	.+10     	; 0xfc2 <CDC_Device_ConfigureEndpoints+0x44>
     fb8:	61 e0       	ldi	r22, 0x01	; 1
     fba:	ce 01       	movw	r24, r28
     fbc:	0b 96       	adiw	r24, 0x0b	; 11
     fbe:	0e 94 b5 0d 	call	0x1b6a	; 0x1b6a <Endpoint_ConfigureEndpointTable>
     fc2:	df 91       	pop	r29
     fc4:	cf 91       	pop	r28
     fc6:	08 95       	ret

00000fc8 <CDC_Device_SendByte>:
     fc8:	cf 93       	push	r28
     fca:	fc 01       	movw	r30, r24
     fcc:	90 91 58 95 	lds	r25, 0x9558
     fd0:	94 30       	cpi	r25, 0x04	; 4
     fd2:	19 f5       	brne	.+70     	; 0x101a <CDC_Device_SendByte+0x52>
     fd4:	84 89       	ldd	r24, Z+20	; 0x14
     fd6:	95 89       	ldd	r25, Z+21	; 0x15
     fd8:	a6 89       	ldd	r26, Z+22	; 0x16
     fda:	b7 89       	ldd	r27, Z+23	; 0x17
     fdc:	89 2b       	or	r24, r25
     fde:	8a 2b       	or	r24, r26
     fe0:	8b 2b       	or	r24, r27
     fe2:	e9 f0       	breq	.+58     	; 0x101e <CDC_Device_SendByte+0x56>
     fe4:	c6 2f       	mov	r28, r22
     fe6:	81 81       	ldd	r24, Z+1	; 0x01
     fe8:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
     fec:	80 91 61 95 	lds	r24, 0x9561
     ff0:	90 91 62 95 	lds	r25, 0x9562
     ff4:	fc 01       	movw	r30, r24
     ff6:	ef 5b       	subi	r30, 0xBF	; 191
     ff8:	ff 4f       	sbci	r31, 0xFF	; 255
     ffa:	20 81       	ld	r18, Z
     ffc:	31 97       	sbiw	r30, 0x01	; 1
     ffe:	80 81       	ld	r24, Z
    1000:	28 17       	cp	r18, r24
    1002:	30 f0       	brcs	.+12     	; 0x1010 <CDC_Device_SendByte+0x48>
    1004:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>
    1008:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <Endpoint_WaitUntilReady>
    100c:	81 11       	cpse	r24, r1
    100e:	08 c0       	rjmp	.+16     	; 0x1020 <CDC_Device_SendByte+0x58>
    1010:	8c 2f       	mov	r24, r28
    1012:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
    1016:	80 e0       	ldi	r24, 0x00	; 0
    1018:	03 c0       	rjmp	.+6      	; 0x1020 <CDC_Device_SendByte+0x58>
    101a:	82 e0       	ldi	r24, 0x02	; 2
    101c:	01 c0       	rjmp	.+2      	; 0x1020 <CDC_Device_SendByte+0x58>
    101e:	82 e0       	ldi	r24, 0x02	; 2
    1020:	cf 91       	pop	r28
    1022:	08 95       	ret

00001024 <CDC_Device_putchar>:
    1024:	fb 01       	movw	r30, r22
    1026:	68 2f       	mov	r22, r24
    1028:	84 85       	ldd	r24, Z+12	; 0x0c
    102a:	95 85       	ldd	r25, Z+13	; 0x0d
    102c:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <CDC_Device_SendByte>
    1030:	21 e0       	ldi	r18, 0x01	; 1
    1032:	30 e0       	ldi	r19, 0x00	; 0
    1034:	81 11       	cpse	r24, r1
    1036:	02 c0       	rjmp	.+4      	; 0x103c <CDC_Device_putchar+0x18>
    1038:	20 e0       	ldi	r18, 0x00	; 0
    103a:	30 e0       	ldi	r19, 0x00	; 0
    103c:	88 27       	eor	r24, r24
    103e:	99 27       	eor	r25, r25
    1040:	82 1b       	sub	r24, r18
    1042:	93 0b       	sbc	r25, r19
    1044:	08 95       	ret

00001046 <CDC_Device_Flush>:
    1046:	cf 93       	push	r28
    1048:	df 93       	push	r29
    104a:	fc 01       	movw	r30, r24
    104c:	90 91 58 95 	lds	r25, 0x9558
    1050:	94 30       	cpi	r25, 0x04	; 4
    1052:	f1 f5       	brne	.+124    	; 0x10d0 <CDC_Device_Flush+0x8a>
    1054:	84 89       	ldd	r24, Z+20	; 0x14
    1056:	95 89       	ldd	r25, Z+21	; 0x15
    1058:	a6 89       	ldd	r26, Z+22	; 0x16
    105a:	b7 89       	ldd	r27, Z+23	; 0x17
    105c:	89 2b       	or	r24, r25
    105e:	8a 2b       	or	r24, r26
    1060:	8b 2b       	or	r24, r27
    1062:	c1 f1       	breq	.+112    	; 0x10d4 <CDC_Device_Flush+0x8e>
    1064:	81 81       	ldd	r24, Z+1	; 0x01
    1066:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
    106a:	80 91 65 95 	lds	r24, 0x9565
    106e:	88 23       	and	r24, r24
    1070:	4c f4       	brge	.+18     	; 0x1084 <CDC_Device_Flush+0x3e>
    1072:	e0 91 61 95 	lds	r30, 0x9561
    1076:	f0 91 62 95 	lds	r31, 0x9562
    107a:	ef 5b       	subi	r30, 0xBF	; 191
    107c:	ff 4f       	sbci	r31, 0xFF	; 255
    107e:	80 81       	ld	r24, Z
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	0d c0       	rjmp	.+26     	; 0x109e <CDC_Device_Flush+0x58>
    1084:	20 91 61 95 	lds	r18, 0x9561
    1088:	30 91 62 95 	lds	r19, 0x9562
    108c:	f9 01       	movw	r30, r18
    108e:	e0 5c       	subi	r30, 0xC0	; 192
    1090:	ff 4f       	sbci	r31, 0xFF	; 255
    1092:	80 81       	ld	r24, Z
    1094:	31 96       	adiw	r30, 0x01	; 1
    1096:	20 81       	ld	r18, Z
    1098:	90 e0       	ldi	r25, 0x00	; 0
    109a:	82 1b       	sub	r24, r18
    109c:	91 09       	sbc	r25, r1
    109e:	89 2b       	or	r24, r25
    10a0:	d9 f0       	breq	.+54     	; 0x10d8 <CDC_Device_Flush+0x92>
    10a2:	80 91 61 95 	lds	r24, 0x9561
    10a6:	90 91 62 95 	lds	r25, 0x9562
    10aa:	fc 01       	movw	r30, r24
    10ac:	ef 5b       	subi	r30, 0xBF	; 191
    10ae:	ff 4f       	sbci	r31, 0xFF	; 255
    10b0:	d0 81       	ld	r29, Z
    10b2:	31 97       	sbiw	r30, 0x01	; 1
    10b4:	c0 81       	ld	r28, Z
    10b6:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>
    10ba:	dc 17       	cp	r29, r28
    10bc:	78 f0       	brcs	.+30     	; 0x10dc <CDC_Device_Flush+0x96>
    10be:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <Endpoint_WaitUntilReady>
    10c2:	c8 2f       	mov	r28, r24
    10c4:	81 11       	cpse	r24, r1
    10c6:	0c c0       	rjmp	.+24     	; 0x10e0 <CDC_Device_Flush+0x9a>
    10c8:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>
    10cc:	8c 2f       	mov	r24, r28
    10ce:	08 c0       	rjmp	.+16     	; 0x10e0 <CDC_Device_Flush+0x9a>
    10d0:	82 e0       	ldi	r24, 0x02	; 2
    10d2:	06 c0       	rjmp	.+12     	; 0x10e0 <CDC_Device_Flush+0x9a>
    10d4:	82 e0       	ldi	r24, 0x02	; 2
    10d6:	04 c0       	rjmp	.+8      	; 0x10e0 <CDC_Device_Flush+0x9a>
    10d8:	80 e0       	ldi	r24, 0x00	; 0
    10da:	02 c0       	rjmp	.+4      	; 0x10e0 <CDC_Device_Flush+0x9a>
    10dc:	80 e0       	ldi	r24, 0x00	; 0
    10de:	00 c0       	rjmp	.+0      	; 0x10e0 <CDC_Device_Flush+0x9a>
    10e0:	df 91       	pop	r29
    10e2:	cf 91       	pop	r28
    10e4:	08 95       	ret

000010e6 <CDC_Device_USBTask>:
    10e6:	cf 93       	push	r28
    10e8:	df 93       	push	r29
    10ea:	fc 01       	movw	r30, r24
    10ec:	90 91 58 95 	lds	r25, 0x9558
    10f0:	94 30       	cpi	r25, 0x04	; 4
    10f2:	99 f4       	brne	.+38     	; 0x111a <CDC_Device_USBTask+0x34>
    10f4:	84 89       	ldd	r24, Z+20	; 0x14
    10f6:	95 89       	ldd	r25, Z+21	; 0x15
    10f8:	a6 89       	ldd	r26, Z+22	; 0x16
    10fa:	b7 89       	ldd	r27, Z+23	; 0x17
    10fc:	89 2b       	or	r24, r25
    10fe:	8a 2b       	or	r24, r26
    1100:	8b 2b       	or	r24, r27
    1102:	59 f0       	breq	.+22     	; 0x111a <CDC_Device_USBTask+0x34>
    1104:	ef 01       	movw	r28, r30
    1106:	81 81       	ldd	r24, Z+1	; 0x01
    1108:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
    110c:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <Endpoint_IsINReady>
    1110:	88 23       	and	r24, r24
    1112:	19 f0       	breq	.+6      	; 0x111a <CDC_Device_USBTask+0x34>
    1114:	ce 01       	movw	r24, r28
    1116:	0e 94 23 08 	call	0x1046	; 0x1046 <CDC_Device_Flush>
    111a:	df 91       	pop	r29
    111c:	cf 91       	pop	r28
    111e:	08 95       	ret

00001120 <CDC_Device_ReceiveByte>:
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	20 91 58 95 	lds	r18, 0x9558
    1128:	24 30       	cpi	r18, 0x04	; 4
    112a:	09 f0       	breq	.+2      	; 0x112e <CDC_Device_ReceiveByte+0xe>
    112c:	56 c0       	rjmp	.+172    	; 0x11da <CDC_Device_ReceiveByte+0xba>
    112e:	fc 01       	movw	r30, r24
    1130:	44 89       	ldd	r20, Z+20	; 0x14
    1132:	55 89       	ldd	r21, Z+21	; 0x15
    1134:	66 89       	ldd	r22, Z+22	; 0x16
    1136:	77 89       	ldd	r23, Z+23	; 0x17
    1138:	45 2b       	or	r20, r21
    113a:	46 2b       	or	r20, r22
    113c:	47 2b       	or	r20, r23
    113e:	09 f4       	brne	.+2      	; 0x1142 <CDC_Device_ReceiveByte+0x22>
    1140:	4f c0       	rjmp	.+158    	; 0x11e0 <CDC_Device_ReceiveByte+0xc0>
    1142:	86 81       	ldd	r24, Z+6	; 0x06
    1144:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
    1148:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <Endpoint_IsOUTReceived>
    114c:	88 23       	and	r24, r24
    114e:	09 f4       	brne	.+2      	; 0x1152 <CDC_Device_ReceiveByte+0x32>
    1150:	4a c0       	rjmp	.+148    	; 0x11e6 <CDC_Device_ReceiveByte+0xc6>
    1152:	80 91 65 95 	lds	r24, 0x9565
    1156:	88 23       	and	r24, r24
    1158:	4c f4       	brge	.+18     	; 0x116c <CDC_Device_ReceiveByte+0x4c>
    115a:	e0 91 61 95 	lds	r30, 0x9561
    115e:	f0 91 62 95 	lds	r31, 0x9562
    1162:	ef 5b       	subi	r30, 0xBF	; 191
    1164:	ff 4f       	sbci	r31, 0xFF	; 255
    1166:	80 81       	ld	r24, Z
    1168:	90 e0       	ldi	r25, 0x00	; 0
    116a:	0d c0       	rjmp	.+26     	; 0x1186 <CDC_Device_ReceiveByte+0x66>
    116c:	20 91 61 95 	lds	r18, 0x9561
    1170:	30 91 62 95 	lds	r19, 0x9562
    1174:	f9 01       	movw	r30, r18
    1176:	e0 5c       	subi	r30, 0xC0	; 192
    1178:	ff 4f       	sbci	r31, 0xFF	; 255
    117a:	80 81       	ld	r24, Z
    117c:	31 96       	adiw	r30, 0x01	; 1
    117e:	20 81       	ld	r18, Z
    1180:	90 e0       	ldi	r25, 0x00	; 0
    1182:	82 1b       	sub	r24, r18
    1184:	91 09       	sbc	r25, r1
    1186:	89 2b       	or	r24, r25
    1188:	29 f0       	breq	.+10     	; 0x1194 <CDC_Device_ReceiveByte+0x74>
    118a:	0e 94 84 0c 	call	0x1908	; 0x1908 <Endpoint_Read_8>
    118e:	c8 2f       	mov	r28, r24
    1190:	d0 e0       	ldi	r29, 0x00	; 0
    1192:	02 c0       	rjmp	.+4      	; 0x1198 <CDC_Device_ReceiveByte+0x78>
    1194:	cf ef       	ldi	r28, 0xFF	; 255
    1196:	df ef       	ldi	r29, 0xFF	; 255
    1198:	80 91 65 95 	lds	r24, 0x9565
    119c:	88 23       	and	r24, r24
    119e:	4c f4       	brge	.+18     	; 0x11b2 <CDC_Device_ReceiveByte+0x92>
    11a0:	e0 91 61 95 	lds	r30, 0x9561
    11a4:	f0 91 62 95 	lds	r31, 0x9562
    11a8:	ef 5b       	subi	r30, 0xBF	; 191
    11aa:	ff 4f       	sbci	r31, 0xFF	; 255
    11ac:	20 81       	ld	r18, Z
    11ae:	30 e0       	ldi	r19, 0x00	; 0
    11b0:	0d c0       	rjmp	.+26     	; 0x11cc <CDC_Device_ReceiveByte+0xac>
    11b2:	40 91 61 95 	lds	r20, 0x9561
    11b6:	50 91 62 95 	lds	r21, 0x9562
    11ba:	fa 01       	movw	r30, r20
    11bc:	e0 5c       	subi	r30, 0xC0	; 192
    11be:	ff 4f       	sbci	r31, 0xFF	; 255
    11c0:	20 81       	ld	r18, Z
    11c2:	31 96       	adiw	r30, 0x01	; 1
    11c4:	80 81       	ld	r24, Z
    11c6:	30 e0       	ldi	r19, 0x00	; 0
    11c8:	28 1b       	sub	r18, r24
    11ca:	31 09       	sbc	r19, r1
    11cc:	23 2b       	or	r18, r19
    11ce:	71 f4       	brne	.+28     	; 0x11ec <CDC_Device_ReceiveByte+0xcc>
    11d0:	0e 94 75 0c 	call	0x18ea	; 0x18ea <Endpoint_ClearOUT>
    11d4:	8c 2f       	mov	r24, r28
    11d6:	9d 2f       	mov	r25, r29
    11d8:	0b c0       	rjmp	.+22     	; 0x11f0 <CDC_Device_ReceiveByte+0xd0>
    11da:	8f ef       	ldi	r24, 0xFF	; 255
    11dc:	9f ef       	ldi	r25, 0xFF	; 255
    11de:	08 c0       	rjmp	.+16     	; 0x11f0 <CDC_Device_ReceiveByte+0xd0>
    11e0:	8f ef       	ldi	r24, 0xFF	; 255
    11e2:	9f ef       	ldi	r25, 0xFF	; 255
    11e4:	05 c0       	rjmp	.+10     	; 0x11f0 <CDC_Device_ReceiveByte+0xd0>
    11e6:	8f ef       	ldi	r24, 0xFF	; 255
    11e8:	9f ef       	ldi	r25, 0xFF	; 255
    11ea:	02 c0       	rjmp	.+4      	; 0x11f0 <CDC_Device_ReceiveByte+0xd0>
    11ec:	8c 2f       	mov	r24, r28
    11ee:	9d 2f       	mov	r25, r29
    11f0:	df 91       	pop	r29
    11f2:	cf 91       	pop	r28
    11f4:	08 95       	ret

000011f6 <CDC_Device_getchar>:
    11f6:	fc 01       	movw	r30, r24
    11f8:	84 85       	ldd	r24, Z+12	; 0x0c
    11fa:	95 85       	ldd	r25, Z+13	; 0x0d
    11fc:	0e 94 90 08 	call	0x1120	; 0x1120 <CDC_Device_ReceiveByte>
    1200:	99 23       	and	r25, r25
    1202:	14 f4       	brge	.+4      	; 0x1208 <CDC_Device_getchar+0x12>
    1204:	8e ef       	ldi	r24, 0xFE	; 254
    1206:	9f ef       	ldi	r25, 0xFF	; 255
    1208:	08 95       	ret

0000120a <CDC_Device_CreateStream>:
    120a:	fb 01       	movw	r30, r22
    120c:	2e e0       	ldi	r18, 0x0E	; 14
    120e:	db 01       	movw	r26, r22
    1210:	1d 92       	st	X+, r1
    1212:	2a 95       	dec	r18
    1214:	e9 f7       	brne	.-6      	; 0x1210 <CDC_Device_CreateStream+0x6>
    1216:	23 e0       	ldi	r18, 0x03	; 3
    1218:	23 83       	std	Z+3, r18	; 0x03
    121a:	22 e1       	ldi	r18, 0x12	; 18
    121c:	38 e0       	ldi	r19, 0x08	; 8
    121e:	20 87       	std	Z+8, r18	; 0x08
    1220:	31 87       	std	Z+9, r19	; 0x09
    1222:	2b ef       	ldi	r18, 0xFB	; 251
    1224:	38 e0       	ldi	r19, 0x08	; 8
    1226:	22 87       	std	Z+10, r18	; 0x0a
    1228:	33 87       	std	Z+11, r19	; 0x0b
    122a:	84 87       	std	Z+12, r24	; 0x0c
    122c:	95 87       	std	Z+13, r25	; 0x0d
    122e:	08 95       	ret

00001230 <CDC_Device_Event_Stub>:
	return ReceivedByte;
}
#endif

void CDC_Device_Event_Stub(void)
{
    1230:	08 95       	ret

00001232 <CDC_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_CDC_DRIVER
#define  __INCLUDE_FROM_CDC_DEVICE_C
#include "CDCClassDevice.h"

void CDC_Device_ProcessControlRequest(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    1232:	ff 92       	push	r15
    1234:	0f 93       	push	r16
    1236:	1f 93       	push	r17
    1238:	cf 93       	push	r28
    123a:	df 93       	push	r29
    123c:	ec 01       	movw	r28, r24
	if (!(Endpoint_IsSETUPReceived()))
    123e:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <Endpoint_IsSETUPReceived>
    1242:	88 23       	and	r24, r24
    1244:	09 f4       	brne	.+2      	; 0x1248 <CDC_Device_ProcessControlRequest+0x16>
    1246:	9b c0       	rjmp	.+310    	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
	  return;

	if (USB_ControlRequest.wIndex != CDCInterfaceInfo->Config.ControlInterfaceNumber)
    1248:	28 81       	ld	r18, Y
    124a:	30 e0       	ldi	r19, 0x00	; 0
    124c:	80 91 5d 95 	lds	r24, 0x955D
    1250:	90 91 5e 95 	lds	r25, 0x955E
    1254:	82 17       	cp	r24, r18
    1256:	93 07       	cpc	r25, r19
    1258:	09 f0       	breq	.+2      	; 0x125c <CDC_Device_ProcessControlRequest+0x2a>
    125a:	91 c0       	rjmp	.+290    	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
	  return;

	switch (USB_ControlRequest.bRequest)
    125c:	80 91 5a 95 	lds	r24, 0x955A
    1260:	81 32       	cpi	r24, 0x21	; 33
    1262:	59 f0       	breq	.+22     	; 0x127a <CDC_Device_ProcessControlRequest+0x48>
    1264:	18 f4       	brcc	.+6      	; 0x126c <CDC_Device_ProcessControlRequest+0x3a>
    1266:	80 32       	cpi	r24, 0x20	; 32
    1268:	81 f1       	breq	.+96     	; 0x12ca <CDC_Device_ProcessControlRequest+0x98>
    126a:	89 c0       	rjmp	.+274    	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
    126c:	82 32       	cpi	r24, 0x22	; 34
    126e:	09 f4       	brne	.+2      	; 0x1272 <CDC_Device_ProcessControlRequest+0x40>
    1270:	67 c0       	rjmp	.+206    	; 0x1340 <CDC_Device_ProcessControlRequest+0x10e>
    1272:	83 32       	cpi	r24, 0x23	; 35
    1274:	09 f4       	brne	.+2      	; 0x1278 <CDC_Device_ProcessControlRequest+0x46>
    1276:	76 c0       	rjmp	.+236    	; 0x1364 <CDC_Device_ProcessControlRequest+0x132>
    1278:	82 c0       	rjmp	.+260    	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
	{
		case CDC_REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    127a:	80 91 59 95 	lds	r24, 0x9559
    127e:	81 3a       	cpi	r24, 0xA1	; 161
    1280:	09 f0       	breq	.+2      	; 0x1284 <CDC_Device_ProcessControlRequest+0x52>
    1282:	7d c0       	rjmp	.+250    	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    1284:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>

				while (!(Endpoint_IsINReady()));
    1288:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <Endpoint_IsINReady>
    128c:	88 23       	and	r24, r24
    128e:	e1 f3       	breq	.-8      	; 0x1288 <CDC_Device_ProcessControlRequest+0x56>

				Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
    1290:	8c 89       	ldd	r24, Y+20	; 0x14
    1292:	fd 88       	ldd	r15, Y+21	; 0x15
    1294:	0e 89       	ldd	r16, Y+22	; 0x16
    1296:	1f 89       	ldd	r17, Y+23	; 0x17
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_32_LE(const uint32_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_32_LE(const uint32_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    1298:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    129c:	8f 2d       	mov	r24, r15
    129e:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 16);
    12a2:	80 2f       	mov	r24, r16
    12a4:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 24);
    12a8:	81 2f       	mov	r24, r17
    12aa:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
    12ae:	88 8d       	ldd	r24, Y+24	; 0x18
    12b0:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
    12b4:	89 8d       	ldd	r24, Y+25	; 0x19
    12b6:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
    12ba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12bc:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>

				Endpoint_ClearIN();
    12c0:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>
				Endpoint_ClearStatusStage();
    12c4:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Endpoint_ClearStatusStage>
    12c8:	5a c0       	rjmp	.+180    	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    12ca:	80 91 59 95 	lds	r24, 0x9559
    12ce:	81 32       	cpi	r24, 0x21	; 33
    12d0:	09 f0       	breq	.+2      	; 0x12d4 <CDC_Device_ProcessControlRequest+0xa2>
    12d2:	55 c0       	rjmp	.+170    	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    12d4:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>

				while (!(Endpoint_IsOUTReceived()))
    12d8:	05 c0       	rjmp	.+10     	; 0x12e4 <CDC_Device_ProcessControlRequest+0xb2>
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    12da:	80 91 58 95 	lds	r24, 0x9558
    12de:	88 23       	and	r24, r24
    12e0:	09 f4       	brne	.+2      	; 0x12e4 <CDC_Device_ProcessControlRequest+0xb2>
    12e2:	4d c0       	rjmp	.+154    	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSETUP();

				while (!(Endpoint_IsOUTReceived()))
    12e4:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <Endpoint_IsOUTReceived>
    12e8:	88 23       	and	r24, r24
    12ea:	b9 f3       	breq	.-18     	; 0x12da <CDC_Device_ProcessControlRequest+0xa8>
			 *  \return Next four bytes in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
    12ec:	0e 94 84 0c 	call	0x1908	; 0x1908 <Endpoint_Read_8>
    12f0:	f8 2e       	mov	r15, r24
				uint32_t Byte1 = Endpoint_Read_8();
    12f2:	0e 94 84 0c 	call	0x1908	; 0x1908 <Endpoint_Read_8>
    12f6:	18 2f       	mov	r17, r24
				uint32_t Byte2 = Endpoint_Read_8();
    12f8:	0e 94 84 0c 	call	0x1908	; 0x1908 <Endpoint_Read_8>
    12fc:	08 2f       	mov	r16, r24
				uint32_t Byte3 = Endpoint_Read_8();
    12fe:	0e 94 84 0c 	call	0x1908	; 0x1908 <Endpoint_Read_8>
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
				uint32_t Byte1 = Endpoint_Read_8();
				uint32_t Byte2 = Endpoint_Read_8();
    1302:	40 2f       	mov	r20, r16
    1304:	50 e0       	ldi	r21, 0x00	; 0
    1306:	60 e0       	ldi	r22, 0x00	; 0
    1308:	70 e0       	ldi	r23, 0x00	; 0
				uint32_t Byte3 = Endpoint_Read_8();

				return ((Byte3 << 24) | (Byte2 << 16) | (Byte1 << 8) | Byte0);
    130a:	ba 01       	movw	r22, r20
    130c:	55 27       	eor	r21, r21
    130e:	44 27       	eor	r20, r20
    1310:	78 2b       	or	r23, r24
    1312:	4f 29       	or	r20, r15
    1314:	51 2b       	or	r21, r17
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
					  return;
				}

				CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
    1316:	4c 8b       	std	Y+20, r20	; 0x14
    1318:	5d 8b       	std	Y+21, r21	; 0x15
    131a:	6e 8b       	std	Y+22, r22	; 0x16
    131c:	7f 8b       	std	Y+23, r23	; 0x17
				CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
    131e:	0e 94 84 0c 	call	0x1908	; 0x1908 <Endpoint_Read_8>
    1322:	88 8f       	std	Y+24, r24	; 0x18
				CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
    1324:	0e 94 84 0c 	call	0x1908	; 0x1908 <Endpoint_Read_8>
    1328:	89 8f       	std	Y+25, r24	; 0x19
				CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
    132a:	0e 94 84 0c 	call	0x1908	; 0x1908 <Endpoint_Read_8>
    132e:	8a 8f       	std	Y+26, r24	; 0x1a

				Endpoint_ClearOUT();
    1330:	0e 94 75 0c 	call	0x18ea	; 0x18ea <Endpoint_ClearOUT>
				Endpoint_ClearStatusStage();
    1334:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_LineEncodingChanged(CDCInterfaceInfo);
    1338:	ce 01       	movw	r24, r28
    133a:	0e 94 18 09 	call	0x1230	; 0x1230 <CDC_Device_Event_Stub>
    133e:	1f c0       	rjmp	.+62     	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SetControlLineState:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    1340:	80 91 59 95 	lds	r24, 0x9559
    1344:	81 32       	cpi	r24, 0x21	; 33
    1346:	d9 f4       	brne	.+54     	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    1348:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    134c:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Endpoint_ClearStatusStage>

				CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
    1350:	80 91 5b 95 	lds	r24, 0x955B
    1354:	90 91 5c 95 	lds	r25, 0x955C
    1358:	88 8b       	std	Y+16, r24	; 0x10
    135a:	99 8b       	std	Y+17, r25	; 0x11

				EVENT_CDC_Device_ControLineStateChanged(CDCInterfaceInfo);
    135c:	ce 01       	movw	r24, r28
    135e:	0e 94 8c 12 	call	0x2518	; 0x2518 <EVENT_CDC_Device_ControLineStateChanged>
    1362:	0d c0       	rjmp	.+26     	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SendBreak:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    1364:	80 91 59 95 	lds	r24, 0x9559
    1368:	81 32       	cpi	r24, 0x21	; 33
    136a:	49 f4       	brne	.+18     	; 0x137e <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    136c:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    1370:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
    1374:	60 91 5b 95 	lds	r22, 0x955B
    1378:	ce 01       	movw	r24, r28
    137a:	0e 94 18 09 	call	0x1230	; 0x1230 <CDC_Device_Event_Stub>
			}

			break;
	}
}
    137e:	df 91       	pop	r29
    1380:	cf 91       	pop	r28
    1382:	1f 91       	pop	r17
    1384:	0f 91       	pop	r16
    1386:	ff 90       	pop	r15
    1388:	08 95       	ret

0000138a <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    138a:	ef 92       	push	r14
    138c:	ff 92       	push	r15
    138e:	0f 93       	push	r16
    1390:	1f 93       	push	r17
    1392:	cf 93       	push	r28
    1394:	df 93       	push	r29
    1396:	cd b7       	in	r28, 0x3d	; 61
    1398:	de b7       	in	r29, 0x3e	; 62
    139a:	ea 97       	sbiw	r28, 0x3a	; 58
    139c:	cd bf       	out	0x3d, r28	; 61
    139e:	de bf       	out	0x3e, r29	; 62
    13a0:	09 e5       	ldi	r16, 0x59	; 89
    13a2:	15 e9       	ldi	r17, 0x95	; 149
    13a4:	0f 2e       	mov	r0, r31
    13a6:	f1 e6       	ldi	r31, 0x61	; 97
    13a8:	ef 2e       	mov	r14, r31
    13aa:	f5 e9       	ldi	r31, 0x95	; 149
    13ac:	ff 2e       	mov	r15, r31
    13ae:	f0 2d       	mov	r31, r0
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    13b0:	0e 94 84 0c 	call	0x1908	; 0x1908 <Endpoint_Read_8>
    13b4:	f8 01       	movw	r30, r16
    13b6:	81 93       	st	Z+, r24
    13b8:	8f 01       	movw	r16, r30
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    13ba:	ee 15       	cp	r30, r14
    13bc:	ff 05       	cpc	r31, r15
    13be:	c1 f7       	brne	.-16     	; 0x13b0 <USB_Device_ProcessControlRequest+0x26>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    13c0:	0e 94 87 12 	call	0x250e	; 0x250e <EVENT_USB_Device_ControlRequest>

	if (Endpoint_IsSETUPReceived())
    13c4:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <Endpoint_IsSETUPReceived>
    13c8:	88 23       	and	r24, r24
    13ca:	09 f4       	brne	.+2      	; 0x13ce <USB_Device_ProcessControlRequest+0x44>
    13cc:	13 c1       	rjmp	.+550    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    13ce:	e9 e5       	ldi	r30, 0x59	; 89
    13d0:	f5 e9       	ldi	r31, 0x95	; 149
    13d2:	20 81       	ld	r18, Z

		switch (USB_ControlRequest.bRequest)
    13d4:	31 81       	ldd	r19, Z+1	; 0x01
    13d6:	83 2f       	mov	r24, r19
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	8a 30       	cpi	r24, 0x0A	; 10
    13dc:	91 05       	cpc	r25, r1
    13de:	08 f0       	brcs	.+2      	; 0x13e2 <USB_Device_ProcessControlRequest+0x58>
    13e0:	09 c1       	rjmp	.+530    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
    13e2:	fc 01       	movw	r30, r24
    13e4:	88 27       	eor	r24, r24
    13e6:	e2 50       	subi	r30, 0x02	; 2
    13e8:	ff 4f       	sbci	r31, 0xFF	; 255
    13ea:	8f 4f       	sbci	r24, 0xFF	; 255
    13ec:	0c 94 16 14 	jmp	0x282c	; 0x282c <__tablejump2__>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    13f0:	20 38       	cpi	r18, 0x80	; 128
    13f2:	21 f0       	breq	.+8      	; 0x13fc <USB_Device_ProcessControlRequest+0x72>
    13f4:	22 38       	cpi	r18, 0x82	; 130
    13f6:	09 f0       	breq	.+2      	; 0x13fa <USB_Device_ProcessControlRequest+0x70>
    13f8:	fd c0       	rjmp	.+506    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
    13fa:	08 c0       	rjmp	.+16     	; 0x140c <USB_Device_ProcessControlRequest+0x82>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    13fc:	10 91 55 95 	lds	r17, 0x9555
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    1400:	80 91 56 95 	lds	r24, 0x9556
    1404:	88 23       	and	r24, r24
    1406:	91 f0       	breq	.+36     	; 0x142c <USB_Device_ProcessControlRequest+0xa2>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    1408:	12 60       	ori	r17, 0x02	; 2
    140a:	10 c0       	rjmp	.+32     	; 0x142c <USB_Device_ProcessControlRequest+0xa2>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    140c:	80 91 5d 95 	lds	r24, 0x955D
    1410:	8f 70       	andi	r24, 0x0F	; 15
    1412:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    1416:	e0 91 63 95 	lds	r30, 0x9563
    141a:	f0 91 64 95 	lds	r31, 0x9564
    141e:	11 81       	ldd	r17, Z+1	; 0x01
    1420:	12 fb       	bst	r17, 2
    1422:	11 27       	eor	r17, r17
    1424:	10 f9       	bld	r17, 0

			CurrentStatus = Endpoint_IsStalled();

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
			break;
		default:
			return;
	}

	Endpoint_ClearSETUP();
    142c:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    1430:	81 2f       	mov	r24, r17
    1432:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    1436:	80 e0       	ldi	r24, 0x00	; 0
    1438:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();
    143c:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>

	Endpoint_ClearStatusStage();
    1440:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Endpoint_ClearStatusStage>
    1444:	d7 c0       	rjmp	.+430    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1446:	22 23       	and	r18, r18
    1448:	09 f4       	brne	.+2      	; 0x144c <USB_Device_ProcessControlRequest+0xc2>
    144a:	dd c0       	rjmp	.+442    	; 0x1606 <USB_Device_ProcessControlRequest+0x27c>
    144c:	22 30       	cpi	r18, 0x02	; 2
    144e:	09 f0       	breq	.+2      	; 0x1452 <USB_Device_ProcessControlRequest+0xc8>
    1450:	d1 c0       	rjmp	.+418    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
    1452:	de c0       	rjmp	.+444    	; 0x1610 <USB_Device_ProcessControlRequest+0x286>
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    1454:	81 e0       	ldi	r24, 0x01	; 1
    1456:	33 30       	cpi	r19, 0x03	; 3
    1458:	09 f0       	breq	.+2      	; 0x145c <USB_Device_ProcessControlRequest+0xd2>
    145a:	80 e0       	ldi	r24, 0x00	; 0
    145c:	80 93 56 95 	sts	0x9556, r24
    1460:	25 c0       	rjmp	.+74     	; 0x14ac <USB_Device_ProcessControlRequest+0x122>
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1462:	e0 91 5d 95 	lds	r30, 0x955D
    1466:	1e 2f       	mov	r17, r30
    1468:	1f 70       	andi	r17, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    146a:	09 f4       	brne	.+2      	; 0x146e <USB_Device_ProcessControlRequest+0xe4>
    146c:	c3 c0       	rjmp	.+390    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
    146e:	81 2f       	mov	r24, r17
    1470:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>

				if (Endpoint_IsEnabled())
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    1474:	80 91 5a 95 	lds	r24, 0x955A
    1478:	83 30       	cpi	r24, 0x03	; 3
    147a:	19 f4       	brne	.+6      	; 0x1482 <USB_Device_ProcessControlRequest+0xf8>
					{
						Endpoint_StallTransaction();
    147c:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <Endpoint_StallTransaction>
    1480:	15 c0       	rjmp	.+42     	; 0x14ac <USB_Device_ProcessControlRequest+0x122>
			 *  \ingroup Group_EndpointPacketManagement_XMEGA
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				USB_Endpoint_SelectedHandle->CTRL &= ~USB_EP_STALL_bm;
    1482:	e0 91 63 95 	lds	r30, 0x9563
    1486:	f0 91 64 95 	lds	r31, 0x9564
    148a:	81 81       	ldd	r24, Z+1	; 0x01
    148c:	8b 7f       	andi	r24, 0xFB	; 251
    148e:	81 83       	std	Z+1, r24	; 0x01
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				if (Address & ENDPOINT_DIR_IN)
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].IN.Position  = 0;
				else
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].OUT.Position = 0;
    1490:	24 e8       	ldi	r18, 0x84	; 132
    1492:	12 9f       	mul	r17, r18
    1494:	f0 01       	movw	r30, r0
    1496:	11 24       	eor	r1, r1
    1498:	e9 55       	subi	r30, 0x59	; 89
    149a:	fa 46       	sbci	r31, 0x6A	; 106
    149c:	10 82       	st	Z, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				USB_Endpoint_SelectedHandle->STATUS &= ~USB_EP_TOGGLE_bm;
    149e:	e0 91 63 95 	lds	r30, 0x9563
    14a2:	f0 91 64 95 	lds	r31, 0x9564
    14a6:	80 81       	ld	r24, Z
    14a8:	8e 7f       	andi	r24, 0xFE	; 254
    14aa:	80 83       	st	Z, r24
		#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    14ac:	80 e0       	ldi	r24, 0x00	; 0
    14ae:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>

	Endpoint_ClearSETUP();
    14b2:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    14b6:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Endpoint_ClearStatusStage>
    14ba:	9c c0       	rjmp	.+312    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    14bc:	21 11       	cpse	r18, r1
    14be:	9a c0       	rjmp	.+308    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    14c0:	10 91 5b 95 	lds	r17, 0x955B
    14c4:	1f 77       	andi	r17, 0x7F	; 127

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();
    14c6:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    14ca:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Endpoint_ClearStatusStage>

	while (!(Endpoint_IsINReady()));
    14ce:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <Endpoint_IsINReady>
    14d2:	88 23       	and	r24, r24
    14d4:	e1 f3       	breq	.-8      	; 0x14ce <USB_Device_ProcessControlRequest+0x144>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    14d6:	10 93 c3 04 	sts	0x04C3, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    14da:	11 11       	cpse	r17, r1
    14dc:	02 c0       	rjmp	.+4      	; 0x14e2 <USB_Device_ProcessControlRequest+0x158>
    14de:	82 e0       	ldi	r24, 0x02	; 2
    14e0:	01 c0       	rjmp	.+2      	; 0x14e4 <USB_Device_ProcessControlRequest+0x15a>
    14e2:	83 e0       	ldi	r24, 0x03	; 3
    14e4:	80 93 58 95 	sts	0x9558, r24
    14e8:	85 c0       	rjmp	.+266    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    14ea:	20 58       	subi	r18, 0x80	; 128
    14ec:	22 30       	cpi	r18, 0x02	; 2
    14ee:	08 f0       	brcs	.+2      	; 0x14f2 <USB_Device_ProcessControlRequest+0x168>
    14f0:	81 c0       	rjmp	.+258    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    14f2:	80 91 5b 95 	lds	r24, 0x955B
    14f6:	90 91 5c 95 	lds	r25, 0x955C
    14fa:	8c 3d       	cpi	r24, 0xDC	; 220
    14fc:	e3 e0       	ldi	r30, 0x03	; 3
    14fe:	9e 07       	cpc	r25, r30
    1500:	b9 f5       	brne	.+110    	; 0x1570 <USB_Device_ProcessControlRequest+0x1e6>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    1502:	83 e0       	ldi	r24, 0x03	; 3
    1504:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    1506:	8a e3       	ldi	r24, 0x3A	; 58
    1508:	89 83       	std	Y+1, r24	; 0x01
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    150a:	7f b7       	in	r23, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    150c:	f8 94       	cli
				#endif

				GCC_MEMORY_BARRIER();
    150e:	ae 01       	movw	r20, r28
    1510:	4d 5f       	subi	r20, 0xFD	; 253
    1512:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1514:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    1516:	38 e0       	ldi	r19, 0x08	; 8

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte;

					NVM.CMD    = NVM_CMD_READ_CALIB_ROW_gc;
    1518:	a0 ec       	ldi	r26, 0xC0	; 192
    151a:	b1 e0       	ldi	r27, 0x01	; 1
    151c:	62 e0       	ldi	r22, 0x02	; 2
    151e:	1a 96       	adiw	r26, 0x0a	; 10
    1520:	6c 93       	st	X, r22
    1522:	1a 97       	sbiw	r26, 0x0a	; 10
					SerialByte = pgm_read_byte(SigReadAddress);
    1524:	e3 2f       	mov	r30, r19
    1526:	f0 e0       	ldi	r31, 0x00	; 0
    1528:	84 91       	lpm	r24, Z
					NVM.CMD    = 0;
    152a:	1a 96       	adiw	r26, 0x0a	; 10
    152c:	1c 92       	st	X, r1
    152e:	1a 97       	sbiw	r26, 0x0a	; 10

					if (SerialCharNum & 0x01)
    1530:	20 ff       	sbrs	r18, 0
    1532:	03 c0       	rjmp	.+6      	; 0x153a <USB_Device_ProcessControlRequest+0x1b0>
					{
						SerialByte >>= 4;
    1534:	82 95       	swap	r24
    1536:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    1538:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    153a:	8f 70       	andi	r24, 0x0F	; 15

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    153c:	8a 30       	cpi	r24, 0x0A	; 10
    153e:	18 f0       	brcs	.+6      	; 0x1546 <USB_Device_ProcessControlRequest+0x1bc>
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	c7 96       	adiw	r24, 0x37	; 55
    1544:	02 c0       	rjmp	.+4      	; 0x154a <USB_Device_ProcessControlRequest+0x1c0>
    1546:	90 e0       	ldi	r25, 0x00	; 0
    1548:	c0 96       	adiw	r24, 0x30	; 48
    154a:	fa 01       	movw	r30, r20
    154c:	81 93       	st	Z+, r24
    154e:	91 93       	st	Z+, r25
    1550:	af 01       	movw	r20, r30
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1552:	2f 5f       	subi	r18, 0xFF	; 255
    1554:	2c 31       	cpi	r18, 0x1C	; 28
    1556:	19 f7       	brne	.-58     	; 0x151e <USB_Device_ProcessControlRequest+0x194>
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    1558:	7f bf       	out	0x3f, r23	; 63

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();
    155a:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    155e:	6a e3       	ldi	r22, 0x3A	; 58
    1560:	70 e0       	ldi	r23, 0x00	; 0
    1562:	ce 01       	movw	r24, r28
    1564:	01 96       	adiw	r24, 0x01	; 1
    1566:	0e 94 2d 0b 	call	0x165a	; 0x165a <Endpoint_Write_Control_Stream_LE>
	Endpoint_ClearOUT();
    156a:	0e 94 75 0c 	call	0x18ea	; 0x18ea <Endpoint_ClearOUT>
    156e:	42 c0       	rjmp	.+132    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    1570:	ae 01       	movw	r20, r28
    1572:	4f 5f       	subi	r20, 0xFF	; 255
    1574:	5f 4f       	sbci	r21, 0xFF	; 255
    1576:	60 91 5d 95 	lds	r22, 0x955D
    157a:	0e 94 c6 01 	call	0x38c	; 0x38c <CALLBACK_USB_GetDescriptor>
    157e:	8c 01       	movw	r16, r24
    1580:	89 2b       	or	r24, r25
    1582:	c1 f1       	breq	.+112    	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
													 )) == NO_DESCRIPTOR)
	{
		return;
	}

	Endpoint_ClearSETUP();
    1584:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    1588:	b8 01       	movw	r22, r16
    158a:	89 81       	ldd	r24, Y+1	; 0x01
    158c:	9a 81       	ldd	r25, Y+2	; 0x02
    158e:	0e 94 c3 0b 	call	0x1786	; 0x1786 <Endpoint_Write_Control_PStream_LE>
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
    1592:	0e 94 75 0c 	call	0x18ea	; 0x18ea <Endpoint_ClearOUT>
    1596:	2e c0       	rjmp	.+92     	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    1598:	20 38       	cpi	r18, 0x80	; 128
    159a:	61 f5       	brne	.+88     	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
	EVENT_USB_Device_ConfigurationChanged();
}

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
    159c:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    15a0:	80 91 54 95 	lds	r24, 0x9554
    15a4:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
	Endpoint_ClearIN();
    15a8:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>

	Endpoint_ClearStatusStage();
    15ac:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Endpoint_ClearStatusStage>
    15b0:	21 c0       	rjmp	.+66     	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    15b2:	21 11       	cpse	r18, r1
    15b4:	1f c0       	rjmp	.+62     	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    15b6:	80 91 5b 95 	lds	r24, 0x955B
    15ba:	82 30       	cpi	r24, 0x02	; 2
    15bc:	d8 f4       	brcc	.+54     	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
	if ((uint8_t)USB_ControlRequest.wValue > DevDescriptorPtr->NumberOfConfigurations)
	  return;
	#endif
	#endif

	Endpoint_ClearSETUP();
    15be:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    15c2:	80 91 5b 95 	lds	r24, 0x955B
    15c6:	80 93 54 95 	sts	0x9554, r24

	Endpoint_ClearStatusStage();
    15ca:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    15ce:	80 91 54 95 	lds	r24, 0x9554
    15d2:	88 23       	and	r24, r24
    15d4:	21 f0       	breq	.+8      	; 0x15de <USB_Device_ProcessControlRequest+0x254>
	  USB_DeviceState = DEVICE_STATE_Configured;
    15d6:	84 e0       	ldi	r24, 0x04	; 4
    15d8:	80 93 58 95 	sts	0x9558, r24
    15dc:	09 c0       	rjmp	.+18     	; 0x15f0 <USB_Device_ProcessControlRequest+0x266>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    15de:	80 91 c3 04 	lds	r24, 0x04C3
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    15e2:	81 11       	cpse	r24, r1
    15e4:	02 c0       	rjmp	.+4      	; 0x15ea <USB_Device_ProcessControlRequest+0x260>
    15e6:	81 e0       	ldi	r24, 0x01	; 1
    15e8:	01 c0       	rjmp	.+2      	; 0x15ec <USB_Device_ProcessControlRequest+0x262>
    15ea:	84 e0       	ldi	r24, 0x04	; 4
    15ec:	80 93 58 95 	sts	0x9558, r24

	EVENT_USB_Device_ConfigurationChanged();
    15f0:	0e 94 70 12 	call	0x24e0	; 0x24e0 <EVENT_USB_Device_ConfigurationChanged>
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    15f4:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <Endpoint_IsSETUPReceived>
    15f8:	88 23       	and	r24, r24
    15fa:	81 f0       	breq	.+32     	; 0x161c <USB_Device_ProcessControlRequest+0x292>
	{
		Endpoint_ClearSETUP();
    15fc:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <Endpoint_ClearSETUP>
		Endpoint_StallTransaction();
    1600:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <Endpoint_StallTransaction>
    1604:	0b c0       	rjmp	.+22     	; 0x161c <USB_Device_ProcessControlRequest+0x292>
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    1606:	80 91 5b 95 	lds	r24, 0x955B
    160a:	81 30       	cpi	r24, 0x01	; 1
    160c:	99 f7       	brne	.-26     	; 0x15f4 <USB_Device_ProcessControlRequest+0x26a>
    160e:	22 cf       	rjmp	.-444    	; 0x1454 <USB_Device_ProcessControlRequest+0xca>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    1610:	80 91 5b 95 	lds	r24, 0x955B
    1614:	88 23       	and	r24, r24
    1616:	09 f4       	brne	.+2      	; 0x161a <USB_Device_ProcessControlRequest+0x290>
    1618:	24 cf       	rjmp	.-440    	; 0x1462 <USB_Device_ProcessControlRequest+0xd8>
    161a:	48 cf       	rjmp	.-368    	; 0x14ac <USB_Device_ProcessControlRequest+0x122>
	if (Endpoint_IsSETUPReceived())
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    161c:	ea 96       	adiw	r28, 0x3a	; 58
    161e:	cd bf       	out	0x3d, r28	; 61
    1620:	de bf       	out	0x3e, r29	; 62
    1622:	df 91       	pop	r29
    1624:	cf 91       	pop	r28
    1626:	1f 91       	pop	r17
    1628:	0f 91       	pop	r16
    162a:	ff 90       	pop	r15
    162c:	ef 90       	pop	r14
    162e:	08 95       	ret

00001630 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    1630:	08 95       	ret

00001632 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    1632:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    1634:	80 91 58 95 	lds	r24, 0x9558
    1638:	88 23       	and	r24, r24
    163a:	69 f0       	breq	.+26     	; 0x1656 <USB_USBTask+0x24>
			 *  \return Index of the currently selected endpoint.
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				return USB_Endpoint_SelectedEndpoint;
    163c:	c0 91 65 95 	lds	r28, 0x9565
	  return;

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    1640:	80 e0       	ldi	r24, 0x00	; 0
    1642:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>

	if (Endpoint_IsSETUPReceived())
    1646:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <Endpoint_IsSETUPReceived>
    164a:	81 11       	cpse	r24, r1
	  USB_Device_ProcessControlRequest();
    164c:	0e 94 c5 09 	call	0x138a	; 0x138a <USB_Device_ProcessControlRequest>

	Endpoint_SelectEndpoint(PrevEndpoint);
    1650:	8c 2f       	mov	r24, r28
    1652:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    1656:	cf 91       	pop	r28
    1658:	08 95       	ret

0000165a <Endpoint_Write_Control_Stream_LE>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    165a:	cf 92       	push	r12
    165c:	df 92       	push	r13
    165e:	ef 92       	push	r14
    1660:	ff 92       	push	r15
    1662:	0f 93       	push	r16
    1664:	1f 93       	push	r17
    1666:	cf 93       	push	r28
    1668:	df 93       	push	r29
    166a:	c8 2e       	mov	r12, r24
    166c:	d9 2e       	mov	r13, r25
    166e:	8b 01       	movw	r16, r22
    1670:	80 91 65 95 	lds	r24, 0x9565
    1674:	80 68       	ori	r24, 0x80	; 128
    1676:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
    167a:	c0 91 5f 95 	lds	r28, 0x955F
    167e:	d0 91 60 95 	lds	r29, 0x9560
    1682:	c0 17       	cp	r28, r16
    1684:	d1 07       	cpc	r29, r17
    1686:	40 f0       	brcs	.+16     	; 0x1698 <Endpoint_Write_Control_Stream_LE+0x3e>
    1688:	01 15       	cp	r16, r1
    168a:	11 05       	cpc	r17, r1
    168c:	21 f4       	brne	.+8      	; 0x1696 <Endpoint_Write_Control_Stream_LE+0x3c>
    168e:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>
    1692:	e8 01       	movw	r28, r16
    1694:	01 c0       	rjmp	.+2      	; 0x1698 <Endpoint_Write_Control_Stream_LE+0x3e>
    1696:	e8 01       	movw	r28, r16
    1698:	ec 2c       	mov	r14, r12
    169a:	fd 2c       	mov	r15, r13
    169c:	d1 2c       	mov	r13, r1
    169e:	49 c0       	rjmp	.+146    	; 0x1732 <Endpoint_Write_Control_Stream_LE+0xd8>
    16a0:	80 91 58 95 	lds	r24, 0x9558
    16a4:	88 23       	and	r24, r24
    16a6:	09 f4       	brne	.+2      	; 0x16aa <Endpoint_Write_Control_Stream_LE+0x50>
    16a8:	5a c0       	rjmp	.+180    	; 0x175e <Endpoint_Write_Control_Stream_LE+0x104>
    16aa:	85 30       	cpi	r24, 0x05	; 5
    16ac:	09 f4       	brne	.+2      	; 0x16b0 <Endpoint_Write_Control_Stream_LE+0x56>
    16ae:	59 c0       	rjmp	.+178    	; 0x1762 <Endpoint_Write_Control_Stream_LE+0x108>
    16b0:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <Endpoint_IsSETUPReceived>
    16b4:	81 11       	cpse	r24, r1
    16b6:	57 c0       	rjmp	.+174    	; 0x1766 <Endpoint_Write_Control_Stream_LE+0x10c>
    16b8:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <Endpoint_IsOUTReceived>
    16bc:	81 11       	cpse	r24, r1
    16be:	49 c0       	rjmp	.+146    	; 0x1752 <Endpoint_Write_Control_Stream_LE+0xf8>
    16c0:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <Endpoint_IsINReady>
    16c4:	88 23       	and	r24, r24
    16c6:	a9 f1       	breq	.+106    	; 0x1732 <Endpoint_Write_Control_Stream_LE+0xd8>
    16c8:	80 91 65 95 	lds	r24, 0x9565
    16cc:	88 23       	and	r24, r24
    16ce:	74 f4       	brge	.+28     	; 0x16ec <Endpoint_Write_Control_Stream_LE+0x92>
    16d0:	e0 91 61 95 	lds	r30, 0x9561
    16d4:	f0 91 62 95 	lds	r31, 0x9562
    16d8:	ef 5b       	subi	r30, 0xBF	; 191
    16da:	ff 4f       	sbci	r31, 0xFF	; 255
    16dc:	00 81       	ld	r16, Z
    16de:	10 e0       	ldi	r17, 0x00	; 0
    16e0:	20 97       	sbiw	r28, 0x00	; 0
    16e2:	f9 f0       	breq	.+62     	; 0x1722 <Endpoint_Write_Control_Stream_LE+0xc8>
    16e4:	08 30       	cpi	r16, 0x08	; 8
    16e6:	11 05       	cpc	r17, r1
    16e8:	78 f0       	brcs	.+30     	; 0x1708 <Endpoint_Write_Control_Stream_LE+0xae>
    16ea:	1b c0       	rjmp	.+54     	; 0x1722 <Endpoint_Write_Control_Stream_LE+0xc8>
    16ec:	80 91 61 95 	lds	r24, 0x9561
    16f0:	90 91 62 95 	lds	r25, 0x9562
    16f4:	fc 01       	movw	r30, r24
    16f6:	e0 5c       	subi	r30, 0xC0	; 192
    16f8:	ff 4f       	sbci	r31, 0xFF	; 255
    16fa:	00 81       	ld	r16, Z
    16fc:	31 96       	adiw	r30, 0x01	; 1
    16fe:	80 81       	ld	r24, Z
    1700:	10 e0       	ldi	r17, 0x00	; 0
    1702:	08 1b       	sub	r16, r24
    1704:	11 09       	sbc	r17, r1
    1706:	ec cf       	rjmp	.-40     	; 0x16e0 <Endpoint_Write_Control_Stream_LE+0x86>
    1708:	f7 01       	movw	r30, r14
    170a:	81 91       	ld	r24, Z+
    170c:	7f 01       	movw	r14, r30
    170e:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
    1712:	21 97       	sbiw	r28, 0x01	; 1
    1714:	0f 5f       	subi	r16, 0xFF	; 255
    1716:	1f 4f       	sbci	r17, 0xFF	; 255
    1718:	20 97       	sbiw	r28, 0x00	; 0
    171a:	19 f0       	breq	.+6      	; 0x1722 <Endpoint_Write_Control_Stream_LE+0xc8>
    171c:	08 30       	cpi	r16, 0x08	; 8
    171e:	11 05       	cpc	r17, r1
    1720:	99 f7       	brne	.-26     	; 0x1708 <Endpoint_Write_Control_Stream_LE+0xae>
    1722:	dd 24       	eor	r13, r13
    1724:	d3 94       	inc	r13
    1726:	08 30       	cpi	r16, 0x08	; 8
    1728:	11 05       	cpc	r17, r1
    172a:	09 f0       	breq	.+2      	; 0x172e <Endpoint_Write_Control_Stream_LE+0xd4>
    172c:	d1 2c       	mov	r13, r1
    172e:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>
    1732:	20 97       	sbiw	r28, 0x00	; 0
    1734:	09 f0       	breq	.+2      	; 0x1738 <Endpoint_Write_Control_Stream_LE+0xde>
    1736:	b4 cf       	rjmp	.-152    	; 0x16a0 <Endpoint_Write_Control_Stream_LE+0x46>
    1738:	d1 10       	cpse	r13, r1
    173a:	b2 cf       	rjmp	.-156    	; 0x16a0 <Endpoint_Write_Control_Stream_LE+0x46>
    173c:	0a c0       	rjmp	.+20     	; 0x1752 <Endpoint_Write_Control_Stream_LE+0xf8>
    173e:	80 91 58 95 	lds	r24, 0x9558
    1742:	88 23       	and	r24, r24
    1744:	91 f0       	breq	.+36     	; 0x176a <Endpoint_Write_Control_Stream_LE+0x110>
    1746:	85 30       	cpi	r24, 0x05	; 5
    1748:	91 f0       	breq	.+36     	; 0x176e <Endpoint_Write_Control_Stream_LE+0x114>
    174a:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <Endpoint_IsSETUPReceived>
    174e:	81 11       	cpse	r24, r1
    1750:	10 c0       	rjmp	.+32     	; 0x1772 <Endpoint_Write_Control_Stream_LE+0x118>
    1752:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <Endpoint_IsOUTReceived>
    1756:	88 23       	and	r24, r24
    1758:	91 f3       	breq	.-28     	; 0x173e <Endpoint_Write_Control_Stream_LE+0xe4>
    175a:	80 e0       	ldi	r24, 0x00	; 0
    175c:	0b c0       	rjmp	.+22     	; 0x1774 <Endpoint_Write_Control_Stream_LE+0x11a>
    175e:	82 e0       	ldi	r24, 0x02	; 2
    1760:	09 c0       	rjmp	.+18     	; 0x1774 <Endpoint_Write_Control_Stream_LE+0x11a>
    1762:	83 e0       	ldi	r24, 0x03	; 3
    1764:	07 c0       	rjmp	.+14     	; 0x1774 <Endpoint_Write_Control_Stream_LE+0x11a>
    1766:	81 e0       	ldi	r24, 0x01	; 1
    1768:	05 c0       	rjmp	.+10     	; 0x1774 <Endpoint_Write_Control_Stream_LE+0x11a>
    176a:	82 e0       	ldi	r24, 0x02	; 2
    176c:	03 c0       	rjmp	.+6      	; 0x1774 <Endpoint_Write_Control_Stream_LE+0x11a>
    176e:	83 e0       	ldi	r24, 0x03	; 3
    1770:	01 c0       	rjmp	.+2      	; 0x1774 <Endpoint_Write_Control_Stream_LE+0x11a>
    1772:	81 e0       	ldi	r24, 0x01	; 1
    1774:	df 91       	pop	r29
    1776:	cf 91       	pop	r28
    1778:	1f 91       	pop	r17
    177a:	0f 91       	pop	r16
    177c:	ff 90       	pop	r15
    177e:	ef 90       	pop	r14
    1780:	df 90       	pop	r13
    1782:	cf 90       	pop	r12
    1784:	08 95       	ret

00001786 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    1786:	df 92       	push	r13
    1788:	ef 92       	push	r14
    178a:	ff 92       	push	r15
    178c:	0f 93       	push	r16
    178e:	1f 93       	push	r17
    1790:	cf 93       	push	r28
    1792:	df 93       	push	r29
    1794:	e8 2e       	mov	r14, r24
    1796:	f9 2e       	mov	r15, r25
    1798:	8b 01       	movw	r16, r22
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    179a:	80 91 65 95 	lds	r24, 0x9565
    179e:	80 68       	ori	r24, 0x80	; 128
    17a0:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>

	if (Length > USB_ControlRequest.wLength)
    17a4:	c0 91 5f 95 	lds	r28, 0x955F
    17a8:	d0 91 60 95 	lds	r29, 0x9560
    17ac:	c0 17       	cp	r28, r16
    17ae:	d1 07       	cpc	r29, r17
    17b0:	40 f0       	brcs	.+16     	; 0x17c2 <Endpoint_Write_Control_PStream_LE+0x3c>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    17b2:	01 15       	cp	r16, r1
    17b4:	11 05       	cpc	r17, r1
    17b6:	21 f4       	brne	.+8      	; 0x17c0 <Endpoint_Write_Control_PStream_LE+0x3a>
	  Endpoint_ClearIN();
    17b8:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>
    17bc:	e8 01       	movw	r28, r16
    17be:	01 c0       	rjmp	.+2      	; 0x17c2 <Endpoint_Write_Control_PStream_LE+0x3c>
    17c0:	e8 01       	movw	r28, r16
    17c2:	0e 2d       	mov	r16, r14
    17c4:	1f 2d       	mov	r17, r15
    17c6:	d1 2c       	mov	r13, r1
    17c8:	4e c0       	rjmp	.+156    	; 0x1866 <Endpoint_Write_Control_PStream_LE+0xe0>

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    17ca:	80 91 58 95 	lds	r24, 0x9558

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    17ce:	88 23       	and	r24, r24
    17d0:	09 f4       	brne	.+2      	; 0x17d4 <Endpoint_Write_Control_PStream_LE+0x4e>
    17d2:	5f c0       	rjmp	.+190    	; 0x1892 <Endpoint_Write_Control_PStream_LE+0x10c>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    17d4:	85 30       	cpi	r24, 0x05	; 5
    17d6:	09 f4       	brne	.+2      	; 0x17da <Endpoint_Write_Control_PStream_LE+0x54>
    17d8:	5e c0       	rjmp	.+188    	; 0x1896 <Endpoint_Write_Control_PStream_LE+0x110>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    17da:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <Endpoint_IsSETUPReceived>
    17de:	81 11       	cpse	r24, r1
    17e0:	5c c0       	rjmp	.+184    	; 0x189a <Endpoint_Write_Control_PStream_LE+0x114>
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    17e2:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <Endpoint_IsOUTReceived>
    17e6:	81 11       	cpse	r24, r1
    17e8:	4e c0       	rjmp	.+156    	; 0x1886 <Endpoint_Write_Control_PStream_LE+0x100>
		  break;

		if (Endpoint_IsINReady())
    17ea:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <Endpoint_IsINReady>
    17ee:	88 23       	and	r24, r24
    17f0:	d1 f1       	breq	.+116    	; 0x1866 <Endpoint_Write_Control_PStream_LE+0xe0>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    17f2:	80 91 65 95 	lds	r24, 0x9565
    17f6:	88 23       	and	r24, r24
    17f8:	7c f4       	brge	.+30     	; 0x1818 <Endpoint_Write_Control_PStream_LE+0x92>
				  return USB_Endpoint_SelectedFIFO->Position;
    17fa:	e0 91 61 95 	lds	r30, 0x9561
    17fe:	f0 91 62 95 	lds	r31, 0x9562
    1802:	ef 5b       	subi	r30, 0xBF	; 191
    1804:	ff 4f       	sbci	r31, 0xFF	; 255
    1806:	e0 80       	ld	r14, Z
    1808:	f1 2c       	mov	r15, r1
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    180a:	20 97       	sbiw	r28, 0x00	; 0
    180c:	19 f1       	breq	.+70     	; 0x1854 <Endpoint_Write_Control_PStream_LE+0xce>
    180e:	88 e0       	ldi	r24, 0x08	; 8
    1810:	e8 16       	cp	r14, r24
    1812:	f1 04       	cpc	r15, r1
    1814:	78 f0       	brcs	.+30     	; 0x1834 <Endpoint_Write_Control_PStream_LE+0xae>
    1816:	1e c0       	rjmp	.+60     	; 0x1854 <Endpoint_Write_Control_PStream_LE+0xce>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    1818:	80 91 61 95 	lds	r24, 0x9561
    181c:	90 91 62 95 	lds	r25, 0x9562
    1820:	fc 01       	movw	r30, r24
    1822:	e0 5c       	subi	r30, 0xC0	; 192
    1824:	ff 4f       	sbci	r31, 0xFF	; 255
    1826:	e0 80       	ld	r14, Z
    1828:	31 96       	adiw	r30, 0x01	; 1
    182a:	80 81       	ld	r24, Z
    182c:	f1 2c       	mov	r15, r1
    182e:	e8 1a       	sub	r14, r24
    1830:	f1 08       	sbc	r15, r1
    1832:	eb cf       	rjmp	.-42     	; 0x180a <Endpoint_Write_Control_PStream_LE+0x84>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1834:	f8 01       	movw	r30, r16
    1836:	84 91       	lpm	r24, Z
    1838:	0e 94 94 0c 	call	0x1928	; 0x1928 <Endpoint_Write_8>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    183c:	0f 5f       	subi	r16, 0xFF	; 255
    183e:	1f 4f       	sbci	r17, 0xFF	; 255
				Length--;
    1840:	21 97       	sbiw	r28, 0x01	; 1
				BytesInEndpoint++;
    1842:	ff ef       	ldi	r31, 0xFF	; 255
    1844:	ef 1a       	sub	r14, r31
    1846:	ff 0a       	sbc	r15, r31

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1848:	20 97       	sbiw	r28, 0x00	; 0
    184a:	21 f0       	breq	.+8      	; 0x1854 <Endpoint_Write_Control_PStream_LE+0xce>
    184c:	88 e0       	ldi	r24, 0x08	; 8
    184e:	e8 16       	cp	r14, r24
    1850:	f1 04       	cpc	r15, r1
    1852:	81 f7       	brne	.-32     	; 0x1834 <Endpoint_Write_Control_PStream_LE+0xae>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1854:	dd 24       	eor	r13, r13
    1856:	d3 94       	inc	r13
    1858:	e8 e0       	ldi	r30, 0x08	; 8
    185a:	ee 16       	cp	r14, r30
    185c:	f1 04       	cpc	r15, r1
    185e:	09 f0       	breq	.+2      	; 0x1862 <Endpoint_Write_Control_PStream_LE+0xdc>
    1860:	d1 2c       	mov	r13, r1
			Endpoint_ClearIN();
    1862:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1866:	20 97       	sbiw	r28, 0x00	; 0
    1868:	09 f0       	breq	.+2      	; 0x186c <Endpoint_Write_Control_PStream_LE+0xe6>
    186a:	af cf       	rjmp	.-162    	; 0x17ca <Endpoint_Write_Control_PStream_LE+0x44>
    186c:	d1 10       	cpse	r13, r1
    186e:	ad cf       	rjmp	.-166    	; 0x17ca <Endpoint_Write_Control_PStream_LE+0x44>
    1870:	0a c0       	rjmp	.+20     	; 0x1886 <Endpoint_Write_Control_PStream_LE+0x100>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1872:	80 91 58 95 	lds	r24, 0x9558

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1876:	88 23       	and	r24, r24
    1878:	91 f0       	breq	.+36     	; 0x189e <Endpoint_Write_Control_PStream_LE+0x118>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    187a:	85 30       	cpi	r24, 0x05	; 5
    187c:	91 f0       	breq	.+36     	; 0x18a2 <Endpoint_Write_Control_PStream_LE+0x11c>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    187e:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <Endpoint_IsSETUPReceived>
    1882:	81 11       	cpse	r24, r1
    1884:	10 c0       	rjmp	.+32     	; 0x18a6 <Endpoint_Write_Control_PStream_LE+0x120>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1886:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <Endpoint_IsOUTReceived>
    188a:	88 23       	and	r24, r24
    188c:	91 f3       	breq	.-28     	; 0x1872 <Endpoint_Write_Control_PStream_LE+0xec>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    188e:	80 e0       	ldi	r24, 0x00	; 0
    1890:	0b c0       	rjmp	.+22     	; 0x18a8 <Endpoint_Write_Control_PStream_LE+0x122>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1892:	82 e0       	ldi	r24, 0x02	; 2
    1894:	09 c0       	rjmp	.+18     	; 0x18a8 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1896:	83 e0       	ldi	r24, 0x03	; 3
    1898:	07 c0       	rjmp	.+14     	; 0x18a8 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    189a:	81 e0       	ldi	r24, 0x01	; 1
    189c:	05 c0       	rjmp	.+10     	; 0x18a8 <Endpoint_Write_Control_PStream_LE+0x122>
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    189e:	82 e0       	ldi	r24, 0x02	; 2
    18a0:	03 c0       	rjmp	.+6      	; 0x18a8 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    18a2:	83 e0       	ldi	r24, 0x03	; 3
    18a4:	01 c0       	rjmp	.+2      	; 0x18a8 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    18a6:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    18a8:	df 91       	pop	r29
    18aa:	cf 91       	pop	r28
    18ac:	1f 91       	pop	r17
    18ae:	0f 91       	pop	r16
    18b0:	ff 90       	pop	r15
    18b2:	ef 90       	pop	r14
    18b4:	df 90       	pop	r13
    18b6:	08 95       	ret

000018b8 <Endpoint_ClearIN>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_ClearIN(void)
{
	USB_Endpoint_SelectedHandle->CNT     = USB_Endpoint_SelectedFIFO->Position;
    18b8:	e0 91 63 95 	lds	r30, 0x9563
    18bc:	f0 91 64 95 	lds	r31, 0x9564
    18c0:	a0 91 61 95 	lds	r26, 0x9561
    18c4:	b0 91 62 95 	lds	r27, 0x9562
    18c8:	af 5b       	subi	r26, 0xBF	; 191
    18ca:	bf 4f       	sbci	r27, 0xFF	; 255
    18cc:	8c 91       	ld	r24, X
    18ce:	90 e0       	ldi	r25, 0x00	; 0
    18d0:	82 83       	std	Z+2, r24	; 0x02
    18d2:	93 83       	std	Z+3, r25	; 0x03
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    18d4:	80 81       	ld	r24, Z
    18d6:	8d 79       	andi	r24, 0x9D	; 157
    18d8:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    18da:	e0 91 61 95 	lds	r30, 0x9561
    18de:	f0 91 62 95 	lds	r31, 0x9562
    18e2:	ef 5b       	subi	r30, 0xBF	; 191
    18e4:	ff 4f       	sbci	r31, 0xFF	; 255
    18e6:	10 82       	st	Z, r1
    18e8:	08 95       	ret

000018ea <Endpoint_ClearOUT>:
}

void Endpoint_ClearOUT(void)
{
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    18ea:	e0 91 63 95 	lds	r30, 0x9563
    18ee:	f0 91 64 95 	lds	r31, 0x9564
    18f2:	80 81       	ld	r24, Z
    18f4:	8d 79       	andi	r24, 0x9D	; 157
    18f6:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    18f8:	e0 91 61 95 	lds	r30, 0x9561
    18fc:	f0 91 62 95 	lds	r31, 0x9562
    1900:	ef 5b       	subi	r30, 0xBF	; 191
    1902:	ff 4f       	sbci	r31, 0xFF	; 255
    1904:	10 82       	st	Z, r1
    1906:	08 95       	ret

00001908 <Endpoint_Read_8>:
	}
}

uint8_t Endpoint_Read_8(void)
{
	return USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++];
    1908:	80 91 61 95 	lds	r24, 0x9561
    190c:	90 91 62 95 	lds	r25, 0x9562
    1910:	fc 01       	movw	r30, r24
    1912:	ef 5b       	subi	r30, 0xBF	; 191
    1914:	ff 4f       	sbci	r31, 0xFF	; 255
    1916:	20 81       	ld	r18, Z
    1918:	31 e0       	ldi	r19, 0x01	; 1
    191a:	32 0f       	add	r19, r18
    191c:	30 83       	st	Z, r19
    191e:	fc 01       	movw	r30, r24
    1920:	e2 0f       	add	r30, r18
    1922:	f1 1d       	adc	r31, r1
    1924:	80 81       	ld	r24, Z
}
    1926:	08 95       	ret

00001928 <Endpoint_Write_8>:

void Endpoint_Write_8(const uint8_t Data)
{
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
    1928:	20 91 61 95 	lds	r18, 0x9561
    192c:	30 91 62 95 	lds	r19, 0x9562
    1930:	f9 01       	movw	r30, r18
    1932:	ef 5b       	subi	r30, 0xBF	; 191
    1934:	ff 4f       	sbci	r31, 0xFF	; 255
    1936:	90 81       	ld	r25, Z
    1938:	41 e0       	ldi	r20, 0x01	; 1
    193a:	49 0f       	add	r20, r25
    193c:	40 83       	st	Z, r20
    193e:	f9 01       	movw	r30, r18
    1940:	e9 0f       	add	r30, r25
    1942:	f1 1d       	adc	r31, r1
    1944:	80 83       	st	Z, r24
    1946:	08 95       	ret

00001948 <Endpoint_SelectEndpoint>:

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);

	USB_Endpoint_SelectedEndpoint = Address;
    1948:	80 93 65 95 	sts	0x9565, r24
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
}

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);
    194c:	28 2f       	mov	r18, r24
    194e:	2f 70       	andi	r18, 0x0F	; 15

	USB_Endpoint_SelectedEndpoint = Address;

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
    1950:	30 e0       	ldi	r19, 0x00	; 0
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;
    1952:	40 91 c6 04 	lds	r20, 0x04C6
    1956:	50 91 c7 04 	lds	r21, 0x04C7

	if (Address & ENDPOINT_DIR_IN)
    195a:	88 23       	and	r24, r24
    195c:	e4 f4       	brge	.+56     	; 0x1996 <Endpoint_SelectEndpoint+0x4e>
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
    195e:	64 e8       	ldi	r22, 0x84	; 132
    1960:	62 9f       	mul	r22, r18
    1962:	c0 01       	movw	r24, r0
    1964:	63 9f       	mul	r22, r19
    1966:	90 0d       	add	r25, r0
    1968:	11 24       	eor	r1, r1
    196a:	88 55       	subi	r24, 0x58	; 88
    196c:	9a 46       	sbci	r25, 0x6A	; 106
    196e:	80 93 61 95 	sts	0x9561, r24
    1972:	90 93 62 95 	sts	0x9562, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].IN;
    1976:	c9 01       	movw	r24, r18
    1978:	82 95       	swap	r24
    197a:	92 95       	swap	r25
    197c:	90 7f       	andi	r25, 0xF0	; 240
    197e:	98 27       	eor	r25, r24
    1980:	80 7f       	andi	r24, 0xF0	; 240
    1982:	98 27       	eor	r25, r24
    1984:	08 96       	adiw	r24, 0x08	; 8
    1986:	9a 01       	movw	r18, r20
    1988:	28 0f       	add	r18, r24
    198a:	39 1f       	adc	r19, r25
    198c:	20 93 63 95 	sts	0x9563, r18
    1990:	30 93 64 95 	sts	0x9564, r19
    1994:	08 95       	ret
	}
	else
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->OUT;
    1996:	64 e8       	ldi	r22, 0x84	; 132
    1998:	62 9f       	mul	r22, r18
    199a:	c0 01       	movw	r24, r0
    199c:	63 9f       	mul	r22, r19
    199e:	90 0d       	add	r25, r0
    19a0:	11 24       	eor	r1, r1
    19a2:	8a 59       	subi	r24, 0x9A	; 154
    19a4:	9a 46       	sbci	r25, 0x6A	; 106
    19a6:	80 93 61 95 	sts	0x9561, r24
    19aa:	90 93 62 95 	sts	0x9562, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].OUT;
    19ae:	22 95       	swap	r18
    19b0:	32 95       	swap	r19
    19b2:	30 7f       	andi	r19, 0xF0	; 240
    19b4:	32 27       	eor	r19, r18
    19b6:	20 7f       	andi	r18, 0xF0	; 240
    19b8:	32 27       	eor	r19, r18
    19ba:	24 0f       	add	r18, r20
    19bc:	35 1f       	adc	r19, r21
    19be:	20 93 63 95 	sts	0x9563, r18
    19c2:	30 93 64 95 	sts	0x9564, r19
    19c6:	08 95       	ret

000019c8 <Endpoint_IsINReady>:
volatile USB_EP_t*        USB_Endpoint_SelectedHandle;
volatile Endpoint_FIFO_t* USB_Endpoint_SelectedFIFO;

bool Endpoint_IsINReady(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    19c8:	80 91 65 95 	lds	r24, 0x9565
    19cc:	80 68       	ori	r24, 0x80	; 128
    19ce:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>

	return ((USB_Endpoint_SelectedHandle->STATUS & USB_EP_BUSNACK0_bm) ? true : false);
    19d2:	e0 91 63 95 	lds	r30, 0x9563
    19d6:	f0 91 64 95 	lds	r31, 0x9564
    19da:	80 81       	ld	r24, Z
}
    19dc:	86 95       	lsr	r24
    19de:	81 70       	andi	r24, 0x01	; 1
    19e0:	08 95       	ret

000019e2 <Endpoint_IsOUTReceived>:

bool Endpoint_IsOUTReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    19e2:	80 91 65 95 	lds	r24, 0x9565
    19e6:	8f 77       	andi	r24, 0x7F	; 127
    19e8:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_TRNCOMPL0_bm)
    19ec:	e0 91 63 95 	lds	r30, 0x9563
    19f0:	f0 91 64 95 	lds	r31, 0x9564
    19f4:	80 81       	ld	r24, Z
    19f6:	85 ff       	sbrs	r24, 5
    19f8:	0c c0       	rjmp	.+24     	; 0x1a12 <Endpoint_IsOUTReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    19fa:	80 91 61 95 	lds	r24, 0x9561
    19fe:	90 91 62 95 	lds	r25, 0x9562
    1a02:	22 81       	ldd	r18, Z+2	; 0x02
    1a04:	33 81       	ldd	r19, Z+3	; 0x03
    1a06:	fc 01       	movw	r30, r24
    1a08:	e0 5c       	subi	r30, 0xC0	; 192
    1a0a:	ff 4f       	sbci	r31, 0xFF	; 255
    1a0c:	20 83       	st	Z, r18
		return true;
    1a0e:	81 e0       	ldi	r24, 0x01	; 1
    1a10:	08 95       	ret
	}

	return false;
    1a12:	80 e0       	ldi	r24, 0x00	; 0
}
    1a14:	08 95       	ret

00001a16 <Endpoint_IsSETUPReceived>:

bool Endpoint_IsSETUPReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    1a16:	80 91 65 95 	lds	r24, 0x9565
    1a1a:	8f 77       	andi	r24, 0x7F	; 127
    1a1c:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_SETUP_bm)
    1a20:	e0 91 63 95 	lds	r30, 0x9563
    1a24:	f0 91 64 95 	lds	r31, 0x9564
    1a28:	80 81       	ld	r24, Z
    1a2a:	84 ff       	sbrs	r24, 4
    1a2c:	0c c0       	rjmp	.+24     	; 0x1a46 <Endpoint_IsSETUPReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    1a2e:	80 91 61 95 	lds	r24, 0x9561
    1a32:	90 91 62 95 	lds	r25, 0x9562
    1a36:	22 81       	ldd	r18, Z+2	; 0x02
    1a38:	33 81       	ldd	r19, Z+3	; 0x03
    1a3a:	fc 01       	movw	r30, r24
    1a3c:	e0 5c       	subi	r30, 0xC0	; 192
    1a3e:	ff 4f       	sbci	r31, 0xFF	; 255
    1a40:	20 83       	st	Z, r18
		return true;
    1a42:	81 e0       	ldi	r24, 0x01	; 1
    1a44:	08 95       	ret
	}

	return false;
    1a46:	80 e0       	ldi	r24, 0x00	; 0
}
    1a48:	08 95       	ret

00001a4a <Endpoint_ClearSETUP>:

void Endpoint_ClearSETUP(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    1a4a:	80 91 65 95 	lds	r24, 0x9565
    1a4e:	8f 77       	andi	r24, 0x7F	; 127
    1a50:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_SETUP_bm | USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    1a54:	e0 91 63 95 	lds	r30, 0x9563
    1a58:	f0 91 64 95 	lds	r31, 0x9564
    1a5c:	80 81       	ld	r24, Z
    1a5e:	8d 78       	andi	r24, 0x8D	; 141
    1a60:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    1a62:	e0 91 63 95 	lds	r30, 0x9563
    1a66:	f0 91 64 95 	lds	r31, 0x9564
    1a6a:	80 81       	ld	r24, Z
    1a6c:	81 60       	ori	r24, 0x01	; 1
    1a6e:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1a70:	e0 91 61 95 	lds	r30, 0x9561
    1a74:	f0 91 62 95 	lds	r31, 0x9562
    1a78:	ef 5b       	subi	r30, 0xBF	; 191
    1a7a:	ff 4f       	sbci	r31, 0xFF	; 255
    1a7c:	10 82       	st	Z, r1

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    1a7e:	80 91 65 95 	lds	r24, 0x9565
    1a82:	80 68       	ori	r24, 0x80	; 128
    1a84:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    1a88:	e0 91 63 95 	lds	r30, 0x9563
    1a8c:	f0 91 64 95 	lds	r31, 0x9564
    1a90:	80 81       	ld	r24, Z
    1a92:	81 60       	ori	r24, 0x01	; 1
    1a94:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1a96:	e0 91 61 95 	lds	r30, 0x9561
    1a9a:	f0 91 62 95 	lds	r31, 0x9562
    1a9e:	ef 5b       	subi	r30, 0xBF	; 191
    1aa0:	ff 4f       	sbci	r31, 0xFF	; 255
    1aa2:	10 82       	st	Z, r1
    1aa4:	08 95       	ret

00001aa6 <Endpoint_StallTransaction>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_StallTransaction(void)
{
	USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    1aa6:	e0 91 63 95 	lds	r30, 0x9563
    1aaa:	f0 91 64 95 	lds	r31, 0x9564
    1aae:	81 81       	ldd	r24, Z+1	; 0x01
    1ab0:	84 60       	ori	r24, 0x04	; 4
    1ab2:	81 83       	std	Z+1, r24	; 0x01

	if ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_TYPE_gm) == USB_EP_TYPE_CONTROL_gc)
    1ab4:	e0 91 63 95 	lds	r30, 0x9563
    1ab8:	f0 91 64 95 	lds	r31, 0x9564
    1abc:	81 81       	ldd	r24, Z+1	; 0x01
    1abe:	80 7c       	andi	r24, 0xC0	; 192
    1ac0:	80 34       	cpi	r24, 0x40	; 64
    1ac2:	61 f4       	brne	.+24     	; 0x1adc <Endpoint_StallTransaction+0x36>
	{
		Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint ^ ENDPOINT_DIR_IN);
    1ac4:	80 91 65 95 	lds	r24, 0x9565
    1ac8:	80 58       	subi	r24, 0x80	; 128
    1aca:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>
		USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    1ace:	e0 91 63 95 	lds	r30, 0x9563
    1ad2:	f0 91 64 95 	lds	r31, 0x9564
    1ad6:	81 81       	ldd	r24, Z+1	; 0x01
    1ad8:	84 60       	ori	r24, 0x04	; 4
    1ada:	81 83       	std	Z+1, r24	; 0x01
    1adc:	08 95       	ret

00001ade <Endpoint_ConfigureEndpoint_PRV>:
}

bool Endpoint_ConfigureEndpoint_PRV(const uint8_t Address,
                                    const uint8_t Config,
                                    const uint8_t Size)
{
    1ade:	1f 93       	push	r17
    1ae0:	cf 93       	push	r28
    1ae2:	df 93       	push	r29
    1ae4:	d8 2f       	mov	r29, r24
    1ae6:	16 2f       	mov	r17, r22
    1ae8:	c4 2f       	mov	r28, r20
	Endpoint_SelectEndpoint(Address);
    1aea:	0e 94 a4 0c 	call	0x1948	; 0x1948 <Endpoint_SelectEndpoint>

	USB_Endpoint_SelectedHandle->CTRL    = 0;
    1aee:	e0 91 63 95 	lds	r30, 0x9563
    1af2:	f0 91 64 95 	lds	r31, 0x9564
    1af6:	11 82       	std	Z+1, r1	; 0x01
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    1af8:	e0 91 63 95 	lds	r30, 0x9563
    1afc:	f0 91 64 95 	lds	r31, 0x9564
    1b00:	dd 23       	and	r29, r29
    1b02:	a4 f0       	brlt	.+40     	; 0x1b2c <Endpoint_ConfigureEndpoint_PRV+0x4e>
    1b04:	10 82       	st	Z, r1
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    1b06:	e0 91 63 95 	lds	r30, 0x9563
    1b0a:	f0 91 64 95 	lds	r31, 0x9564
    1b0e:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    1b10:	e0 91 63 95 	lds	r30, 0x9563
    1b14:	f0 91 64 95 	lds	r31, 0x9564
    1b18:	12 82       	std	Z+2, r1	; 0x02
    1b1a:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    1b1c:	80 91 61 95 	lds	r24, 0x9561
    1b20:	90 91 62 95 	lds	r25, 0x9562
    1b24:	84 83       	std	Z+4, r24	; 0x04
    1b26:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    1b28:	40 e0       	ldi	r20, 0x00	; 0
    1b2a:	14 c0       	rjmp	.+40     	; 0x1b54 <Endpoint_ConfigureEndpoint_PRV+0x76>
                                    const uint8_t Size)
{
	Endpoint_SelectEndpoint(Address);

	USB_Endpoint_SelectedHandle->CTRL    = 0;
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    1b2c:	82 e0       	ldi	r24, 0x02	; 2
    1b2e:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    1b30:	e0 91 63 95 	lds	r30, 0x9563
    1b34:	f0 91 64 95 	lds	r31, 0x9564
    1b38:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    1b3a:	e0 91 63 95 	lds	r30, 0x9563
    1b3e:	f0 91 64 95 	lds	r31, 0x9564
    1b42:	12 82       	std	Z+2, r1	; 0x02
    1b44:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    1b46:	80 91 61 95 	lds	r24, 0x9561
    1b4a:	90 91 62 95 	lds	r25, 0x9562
    1b4e:	84 83       	std	Z+4, r24	; 0x04
    1b50:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    1b52:	4c 2f       	mov	r20, r28
    1b54:	fc 01       	movw	r30, r24
    1b56:	e0 5c       	subi	r30, 0xC0	; 192
    1b58:	ff 4f       	sbci	r31, 0xFF	; 255
    1b5a:	40 83       	st	Z, r20
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1b5c:	31 96       	adiw	r30, 0x01	; 1
    1b5e:	10 82       	st	Z, r1

	return true;
}
    1b60:	81 e0       	ldi	r24, 0x01	; 1
    1b62:	df 91       	pop	r29
    1b64:	cf 91       	pop	r28
    1b66:	1f 91       	pop	r17
    1b68:	08 95       	ret

00001b6a <Endpoint_ConfigureEndpointTable>:
	}
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    1b6a:	af 92       	push	r10
    1b6c:	bf 92       	push	r11
    1b6e:	cf 92       	push	r12
    1b70:	df 92       	push	r13
    1b72:	ef 92       	push	r14
    1b74:	ff 92       	push	r15
    1b76:	0f 93       	push	r16
    1b78:	1f 93       	push	r17
    1b7a:	cf 93       	push	r28
    1b7c:	df 93       	push	r29
	for (uint8_t i = 0; i < Entries; i++)
    1b7e:	66 23       	and	r22, r22
    1b80:	09 f4       	brne	.+2      	; 0x1b84 <Endpoint_ConfigureEndpointTable+0x1a>
    1b82:	57 c0       	rjmp	.+174    	; 0x1c32 <Endpoint_ConfigureEndpointTable+0xc8>
    1b84:	a6 2e       	mov	r10, r22
    1b86:	7c 01       	movw	r14, r24
    1b88:	8c 01       	movw	r16, r24
    1b8a:	84 e0       	ldi	r24, 0x04	; 4
    1b8c:	e8 0e       	add	r14, r24
    1b8e:	f1 1c       	adc	r15, r1
    1b90:	b1 2c       	mov	r11, r1
	{
		if (!(Table[i].Address))
    1b92:	f8 01       	movw	r30, r16
    1b94:	c0 80       	ld	r12, Z
    1b96:	cc 20       	and	r12, r12
    1b98:	09 f4       	brne	.+2      	; 0x1b9c <Endpoint_ConfigureEndpointTable+0x32>
    1b9a:	41 c0       	rjmp	.+130    	; 0x1c1e <Endpoint_ConfigureEndpointTable+0xb4>
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    1b9c:	c1 81       	ldd	r28, Z+1	; 0x01
    1b9e:	d2 81       	ldd	r29, Z+2	; 0x02
    1ba0:	f7 01       	movw	r30, r14
    1ba2:	31 97       	sbiw	r30, 0x01	; 1
    1ba4:	80 81       	ld	r24, Z
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    1ba6:	f7 01       	movw	r30, r14
    1ba8:	90 81       	ld	r25, Z
    1baa:	92 30       	cpi	r25, 0x02	; 2
    1bac:	10 f4       	brcc	.+4      	; 0x1bb2 <Endpoint_ConfigureEndpointTable+0x48>
    1bae:	48 e0       	ldi	r20, 0x08	; 8
    1bb0:	01 c0       	rjmp	.+2      	; 0x1bb4 <Endpoint_ConfigureEndpointTable+0x4a>
    1bb2:	48 e1       	ldi	r20, 0x18	; 24
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    1bb4:	c9 30       	cpi	r28, 0x09	; 9
    1bb6:	d1 05       	cpc	r29, r1
    1bb8:	50 f0       	brcs	.+20     	; 0x1bce <Endpoint_ConfigureEndpointTable+0x64>
    1bba:	28 e0       	ldi	r18, 0x08	; 8
    1bbc:	30 e0       	ldi	r19, 0x00	; 0
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
				{
					MaskVal++;
    1bc0:	9f 5f       	subi	r25, 0xFF	; 255
					CheckBytes <<= 1;
    1bc2:	22 0f       	add	r18, r18
    1bc4:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    1bc6:	2c 17       	cp	r18, r28
    1bc8:	3d 07       	cpc	r19, r29
    1bca:	d0 f3       	brcs	.-12     	; 0x1bc0 <Endpoint_ConfigureEndpointTable+0x56>
    1bcc:	01 c0       	rjmp	.+2      	; 0x1bd0 <Endpoint_ConfigureEndpointTable+0x66>
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    1bce:	90 e0       	ldi	r25, 0x00	; 0
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    1bd0:	94 2b       	or	r25, r20

				if ((Address & ENDPOINT_EPNUM_MASK) >= ENDPOINT_TOTAL_ENDPOINTS)
    1bd2:	2c 2d       	mov	r18, r12
    1bd4:	2f 70       	andi	r18, 0x0F	; 15
    1bd6:	30 e0       	ldi	r19, 0x00	; 0
    1bd8:	25 30       	cpi	r18, 0x05	; 5
    1bda:	31 05       	cpc	r19, r1
    1bdc:	64 f5       	brge	.+88     	; 0x1c36 <Endpoint_ConfigureEndpointTable+0xcc>
				  return false;

				// TODO - Fix once limitations are lifted
				EPConfigMask &= ~USB_EP_PINGPONG_bm;
    1bde:	9f 7e       	andi	r25, 0xEF	; 239
				if (Size > 64)
    1be0:	c1 34       	cpi	r28, 0x41	; 65
    1be2:	d1 05       	cpc	r29, r1
    1be4:	50 f5       	brcc	.+84     	; 0x1c3a <Endpoint_ConfigureEndpointTable+0xd0>
				  return false;

				switch (Type)
    1be6:	88 23       	and	r24, r24
    1be8:	19 f0       	breq	.+6      	; 0x1bf0 <Endpoint_ConfigureEndpointTable+0x86>
    1bea:	81 30       	cpi	r24, 0x01	; 1
    1bec:	21 f0       	breq	.+8      	; 0x1bf6 <Endpoint_ConfigureEndpointTable+0x8c>
    1bee:	06 c0       	rjmp	.+12     	; 0x1bfc <Endpoint_ConfigureEndpointTable+0x92>
				{
					case EP_TYPE_CONTROL:
						EPConfigMask |= USB_EP_TYPE_CONTROL_gc;
    1bf0:	90 64       	ori	r25, 0x40	; 64
    1bf2:	d9 2e       	mov	r13, r25
    1bf4:	07 c0       	rjmp	.+14     	; 0x1c04 <Endpoint_ConfigureEndpointTable+0x9a>
						break;
					case EP_TYPE_ISOCHRONOUS:
						EPConfigMask |= USB_EP_TYPE_ISOCHRONOUS_gc;
    1bf6:	90 6c       	ori	r25, 0xC0	; 192
    1bf8:	d9 2e       	mov	r13, r25
    1bfa:	0a c0       	rjmp	.+20     	; 0x1c10 <Endpoint_ConfigureEndpointTable+0xa6>
						break;
					default:
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
    1bfc:	90 68       	ori	r25, 0x80	; 128
    1bfe:	d9 2e       	mov	r13, r25
						break;
				}

				if (Type == EP_TYPE_CONTROL)
    1c00:	81 11       	cpse	r24, r1
    1c02:	06 c0       	rjmp	.+12     	; 0x1c10 <Endpoint_ConfigureEndpointTable+0xa6>
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    1c04:	4c 2f       	mov	r20, r28
    1c06:	6d 2d       	mov	r22, r13
    1c08:	80 e8       	ldi	r24, 0x80	; 128
    1c0a:	8c 0d       	add	r24, r12
    1c0c:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    1c10:	4c 2f       	mov	r20, r28
    1c12:	6d 2d       	mov	r22, r13
    1c14:	8c 2d       	mov	r24, r12
    1c16:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <Endpoint_ConfigureEndpoint_PRV>
    1c1a:	88 23       	and	r24, r24
    1c1c:	79 f0       	breq	.+30     	; 0x1c3c <Endpoint_ConfigureEndpointTable+0xd2>
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    1c1e:	b3 94       	inc	r11
    1c20:	0b 5f       	subi	r16, 0xFB	; 251
    1c22:	1f 4f       	sbci	r17, 0xFF	; 255
    1c24:	f5 e0       	ldi	r31, 0x05	; 5
    1c26:	ef 0e       	add	r14, r31
    1c28:	f1 1c       	adc	r15, r1
    1c2a:	ba 10       	cpse	r11, r10
    1c2c:	b2 cf       	rjmp	.-156    	; 0x1b92 <Endpoint_ConfigureEndpointTable+0x28>
		{
			return false;
		}
	}

	return true;
    1c2e:	81 e0       	ldi	r24, 0x01	; 1
    1c30:	05 c0       	rjmp	.+10     	; 0x1c3c <Endpoint_ConfigureEndpointTable+0xd2>
    1c32:	81 e0       	ldi	r24, 0x01	; 1
    1c34:	03 c0       	rjmp	.+6      	; 0x1c3c <Endpoint_ConfigureEndpointTable+0xd2>
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		{
			return false;
    1c36:	80 e0       	ldi	r24, 0x00	; 0
    1c38:	01 c0       	rjmp	.+2      	; 0x1c3c <Endpoint_ConfigureEndpointTable+0xd2>
    1c3a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return true;
}
    1c3c:	df 91       	pop	r29
    1c3e:	cf 91       	pop	r28
    1c40:	1f 91       	pop	r17
    1c42:	0f 91       	pop	r16
    1c44:	ff 90       	pop	r15
    1c46:	ef 90       	pop	r14
    1c48:	df 90       	pop	r13
    1c4a:	cf 90       	pop	r12
    1c4c:	bf 90       	pop	r11
    1c4e:	af 90       	pop	r10
    1c50:	08 95       	ret

00001c52 <Endpoint_ClearEndpoints>:

	return true;
}

void Endpoint_ClearEndpoints(void)
{
    1c52:	20 e0       	ldi	r18, 0x00	; 0
    1c54:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
    1c56:	a0 ec       	ldi	r26, 0xC0	; 192
    1c58:	b4 e0       	ldi	r27, 0x04	; 4
    1c5a:	16 96       	adiw	r26, 0x06	; 6
    1c5c:	ed 91       	ld	r30, X+
    1c5e:	fc 91       	ld	r31, X
    1c60:	17 97       	sbiw	r26, 0x07	; 7
    1c62:	c9 01       	movw	r24, r18
    1c64:	82 95       	swap	r24
    1c66:	92 95       	swap	r25
    1c68:	90 7f       	andi	r25, 0xF0	; 240
    1c6a:	98 27       	eor	r25, r24
    1c6c:	80 7f       	andi	r24, 0xF0	; 240
    1c6e:	98 27       	eor	r25, r24
    1c70:	e8 0f       	add	r30, r24
    1c72:	f9 1f       	adc	r31, r25
    1c74:	11 86       	std	Z+9, r1	; 0x09
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
    1c76:	16 96       	adiw	r26, 0x06	; 6
    1c78:	4d 91       	ld	r20, X+
    1c7a:	5c 91       	ld	r21, X
    1c7c:	17 97       	sbiw	r26, 0x07	; 7
    1c7e:	fa 01       	movw	r30, r20
    1c80:	e8 0f       	add	r30, r24
    1c82:	f9 1f       	adc	r31, r25
    1c84:	11 82       	std	Z+1, r1	; 0x01
    1c86:	2f 5f       	subi	r18, 0xFF	; 255
    1c88:	3f 4f       	sbci	r19, 0xFF	; 255
	return true;
}

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1c8a:	25 30       	cpi	r18, 0x05	; 5
    1c8c:	31 05       	cpc	r19, r1
    1c8e:	29 f7       	brne	.-54     	; 0x1c5a <Endpoint_ClearEndpoints+0x8>
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
	}
}
    1c90:	08 95       	ret

00001c92 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1c92:	80 91 59 95 	lds	r24, 0x9559
    1c96:	88 23       	and	r24, r24
    1c98:	84 f4       	brge	.+32     	; 0x1cba <Endpoint_ClearStatusStage+0x28>
    1c9a:	04 c0       	rjmp	.+8      	; 0x1ca4 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c9c:	80 91 58 95 	lds	r24, 0x9558
    1ca0:	88 23       	and	r24, r24
    1ca2:	89 f0       	breq	.+34     	; 0x1cc6 <Endpoint_ClearStatusStage+0x34>

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1ca4:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <Endpoint_IsOUTReceived>
    1ca8:	88 23       	and	r24, r24
    1caa:	c1 f3       	breq	.-16     	; 0x1c9c <Endpoint_ClearStatusStage+0xa>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearOUT();
    1cac:	0e 94 75 0c 	call	0x18ea	; 0x18ea <Endpoint_ClearOUT>
    1cb0:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1cb2:	80 91 58 95 	lds	r24, 0x9558
    1cb6:	88 23       	and	r24, r24
    1cb8:	31 f0       	breq	.+12     	; 0x1cc6 <Endpoint_ClearStatusStage+0x34>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1cba:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <Endpoint_IsINReady>
    1cbe:	88 23       	and	r24, r24
    1cc0:	c1 f3       	breq	.-16     	; 0x1cb2 <Endpoint_ClearStatusStage+0x20>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearIN();
    1cc2:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <Endpoint_ClearIN>
    1cc6:	08 95       	ret

00001cc8 <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    1cc8:	ff 92       	push	r15
    1cca:	0f 93       	push	r16
    1ccc:	1f 93       	push	r17
    1cce:	cf 93       	push	r28
    1cd0:	df 93       	push	r29
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return ((USB_EndpointTable_t*)USB.EPPTR)->FrameNum;
    1cd2:	e0 91 c6 04 	lds	r30, 0x04C6
    1cd6:	f0 91 c7 04 	lds	r31, 0x04C7
    1cda:	e0 5b       	subi	r30, 0xB0	; 176
    1cdc:	ff 4f       	sbci	r31, 0xFF	; 255
    1cde:	c0 81       	ld	r28, Z
    1ce0:	d1 81       	ldd	r29, Z+1	; 0x01
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    1ce2:	0f 2e       	mov	r0, r31
    1ce4:	f4 e6       	ldi	r31, 0x64	; 100
    1ce6:	ff 2e       	mov	r15, r31
    1ce8:	f0 2d       	mov	r31, r0
    1cea:	00 ec       	ldi	r16, 0xC0	; 192
    1cec:	14 e0       	ldi	r17, 0x04	; 4
    1cee:	02 c0       	rjmp	.+4      	; 0x1cf4 <Endpoint_WaitUntilReady+0x2c>

		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1cf0:	f2 2e       	mov	r15, r18
    1cf2:	ec 01       	movw	r28, r24
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN);
    1cf4:	80 91 65 95 	lds	r24, 0x9565

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    1cf8:	88 23       	and	r24, r24
    1cfa:	2c f4       	brge	.+10     	; 0x1d06 <Endpoint_WaitUntilReady+0x3e>
		{
			if (Endpoint_IsINReady())
    1cfc:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <Endpoint_IsINReady>
    1d00:	88 23       	and	r24, r24
    1d02:	29 f0       	breq	.+10     	; 0x1d0e <Endpoint_WaitUntilReady+0x46>
    1d04:	23 c0       	rjmp	.+70     	; 0x1d4c <Endpoint_WaitUntilReady+0x84>
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1d06:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <Endpoint_IsOUTReceived>
    1d0a:	81 11       	cpse	r24, r1
    1d0c:	21 c0       	rjmp	.+66     	; 0x1d50 <Endpoint_WaitUntilReady+0x88>
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1d0e:	80 91 58 95 	lds	r24, 0x9558

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1d12:	88 23       	and	r24, r24
    1d14:	f9 f0       	breq	.+62     	; 0x1d54 <Endpoint_WaitUntilReady+0x8c>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1d16:	85 30       	cpi	r24, 0x05	; 5
    1d18:	f9 f0       	breq	.+62     	; 0x1d58 <Endpoint_WaitUntilReady+0x90>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    1d1a:	e0 91 63 95 	lds	r30, 0x9563
    1d1e:	f0 91 64 95 	lds	r31, 0x9564
    1d22:	81 81       	ldd	r24, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1d24:	82 fd       	sbrc	r24, 2
    1d26:	1a c0       	rjmp	.+52     	; 0x1d5c <Endpoint_WaitUntilReady+0x94>
    1d28:	d8 01       	movw	r26, r16
    1d2a:	16 96       	adiw	r26, 0x06	; 6
    1d2c:	ed 91       	ld	r30, X+
    1d2e:	fc 91       	ld	r31, X
    1d30:	17 97       	sbiw	r26, 0x07	; 7
    1d32:	e0 5b       	subi	r30, 0xB0	; 176
    1d34:	ff 4f       	sbci	r31, 0xFF	; 255
    1d36:	80 81       	ld	r24, Z
    1d38:	91 81       	ldd	r25, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1d3a:	c8 17       	cp	r28, r24
    1d3c:	d9 07       	cpc	r29, r25
    1d3e:	c9 f2       	breq	.-78     	; 0x1cf2 <Endpoint_WaitUntilReady+0x2a>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1d40:	2f ef       	ldi	r18, 0xFF	; 255
    1d42:	2f 0d       	add	r18, r15
    1d44:	f1 10       	cpse	r15, r1
    1d46:	d4 cf       	rjmp	.-88     	; 0x1cf0 <Endpoint_WaitUntilReady+0x28>
			  return ENDPOINT_READYWAIT_Timeout;
    1d48:	84 e0       	ldi	r24, 0x04	; 4
    1d4a:	09 c0       	rjmp	.+18     	; 0x1d5e <Endpoint_WaitUntilReady+0x96>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    1d4c:	80 e0       	ldi	r24, 0x00	; 0
    1d4e:	07 c0       	rjmp	.+14     	; 0x1d5e <Endpoint_WaitUntilReady+0x96>
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    1d50:	80 e0       	ldi	r24, 0x00	; 0
    1d52:	05 c0       	rjmp	.+10     	; 0x1d5e <Endpoint_WaitUntilReady+0x96>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    1d54:	82 e0       	ldi	r24, 0x02	; 2
    1d56:	03 c0       	rjmp	.+6      	; 0x1d5e <Endpoint_WaitUntilReady+0x96>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    1d58:	83 e0       	ldi	r24, 0x03	; 3
    1d5a:	01 c0       	rjmp	.+2      	; 0x1d5e <Endpoint_WaitUntilReady+0x96>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    1d5c:	81 e0       	ldi	r24, 0x01	; 1

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1d5e:	df 91       	pop	r29
    1d60:	cf 91       	pop	r28
    1d62:	1f 91       	pop	r17
    1d64:	0f 91       	pop	r16
    1d66:	ff 90       	pop	r15
    1d68:	08 95       	ret

00001d6a <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    1d6a:	cf 93       	push	r28
    1d6c:	df 93       	push	r29
	{
		DividerIndex++;
		PrescalerNeeded >>= 1;
	}

	CLK.USBCTRL = (DividerIndex - 1) << CLK_USBPSDIV_gp;
    1d6e:	e0 e4       	ldi	r30, 0x40	; 64
    1d70:	f0 e0       	ldi	r31, 0x00	; 0
    1d72:	14 82       	std	Z+4, r1	; 0x04

	if (USB_Options & USB_OPT_PLLCLKSRC)
	  CLK.USBCTRL |= (CLK_USBSRC_PLL_gc   | CLK_USBSEN_bm);
	else
	  CLK.USBCTRL |= (CLK_USBSRC_RC32M_gc | CLK_USBSEN_bm);
    1d74:	84 81       	ldd	r24, Z+4	; 0x04
    1d76:	83 60       	ori	r24, 0x03	; 3
    1d78:	84 83       	std	Z+4, r24	; 0x04

	USB_Device_SetDeviceAddress(0);

	USB_INT_DisableAllInterrupts();
    1d7a:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1d7e:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USB.CTRLA &= ~USB_ENABLE_bm;
    1d82:	c0 ec       	ldi	r28, 0xC0	; 192
    1d84:	d4 e0       	ldi	r29, 0x04	; 4
    1d86:	88 81       	ld	r24, Y
    1d88:	8f 77       	andi	r24, 0x7F	; 127
    1d8a:	88 83       	st	Y, r24
				USB.CTRLA |=  USB_ENABLE_bm;
    1d8c:	88 81       	ld	r24, Y
    1d8e:	80 68       	ori	r24, 0x80	; 128
    1d90:	88 83       	st	Y, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1d92:	10 92 58 95 	sts	0x9558, r1
	USB_Device_ConfigurationNumber  = 0;
    1d96:	10 92 54 95 	sts	0x9554, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1d9a:	10 92 56 95 	sts	0x9556, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1d9e:	10 92 55 95 	sts	0x9555, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				USB.CTRLA |=  USB_SPEED_bm;
    1da2:	88 81       	ld	r24, Y
    1da4:	80 64       	ori	r24, 0x40	; 64
    1da6:	88 83       	st	Y, r24
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    1da8:	48 e0       	ldi	r20, 0x08	; 8
    1daa:	68 e4       	ldi	r22, 0x48	; 72
    1dac:	80 e8       	ldi	r24, 0x80	; 128
    1dae:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    1db2:	48 e0       	ldi	r20, 0x08	; 8
    1db4:	68 e4       	ldi	r22, 0x48	; 72
    1db6:	80 e0       	ldi	r24, 0x00	; 0
    1db8:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <Endpoint_ConfigureEndpoint_PRV>
			static inline void USB_INT_Enable(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						USB.INTCTRLA |= USB_BUSEVIE_bm;
    1dbc:	88 85       	ldd	r24, Y+8	; 0x08
    1dbe:	80 64       	ori	r24, 0x40	; 64
    1dc0:	88 87       	std	Y+8, r24	; 0x08
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				USB.CTRLB |= USB_ATTACH_bm;
    1dc2:	89 81       	ldd	r24, Y+1	; 0x01
    1dc4:	81 60       	ori	r24, 0x01	; 1
    1dc6:	89 83       	std	Y+1, r24	; 0x01
	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();

	USB_Controller_Reset();
	USB_Init_Device();
}
    1dc8:	df 91       	pop	r29
    1dca:	cf 91       	pop	r28
    1dcc:	08 95       	ret

00001dce <USB_Init>:

               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
    1dce:	cf 93       	push	r28
    1dd0:	df 93       	push	r29
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    1dd2:	2f b7       	in	r18, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    1dd4:	f8 94       	cli
	#endif

	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();

	NVM.CMD  = NVM_CMD_READ_CALIB_ROW_gc;
    1dd6:	c0 ec       	ldi	r28, 0xC0	; 192
    1dd8:	d1 e0       	ldi	r29, 0x01	; 1
    1dda:	82 e0       	ldi	r24, 0x02	; 2
    1ddc:	8a 87       	std	Y+10, r24	; 0x0a
	USB.CAL0 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL0));
    1dde:	ea e1       	ldi	r30, 0x1A	; 26
    1de0:	f0 e0       	ldi	r31, 0x00	; 0
    1de2:	e4 91       	lpm	r30, Z
    1de4:	a0 ec       	ldi	r26, 0xC0	; 192
    1de6:	b4 e0       	ldi	r27, 0x04	; 4
    1de8:	da 96       	adiw	r26, 0x3a	; 58
    1dea:	ec 93       	st	X, r30
    1dec:	da 97       	sbiw	r26, 0x3a	; 58
	USB.CAL1 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL1));
    1dee:	eb e1       	ldi	r30, 0x1B	; 27
    1df0:	f0 e0       	ldi	r31, 0x00	; 0
    1df2:	e4 91       	lpm	r30, Z
    1df4:	db 96       	adiw	r26, 0x3b	; 59
    1df6:	ec 93       	st	X, r30
    1df8:	db 97       	sbiw	r26, 0x3b	; 59
	NVM.CMD  = NVM_CMD_NO_OPERATION_gc;
    1dfa:	1a 86       	std	Y+10, r1	; 0x0a

	/* Ugly workaround to ensure an aligned table, since __BIGGEST_ALIGNMENT__ == 1 for the 8-bit AVR-GCC toolchain */
	USB.EPPTR = ((intptr_t)&USB_EndpointTable[1] & ~(1 << 0));
    1dfc:	8b ef       	ldi	r24, 0xFB	; 251
    1dfe:	97 e9       	ldi	r25, 0x97	; 151
    1e00:	8e 7f       	andi	r24, 0xFE	; 254
    1e02:	16 96       	adiw	r26, 0x06	; 6
    1e04:	8d 93       	st	X+, r24
    1e06:	9c 93       	st	X, r25
    1e08:	17 97       	sbiw	r26, 0x07	; 7
	USB.CTRLA = (USB_STFRNUM_bm | ((ENDPOINT_TOTAL_ENDPOINTS - 1) << USB_MAXEP_gp));
    1e0a:	84 e1       	ldi	r24, 0x14	; 20
    1e0c:	8c 93       	st	X, r24

	if ((USB_Options & USB_OPT_BUSEVENT_PRIHIGH) == USB_OPT_BUSEVENT_PRIHIGH)
	  USB.INTCTRLA = (3 << USB_INTLVL_gp);
    1e0e:	83 e0       	ldi	r24, 0x03	; 3
    1e10:	18 96       	adiw	r26, 0x08	; 8
    1e12:	8c 93       	st	X, r24
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    1e14:	2f bf       	out	0x3f, r18	; 63

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;
    1e16:	81 e0       	ldi	r24, 0x01	; 1
    1e18:	80 93 57 95 	sts	0x9557, r24

	USB_ResetInterface();
    1e1c:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <USB_ResetInterface>
}
    1e20:	df 91       	pop	r29
    1e22:	cf 91       	pop	r28
    1e24:	08 95       	ret

00001e26 <USB_INT_DisableAllInterrupts>:
#define  __INCLUDE_FROM_USB_DRIVER
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	USB.INTCTRLA    &= USB_INTLVL_gm;
    1e26:	e0 ec       	ldi	r30, 0xC0	; 192
    1e28:	f4 e0       	ldi	r31, 0x04	; 4
    1e2a:	80 85       	ldd	r24, Z+8	; 0x08
    1e2c:	83 70       	andi	r24, 0x03	; 3
    1e2e:	80 87       	std	Z+8, r24	; 0x08
	USB.INTCTRLB     = 0;
    1e30:	11 86       	std	Z+9, r1	; 0x09
    1e32:	08 95       	ret

00001e34 <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	USB.INTFLAGSACLR = 0xFF;
    1e34:	e0 ec       	ldi	r30, 0xC0	; 192
    1e36:	f4 e0       	ldi	r31, 0x04	; 4
    1e38:	8f ef       	ldi	r24, 0xFF	; 255
    1e3a:	82 87       	std	Z+10, r24	; 0x0a
	USB.INTFLAGSBCLR = 0xFF;
    1e3c:	84 87       	std	Z+12, r24	; 0x0c
    1e3e:	08 95       	ret

00001e40 <__vector_125>:
}

ISR(USB_BUSEVENT_vect)
{
    1e40:	1f 92       	push	r1
    1e42:	0f 92       	push	r0
    1e44:	0f b6       	in	r0, 0x3f	; 63
    1e46:	0f 92       	push	r0
    1e48:	11 24       	eor	r1, r1
    1e4a:	0b b6       	in	r0, 0x3b	; 59
    1e4c:	0f 92       	push	r0
    1e4e:	2f 93       	push	r18
    1e50:	3f 93       	push	r19
    1e52:	4f 93       	push	r20
    1e54:	5f 93       	push	r21
    1e56:	6f 93       	push	r22
    1e58:	7f 93       	push	r23
    1e5a:	8f 93       	push	r24
    1e5c:	9f 93       	push	r25
    1e5e:	af 93       	push	r26
    1e60:	bf 93       	push	r27
    1e62:	ef 93       	push	r30
    1e64:	ff 93       	push	r31
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTFLAGSACLR & USB_SOFIF_bm) ? true : false);
    1e66:	80 91 ca 04 	lds	r24, 0x04CA
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1e6a:	88 23       	and	r24, r24
    1e6c:	4c f4       	brge	.+18     	; 0x1e80 <__vector_125+0x40>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						return ((USB.INTCTRLA & USB_BUSEVIE_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTCTRLA & USB_SOFIE_bm) ? true : false);
    1e6e:	80 91 c8 04 	lds	r24, 0x04C8
    1e72:	88 23       	and	r24, r24
    1e74:	2c f4       	brge	.+10     	; 0x1e80 <__vector_125+0x40>
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
						break;
					case USB_INT_SOFI:
						USB.INTFLAGSACLR = USB_SOFIF_bm;
    1e76:	80 e8       	ldi	r24, 0x80	; 128
    1e78:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1e7c:	0e 94 18 0b 	call	0x1630	; 0x1630 <USB_Event_Stub>
			static inline bool USB_INT_HasOccurred(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
    1e80:	80 91 ca 04 	lds	r24, 0x04CA
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Suspend))
    1e84:	86 ff       	sbrs	r24, 6
    1e86:	07 c0       	rjmp	.+14     	; 0x1e96 <__vector_125+0x56>
			static inline void USB_INT_Clear(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
    1e88:	80 e4       	ldi	r24, 0x40	; 64
    1e8a:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Suspend);

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    1e8e:	10 92 58 95 	sts	0x9558, r1
		EVENT_USB_Device_Disconnect();
    1e92:	0e 94 64 12 	call	0x24c8	; 0x24c8 <EVENT_USB_Device_Disconnect>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
    1e96:	80 91 ca 04 	lds	r24, 0x04CA
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Resume))
    1e9a:	85 ff       	sbrs	r24, 5
    1e9c:	16 c0       	rjmp	.+44     	; 0x1eca <__vector_125+0x8a>
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
    1e9e:	80 e2       	ldi	r24, 0x20	; 32
    1ea0:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Resume);

		if (USB_Device_ConfigurationNumber)
    1ea4:	80 91 54 95 	lds	r24, 0x9554
    1ea8:	88 23       	and	r24, r24
    1eaa:	21 f0       	breq	.+8      	; 0x1eb4 <__vector_125+0x74>
		  USB_DeviceState = DEVICE_STATE_Configured;
    1eac:	84 e0       	ldi	r24, 0x04	; 4
    1eae:	80 93 58 95 	sts	0x9558, r24
    1eb2:	09 c0       	rjmp	.+18     	; 0x1ec6 <__vector_125+0x86>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    1eb4:	80 91 c3 04 	lds	r24, 0x04C3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    1eb8:	81 11       	cpse	r24, r1
    1eba:	02 c0       	rjmp	.+4      	; 0x1ec0 <__vector_125+0x80>
    1ebc:	81 e0       	ldi	r24, 0x01	; 1
    1ebe:	01 c0       	rjmp	.+2      	; 0x1ec2 <__vector_125+0x82>
    1ec0:	83 e0       	ldi	r24, 0x03	; 3
    1ec2:	80 93 58 95 	sts	0x9558, r24

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
    1ec6:	0e 94 57 12 	call	0x24ae	; 0x24ae <EVENT_USB_Device_Connect>
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
    1eca:	80 91 ca 04 	lds	r24, 0x04CA
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Reset))
    1ece:	84 ff       	sbrs	r24, 4
    1ed0:	18 c0       	rjmp	.+48     	; 0x1f02 <__vector_125+0xc2>
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
    1ed2:	e0 ec       	ldi	r30, 0xC0	; 192
    1ed4:	f4 e0       	ldi	r31, 0x04	; 4
    1ed6:	80 e1       	ldi	r24, 0x10	; 16
    1ed8:	82 87       	std	Z+10, r24	; 0x0a
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Reset);

		USB_DeviceState                = DEVICE_STATE_Default;
    1eda:	82 e0       	ldi	r24, 0x02	; 2
    1edc:	80 93 58 95 	sts	0x9558, r24
		USB_Device_ConfigurationNumber = 0;
    1ee0:	10 92 54 95 	sts	0x9554, r1
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    1ee4:	13 82       	std	Z+3, r1	; 0x03

		USB_Device_EnableDeviceAddress(0);

		Endpoint_ClearEndpoints();
    1ee6:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <Endpoint_ClearEndpoints>
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    1eea:	48 e0       	ldi	r20, 0x08	; 8
    1eec:	68 e4       	ldi	r22, 0x48	; 72
    1eee:	80 e8       	ldi	r24, 0x80	; 128
    1ef0:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    1ef4:	48 e0       	ldi	r20, 0x08	; 8
    1ef6:	68 e4       	ldi	r22, 0x48	; 72
    1ef8:	80 e0       	ldi	r24, 0x00	; 0
    1efa:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <Endpoint_ConfigureEndpoint_PRV>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           USB_Device_ControlEndpointSize, 1);

		EVENT_USB_Device_Reset();
    1efe:	0e 94 18 0b 	call	0x1630	; 0x1630 <USB_Event_Stub>
	}
}
    1f02:	ff 91       	pop	r31
    1f04:	ef 91       	pop	r30
    1f06:	bf 91       	pop	r27
    1f08:	af 91       	pop	r26
    1f0a:	9f 91       	pop	r25
    1f0c:	8f 91       	pop	r24
    1f0e:	7f 91       	pop	r23
    1f10:	6f 91       	pop	r22
    1f12:	5f 91       	pop	r21
    1f14:	4f 91       	pop	r20
    1f16:	3f 91       	pop	r19
    1f18:	2f 91       	pop	r18
    1f1a:	0f 90       	pop	r0
    1f1c:	0b be       	out	0x3b, r0	; 59
    1f1e:	0f 90       	pop	r0
    1f20:	0f be       	out	0x3f, r0	; 63
    1f22:	0f 90       	pop	r0
    1f24:	1f 90       	pop	r1
    1f26:	18 95       	reti

00001f28 <USBThread>:
		temp ^= pixel_mask;
		break;
	}

	gfx_mono_put_byte(page, column, temp);
}
    1f28:	0e 94 bf 05 	call	0xb7e	; 0xb7e <vTaskSuspendAll>
    1f2c:	8b e8       	ldi	r24, 0x8B	; 139
    1f2e:	92 e2       	ldi	r25, 0x22	; 34
    1f30:	0e 94 73 08 	call	0x10e6	; 0x10e6 <CDC_Device_USBTask>
    1f34:	0e 94 19 0b 	call	0x1632	; 0x1632 <USB_USBTask>
    1f38:	0e 94 7f 06 	call	0xcfe	; 0xcfe <xTaskResumeAll>
    1f3c:	81 e0       	ldi	r24, 0x01	; 1
    1f3e:	90 e0       	ldi	r25, 0x00	; 0
    1f40:	0e 94 01 07 	call	0xe02	; 0xe02 <vTaskDelay>
    1f44:	f1 cf       	rjmp	.-30     	; 0x1f28 <USBThread>

00001f46 <thread_2>:
    1f46:	84 e6       	ldi	r24, 0x64	; 100
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	0e 94 01 07 	call	0xe02	; 0xe02 <vTaskDelay>
    1f4e:	86 ea       	ldi	r24, 0xA6	; 166
    1f50:	92 e2       	ldi	r25, 0x22	; 34
    1f52:	0e 94 9f 12 	call	0x253e	; 0x253e <DigitalPin_ToggleValue>
    1f56:	f7 cf       	rjmp	.-18     	; 0x1f46 <thread_2>

00001f58 <thread_1>:
    1f58:	c0 e0       	ldi	r28, 0x00	; 0
    1f5a:	d1 e0       	ldi	r29, 0x01	; 1
    1f5c:	84 ef       	ldi	r24, 0xF4	; 244
    1f5e:	91 e0       	ldi	r25, 0x01	; 1
    1f60:	0e 94 01 07 	call	0xe02	; 0xe02 <vTaskDelay>
    1f64:	8c 2f       	mov	r24, r28
    1f66:	0e 94 bc 01 	call	0x378	; 0x378 <lcd03_backlight>
    1f6a:	cd 27       	eor	r28, r29
    1f6c:	89 ea       	ldi	r24, 0xA9	; 169
    1f6e:	92 e2       	ldi	r25, 0x22	; 34
    1f70:	0e 94 9f 12 	call	0x253e	; 0x253e <DigitalPin_ToggleValue>
    1f74:	0e 94 bf 05 	call	0xb7e	; 0xb7e <vTaskSuspendAll>
    1f78:	29 e2       	ldi	r18, 0x29	; 41
    1f7a:	33 e9       	ldi	r19, 0x93	; 147
    1f7c:	4a e0       	ldi	r20, 0x0A	; 10
    1f7e:	50 e0       	ldi	r21, 0x00	; 0
    1f80:	61 e0       	ldi	r22, 0x01	; 1
    1f82:	70 e0       	ldi	r23, 0x00	; 0
    1f84:	81 eb       	ldi	r24, 0xB1	; 177
    1f86:	92 e2       	ldi	r25, 0x22	; 34
    1f88:	0e 94 25 14 	call	0x284a	; 0x284a <fwrite>
    1f8c:	0e 94 7f 06 	call	0xcfe	; 0xcfe <xTaskResumeAll>
    1f90:	e5 cf       	rjmp	.-54     	; 0x1f5c <thread_1+0x4>

00001f92 <usart_spi_transmit_receive>:
    1f92:	fc 01       	movw	r30, r24
    1f94:	81 81       	ldd	r24, Z+1	; 0x01
    1f96:	85 ff       	sbrs	r24, 5
    1f98:	fd cf       	rjmp	.-6      	; 0x1f94 <usart_spi_transmit_receive+0x2>
    1f9a:	60 83       	st	Z, r22
    1f9c:	81 81       	ldd	r24, Z+1	; 0x01
    1f9e:	86 ff       	sbrs	r24, 6
    1fa0:	fd cf       	rjmp	.-6      	; 0x1f9c <usart_spi_transmit_receive+0xa>
    1fa2:	80 e4       	ldi	r24, 0x40	; 64
    1fa4:	81 83       	std	Z+1, r24	; 0x01
    1fa6:	80 81       	ld	r24, Z
    1fa8:	08 95       	ret

00001faa <ssd1306_write_command>:
    1faa:	1f 93       	push	r17
    1fac:	cf 93       	push	r28
    1fae:	df 93       	push	r29
    1fb0:	c0 ea       	ldi	r28, 0xA0	; 160
    1fb2:	d6 e0       	ldi	r29, 0x06	; 6
    1fb4:	18 e0       	ldi	r17, 0x08	; 8
    1fb6:	1e 83       	std	Y+6, r17	; 0x06
    1fb8:	e0 e6       	ldi	r30, 0x60	; 96
    1fba:	f6 e0       	ldi	r31, 0x06	; 6
    1fbc:	91 e0       	ldi	r25, 0x01	; 1
    1fbe:	96 83       	std	Z+6, r25	; 0x06
    1fc0:	96 83       	std	Z+6, r25	; 0x06
    1fc2:	68 2f       	mov	r22, r24
    1fc4:	80 ea       	ldi	r24, 0xA0	; 160
    1fc6:	99 e0       	ldi	r25, 0x09	; 9
    1fc8:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <usart_spi_transmit_receive>
    1fcc:	1d 83       	std	Y+5, r17	; 0x05
    1fce:	df 91       	pop	r29
    1fd0:	cf 91       	pop	r28
    1fd2:	1f 91       	pop	r17
    1fd4:	08 95       	ret

00001fd6 <ssd1306_write_data>:
    1fd6:	ef 92       	push	r14
    1fd8:	ff 92       	push	r15
    1fda:	0f 93       	push	r16
    1fdc:	1f 93       	push	r17
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	c0 ea       	ldi	r28, 0xA0	; 160
    1fe4:	d6 e0       	ldi	r29, 0x06	; 6
    1fe6:	18 e0       	ldi	r17, 0x08	; 8
    1fe8:	1e 83       	std	Y+6, r17	; 0x06
    1fea:	0f 2e       	mov	r0, r31
    1fec:	f0 e6       	ldi	r31, 0x60	; 96
    1fee:	ef 2e       	mov	r14, r31
    1ff0:	f6 e0       	ldi	r31, 0x06	; 6
    1ff2:	ff 2e       	mov	r15, r31
    1ff4:	f0 2d       	mov	r31, r0
    1ff6:	01 e0       	ldi	r16, 0x01	; 1
    1ff8:	f7 01       	movw	r30, r14
    1ffa:	05 83       	std	Z+5, r16	; 0x05
    1ffc:	68 2f       	mov	r22, r24
    1ffe:	80 ea       	ldi	r24, 0xA0	; 160
    2000:	99 e0       	ldi	r25, 0x09	; 9
    2002:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <usart_spi_transmit_receive>
    2006:	f7 01       	movw	r30, r14
    2008:	06 83       	std	Z+6, r16	; 0x06
    200a:	1d 83       	std	Y+5, r17	; 0x05
    200c:	df 91       	pop	r29
    200e:	cf 91       	pop	r28
    2010:	1f 91       	pop	r17
    2012:	0f 91       	pop	r16
    2014:	ff 90       	pop	r15
    2016:	ef 90       	pop	r14
    2018:	08 95       	ret

0000201a <ssd1306_set_page_address>:
    201a:	87 70       	andi	r24, 0x07	; 7
    201c:	80 6b       	ori	r24, 0xB0	; 176
    201e:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2022:	08 95       	ret

00002024 <ssd1306_set_column_address>:
    2024:	cf 93       	push	r28
    2026:	c8 2f       	mov	r28, r24
    2028:	98 2f       	mov	r25, r24
    202a:	9f 77       	andi	r25, 0x7F	; 127
    202c:	89 2f       	mov	r24, r25
    202e:	82 95       	swap	r24
    2030:	8f 70       	andi	r24, 0x0F	; 15
    2032:	80 61       	ori	r24, 0x10	; 16
    2034:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2038:	8c 2f       	mov	r24, r28
    203a:	8f 70       	andi	r24, 0x0F	; 15
    203c:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2040:	cf 91       	pop	r28
    2042:	08 95       	ret

00002044 <usart_init_spi>:
    2044:	cf 93       	push	r28
    2046:	df 93       	push	r29
    2048:	ec 01       	movw	r28, r24
    204a:	fb 01       	movw	r30, r22
    204c:	8c 81       	ldd	r24, Y+4	; 0x04
    204e:	8f 7e       	andi	r24, 0xEF	; 239
    2050:	8c 83       	std	Y+4, r24	; 0x04
    2052:	a0 e6       	ldi	r26, 0x60	; 96
    2054:	b6 e0       	ldi	r27, 0x06	; 6
    2056:	82 e0       	ldi	r24, 0x02	; 2
    2058:	11 96       	adiw	r26, 0x01	; 1
    205a:	8c 93       	st	X, r24
    205c:	11 97       	sbiw	r26, 0x01	; 1
    205e:	15 96       	adiw	r26, 0x05	; 5
    2060:	8c 93       	st	X, r24
    2062:	8d 81       	ldd	r24, Y+5	; 0x05
    2064:	80 6c       	ori	r24, 0xC0	; 192
    2066:	8d 83       	std	Y+5, r24	; 0x05
    2068:	84 81       	ldd	r24, Z+4	; 0x04
    206a:	8d 7f       	andi	r24, 0xFD	; 253
    206c:	81 30       	cpi	r24, 0x01	; 1
    206e:	21 f4       	brne	.+8      	; 0x2078 <usart_init_spi+0x34>
    2070:	8d 81       	ldd	r24, Y+5	; 0x05
    2072:	82 60       	ori	r24, 0x02	; 2
    2074:	8d 83       	std	Y+5, r24	; 0x05
    2076:	03 c0       	rjmp	.+6      	; 0x207e <usart_init_spi+0x3a>
    2078:	8d 81       	ldd	r24, Y+5	; 0x05
    207a:	8d 7f       	andi	r24, 0xFD	; 253
    207c:	8d 83       	std	Y+5, r24	; 0x05
    207e:	85 81       	ldd	r24, Z+5	; 0x05
    2080:	88 23       	and	r24, r24
    2082:	21 f0       	breq	.+8      	; 0x208c <usart_init_spi+0x48>
    2084:	8d 81       	ldd	r24, Y+5	; 0x05
    2086:	84 60       	ori	r24, 0x04	; 4
    2088:	8d 83       	std	Y+5, r24	; 0x05
    208a:	03 c0       	rjmp	.+6      	; 0x2092 <usart_init_spi+0x4e>
    208c:	8d 81       	ldd	r24, Y+5	; 0x05
    208e:	8b 7f       	andi	r24, 0xFB	; 251
    2090:	8d 83       	std	Y+5, r24	; 0x05
    2092:	80 81       	ld	r24, Z
    2094:	91 81       	ldd	r25, Z+1	; 0x01
    2096:	a2 81       	ldd	r26, Z+2	; 0x02
    2098:	b3 81       	ldd	r27, Z+3	; 0x03
    209a:	9c 01       	movw	r18, r24
    209c:	ad 01       	movw	r20, r26
    209e:	22 0f       	add	r18, r18
    20a0:	33 1f       	adc	r19, r19
    20a2:	44 1f       	adc	r20, r20
    20a4:	55 1f       	adc	r21, r21
    20a6:	60 e0       	ldi	r22, 0x00	; 0
    20a8:	78 e4       	ldi	r23, 0x48	; 72
    20aa:	88 ee       	ldi	r24, 0xE8	; 232
    20ac:	91 e0       	ldi	r25, 0x01	; 1
    20ae:	0e 94 f4 13 	call	0x27e8	; 0x27e8 <__udivmodsi4>
    20b2:	21 50       	subi	r18, 0x01	; 1
    20b4:	31 09       	sbc	r19, r1
    20b6:	83 2f       	mov	r24, r19
    20b8:	8f 70       	andi	r24, 0x0F	; 15
    20ba:	8f 83       	std	Y+7, r24	; 0x07
    20bc:	2e 83       	std	Y+6, r18	; 0x06
    20be:	8c 81       	ldd	r24, Y+4	; 0x04
    20c0:	88 60       	ori	r24, 0x08	; 8
    20c2:	8c 83       	std	Y+4, r24	; 0x04
    20c4:	df 91       	pop	r29
    20c6:	cf 91       	pop	r28
    20c8:	08 95       	ret

000020ca <ssd1306_init>:
    20ca:	cf 93       	push	r28
    20cc:	df 93       	push	r29
    20ce:	00 d0       	rcall	.+0      	; 0x20d0 <ssd1306_init+0x6>
    20d0:	00 d0       	rcall	.+0      	; 0x20d2 <ssd1306_init+0x8>
    20d2:	cd b7       	in	r28, 0x3d	; 61
    20d4:	de b7       	in	r29, 0x3e	; 62
    20d6:	20 ea       	ldi	r18, 0xA0	; 160
    20d8:	36 e0       	ldi	r19, 0x06	; 6
    20da:	88 e0       	ldi	r24, 0x08	; 8
    20dc:	d9 01       	movw	r26, r18
    20de:	11 96       	adiw	r26, 0x01	; 1
    20e0:	8c 93       	st	X, r24
    20e2:	a0 e6       	ldi	r26, 0x60	; 96
    20e4:	b6 e0       	ldi	r27, 0x06	; 6
    20e6:	91 e0       	ldi	r25, 0x01	; 1
    20e8:	11 96       	adiw	r26, 0x01	; 1
    20ea:	9c 93       	st	X, r25
    20ec:	11 97       	sbiw	r26, 0x01	; 1
    20ee:	e0 e0       	ldi	r30, 0x00	; 0
    20f0:	f6 e0       	ldi	r31, 0x06	; 6
    20f2:	81 83       	std	Z+1, r24	; 0x01
    20f4:	92 e0       	ldi	r25, 0x02	; 2
    20f6:	11 96       	adiw	r26, 0x01	; 1
    20f8:	9c 93       	st	X, r25
    20fa:	11 97       	sbiw	r26, 0x01	; 1
    20fc:	11 96       	adiw	r26, 0x01	; 1
    20fe:	8c 93       	st	X, r24
    2100:	d9 01       	movw	r26, r18
    2102:	15 96       	adiw	r26, 0x05	; 5
    2104:	8c 93       	st	X, r24
    2106:	86 83       	std	Z+6, r24	; 0x06
    2108:	ba e6       	ldi	r27, 0x6A	; 106
    210a:	ba 95       	dec	r27
    210c:	f1 f7       	brne	.-4      	; 0x210a <ssd1306_init+0x40>
    210e:	00 c0       	rjmp	.+0      	; 0x2110 <ssd1306_init+0x46>
    2110:	85 83       	std	Z+5, r24	; 0x05
    2112:	ea e6       	ldi	r30, 0x6A	; 106
    2114:	ea 95       	dec	r30
    2116:	f1 f7       	brne	.-4      	; 0x2114 <ssd1306_init+0x4a>
    2118:	00 c0       	rjmp	.+0      	; 0x211a <ssd1306_init+0x50>
    211a:	e0 e7       	ldi	r30, 0x70	; 112
    211c:	f0 e0       	ldi	r31, 0x00	; 0
    211e:	84 81       	ldd	r24, Z+4	; 0x04
    2120:	8f 7e       	andi	r24, 0xEF	; 239
    2122:	84 83       	std	Z+4, r24	; 0x04
    2124:	80 e0       	ldi	r24, 0x00	; 0
    2126:	9b e1       	ldi	r25, 0x1B	; 27
    2128:	a7 eb       	ldi	r26, 0xB7	; 183
    212a:	b0 e0       	ldi	r27, 0x00	; 0
    212c:	89 83       	std	Y+1, r24	; 0x01
    212e:	9a 83       	std	Y+2, r25	; 0x02
    2130:	ab 83       	std	Y+3, r26	; 0x03
    2132:	bc 83       	std	Y+4, r27	; 0x04
    2134:	1d 82       	std	Y+5, r1	; 0x05
    2136:	1e 82       	std	Y+6, r1	; 0x06
    2138:	be 01       	movw	r22, r28
    213a:	6f 5f       	subi	r22, 0xFF	; 255
    213c:	7f 4f       	sbci	r23, 0xFF	; 255
    213e:	80 ea       	ldi	r24, 0xA0	; 160
    2140:	99 e0       	ldi	r25, 0x09	; 9
    2142:	0e 94 22 10 	call	0x2044	; 0x2044 <usart_init_spi>
    2146:	88 ea       	ldi	r24, 0xA8	; 168
    2148:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    214c:	8f e1       	ldi	r24, 0x1F	; 31
    214e:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2152:	83 ed       	ldi	r24, 0xD3	; 211
    2154:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2158:	80 e0       	ldi	r24, 0x00	; 0
    215a:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    215e:	80 e4       	ldi	r24, 0x40	; 64
    2160:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2164:	81 ea       	ldi	r24, 0xA1	; 161
    2166:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    216a:	88 ec       	ldi	r24, 0xC8	; 200
    216c:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2170:	8a ed       	ldi	r24, 0xDA	; 218
    2172:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2176:	82 e0       	ldi	r24, 0x02	; 2
    2178:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    217c:	81 e8       	ldi	r24, 0x81	; 129
    217e:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2182:	8f e8       	ldi	r24, 0x8F	; 143
    2184:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2188:	84 ea       	ldi	r24, 0xA4	; 164
    218a:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    218e:	86 ea       	ldi	r24, 0xA6	; 166
    2190:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    2194:	85 ed       	ldi	r24, 0xD5	; 213
    2196:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    219a:	80 e8       	ldi	r24, 0x80	; 128
    219c:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    21a0:	8d e8       	ldi	r24, 0x8D	; 141
    21a2:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    21a6:	84 e1       	ldi	r24, 0x14	; 20
    21a8:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    21ac:	8b ed       	ldi	r24, 0xDB	; 219
    21ae:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    21b2:	80 e4       	ldi	r24, 0x40	; 64
    21b4:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    21b8:	89 ed       	ldi	r24, 0xD9	; 217
    21ba:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    21be:	81 ef       	ldi	r24, 0xF1	; 241
    21c0:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    21c4:	8f ea       	ldi	r24, 0xAF	; 175
    21c6:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
    21ca:	26 96       	adiw	r28, 0x06	; 6
    21cc:	cd bf       	out	0x3d, r28	; 61
    21ce:	de bf       	out	0x3e, r29	; 62
    21d0:	df 91       	pop	r29
    21d2:	cf 91       	pop	r28
    21d4:	08 95       	ret

000021d6 <ssd1306_write_text>:
    21d6:	ef 92       	push	r14
    21d8:	ff 92       	push	r15
    21da:	0f 93       	push	r16
    21dc:	1f 93       	push	r17
    21de:	cf 93       	push	r28
    21e0:	dc 01       	movw	r26, r24
    21e2:	ec 91       	ld	r30, X
    21e4:	ee 23       	and	r30, r30
    21e6:	29 f1       	breq	.+74     	; 0x2232 <ssd1306_write_text+0x5c>
    21e8:	7c 01       	movw	r14, r24
    21ea:	bf ef       	ldi	r27, 0xFF	; 255
    21ec:	eb 1a       	sub	r14, r27
    21ee:	fb 0a       	sbc	r15, r27
    21f0:	ef 37       	cpi	r30, 0x7F	; 127
    21f2:	d0 f4       	brcc	.+52     	; 0x2228 <ssd1306_write_text+0x52>
    21f4:	f0 e0       	ldi	r31, 0x00	; 0
    21f6:	ee 0f       	add	r30, r30
    21f8:	ff 1f       	adc	r31, r31
    21fa:	e5 57       	subi	r30, 0x75	; 117
    21fc:	fe 4d       	sbci	r31, 0xDE	; 222
    21fe:	00 81       	ld	r16, Z
    2200:	11 81       	ldd	r17, Z+1	; 0x01
    2202:	f8 01       	movw	r30, r16
    2204:	80 81       	ld	r24, Z
    2206:	88 23       	and	r24, r24
    2208:	61 f0       	breq	.+24     	; 0x2222 <ssd1306_write_text+0x4c>
    220a:	c1 e0       	ldi	r28, 0x01	; 1
    220c:	f8 01       	movw	r30, r16
    220e:	ec 0f       	add	r30, r28
    2210:	f1 1d       	adc	r31, r1
    2212:	80 81       	ld	r24, Z
    2214:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <ssd1306_write_data>
    2218:	cf 5f       	subi	r28, 0xFF	; 255
    221a:	d8 01       	movw	r26, r16
    221c:	9c 91       	ld	r25, X
    221e:	9c 17       	cp	r25, r28
    2220:	a8 f7       	brcc	.-22     	; 0x220c <ssd1306_write_text+0x36>
    2222:	80 e0       	ldi	r24, 0x00	; 0
    2224:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <ssd1306_write_data>
    2228:	d7 01       	movw	r26, r14
    222a:	ed 91       	ld	r30, X+
    222c:	7d 01       	movw	r14, r26
    222e:	e1 11       	cpse	r30, r1
    2230:	df cf       	rjmp	.-66     	; 0x21f0 <ssd1306_write_text+0x1a>
    2232:	cf 91       	pop	r28
    2234:	1f 91       	pop	r17
    2236:	0f 91       	pop	r16
    2238:	ff 90       	pop	r15
    223a:	ef 90       	pop	r14
    223c:	08 95       	ret

0000223e <gfx_mono_framebuffer_put_byte>:
    223e:	20 e8       	ldi	r18, 0x80	; 128
    2240:	82 9f       	mul	r24, r18
    2242:	c0 01       	movw	r24, r0
    2244:	11 24       	eor	r1, r1
    2246:	86 0f       	add	r24, r22
    2248:	91 1d       	adc	r25, r1
    224a:	e0 91 37 93 	lds	r30, 0x9337
    224e:	f0 91 38 93 	lds	r31, 0x9338
    2252:	e8 0f       	add	r30, r24
    2254:	f9 1f       	adc	r31, r25
    2256:	40 83       	st	Z, r20
    2258:	08 95       	ret

0000225a <gfx_mono_framebuffer_get_byte>:
    225a:	20 e8       	ldi	r18, 0x80	; 128
    225c:	82 9f       	mul	r24, r18
    225e:	c0 01       	movw	r24, r0
    2260:	11 24       	eor	r1, r1
    2262:	86 0f       	add	r24, r22
    2264:	91 1d       	adc	r25, r1
    2266:	e0 91 37 93 	lds	r30, 0x9337
    226a:	f0 91 38 93 	lds	r31, 0x9338
    226e:	e8 0f       	add	r30, r24
    2270:	f9 1f       	adc	r31, r25
    2272:	80 81       	ld	r24, Z
    2274:	08 95       	ret

00002276 <gfx_mono_ssd1306_put_byte>:
    2276:	1f 93       	push	r17
    2278:	cf 93       	push	r28
    227a:	df 93       	push	r29
    227c:	18 2f       	mov	r17, r24
    227e:	d6 2f       	mov	r29, r22
    2280:	c4 2f       	mov	r28, r20
    2282:	21 11       	cpse	r18, r1
    2284:	04 c0       	rjmp	.+8      	; 0x228e <gfx_mono_ssd1306_put_byte+0x18>
    2286:	0e 94 2d 11 	call	0x225a	; 0x225a <gfx_mono_framebuffer_get_byte>
    228a:	8c 17       	cp	r24, r28
    228c:	71 f0       	breq	.+28     	; 0x22aa <gfx_mono_ssd1306_put_byte+0x34>
    228e:	4c 2f       	mov	r20, r28
    2290:	6d 2f       	mov	r22, r29
    2292:	81 2f       	mov	r24, r17
    2294:	0e 94 1f 11 	call	0x223e	; 0x223e <gfx_mono_framebuffer_put_byte>
    2298:	81 2f       	mov	r24, r17
    229a:	0e 94 0d 10 	call	0x201a	; 0x201a <ssd1306_set_page_address>
    229e:	8d 2f       	mov	r24, r29
    22a0:	0e 94 12 10 	call	0x2024	; 0x2024 <ssd1306_set_column_address>
    22a4:	8c 2f       	mov	r24, r28
    22a6:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <ssd1306_write_data>
    22aa:	df 91       	pop	r29
    22ac:	cf 91       	pop	r28
    22ae:	1f 91       	pop	r17
    22b0:	08 95       	ret

000022b2 <SetupHardware>:
}


/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
    22b2:	cf 93       	push	r28
    22b4:	df 93       	push	r29
				  return false;

				switch (Source)
				{
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.PLLCTRL = (OSC_PLLSRC_RC2M_gc  | MulFactor);
    22b6:	e0 e5       	ldi	r30, 0x50	; 80
    22b8:	f0 e0       	ldi	r31, 0x00	; 0
    22ba:	80 e1       	ldi	r24, 0x10	; 16
    22bc:	85 83       	std	Z+5, r24	; 0x05
						break;
					default:
						return false;
				}

				OSC.CTRL |= OSC_PLLEN_bm;
    22be:	80 81       	ld	r24, Z
    22c0:	80 61       	ori	r24, 0x10	; 16
    22c2:	80 83       	st	Z, r24

				while (!(OSC.STATUS & OSC_PLLRDY_bm));
    22c4:	81 81       	ldd	r24, Z+1	; 0x01
    22c6:	84 ff       	sbrs	r24, 4
    22c8:	fd cf       	rjmp	.-6      	; 0x22c4 <SetupHardware+0x12>
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    22ca:	8f b7       	in	r24, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    22cc:	f8 94       	cli
			 *  \param[in] Value    Value to write to the protected location
			 */
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value) ATTR_NON_NULL_PTR_ARG(1) ATTR_ALWAYS_INLINE;
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value)
			{
				__asm__ __volatile__ (
    22ce:	a0 e4       	ldi	r26, 0x40	; 64
    22d0:	b0 e0       	ldi	r27, 0x00	; 0
    22d2:	94 e0       	ldi	r25, 0x04	; 4
    22d4:	28 ed       	ldi	r18, 0xD8	; 216
    22d6:	30 e0       	ldi	r19, 0x00	; 0
    22d8:	1b be       	out	0x3b, r1	; 59
    22da:	fd 01       	movw	r30, r26
    22dc:	24 bf       	out	0x34, r18	; 52
    22de:	90 83       	st	Z, r25
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    22e0:	8f bf       	out	0x3f, r24	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    22e2:	8f e3       	ldi	r24, 0x3F	; 63
    22e4:	9f e1       	ldi	r25, 0x1F	; 31
    22e6:	01 97       	sbiw	r24, 0x01	; 1
    22e8:	f1 f7       	brne	.-4      	; 0x22e6 <SetupHardware+0x34>
    22ea:	00 c0       	rjmp	.+0      	; 0x22ec <SetupHardware+0x3a>
    22ec:	00 00       	nop
				XMEGACLK_CCP_Write(&CLK.CTRL, ClockSourceMask);

				SetGlobalInterruptMask(CurrentGlobalInt);

				Delay_MS(1);
				return (CLK.CTRL == ClockSourceMask);
    22ee:	8c 91       	ld	r24, X
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.CTRL |= OSC_RC2MEN_bm;
						while (!(OSC.STATUS & OSC_RC2MRDY_bm));
						return true;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.CTRL |= OSC_RC32MEN_bm;
    22f0:	e0 e5       	ldi	r30, 0x50	; 80
    22f2:	f0 e0       	ldi	r31, 0x00	; 0
    22f4:	80 81       	ld	r24, Z
    22f6:	82 60       	ori	r24, 0x02	; 2
    22f8:	80 83       	st	Z, r24
						while (!(OSC.STATUS & OSC_RC32MRDY_bm));
    22fa:	81 81       	ldd	r24, Z+1	; 0x01
    22fc:	81 ff       	sbrs	r24, 1
    22fe:	fd cf       	rjmp	.-6      	; 0x22fa <SetupHardware+0x48>
						DFLLRC2M.COMP1  = (DFLLCompare & 0xFF);
						DFLLRC2M.COMP2  = (DFLLCompare >> 8);
						DFLLRC2M.CTRL   = DFLL_ENABLE_bm;
						break;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.DFLLCTRL   |= (Reference << OSC_RC32MCREF_gp);
    2300:	e0 e5       	ldi	r30, 0x50	; 80
    2302:	f0 e0       	ldi	r31, 0x00	; 0
    2304:	86 81       	ldd	r24, Z+6	; 0x06
    2306:	84 60       	ori	r24, 0x04	; 4
    2308:	86 83       	std	Z+6, r24	; 0x06
						DFLLRC32M.COMP1 = (DFLLCompare & 0xFF);
    230a:	a0 e6       	ldi	r26, 0x60	; 96
    230c:	b0 e0       	ldi	r27, 0x00	; 0
    230e:	8b e1       	ldi	r24, 0x1B	; 27
    2310:	15 96       	adiw	r26, 0x05	; 5
    2312:	8c 93       	st	X, r24
    2314:	15 97       	sbiw	r26, 0x05	; 5
						DFLLRC32M.COMP2 = (DFLLCompare >> 8);
    2316:	87 eb       	ldi	r24, 0xB7	; 183
    2318:	16 96       	adiw	r26, 0x06	; 6
    231a:	8c 93       	st	X, r24
    231c:	16 97       	sbiw	r26, 0x06	; 6

						if (Reference == DFLL_REF_INT_USBSOF)
						{
							NVM.CMD        = NVM_CMD_READ_CALIB_ROW_gc;
    231e:	c0 ec       	ldi	r28, 0xC0	; 192
    2320:	d1 e0       	ldi	r29, 0x01	; 1
    2322:	82 e0       	ldi	r24, 0x02	; 2
    2324:	8a 87       	std	Y+10, r24	; 0x0a
							DFLLRC32M.CALA = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSCA));
    2326:	ed e1       	ldi	r30, 0x1D	; 29
    2328:	f0 e0       	ldi	r31, 0x00	; 0
    232a:	e4 91       	lpm	r30, Z
    232c:	12 96       	adiw	r26, 0x02	; 2
    232e:	ec 93       	st	X, r30
    2330:	12 97       	sbiw	r26, 0x02	; 2
							DFLLRC32M.CALB = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSC));
    2332:	ec e1       	ldi	r30, 0x1C	; 28
    2334:	f0 e0       	ldi	r31, 0x00	; 0
    2336:	e4 91       	lpm	r30, Z
    2338:	13 96       	adiw	r26, 0x03	; 3
    233a:	ec 93       	st	X, r30
    233c:	13 97       	sbiw	r26, 0x03	; 3
							NVM.CMD        = 0;
    233e:	1a 86       	std	Y+10, r1	; 0x0a
						}

						DFLLRC32M.CTRL  = DFLL_ENABLE_bm;
    2340:	81 e0       	ldi	r24, 0x01	; 1
    2342:	8c 93       	st	X, r24

	/* Start the 32MHz internal RC oscillator and start the DFLL to increase it to 48MHz using the USB SOF as a reference */
	XMEGACLK_StartInternalOscillator(CLOCK_SRC_INT_RC32MHZ);
	XMEGACLK_StartDFLL(CLOCK_SRC_INT_RC32MHZ, DFLL_REF_INT_USBSOF, F_USB);

	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
    2344:	87 e0       	ldi	r24, 0x07	; 7
    2346:	80 93 a2 00 	sts	0x00A2, r24

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				PORTR.DIRSET    = LEDS_PORTR_LEDS;
    234a:	e0 ee       	ldi	r30, 0xE0	; 224
    234c:	f7 e0       	ldi	r31, 0x07	; 7
    234e:	83 e0       	ldi	r24, 0x03	; 3
    2350:	81 83       	std	Z+1, r24	; 0x01
				PORTR.OUTCLR    = LEDS_PORTR_LEDS;
    2352:	86 83       	std	Z+6, r24	; 0x06

				PORTCFG.MPCMASK = LEDS_PORTR_LEDS;
    2354:	80 93 b0 00 	sts	0x00B0, r24
				PORTR.PIN0CTRL  = PORT_INVEN_bm;
    2358:	80 e4       	ldi	r24, 0x40	; 64
    235a:	80 8b       	std	Z+16, r24	; 0x10

				PORTD.DIRSET    = LEDS_PORTD_LEDS;
    235c:	e0 e6       	ldi	r30, 0x60	; 96
    235e:	f6 e0       	ldi	r31, 0x06	; 6
    2360:	90 e3       	ldi	r25, 0x30	; 48
    2362:	91 83       	std	Z+1, r25	; 0x01
				PORTD.OUTCLR    = LEDS_PORTD_LEDS;
    2364:	96 83       	std	Z+6, r25	; 0x06

				PORTD.PIN4CTRL  = PORT_INVEN_bm;
    2366:	84 8b       	std	Z+20, r24	; 0x14
#endif

	/* Hardware Initialization */
	LEDs_Init();
	USB_Init();
    2368:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <USB_Init>
}
    236c:	df 91       	pop	r29
    236e:	cf 91       	pop	r28
    2370:	08 95       	ret

00002372 <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	DigitalPin_SetDIr(&led,1);
    2372:	61 e0       	ldi	r22, 0x01	; 1
    2374:	89 ea       	ldi	r24, 0xA9	; 169
    2376:	92 e2       	ldi	r25, 0x22	; 34
    2378:	0e 94 8d 12 	call	0x251a	; 0x251a <DigitalPin_SetDIr>
	DigitalPin_SetDIr(&led2,1);
    237c:	61 e0       	ldi	r22, 0x01	; 1
    237e:	86 ea       	ldi	r24, 0xA6	; 166
    2380:	92 e2       	ldi	r25, 0x22	; 34
    2382:	0e 94 8d 12 	call	0x251a	; 0x251a <DigitalPin_SetDIr>
	
	SetupHardware();
    2386:	0e 94 59 11 	call	0x22b2	; 0x22b2 <SetupHardware>
	gfx_mono_set_framebuffer(framebuffer);
\endcode
 */
void gfx_mono_set_framebuffer(uint8_t *framebuffer)
{
	fbpointer = framebuffer;
    238a:	89 e3       	ldi	r24, 0x39	; 57
    238c:	93 e9       	ldi	r25, 0x93	; 147
    238e:	80 93 37 93 	sts	0x9337, r24
    2392:	90 93 38 93 	sts	0x9338, r25

	uint8_t page;
	uint8_t column;
	gfx_mono_set_framebuffer(framebuffer);
	ssd1306_init();
    2396:	0e 94 65 10 	call	0x20ca	; 0x20ca <ssd1306_init>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    239a:	d0 e0       	ldi	r29, 0x00	; 0
    239c:	0f c0       	rjmp	.+30     	; 0x23bc <main+0x4a>
	{
		for (col = 0; col < 128; ++col)
		{
			ssd1306_set_page_address(page);
    239e:	8d 2f       	mov	r24, r29
    23a0:	0e 94 0d 10 	call	0x201a	; 0x201a <ssd1306_set_page_address>
			ssd1306_set_column_address(col);
    23a4:	8c 2f       	mov	r24, r28
    23a6:	0e 94 12 10 	call	0x2024	; 0x2024 <ssd1306_set_column_address>
			ssd1306_write_data(0x00);
    23aa:	80 e0       	ldi	r24, 0x00	; 0
    23ac:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <ssd1306_write_data>
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
	{
		for (col = 0; col < 128; ++col)
    23b0:	cf 5f       	subi	r28, 0xFF	; 255
    23b2:	c0 38       	cpi	r28, 0x80	; 128
    23b4:	a1 f7       	brne	.-24     	; 0x239e <main+0x2c>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    23b6:	df 5f       	subi	r29, 0xFF	; 255
    23b8:	d4 30       	cpi	r29, 0x04	; 4
    23ba:	11 f0       	breq	.+4      	; 0x23c0 <main+0x4e>

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
    23bc:	c0 e0       	ldi	r28, 0x00	; 0
    23be:	ef cf       	rjmp	.-34     	; 0x239e <main+0x2c>
 */
static inline void ssd1306_set_display_start_line_address(uint8_t address)
{
	// Make sure address is 6 bits
	address &= 0x3F;
	ssd1306_write_command(SSD1306_CMD_SET_START_LINE(address));
    23c0:	80 e4       	ldi	r24, 0x40	; 64
    23c2:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <ssd1306_write_command>
	uint8_t column;
	gfx_mono_set_framebuffer(framebuffer);
	ssd1306_init();
	ssd1306_clear();
	ssd1306_set_display_start_line_address(0);
 	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    23c6:	d0 e0       	ldi	r29, 0x00	; 0
    23c8:	0c c0       	rjmp	.+24     	; 0x23e2 <main+0x70>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
    23ca:	21 e0       	ldi	r18, 0x01	; 1
    23cc:	40 e0       	ldi	r20, 0x00	; 0
    23ce:	6c 2f       	mov	r22, r28
    23d0:	8d 2f       	mov	r24, r29
    23d2:	0e 94 3b 11 	call	0x2276	; 0x2276 <gfx_mono_ssd1306_put_byte>
	gfx_mono_set_framebuffer(framebuffer);
	ssd1306_init();
	ssd1306_clear();
	ssd1306_set_display_start_line_address(0);
 	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    23d6:	cf 5f       	subi	r28, 0xFF	; 255
    23d8:	c0 38       	cpi	r28, 0x80	; 128
    23da:	b9 f7       	brne	.-18     	; 0x23ca <main+0x58>
	uint8_t column;
	gfx_mono_set_framebuffer(framebuffer);
	ssd1306_init();
	ssd1306_clear();
	ssd1306_set_display_start_line_address(0);
 	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    23dc:	df 5f       	subi	r29, 0xFF	; 255
    23de:	d4 30       	cpi	r29, 0x04	; 4
    23e0:	11 f0       	breq	.+4      	; 0x23e6 <main+0x74>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    23e2:	c0 e0       	ldi	r28, 0x00	; 0
    23e4:	f2 cf       	rjmp	.-28     	; 0x23ca <main+0x58>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
		}
	}

	asm("nop");
    23e6:	00 00       	nop
	ssd1306_set_page_address(0);
    23e8:	80 e0       	ldi	r24, 0x00	; 0
    23ea:	0e 94 0d 10 	call	0x201a	; 0x201a <ssd1306_set_page_address>
	ssd1306_write_text("EMON");
    23ee:	8c eb       	ldi	r24, 0xBC	; 188
    23f0:	92 e2       	ldi	r25, 0x22	; 34
    23f2:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <ssd1306_write_text>


	DigitalPin_SetDIr(&led,1);
    23f6:	61 e0       	ldi	r22, 0x01	; 1
    23f8:	89 ea       	ldi	r24, 0xA9	; 169
    23fa:	92 e2       	ldi	r25, 0x22	; 34
    23fc:	0e 94 8d 12 	call	0x251a	; 0x251a <DigitalPin_SetDIr>
	DigitalPin_SetDIr(&led2,1);
    2400:	61 e0       	ldi	r22, 0x01	; 1
    2402:	86 ea       	ldi	r24, 0xA6	; 166
    2404:	92 e2       	ldi	r25, 0x22	; 34
    2406:	0e 94 8d 12 	call	0x251a	; 0x251a <DigitalPin_SetDIr>
	//PORT_SetDirection(&PORTR,(1<<0));

	CLKSYS_Enable( OSC_RC32MEN_bm );
    240a:	e0 e5       	ldi	r30, 0x50	; 80
    240c:	f0 e0       	ldi	r31, 0x00	; 0
    240e:	80 81       	ld	r24, Z
    2410:	82 60       	ori	r24, 0x02	; 2
    2412:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC32MRDY_bm ) == 0 );
    2414:	81 81       	ldd	r24, Z+1	; 0x01
    2416:	81 ff       	sbrs	r24, 1
    2418:	fd cf       	rjmp	.-6      	; 0x2414 <main+0xa2>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    241a:	81 e0       	ldi	r24, 0x01	; 1
    241c:	0e 94 46 13 	call	0x268c	; 0x268c <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    2420:	81 e0       	ldi	r24, 0x01	; 1
    2422:	0e 94 3c 13 	call	0x2678	; 0x2678 <CLKSYS_Disable>

	char time_string[20];
	uint8_t rxData[33];


	PORTR.DIRSET = (1<<0);
    2426:	e0 ee       	ldi	r30, 0xE0	; 224
    2428:	f7 e0       	ldi	r31, 0x07	; 7
    242a:	81 e0       	ldi	r24, 0x01	; 1
    242c:	81 83       	std	Z+1, r24	; 0x01
	PORTR.DIRSET = (1<<1);
    242e:	82 e0       	ldi	r24, 0x02	; 2
    2430:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = (1<<4);
    2432:	80 e1       	ldi	r24, 0x10	; 16
    2434:	80 93 61 06 	sts	0x0661, r24

	CDC_Device_CreateStream(&VirtualSerial_CDC_Interface, &USBSerialStream);
    2438:	69 e2       	ldi	r22, 0x29	; 41
    243a:	73 e9       	ldi	r23, 0x93	; 147
    243c:	8b e8       	ldi	r24, 0x8B	; 139
    243e:	92 e2       	ldi	r25, 0x22	; 34
    2440:	0e 94 05 09 	call	0x120a	; 0x120a <CDC_Device_CreateStream>
				#if (ARCH == ARCH_AVR8)
				sei();
				#elif (ARCH == ARCH_UC3)
				__builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				sei();
    2444:	78 94       	sei
	GlobalInterruptEnable();

	asm("nop");
    2446:	00 00       	nop

	TWI_MasterInit(&lcd03i2c,
    2448:	2b e9       	ldi	r18, 0x9B	; 155
    244a:	40 e0       	ldi	r20, 0x00	; 0
    244c:	60 ea       	ldi	r22, 0xA0	; 160
    244e:	74 e0       	ldi	r23, 0x04	; 4
    2450:	89 e3       	ldi	r24, 0x39	; 57
    2452:	95 e9       	ldi	r25, 0x95	; 149
    2454:	0e 94 67 13 	call	0x26ce	; 0x26ce <TWI_MasterInit>
	&TWIE,
	TWI_MASTER_INTLVL_OFF_gc,
	TWI_BAUD(F_CPU, 100000));
	
	asm("nop");
    2458:	00 00       	nop
// 		while(!(TWIE.MASTER.STATUS&TWI_MASTER_WIF_bm));
// 	}
	


	asm("nop");
    245a:	00 00       	nop





	asm("nop");
    245c:	00 00       	nop


	
	xTaskCreate(thread_1,(signed portCHAR *) "t1", 100, NULL, tskIDLE_PRIORITY, NULL );
    245e:	a1 2c       	mov	r10, r1
    2460:	b1 2c       	mov	r11, r1
    2462:	c1 2c       	mov	r12, r1
    2464:	d1 2c       	mov	r13, r1
    2466:	e1 2c       	mov	r14, r1
    2468:	f1 2c       	mov	r15, r1
    246a:	00 e0       	ldi	r16, 0x00	; 0
    246c:	20 e0       	ldi	r18, 0x00	; 0
    246e:	30 e0       	ldi	r19, 0x00	; 0
    2470:	44 e6       	ldi	r20, 0x64	; 100
    2472:	50 e0       	ldi	r21, 0x00	; 0
    2474:	61 ec       	ldi	r22, 0xC1	; 193
    2476:	72 e2       	ldi	r23, 0x22	; 34
    2478:	8c ea       	ldi	r24, 0xAC	; 172
    247a:	9f e0       	ldi	r25, 0x0F	; 15
    247c:	0e 94 81 04 	call	0x902	; 0x902 <xTaskGenericCreate>
	xTaskCreate(thread_2,(signed portCHAR *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
    2480:	20 e0       	ldi	r18, 0x00	; 0
    2482:	30 e0       	ldi	r19, 0x00	; 0
    2484:	44 e6       	ldi	r20, 0x64	; 100
    2486:	50 e0       	ldi	r21, 0x00	; 0
    2488:	64 ec       	ldi	r22, 0xC4	; 196
    248a:	72 e2       	ldi	r23, 0x22	; 34
    248c:	83 ea       	ldi	r24, 0xA3	; 163
    248e:	9f e0       	ldi	r25, 0x0F	; 15
    2490:	0e 94 81 04 	call	0x902	; 0x902 <xTaskGenericCreate>
	xTaskCreate(USBThread,(signed portCHAR *) "usb", 200, NULL, tskIDLE_PRIORITY, NULL );
    2494:	20 e0       	ldi	r18, 0x00	; 0
    2496:	30 e0       	ldi	r19, 0x00	; 0
    2498:	48 ec       	ldi	r20, 0xC8	; 200
    249a:	50 e0       	ldi	r21, 0x00	; 0
    249c:	67 ec       	ldi	r22, 0xC7	; 199
    249e:	72 e2       	ldi	r23, 0x22	; 34
    24a0:	84 e9       	ldi	r24, 0x94	; 148
    24a2:	9f e0       	ldi	r25, 0x0F	; 15
    24a4:	0e 94 81 04 	call	0x902	; 0x902 <xTaskGenericCreate>
	

	//starting the scheduler
	vTaskStartScheduler();
    24a8:	0e 94 94 05 	call	0xb28	; 0xb28 <vTaskStartScheduler>

	for (;;)
	{
// 		CDC_Device_USBTask(&VirtualSerial_CDC_Interface);
// 		USB_USBTask();
	}
    24ac:	ff cf       	rjmp	.-2      	; 0x24ac <main+0x13a>

000024ae <EVENT_USB_Device_Connect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    24ae:	83 e0       	ldi	r24, 0x03	; 3
    24b0:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    24b4:	80 e3       	ldi	r24, 0x30	; 48
    24b6:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    24ba:	82 e0       	ldi	r24, 0x02	; 2
    24bc:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    24c0:	80 e1       	ldi	r24, 0x10	; 16
    24c2:	80 93 65 06 	sts	0x0665, r24
    24c6:	08 95       	ret

000024c8 <EVENT_USB_Device_Disconnect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    24c8:	83 e0       	ldi	r24, 0x03	; 3
    24ca:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    24ce:	80 e3       	ldi	r24, 0x30	; 48
    24d0:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    24d4:	81 e0       	ldi	r24, 0x01	; 1
    24d6:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    24da:	10 92 65 06 	sts	0x0665, r1
    24de:	08 95       	ret

000024e0 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= CDC_Device_ConfigureEndpoints(&VirtualSerial_CDC_Interface);
    24e0:	8b e8       	ldi	r24, 0x8B	; 139
    24e2:	92 e2       	ldi	r25, 0x22	; 34
    24e4:	0e 94 bf 07 	call	0xf7e	; 0xf7e <CDC_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
    24e8:	81 11       	cpse	r24, r1
    24ea:	02 c0       	rjmp	.+4      	; 0x24f0 <EVENT_USB_Device_ConfigurationChanged+0x10>
    24ec:	81 e1       	ldi	r24, 0x11	; 17
    24ee:	01 c0       	rjmp	.+2      	; 0x24f2 <EVENT_USB_Device_ConfigurationChanged+0x12>
    24f0:	82 e2       	ldi	r24, 0x22	; 34
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    24f2:	93 e0       	ldi	r25, 0x03	; 3
    24f4:	90 93 e6 07 	sts	0x07E6, r25
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    24f8:	90 e3       	ldi	r25, 0x30	; 48
    24fa:	90 93 66 06 	sts	0x0666, r25

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    24fe:	98 2f       	mov	r25, r24
    2500:	93 70       	andi	r25, 0x03	; 3
    2502:	90 93 e5 07 	sts	0x07E5, r25
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    2506:	80 73       	andi	r24, 0x30	; 48
    2508:	80 93 65 06 	sts	0x0665, r24
    250c:	08 95       	ret

0000250e <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	CDC_Device_ProcessControlRequest(&VirtualSerial_CDC_Interface);
    250e:	8b e8       	ldi	r24, 0x8B	; 139
    2510:	92 e2       	ldi	r25, 0x22	; 34
    2512:	0e 94 19 09 	call	0x1232	; 0x1232 <CDC_Device_ProcessControlRequest>
    2516:	08 95       	ret

00002518 <EVENT_CDC_Device_ControLineStateChanged>:
 *  control lines sent from the host..
 *
 *  \param[in] CDCInterfaceInfo  Pointer to the CDC class interface configuration structure being referenced
 */
void EVENT_CDC_Device_ControLineStateChanged(USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo)
{
    2518:	08 95       	ret

0000251a <DigitalPin_SetDIr>:
void DigitalPin_SetValue(DigitalPin_t *pin){
	pin->_port->OUTSET = (1<< pin->_pin);
}

void DigitalPin_ClearValue(DigitalPin_t *pin){
	pin->_port->OUTCLR = (1<< pin->_pin);
    251a:	66 23       	and	r22, r22
    251c:	79 f0       	breq	.+30     	; 0x253c <DigitalPin_SetDIr+0x22>
    251e:	dc 01       	movw	r26, r24
    2520:	ed 91       	ld	r30, X+
    2522:	fc 91       	ld	r31, X
    2524:	11 97       	sbiw	r26, 0x01	; 1
    2526:	21 e0       	ldi	r18, 0x01	; 1
    2528:	30 e0       	ldi	r19, 0x00	; 0
    252a:	a9 01       	movw	r20, r18
    252c:	12 96       	adiw	r26, 0x02	; 2
    252e:	0c 90       	ld	r0, X
    2530:	02 c0       	rjmp	.+4      	; 0x2536 <DigitalPin_SetDIr+0x1c>
    2532:	44 0f       	add	r20, r20
    2534:	55 1f       	adc	r21, r21
    2536:	0a 94       	dec	r0
    2538:	e2 f7       	brpl	.-8      	; 0x2532 <DigitalPin_SetDIr+0x18>
    253a:	41 83       	std	Z+1, r20	; 0x01
    253c:	08 95       	ret

0000253e <DigitalPin_ToggleValue>:
}

void DigitalPin_ToggleValue(DigitalPin_t *pin){
	pin->_port->OUTTGL = (1<< pin->_pin);
    253e:	dc 01       	movw	r26, r24
    2540:	ed 91       	ld	r30, X+
    2542:	fc 91       	ld	r31, X
    2544:	11 97       	sbiw	r26, 0x01	; 1
    2546:	21 e0       	ldi	r18, 0x01	; 1
    2548:	30 e0       	ldi	r19, 0x00	; 0
    254a:	a9 01       	movw	r20, r18
    254c:	12 96       	adiw	r26, 0x02	; 2
    254e:	0c 90       	ld	r0, X
    2550:	02 c0       	rjmp	.+4      	; 0x2556 <DigitalPin_ToggleValue+0x18>
    2552:	44 0f       	add	r20, r20
    2554:	55 1f       	adc	r21, r21
    2556:	0a 94       	dec	r0
    2558:	e2 f7       	brpl	.-8      	; 0x2552 <DigitalPin_ToggleValue+0x14>
    255a:	47 83       	std	Z+7, r20	; 0x07
    255c:	08 95       	ret

0000255e <__vector_25>:


}

#if defined(USARTC0)
ISR(USARTC0_RXC_vect){
    255e:	1f 92       	push	r1
    2560:	0f 92       	push	r0
    2562:	0f b6       	in	r0, 0x3f	; 63
    2564:	0f 92       	push	r0
    2566:	11 24       	eor	r1, r1

}
    2568:	0f 90       	pop	r0
    256a:	0f be       	out	0x3f, r0	; 63
    256c:	0f 90       	pop	r0
    256e:	1f 90       	pop	r1
    2570:	18 95       	reti

00002572 <__vector_27>:

ISR(USARTC0_TXC_vect){
    2572:	1f 92       	push	r1
    2574:	0f 92       	push	r0
    2576:	0f b6       	in	r0, 0x3f	; 63
    2578:	0f 92       	push	r0
    257a:	11 24       	eor	r1, r1
	
}
    257c:	0f 90       	pop	r0
    257e:	0f be       	out	0x3f, r0	; 63
    2580:	0f 90       	pop	r0
    2582:	1f 90       	pop	r1
    2584:	18 95       	reti

00002586 <__vector_26>:

ISR(USARTC0_DRE_vect){
    2586:	1f 92       	push	r1
    2588:	0f 92       	push	r0
    258a:	0f b6       	in	r0, 0x3f	; 63
    258c:	0f 92       	push	r0
    258e:	11 24       	eor	r1, r1
	
}
    2590:	0f 90       	pop	r0
    2592:	0f be       	out	0x3f, r0	; 63
    2594:	0f 90       	pop	r0
    2596:	1f 90       	pop	r1
    2598:	18 95       	reti

0000259a <__vector_28>:
#endif


#if defined(USARTC1)
ISR(USARTC1_RXC_vect){
    259a:	1f 92       	push	r1
    259c:	0f 92       	push	r0
    259e:	0f b6       	in	r0, 0x3f	; 63
    25a0:	0f 92       	push	r0
    25a2:	11 24       	eor	r1, r1
	
}
    25a4:	0f 90       	pop	r0
    25a6:	0f be       	out	0x3f, r0	; 63
    25a8:	0f 90       	pop	r0
    25aa:	1f 90       	pop	r1
    25ac:	18 95       	reti

000025ae <__vector_30>:

ISR(USARTC1_TXC_vect){
    25ae:	1f 92       	push	r1
    25b0:	0f 92       	push	r0
    25b2:	0f b6       	in	r0, 0x3f	; 63
    25b4:	0f 92       	push	r0
    25b6:	11 24       	eor	r1, r1
	
}
    25b8:	0f 90       	pop	r0
    25ba:	0f be       	out	0x3f, r0	; 63
    25bc:	0f 90       	pop	r0
    25be:	1f 90       	pop	r1
    25c0:	18 95       	reti

000025c2 <__vector_29>:

ISR(USARTC1_DRE_vect){
    25c2:	1f 92       	push	r1
    25c4:	0f 92       	push	r0
    25c6:	0f b6       	in	r0, 0x3f	; 63
    25c8:	0f 92       	push	r0
    25ca:	11 24       	eor	r1, r1
	
}
    25cc:	0f 90       	pop	r0
    25ce:	0f be       	out	0x3f, r0	; 63
    25d0:	0f 90       	pop	r0
    25d2:	1f 90       	pop	r1
    25d4:	18 95       	reti

000025d6 <__vector_88>:
#endif


#if defined(USARTD0)
ISR(USARTD0_RXC_vect){
    25d6:	1f 92       	push	r1
    25d8:	0f 92       	push	r0
    25da:	0f b6       	in	r0, 0x3f	; 63
    25dc:	0f 92       	push	r0
    25de:	11 24       	eor	r1, r1
	
}
    25e0:	0f 90       	pop	r0
    25e2:	0f be       	out	0x3f, r0	; 63
    25e4:	0f 90       	pop	r0
    25e6:	1f 90       	pop	r1
    25e8:	18 95       	reti

000025ea <__vector_90>:

ISR(USARTD0_TXC_vect){
    25ea:	1f 92       	push	r1
    25ec:	0f 92       	push	r0
    25ee:	0f b6       	in	r0, 0x3f	; 63
    25f0:	0f 92       	push	r0
    25f2:	11 24       	eor	r1, r1
	
}
    25f4:	0f 90       	pop	r0
    25f6:	0f be       	out	0x3f, r0	; 63
    25f8:	0f 90       	pop	r0
    25fa:	1f 90       	pop	r1
    25fc:	18 95       	reti

000025fe <__vector_89>:

ISR(USARTD0_DRE_vect){
    25fe:	1f 92       	push	r1
    2600:	0f 92       	push	r0
    2602:	0f b6       	in	r0, 0x3f	; 63
    2604:	0f 92       	push	r0
    2606:	11 24       	eor	r1, r1
	
}
    2608:	0f 90       	pop	r0
    260a:	0f be       	out	0x3f, r0	; 63
    260c:	0f 90       	pop	r0
    260e:	1f 90       	pop	r1
    2610:	18 95       	reti

00002612 <__vector_58>:
	
}
#endif

#if defined(USARTE0)
ISR(USARTE0_RXC_vect){
    2612:	1f 92       	push	r1
    2614:	0f 92       	push	r0
    2616:	0f b6       	in	r0, 0x3f	; 63
    2618:	0f 92       	push	r0
    261a:	11 24       	eor	r1, r1
	
}
    261c:	0f 90       	pop	r0
    261e:	0f be       	out	0x3f, r0	; 63
    2620:	0f 90       	pop	r0
    2622:	1f 90       	pop	r1
    2624:	18 95       	reti

00002626 <__vector_60>:

ISR(USARTE0_TXC_vect){
    2626:	1f 92       	push	r1
    2628:	0f 92       	push	r0
    262a:	0f b6       	in	r0, 0x3f	; 63
    262c:	0f 92       	push	r0
    262e:	11 24       	eor	r1, r1
	
}
    2630:	0f 90       	pop	r0
    2632:	0f be       	out	0x3f, r0	; 63
    2634:	0f 90       	pop	r0
    2636:	1f 90       	pop	r1
    2638:	18 95       	reti

0000263a <__vector_59>:

ISR(USARTE0_DRE_vect){
    263a:	1f 92       	push	r1
    263c:	0f 92       	push	r0
    263e:	0f b6       	in	r0, 0x3f	; 63
    2640:	0f 92       	push	r0
    2642:	11 24       	eor	r1, r1
	
}
    2644:	0f 90       	pop	r0
    2646:	0f be       	out	0x3f, r0	; 63
    2648:	0f 90       	pop	r0
    264a:	1f 90       	pop	r1
    264c:	18 95       	reti

0000264e <CCPWrite>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
    264e:	0f 93       	push	r16
    2650:	cf 93       	push	r28
    2652:	df 93       	push	r29
    2654:	1f 92       	push	r1
    2656:	cd b7       	in	r28, 0x3d	; 61
    2658:	de b7       	in	r29, 0x3e	; 62
    265a:	2f b7       	in	r18, 0x3f	; 63
    265c:	29 83       	std	Y+1, r18	; 0x01
    265e:	f8 94       	cli
    2660:	1b be       	out	0x3b, r1	; 59
    2662:	fc 01       	movw	r30, r24
    2664:	08 ed       	ldi	r16, 0xD8	; 216
    2666:	04 bf       	out	0x34, r16	; 52
    2668:	60 83       	st	Z, r22
    266a:	89 81       	ldd	r24, Y+1	; 0x01
    266c:	8f bf       	out	0x3f, r24	; 63
    266e:	0f 90       	pop	r0
    2670:	df 91       	pop	r29
    2672:	cf 91       	pop	r28
    2674:	0f 91       	pop	r16
    2676:	08 95       	ret

00002678 <CLKSYS_Disable>:
    2678:	e0 e5       	ldi	r30, 0x50	; 80
    267a:	f0 e0       	ldi	r31, 0x00	; 0
    267c:	90 81       	ld	r25, Z
    267e:	28 2f       	mov	r18, r24
    2680:	20 95       	com	r18
    2682:	92 23       	and	r25, r18
    2684:	90 83       	st	Z, r25
    2686:	90 81       	ld	r25, Z
    2688:	89 23       	and	r24, r25
    268a:	08 95       	ret

0000268c <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    268c:	0f 93       	push	r16
    268e:	1f 93       	push	r17
    2690:	cf 93       	push	r28
    2692:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    2694:	00 e4       	ldi	r16, 0x40	; 64
    2696:	10 e0       	ldi	r17, 0x00	; 0
    2698:	f8 01       	movw	r30, r16
    269a:	60 81       	ld	r22, Z
    269c:	68 7f       	andi	r22, 0xF8	; 248
    269e:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    26a0:	80 e4       	ldi	r24, 0x40	; 64
    26a2:	90 e0       	ldi	r25, 0x00	; 0
    26a4:	0e 94 27 13 	call	0x264e	; 0x264e <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    26a8:	f8 01       	movw	r30, r16
    26aa:	80 81       	ld	r24, Z
	return clkCtrl;
}
    26ac:	8c 23       	and	r24, r28
    26ae:	cf 91       	pop	r28
    26b0:	1f 91       	pop	r17
    26b2:	0f 91       	pop	r16
    26b4:	08 95       	ret

000026b6 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
    26b6:	fc 01       	movw	r30, r24
    26b8:	90 81       	ld	r25, Z
    26ba:	90 7f       	andi	r25, 0xF0	; 240
    26bc:	69 2b       	or	r22, r25
    26be:	60 83       	st	Z, r22
    26c0:	08 95       	ret

000026c2 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
    26c2:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    26c4:	96 81       	ldd	r25, Z+6	; 0x06
    26c6:	9c 7f       	andi	r25, 0xFC	; 252
    26c8:	69 2b       	or	r22, r25
    26ca:	66 83       	std	Z+6, r22	; 0x06
    26cc:	08 95       	ret

000026ce <TWI_MasterInit>:
	}

	/* Clear interrupt flag. */
	twi->interface->MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;

	twi->status = TWIM_STATUS_READY;
    26ce:	fc 01       	movw	r30, r24
    26d0:	60 83       	st	Z, r22
    26d2:	71 83       	std	Z+1, r23	; 0x01
    26d4:	48 63       	ori	r20, 0x38	; 56
    26d6:	db 01       	movw	r26, r22
    26d8:	11 96       	adiw	r26, 0x01	; 1
    26da:	4c 93       	st	X, r20
    26dc:	a0 81       	ld	r26, Z
    26de:	b1 81       	ldd	r27, Z+1	; 0x01
    26e0:	15 96       	adiw	r26, 0x05	; 5
    26e2:	2c 93       	st	X, r18
    26e4:	01 90       	ld	r0, Z+
    26e6:	f0 81       	ld	r31, Z
    26e8:	e0 2d       	mov	r30, r0
    26ea:	81 e0       	ldi	r24, 0x01	; 1
    26ec:	84 83       	std	Z+4, r24	; 0x04
    26ee:	08 95       	ret

000026f0 <TWI_MasterWriteRead>:
    26f0:	0f 93       	push	r16
    26f2:	cf 93       	push	r28
    26f4:	df 93       	push	r29
    26f6:	fc 01       	movw	r30, r24
    26f8:	29 30       	cpi	r18, 0x09	; 9
    26fa:	98 f5       	brcc	.+102    	; 0x2762 <TWI_MasterWriteRead+0x72>
    26fc:	09 30       	cpi	r16, 0x09	; 9
    26fe:	98 f5       	brcc	.+102    	; 0x2766 <TWI_MasterWriteRead+0x76>
    2700:	87 89       	ldd	r24, Z+23	; 0x17
    2702:	81 11       	cpse	r24, r1
    2704:	32 c0       	rjmp	.+100    	; 0x276a <TWI_MasterWriteRead+0x7a>
    2706:	81 e0       	ldi	r24, 0x01	; 1
    2708:	87 8b       	std	Z+23, r24	; 0x17
    270a:	10 8e       	std	Z+24, r1	; 0x18
    270c:	66 0f       	add	r22, r22
    270e:	62 83       	std	Z+2, r22	; 0x02
    2710:	22 23       	and	r18, r18
    2712:	69 f0       	breq	.+26     	; 0x272e <TWI_MasterWriteRead+0x3e>
    2714:	a4 2f       	mov	r26, r20
    2716:	b5 2f       	mov	r27, r21
    2718:	40 e0       	ldi	r20, 0x00	; 0
    271a:	50 e0       	ldi	r21, 0x00	; 0
    271c:	8d 91       	ld	r24, X+
    271e:	ef 01       	movw	r28, r30
    2720:	c4 0f       	add	r28, r20
    2722:	d5 1f       	adc	r29, r21
    2724:	8b 83       	std	Y+3, r24	; 0x03
    2726:	4f 5f       	subi	r20, 0xFF	; 255
    2728:	5f 4f       	sbci	r21, 0xFF	; 255
    272a:	42 17       	cp	r20, r18
    272c:	b8 f3       	brcs	.-18     	; 0x271c <TWI_MasterWriteRead+0x2c>
    272e:	23 8b       	std	Z+19, r18	; 0x13
    2730:	04 8b       	std	Z+20, r16	; 0x14
    2732:	15 8a       	std	Z+21, r1	; 0x15
    2734:	16 8a       	std	Z+22, r1	; 0x16
    2736:	83 89       	ldd	r24, Z+19	; 0x13
    2738:	88 23       	and	r24, r24
    273a:	41 f0       	breq	.+16     	; 0x274c <TWI_MasterWriteRead+0x5c>
    273c:	82 81       	ldd	r24, Z+2	; 0x02
    273e:	8e 7f       	andi	r24, 0xFE	; 254
    2740:	01 90       	ld	r0, Z+
    2742:	f0 81       	ld	r31, Z
    2744:	e0 2d       	mov	r30, r0
    2746:	86 83       	std	Z+6, r24	; 0x06
    2748:	81 e0       	ldi	r24, 0x01	; 1
    274a:	12 c0       	rjmp	.+36     	; 0x2770 <TWI_MasterWriteRead+0x80>
    274c:	84 89       	ldd	r24, Z+20	; 0x14
    274e:	88 23       	and	r24, r24
    2750:	71 f0       	breq	.+28     	; 0x276e <TWI_MasterWriteRead+0x7e>
    2752:	82 81       	ldd	r24, Z+2	; 0x02
    2754:	81 60       	ori	r24, 0x01	; 1
    2756:	01 90       	ld	r0, Z+
    2758:	f0 81       	ld	r31, Z
    275a:	e0 2d       	mov	r30, r0
    275c:	86 83       	std	Z+6, r24	; 0x06
    275e:	81 e0       	ldi	r24, 0x01	; 1
    2760:	07 c0       	rjmp	.+14     	; 0x2770 <TWI_MasterWriteRead+0x80>
    2762:	80 e0       	ldi	r24, 0x00	; 0
    2764:	05 c0       	rjmp	.+10     	; 0x2770 <TWI_MasterWriteRead+0x80>
    2766:	80 e0       	ldi	r24, 0x00	; 0
    2768:	03 c0       	rjmp	.+6      	; 0x2770 <TWI_MasterWriteRead+0x80>
    276a:	80 e0       	ldi	r24, 0x00	; 0
    276c:	01 c0       	rjmp	.+2      	; 0x2770 <TWI_MasterWriteRead+0x80>
    276e:	81 e0       	ldi	r24, 0x01	; 1
    2770:	df 91       	pop	r29
    2772:	cf 91       	pop	r28
    2774:	0f 91       	pop	r16
    2776:	08 95       	ret

00002778 <TWI_MasterWrite>:
    2778:	0f 93       	push	r16
    277a:	00 e0       	ldi	r16, 0x00	; 0
    277c:	0e 94 78 13 	call	0x26f0	; 0x26f0 <TWI_MasterWriteRead>
    2780:	0f 91       	pop	r16
    2782:	08 95       	ret

00002784 <TWI_MasterWriteHandler>:
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 *
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterWriteHandler(TWI_Master_t *twi)
{
    2784:	cf 93       	push	r28
    2786:	df 93       	push	r29
    2788:	fc 01       	movw	r30, r24
	/* Local variables used in if tests to avoid compiler warning. */
	uint8_t bytesToWrite  = twi->bytesToWrite;
    278a:	93 89       	ldd	r25, Z+19	; 0x13
	uint8_t bytesToRead   = twi->bytesToRead;
    278c:	24 89       	ldd	r18, Z+20	; 0x14

	/* If NOT acknowledged (NACK) by slave cancel the transaction. */
	if (twi->interface->MASTER.STATUS & TWI_MASTER_RXACK_bm) {
    278e:	a0 81       	ld	r26, Z
    2790:	b1 81       	ldd	r27, Z+1	; 0x01
    2792:	14 96       	adiw	r26, 0x04	; 4
    2794:	8c 91       	ld	r24, X
    2796:	14 97       	sbiw	r26, 0x04	; 4
    2798:	84 ff       	sbrs	r24, 4
    279a:	07 c0       	rjmp	.+14     	; 0x27aa <TWI_MasterWriteHandler+0x26>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    279c:	83 e0       	ldi	r24, 0x03	; 3
    279e:	13 96       	adiw	r26, 0x03	; 3
    27a0:	8c 93       	st	X, r24
		twi->result = TWIM_RESULT_NACK_RECEIVED;
    27a2:	85 e0       	ldi	r24, 0x05	; 5
    27a4:	80 8f       	std	Z+24, r24	; 0x18
		twi->status = TWIM_STATUS_READY;
    27a6:	17 8a       	std	Z+23, r1	; 0x17
    27a8:	1c c0       	rjmp	.+56     	; 0x27e2 <TWI_MasterWriteHandler+0x5e>
	}

	/* If more bytes to write, send data. */
	else if (twi->bytesWritten < bytesToWrite) {
    27aa:	85 89       	ldd	r24, Z+21	; 0x15
    27ac:	89 17       	cp	r24, r25
    27ae:	58 f4       	brcc	.+22     	; 0x27c6 <TWI_MasterWriteHandler+0x42>
		uint8_t data = twi->writeData[twi->bytesWritten];
    27b0:	85 89       	ldd	r24, Z+21	; 0x15
    27b2:	ef 01       	movw	r28, r30
    27b4:	c8 0f       	add	r28, r24
    27b6:	d1 1d       	adc	r29, r1
    27b8:	8b 81       	ldd	r24, Y+3	; 0x03
		twi->interface->MASTER.DATA = data;
    27ba:	17 96       	adiw	r26, 0x07	; 7
    27bc:	8c 93       	st	X, r24
		++twi->bytesWritten;
    27be:	85 89       	ldd	r24, Z+21	; 0x15
    27c0:	8f 5f       	subi	r24, 0xFF	; 255
    27c2:	85 8b       	std	Z+21, r24	; 0x15
    27c4:	0e c0       	rjmp	.+28     	; 0x27e2 <TWI_MasterWriteHandler+0x5e>
	}

	/* If bytes to read, send repeated START condition + Address +
	 * 'R/_W = 1'
	 */
	else if (twi->bytesRead < bytesToRead) {
    27c6:	86 89       	ldd	r24, Z+22	; 0x16
    27c8:	82 17       	cp	r24, r18
    27ca:	28 f4       	brcc	.+10     	; 0x27d6 <TWI_MasterWriteHandler+0x52>
		uint8_t readAddress = twi->address | 0x01;
    27cc:	82 81       	ldd	r24, Z+2	; 0x02
    27ce:	81 60       	ori	r24, 0x01	; 1
		twi->interface->MASTER.ADDR = readAddress;
    27d0:	16 96       	adiw	r26, 0x06	; 6
    27d2:	8c 93       	st	X, r24
    27d4:	06 c0       	rjmp	.+12     	; 0x27e2 <TWI_MasterWriteHandler+0x5e>
	}

	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    27d6:	83 e0       	ldi	r24, 0x03	; 3
    27d8:	13 96       	adiw	r26, 0x03	; 3
    27da:	8c 93       	st	X, r24
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    27dc:	81 e0       	ldi	r24, 0x01	; 1
    27de:	80 8f       	std	Z+24, r24	; 0x18
	twi->status = TWIM_STATUS_READY;
    27e0:	17 8a       	std	Z+23, r1	; 0x17
	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_OK);
	}
}
    27e2:	df 91       	pop	r29
    27e4:	cf 91       	pop	r28
    27e6:	08 95       	ret

000027e8 <__udivmodsi4>:
    27e8:	a1 e2       	ldi	r26, 0x21	; 33
    27ea:	1a 2e       	mov	r1, r26
    27ec:	aa 1b       	sub	r26, r26
    27ee:	bb 1b       	sub	r27, r27
    27f0:	fd 01       	movw	r30, r26
    27f2:	0d c0       	rjmp	.+26     	; 0x280e <__udivmodsi4_ep>

000027f4 <__udivmodsi4_loop>:
    27f4:	aa 1f       	adc	r26, r26
    27f6:	bb 1f       	adc	r27, r27
    27f8:	ee 1f       	adc	r30, r30
    27fa:	ff 1f       	adc	r31, r31
    27fc:	a2 17       	cp	r26, r18
    27fe:	b3 07       	cpc	r27, r19
    2800:	e4 07       	cpc	r30, r20
    2802:	f5 07       	cpc	r31, r21
    2804:	20 f0       	brcs	.+8      	; 0x280e <__udivmodsi4_ep>
    2806:	a2 1b       	sub	r26, r18
    2808:	b3 0b       	sbc	r27, r19
    280a:	e4 0b       	sbc	r30, r20
    280c:	f5 0b       	sbc	r31, r21

0000280e <__udivmodsi4_ep>:
    280e:	66 1f       	adc	r22, r22
    2810:	77 1f       	adc	r23, r23
    2812:	88 1f       	adc	r24, r24
    2814:	99 1f       	adc	r25, r25
    2816:	1a 94       	dec	r1
    2818:	69 f7       	brne	.-38     	; 0x27f4 <__udivmodsi4_loop>
    281a:	60 95       	com	r22
    281c:	70 95       	com	r23
    281e:	80 95       	com	r24
    2820:	90 95       	com	r25
    2822:	9b 01       	movw	r18, r22
    2824:	ac 01       	movw	r20, r24
    2826:	bd 01       	movw	r22, r26
    2828:	cf 01       	movw	r24, r30
    282a:	08 95       	ret

0000282c <__tablejump2__>:
    282c:	ee 0f       	add	r30, r30
    282e:	ff 1f       	adc	r31, r31
    2830:	88 1f       	adc	r24, r24
    2832:	8b bf       	out	0x3b, r24	; 59
    2834:	07 90       	elpm	r0, Z+
    2836:	f6 91       	elpm	r31, Z
    2838:	e0 2d       	mov	r30, r0
    283a:	19 94       	eijmp

0000283c <memset>:
    283c:	dc 01       	movw	r26, r24
    283e:	01 c0       	rjmp	.+2      	; 0x2842 <memset+0x6>
    2840:	6d 93       	st	X+, r22
    2842:	41 50       	subi	r20, 0x01	; 1
    2844:	50 40       	sbci	r21, 0x00	; 0
    2846:	e0 f7       	brcc	.-8      	; 0x2840 <memset+0x4>
    2848:	08 95       	ret

0000284a <fwrite>:
    284a:	8f 92       	push	r8
    284c:	9f 92       	push	r9
    284e:	af 92       	push	r10
    2850:	bf 92       	push	r11
    2852:	cf 92       	push	r12
    2854:	df 92       	push	r13
    2856:	ef 92       	push	r14
    2858:	ff 92       	push	r15
    285a:	0f 93       	push	r16
    285c:	1f 93       	push	r17
    285e:	cf 93       	push	r28
    2860:	df 93       	push	r29
    2862:	5b 01       	movw	r10, r22
    2864:	4a 01       	movw	r8, r20
    2866:	79 01       	movw	r14, r18
    2868:	d9 01       	movw	r26, r18
    286a:	13 96       	adiw	r26, 0x03	; 3
    286c:	2c 91       	ld	r18, X
    286e:	21 ff       	sbrs	r18, 1
    2870:	1d c0       	rjmp	.+58     	; 0x28ac <fwrite+0x62>
    2872:	c0 e0       	ldi	r28, 0x00	; 0
    2874:	d0 e0       	ldi	r29, 0x00	; 0
    2876:	c8 15       	cp	r28, r8
    2878:	d9 05       	cpc	r29, r9
    287a:	d9 f0       	breq	.+54     	; 0x28b2 <fwrite+0x68>
    287c:	8c 01       	movw	r16, r24
    287e:	6c 01       	movw	r12, r24
    2880:	ca 0c       	add	r12, r10
    2882:	db 1c       	adc	r13, r11
    2884:	c8 01       	movw	r24, r16
    2886:	0c 15       	cp	r16, r12
    2888:	1d 05       	cpc	r17, r13
    288a:	71 f0       	breq	.+28     	; 0x28a8 <fwrite+0x5e>
    288c:	0f 5f       	subi	r16, 0xFF	; 255
    288e:	1f 4f       	sbci	r17, 0xFF	; 255
    2890:	d7 01       	movw	r26, r14
    2892:	18 96       	adiw	r26, 0x08	; 8
    2894:	ed 91       	ld	r30, X+
    2896:	fc 91       	ld	r31, X
    2898:	19 97       	sbiw	r26, 0x09	; 9
    289a:	b7 01       	movw	r22, r14
    289c:	dc 01       	movw	r26, r24
    289e:	8c 91       	ld	r24, X
    28a0:	19 95       	eicall
    28a2:	89 2b       	or	r24, r25
    28a4:	79 f3       	breq	.-34     	; 0x2884 <fwrite+0x3a>
    28a6:	05 c0       	rjmp	.+10     	; 0x28b2 <fwrite+0x68>
    28a8:	21 96       	adiw	r28, 0x01	; 1
    28aa:	e5 cf       	rjmp	.-54     	; 0x2876 <fwrite+0x2c>
    28ac:	80 e0       	ldi	r24, 0x00	; 0
    28ae:	90 e0       	ldi	r25, 0x00	; 0
    28b0:	01 c0       	rjmp	.+2      	; 0x28b4 <fwrite+0x6a>
    28b2:	ce 01       	movw	r24, r28
    28b4:	df 91       	pop	r29
    28b6:	cf 91       	pop	r28
    28b8:	1f 91       	pop	r17
    28ba:	0f 91       	pop	r16
    28bc:	ff 90       	pop	r15
    28be:	ef 90       	pop	r14
    28c0:	df 90       	pop	r13
    28c2:	cf 90       	pop	r12
    28c4:	bf 90       	pop	r11
    28c6:	af 90       	pop	r10
    28c8:	9f 90       	pop	r9
    28ca:	8f 90       	pop	r8
    28cc:	08 95       	ret

000028ce <_exit>:
    28ce:	f8 94       	cli

000028d0 <__stop_program>:
    28d0:	ff cf       	rjmp	.-2      	; 0x28d0 <__stop_program>
