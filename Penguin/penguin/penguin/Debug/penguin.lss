
penguin.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000271e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002cc  00802000  0000271e  000027b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00007566  008022cc  008022cc  00002a7e  2**0
                  ALLOC
  3 .comment      00000041  00000000  00000000  00002a7e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002ac0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000008c8  00000000  00000000  00002b00  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000f20c  00000000  00000000  000033c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002aec  00000000  00000000  000125d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000650f  00000000  00000000  000150c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000018e0  00000000  00000000  0001b5d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000059a9  00000000  00000000  0001ceb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000079ec  00000000  00000000  00022859  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000b18  00000000  00000000  0002a245  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 68 01 	jmp	0x2d0	; 0x2d0 <__ctors_end>
       4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
       8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
       c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      10:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      14:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      18:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      1c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      20:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      24:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      28:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      2c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      30:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      34:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      38:	0c 94 2d 03 	jmp	0x65a	; 0x65a <__vector_14>
      3c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      40:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      44:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      48:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      4c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      50:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      54:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      58:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      5c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      60:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      64:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__vector_25>
      68:	0c 94 76 12 	jmp	0x24ec	; 0x24ec <__vector_26>
      6c:	0c 94 6c 12 	jmp	0x24d8	; 0x24d8 <__vector_27>
      70:	0c 94 80 12 	jmp	0x2500	; 0x2500 <__vector_28>
      74:	0c 94 94 12 	jmp	0x2528	; 0x2528 <__vector_29>
      78:	0c 94 8a 12 	jmp	0x2514	; 0x2514 <__vector_30>
      7c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      80:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      84:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      88:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      8c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      90:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      94:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      98:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      9c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      a8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      ac:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      b8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      bc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      c8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      cc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      d8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      dc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      e8:	0c 94 bc 12 	jmp	0x2578	; 0x2578 <__vector_58>
      ec:	0c 94 d0 12 	jmp	0x25a0	; 0x25a0 <__vector_59>
      f0:	0c 94 c6 12 	jmp	0x258c	; 0x258c <__vector_60>
      f4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      f8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
      fc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     100:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     104:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     108:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     10c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     110:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     114:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     118:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     11c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     120:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     124:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     128:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     12c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     130:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     134:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     138:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     13c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     140:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     144:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     148:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     14c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     150:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     154:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     158:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     15c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     160:	0c 94 9e 12 	jmp	0x253c	; 0x253c <__vector_88>
     164:	0c 94 b2 12 	jmp	0x2564	; 0x2564 <__vector_89>
     168:	0c 94 a8 12 	jmp	0x2550	; 0x2550 <__vector_90>
     16c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     170:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     174:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     178:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     17c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     180:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     184:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     188:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     18c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     190:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     194:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     198:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     19c:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1a8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1ac:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1b8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1bc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1c8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1cc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1d8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1dc:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e4:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1e8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1ec:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1f0:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1f4:	0c 94 e5 0e 	jmp	0x1dca	; 0x1dca <__vector_125>
     1f8:	0c 94 89 01 	jmp	0x312	; 0x312 <__bad_interrupt>
     1fc:	bd 09       	sbc	r27, r13
     1fe:	e8 09       	sbc	r30, r8
     200:	bf 0a       	sbc	r11, r31
     202:	e8 09       	sbc	r30, r8
     204:	bf 0a       	sbc	r11, r31
     206:	23 0a       	sbc	r2, r19
     208:	3a 0a       	sbc	r3, r26
     20a:	bf 0a       	sbc	r11, r31
     20c:	91 0a       	sbc	r9, r17
     20e:	9e 0a       	sbc	r9, r30

00000210 <__trampolines_start>:
     210:	0c 94 bd 09 	jmp	0x137a	; 0x137a <USB_Device_ProcessControlRequest+0x66>
     214:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <USBThread>
     218:	0c 94 c0 08 	jmp	0x1180	; 0x1180 <CDC_Device_getchar>
     21c:	0c 94 e8 09 	jmp	0x13d0	; 0x13d0 <USB_Device_ProcessControlRequest+0xbc>
     220:	0c 94 91 0a 	jmp	0x1522	; 0x1522 <USB_Device_ProcessControlRequest+0x20e>
     224:	0c 94 68 0f 	jmp	0x1ed0	; 0x1ed0 <thread_2>
     228:	0c 94 d7 07 	jmp	0xfae	; 0xfae <CDC_Device_putchar>
     22c:	0c 94 e6 06 	jmp	0xdcc	; 0xdcc <prvIdleTask>
     230:	0c 94 9e 0a 	jmp	0x153c	; 0x153c <USB_Device_ProcessControlRequest+0x228>
     234:	0c 94 bf 0a 	jmp	0x157e	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
     238:	0c 94 3a 0a 	jmp	0x1474	; 0x1474 <USB_Device_ProcessControlRequest+0x160>
     23c:	0c 94 23 0a 	jmp	0x1446	; 0x1446 <USB_Device_ProcessControlRequest+0x132>
     240:	0c 94 71 0f 	jmp	0x1ee2	; 0x1ee2 <thread_1>

00000244 <ProductString>:
     244:	1c 03 4c 00 55 00 46 00 41 00 20 00 43 00 44 00     ..L.U.F.A. .C.D.
     254:	43 00 20 00 44 00 65 00 6d 00 6f 00 00 00           C. .D.e.m.o...

00000262 <ManufacturerString>:
     262:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
     272:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

0000027c <LanguageString>:
     27c:	04 03 09 04                                         ....

00000280 <ConfigurationDescriptor>:
     280:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
     290:	01 00 05 24 00 10 01 04 24 02 06 05 24 06 00 01     ...$....$...$...
     2a0:	07 05 82 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     2b0:	07 05 04 02 10 00 05 07 05 83 02 10 00 05           ..............

000002be <DeviceDescriptor>:
     2be:	12 01 10 01 02 00 00 08 eb 03 44 20 01 00 01 02     ..........D ....
     2ce:	dc 01                                               ..

000002d0 <__ctors_end>:
     2d0:	11 24       	eor	r1, r1
     2d2:	1f be       	out	0x3f, r1	; 63
     2d4:	cf ef       	ldi	r28, 0xFF	; 255
     2d6:	cd bf       	out	0x3d, r28	; 61
     2d8:	df e9       	ldi	r29, 0x9F	; 159
     2da:	de bf       	out	0x3e, r29	; 62
     2dc:	00 e0       	ldi	r16, 0x00	; 0
     2de:	0c bf       	out	0x3c, r16	; 60

000002e0 <__do_copy_data>:
     2e0:	12 e2       	ldi	r17, 0x22	; 34
     2e2:	a0 e0       	ldi	r26, 0x00	; 0
     2e4:	b0 e2       	ldi	r27, 0x20	; 32
     2e6:	ee e1       	ldi	r30, 0x1E	; 30
     2e8:	f7 e2       	ldi	r31, 0x27	; 39
     2ea:	00 e0       	ldi	r16, 0x00	; 0
     2ec:	0b bf       	out	0x3b, r16	; 59
     2ee:	02 c0       	rjmp	.+4      	; 0x2f4 <__do_copy_data+0x14>
     2f0:	07 90       	elpm	r0, Z+
     2f2:	0d 92       	st	X+, r0
     2f4:	ac 3c       	cpi	r26, 0xCC	; 204
     2f6:	b1 07       	cpc	r27, r17
     2f8:	d9 f7       	brne	.-10     	; 0x2f0 <__do_copy_data+0x10>

000002fa <__do_clear_bss>:
     2fa:	28 e9       	ldi	r18, 0x98	; 152
     2fc:	ac ec       	ldi	r26, 0xCC	; 204
     2fe:	b2 e2       	ldi	r27, 0x22	; 34
     300:	01 c0       	rjmp	.+2      	; 0x304 <.do_clear_bss_start>

00000302 <.do_clear_bss_loop>:
     302:	1d 92       	st	X+, r1

00000304 <.do_clear_bss_start>:
     304:	a2 33       	cpi	r26, 0x32	; 50
     306:	b2 07       	cpc	r27, r18
     308:	e1 f7       	brne	.-8      	; 0x302 <.do_clear_bss_loop>
     30a:	0e 94 78 11 	call	0x22f0	; 0x22f0 <main>
     30e:	0c 94 8d 13 	jmp	0x271a	; 0x271a <_exit>

00000312 <__bad_interrupt>:
     312:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000316 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
     316:	29 2f       	mov	r18, r25
     318:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     31a:	22 30       	cpi	r18, 0x02	; 2
     31c:	31 05       	cpc	r19, r1
     31e:	59 f0       	breq	.+22     	; 0x336 <CALLBACK_USB_GetDescriptor+0x20>
     320:	23 30       	cpi	r18, 0x03	; 3
     322:	31 05       	cpc	r19, r1
     324:	69 f0       	breq	.+26     	; 0x340 <CALLBACK_USB_GetDescriptor+0x2a>
     326:	21 30       	cpi	r18, 0x01	; 1
     328:	31 05       	cpc	r19, r1
     32a:	29 f5       	brne	.+74     	; 0x376 <CALLBACK_USB_GetDescriptor+0x60>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     32c:	82 e1       	ldi	r24, 0x12	; 18
     32e:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     330:	2e eb       	ldi	r18, 0xBE	; 190
     332:	32 e0       	ldi	r19, 0x02	; 2
     334:	29 c0       	rjmp	.+82     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     336:	8e e3       	ldi	r24, 0x3E	; 62
     338:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     33a:	20 e8       	ldi	r18, 0x80	; 128
     33c:	32 e0       	ldi	r19, 0x02	; 2
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     33e:	24 c0       	rjmp	.+72     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
     340:	99 27       	eor	r25, r25
		case DTYPE_String:
			switch (DescriptorNumber)
     342:	81 30       	cpi	r24, 0x01	; 1
     344:	91 05       	cpc	r25, r1
     346:	59 f0       	breq	.+22     	; 0x35e <CALLBACK_USB_GetDescriptor+0x48>
     348:	82 30       	cpi	r24, 0x02	; 2
     34a:	91 05       	cpc	r25, r1
     34c:	71 f0       	breq	.+28     	; 0x36a <CALLBACK_USB_GetDescriptor+0x54>
     34e:	89 2b       	or	r24, r25
     350:	b9 f4       	brne	.+46     	; 0x380 <CALLBACK_USB_GetDescriptor+0x6a>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     352:	ec e7       	ldi	r30, 0x7C	; 124
     354:	f2 e0       	ldi	r31, 0x02	; 2
     356:	84 91       	lpm	r24, Z
     358:	90 e0       	ldi	r25, 0x00	; 0
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case STRING_ID_Language:
					Address = &LanguageString;
     35a:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
     35c:	15 c0       	rjmp	.+42     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     35e:	e2 e6       	ldi	r30, 0x62	; 98
     360:	f2 e0       	ldi	r31, 0x02	; 2
     362:	84 91       	lpm	r24, Z
     364:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
     366:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
     368:	0f c0       	rjmp	.+30     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     36a:	e4 e4       	ldi	r30, 0x44	; 68
     36c:	f2 e0       	ldi	r31, 0x02	; 2
     36e:	84 91       	lpm	r24, Z
     370:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
     372:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
     374:	09 c0       	rjmp	.+18     	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     37a:	20 e0       	ldi	r18, 0x00	; 0
     37c:	30 e0       	ldi	r19, 0x00	; 0
     37e:	04 c0       	rjmp	.+8      	; 0x388 <CALLBACK_USB_GetDescriptor+0x72>
	uint16_t    Size    = NO_DESCRIPTOR;
     380:	80 e0       	ldi	r24, 0x00	; 0
     382:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     388:	fa 01       	movw	r30, r20
     38a:	20 83       	st	Z, r18
     38c:	31 83       	std	Z+1, r19	; 0x01
	return Size;
}
     38e:	08 95       	ret

00000390 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     390:	31 e1       	ldi	r19, 0x11	; 17
     392:	fc 01       	movw	r30, r24
     394:	30 83       	st	Z, r19
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	22 e2       	ldi	r18, 0x22	; 34
     39a:	20 83       	st	Z, r18
     39c:	31 97       	sbiw	r30, 0x01	; 1
     39e:	a3 e3       	ldi	r26, 0x33	; 51
     3a0:	a0 83       	st	Z, r26
     3a2:	31 97       	sbiw	r30, 0x01	; 1
     3a4:	60 83       	st	Z, r22
     3a6:	31 97       	sbiw	r30, 0x01	; 1
     3a8:	70 83       	st	Z, r23
     3aa:	31 97       	sbiw	r30, 0x01	; 1
     3ac:	10 82       	st	Z, r1
     3ae:	31 97       	sbiw	r30, 0x01	; 1
     3b0:	10 82       	st	Z, r1
     3b2:	31 97       	sbiw	r30, 0x01	; 1
     3b4:	60 e8       	ldi	r22, 0x80	; 128
     3b6:	60 83       	st	Z, r22
     3b8:	31 97       	sbiw	r30, 0x01	; 1
     3ba:	10 82       	st	Z, r1
     3bc:	31 97       	sbiw	r30, 0x01	; 1
     3be:	62 e0       	ldi	r22, 0x02	; 2
     3c0:	60 83       	st	Z, r22
     3c2:	31 97       	sbiw	r30, 0x01	; 1
     3c4:	63 e0       	ldi	r22, 0x03	; 3
     3c6:	60 83       	st	Z, r22
     3c8:	31 97       	sbiw	r30, 0x01	; 1
     3ca:	64 e0       	ldi	r22, 0x04	; 4
     3cc:	60 83       	st	Z, r22
     3ce:	31 97       	sbiw	r30, 0x01	; 1
     3d0:	65 e0       	ldi	r22, 0x05	; 5
     3d2:	60 83       	st	Z, r22
     3d4:	31 97       	sbiw	r30, 0x01	; 1
     3d6:	66 e0       	ldi	r22, 0x06	; 6
     3d8:	60 83       	st	Z, r22
     3da:	31 97       	sbiw	r30, 0x01	; 1
     3dc:	67 e0       	ldi	r22, 0x07	; 7
     3de:	60 83       	st	Z, r22
     3e0:	31 97       	sbiw	r30, 0x01	; 1
     3e2:	68 e0       	ldi	r22, 0x08	; 8
     3e4:	60 83       	st	Z, r22
     3e6:	31 97       	sbiw	r30, 0x01	; 1
     3e8:	69 e0       	ldi	r22, 0x09	; 9
     3ea:	60 83       	st	Z, r22
     3ec:	31 97       	sbiw	r30, 0x01	; 1
     3ee:	60 e1       	ldi	r22, 0x10	; 16
     3f0:	60 83       	st	Z, r22
     3f2:	31 97       	sbiw	r30, 0x01	; 1
     3f4:	30 83       	st	Z, r19
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	32 e1       	ldi	r19, 0x12	; 18
     3fa:	30 83       	st	Z, r19
     3fc:	31 97       	sbiw	r30, 0x01	; 1
     3fe:	33 e1       	ldi	r19, 0x13	; 19
     400:	30 83       	st	Z, r19
     402:	31 97       	sbiw	r30, 0x01	; 1
     404:	34 e1       	ldi	r19, 0x14	; 20
     406:	30 83       	st	Z, r19
     408:	31 97       	sbiw	r30, 0x01	; 1
     40a:	35 e1       	ldi	r19, 0x15	; 21
     40c:	30 83       	st	Z, r19
     40e:	31 97       	sbiw	r30, 0x01	; 1
     410:	36 e1       	ldi	r19, 0x16	; 22
     412:	30 83       	st	Z, r19
     414:	31 97       	sbiw	r30, 0x01	; 1
     416:	37 e1       	ldi	r19, 0x17	; 23
     418:	30 83       	st	Z, r19
     41a:	31 97       	sbiw	r30, 0x01	; 1
     41c:	38 e1       	ldi	r19, 0x18	; 24
     41e:	30 83       	st	Z, r19
     420:	31 97       	sbiw	r30, 0x01	; 1
     422:	39 e1       	ldi	r19, 0x19	; 25
     424:	30 83       	st	Z, r19
     426:	31 97       	sbiw	r30, 0x01	; 1
     428:	30 e2       	ldi	r19, 0x20	; 32
     42a:	30 83       	st	Z, r19
     42c:	31 97       	sbiw	r30, 0x01	; 1
     42e:	31 e2       	ldi	r19, 0x21	; 33
     430:	30 83       	st	Z, r19
     432:	31 97       	sbiw	r30, 0x01	; 1
     434:	20 83       	st	Z, r18
     436:	31 97       	sbiw	r30, 0x01	; 1
     438:	23 e2       	ldi	r18, 0x23	; 35
     43a:	20 83       	st	Z, r18
     43c:	31 97       	sbiw	r30, 0x01	; 1
     43e:	40 83       	st	Z, r20
     440:	31 97       	sbiw	r30, 0x01	; 1
     442:	50 83       	st	Z, r21
     444:	31 97       	sbiw	r30, 0x01	; 1
     446:	26 e2       	ldi	r18, 0x26	; 38
     448:	20 83       	st	Z, r18
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	27 e2       	ldi	r18, 0x27	; 39
     44e:	20 83       	st	Z, r18
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	28 e2       	ldi	r18, 0x28	; 40
     454:	20 83       	st	Z, r18
     456:	31 97       	sbiw	r30, 0x01	; 1
     458:	29 e2       	ldi	r18, 0x29	; 41
     45a:	20 83       	st	Z, r18
     45c:	31 97       	sbiw	r30, 0x01	; 1
     45e:	20 e3       	ldi	r18, 0x30	; 48
     460:	20 83       	st	Z, r18
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	21 e3       	ldi	r18, 0x31	; 49
     466:	20 83       	st	Z, r18
     468:	87 97       	sbiw	r24, 0x27	; 39
     46a:	08 95       	ret

0000046c <xPortStartScheduler>:
     46c:	65 e0       	ldi	r22, 0x05	; 5
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	98 e0       	ldi	r25, 0x08	; 8
     472:	0e 94 0e 13 	call	0x261c	; 0x261c <TC0_ConfigClockSource>
     476:	83 ef       	ldi	r24, 0xF3	; 243
     478:	91 e0       	ldi	r25, 0x01	; 1
     47a:	80 93 26 08 	sts	0x0826, r24
     47e:	90 93 27 08 	sts	0x0827, r25
     482:	61 e0       	ldi	r22, 0x01	; 1
     484:	80 e0       	ldi	r24, 0x00	; 0
     486:	98 e0       	ldi	r25, 0x08	; 8
     488:	0e 94 14 13 	call	0x2628	; 0x2628 <TC0_SetOverflowIntLevel>
     48c:	e0 ea       	ldi	r30, 0xA0	; 160
     48e:	f0 e0       	ldi	r31, 0x00	; 0
     490:	82 81       	ldd	r24, Z+2	; 0x02
     492:	81 60       	ori	r24, 0x01	; 1
     494:	82 83       	std	Z+2, r24	; 0x02
     496:	a0 91 27 93 	lds	r26, 0x9327
     49a:	b0 91 28 93 	lds	r27, 0x9328
     49e:	cd 91       	ld	r28, X+
     4a0:	cd bf       	out	0x3d, r28	; 61
     4a2:	dd 91       	ld	r29, X+
     4a4:	de bf       	out	0x3e, r29	; 62
     4a6:	ff 91       	pop	r31
     4a8:	ef 91       	pop	r30
     4aa:	df 91       	pop	r29
     4ac:	cf 91       	pop	r28
     4ae:	bf 91       	pop	r27
     4b0:	af 91       	pop	r26
     4b2:	9f 91       	pop	r25
     4b4:	8f 91       	pop	r24
     4b6:	7f 91       	pop	r23
     4b8:	6f 91       	pop	r22
     4ba:	5f 91       	pop	r21
     4bc:	4f 91       	pop	r20
     4be:	3f 91       	pop	r19
     4c0:	2f 91       	pop	r18
     4c2:	1f 91       	pop	r17
     4c4:	0f 91       	pop	r16
     4c6:	ff 90       	pop	r15
     4c8:	ef 90       	pop	r14
     4ca:	df 90       	pop	r13
     4cc:	cf 90       	pop	r12
     4ce:	bf 90       	pop	r11
     4d0:	af 90       	pop	r10
     4d2:	9f 90       	pop	r9
     4d4:	8f 90       	pop	r8
     4d6:	7f 90       	pop	r7
     4d8:	6f 90       	pop	r6
     4da:	5f 90       	pop	r5
     4dc:	4f 90       	pop	r4
     4de:	3f 90       	pop	r3
     4e0:	2f 90       	pop	r2
     4e2:	1f 90       	pop	r1
     4e4:	0f 90       	pop	r0
     4e6:	0f be       	out	0x3f, r0	; 63
     4e8:	0f 90       	pop	r0
     4ea:	08 95       	ret
     4ec:	81 e0       	ldi	r24, 0x01	; 1
     4ee:	08 95       	ret

000004f0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     4f0:	0f 92       	push	r0
     4f2:	0f b6       	in	r0, 0x3f	; 63
     4f4:	f8 94       	cli
     4f6:	0f 92       	push	r0
     4f8:	1f 92       	push	r1
     4fa:	11 24       	eor	r1, r1
     4fc:	2f 92       	push	r2
     4fe:	3f 92       	push	r3
     500:	4f 92       	push	r4
     502:	5f 92       	push	r5
     504:	6f 92       	push	r6
     506:	7f 92       	push	r7
     508:	8f 92       	push	r8
     50a:	9f 92       	push	r9
     50c:	af 92       	push	r10
     50e:	bf 92       	push	r11
     510:	cf 92       	push	r12
     512:	df 92       	push	r13
     514:	ef 92       	push	r14
     516:	ff 92       	push	r15
     518:	0f 93       	push	r16
     51a:	1f 93       	push	r17
     51c:	2f 93       	push	r18
     51e:	3f 93       	push	r19
     520:	4f 93       	push	r20
     522:	5f 93       	push	r21
     524:	6f 93       	push	r22
     526:	7f 93       	push	r23
     528:	8f 93       	push	r24
     52a:	9f 93       	push	r25
     52c:	af 93       	push	r26
     52e:	bf 93       	push	r27
     530:	cf 93       	push	r28
     532:	df 93       	push	r29
     534:	ef 93       	push	r30
     536:	ff 93       	push	r31
     538:	a0 91 27 93 	lds	r26, 0x9327
     53c:	b0 91 28 93 	lds	r27, 0x9328
     540:	0d b6       	in	r0, 0x3d	; 61
     542:	0d 92       	st	X+, r0
     544:	0e b6       	in	r0, 0x3e	; 62
     546:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     548:	0e 94 17 07 	call	0xe2e	; 0xe2e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     54c:	a0 91 27 93 	lds	r26, 0x9327
     550:	b0 91 28 93 	lds	r27, 0x9328
     554:	cd 91       	ld	r28, X+
     556:	cd bf       	out	0x3d, r28	; 61
     558:	dd 91       	ld	r29, X+
     55a:	de bf       	out	0x3e, r29	; 62
     55c:	ff 91       	pop	r31
     55e:	ef 91       	pop	r30
     560:	df 91       	pop	r29
     562:	cf 91       	pop	r28
     564:	bf 91       	pop	r27
     566:	af 91       	pop	r26
     568:	9f 91       	pop	r25
     56a:	8f 91       	pop	r24
     56c:	7f 91       	pop	r23
     56e:	6f 91       	pop	r22
     570:	5f 91       	pop	r21
     572:	4f 91       	pop	r20
     574:	3f 91       	pop	r19
     576:	2f 91       	pop	r18
     578:	1f 91       	pop	r17
     57a:	0f 91       	pop	r16
     57c:	ff 90       	pop	r15
     57e:	ef 90       	pop	r14
     580:	df 90       	pop	r13
     582:	cf 90       	pop	r12
     584:	bf 90       	pop	r11
     586:	af 90       	pop	r10
     588:	9f 90       	pop	r9
     58a:	8f 90       	pop	r8
     58c:	7f 90       	pop	r7
     58e:	6f 90       	pop	r6
     590:	5f 90       	pop	r5
     592:	4f 90       	pop	r4
     594:	3f 90       	pop	r3
     596:	2f 90       	pop	r2
     598:	1f 90       	pop	r1
     59a:	0f 90       	pop	r0
     59c:	0f be       	out	0x3f, r0	; 63
     59e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5a0:	08 95       	ret

000005a2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5a2:	0f 92       	push	r0
     5a4:	0f b6       	in	r0, 0x3f	; 63
     5a6:	f8 94       	cli
     5a8:	0f 92       	push	r0
     5aa:	1f 92       	push	r1
     5ac:	11 24       	eor	r1, r1
     5ae:	2f 92       	push	r2
     5b0:	3f 92       	push	r3
     5b2:	4f 92       	push	r4
     5b4:	5f 92       	push	r5
     5b6:	6f 92       	push	r6
     5b8:	7f 92       	push	r7
     5ba:	8f 92       	push	r8
     5bc:	9f 92       	push	r9
     5be:	af 92       	push	r10
     5c0:	bf 92       	push	r11
     5c2:	cf 92       	push	r12
     5c4:	df 92       	push	r13
     5c6:	ef 92       	push	r14
     5c8:	ff 92       	push	r15
     5ca:	0f 93       	push	r16
     5cc:	1f 93       	push	r17
     5ce:	2f 93       	push	r18
     5d0:	3f 93       	push	r19
     5d2:	4f 93       	push	r20
     5d4:	5f 93       	push	r21
     5d6:	6f 93       	push	r22
     5d8:	7f 93       	push	r23
     5da:	8f 93       	push	r24
     5dc:	9f 93       	push	r25
     5de:	af 93       	push	r26
     5e0:	bf 93       	push	r27
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	ef 93       	push	r30
     5e8:	ff 93       	push	r31
     5ea:	a0 91 27 93 	lds	r26, 0x9327
     5ee:	b0 91 28 93 	lds	r27, 0x9328
     5f2:	0d b6       	in	r0, 0x3d	; 61
     5f4:	0d 92       	st	X+, r0
     5f6:	0e b6       	in	r0, 0x3e	; 62
     5f8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     5fa:	0e 94 8a 05 	call	0xb14	; 0xb14 <xTaskIncrementTick>
     5fe:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     600:	0e 94 17 07 	call	0xe2e	; 0xe2e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     604:	a0 91 27 93 	lds	r26, 0x9327
     608:	b0 91 28 93 	lds	r27, 0x9328
     60c:	cd 91       	ld	r28, X+
     60e:	cd bf       	out	0x3d, r28	; 61
     610:	dd 91       	ld	r29, X+
     612:	de bf       	out	0x3e, r29	; 62
     614:	ff 91       	pop	r31
     616:	ef 91       	pop	r30
     618:	df 91       	pop	r29
     61a:	cf 91       	pop	r28
     61c:	bf 91       	pop	r27
     61e:	af 91       	pop	r26
     620:	9f 91       	pop	r25
     622:	8f 91       	pop	r24
     624:	7f 91       	pop	r23
     626:	6f 91       	pop	r22
     628:	5f 91       	pop	r21
     62a:	4f 91       	pop	r20
     62c:	3f 91       	pop	r19
     62e:	2f 91       	pop	r18
     630:	1f 91       	pop	r17
     632:	0f 91       	pop	r16
     634:	ff 90       	pop	r15
     636:	ef 90       	pop	r14
     638:	df 90       	pop	r13
     63a:	cf 90       	pop	r12
     63c:	bf 90       	pop	r11
     63e:	af 90       	pop	r10
     640:	9f 90       	pop	r9
     642:	8f 90       	pop	r8
     644:	7f 90       	pop	r7
     646:	6f 90       	pop	r6
     648:	5f 90       	pop	r5
     64a:	4f 90       	pop	r4
     64c:	3f 90       	pop	r3
     64e:	2f 90       	pop	r2
     650:	1f 90       	pop	r1
     652:	0f 90       	pop	r0
     654:	0f be       	out	0x3f, r0	; 63
     656:	0f 90       	pop	r0

	asm volatile ( "ret" );
     658:	08 95       	ret

0000065a <__vector_14>:
	 */
	
	void TCC0_OVF_vect( void ) __attribute__ ( ( signal, naked ) );
	void TCC0_OVF_vect( void )
	{
		vPortYieldFromTick();
     65a:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     65e:	18 95       	reti

00000660 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     660:	cf 93       	push	r28
     662:	df 93       	push	r29
     664:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     666:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     66a:	80 91 cc 22 	lds	r24, 0x22CC
     66e:	90 91 cd 22 	lds	r25, 0x22CD
     672:	89 2b       	or	r24, r25
     674:	31 f4       	brne	.+12     	; 0x682 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     676:	81 ed       	ldi	r24, 0xD1	; 209
     678:	92 e2       	ldi	r25, 0x22	; 34
     67a:	80 93 cc 22 	sts	0x22CC, r24
     67e:	90 93 cd 22 	sts	0x22CD, r25
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     682:	20 91 ce 22 	lds	r18, 0x22CE
     686:	30 91 cf 22 	lds	r19, 0x22CF
     68a:	ce 01       	movw	r24, r28
     68c:	82 0f       	add	r24, r18
     68e:	93 1f       	adc	r25, r19
     690:	8f 3f       	cpi	r24, 0xFF	; 255
     692:	4f e6       	ldi	r20, 0x6F	; 111
     694:	94 07       	cpc	r25, r20
     696:	70 f4       	brcc	.+28     	; 0x6b4 <pvPortMalloc+0x54>
     698:	28 17       	cp	r18, r24
     69a:	39 07       	cpc	r19, r25
     69c:	70 f4       	brcc	.+28     	; 0x6ba <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     69e:	c0 91 cc 22 	lds	r28, 0x22CC
     6a2:	d0 91 cd 22 	lds	r29, 0x22CD
     6a6:	c2 0f       	add	r28, r18
     6a8:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     6aa:	80 93 ce 22 	sts	0x22CE, r24
     6ae:	90 93 cf 22 	sts	0x22CF, r25
     6b2:	05 c0       	rjmp	.+10     	; 0x6be <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6b4:	c0 e0       	ldi	r28, 0x00	; 0
     6b6:	d0 e0       	ldi	r29, 0x00	; 0
     6b8:	02 c0       	rjmp	.+4      	; 0x6be <pvPortMalloc+0x5e>
     6ba:	c0 e0       	ldi	r28, 0x00	; 0
     6bc:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6be:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6c2:	ce 01       	movw	r24, r28
     6c4:	df 91       	pop	r29
     6c6:	cf 91       	pop	r28
     6c8:	08 95       	ret

000006ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6ca:	08 95       	ret

000006cc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6cc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ce:	03 96       	adiw	r24, 0x03	; 3
     6d0:	81 83       	std	Z+1, r24	; 0x01
     6d2:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6d4:	2f ef       	ldi	r18, 0xFF	; 255
     6d6:	3f ef       	ldi	r19, 0xFF	; 255
     6d8:	23 83       	std	Z+3, r18	; 0x03
     6da:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6dc:	85 83       	std	Z+5, r24	; 0x05
     6de:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6e0:	87 83       	std	Z+7, r24	; 0x07
     6e2:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6e4:	10 82       	st	Z, r1
     6e6:	08 95       	ret

000006e8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6e8:	fc 01       	movw	r30, r24
     6ea:	10 86       	std	Z+8, r1	; 0x08
     6ec:	11 86       	std	Z+9, r1	; 0x09
     6ee:	08 95       	ret

000006f0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	9c 01       	movw	r18, r24
     6f6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6f8:	dc 01       	movw	r26, r24
     6fa:	11 96       	adiw	r26, 0x01	; 1
     6fc:	cd 91       	ld	r28, X+
     6fe:	dc 91       	ld	r29, X
     700:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     702:	c2 83       	std	Z+2, r28	; 0x02
     704:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     706:	8c 81       	ldd	r24, Y+4	; 0x04
     708:	9d 81       	ldd	r25, Y+5	; 0x05
     70a:	84 83       	std	Z+4, r24	; 0x04
     70c:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     70e:	8c 81       	ldd	r24, Y+4	; 0x04
     710:	9d 81       	ldd	r25, Y+5	; 0x05
     712:	dc 01       	movw	r26, r24
     714:	12 96       	adiw	r26, 0x02	; 2
     716:	6d 93       	st	X+, r22
     718:	7c 93       	st	X, r23
     71a:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
     71c:	6c 83       	std	Y+4, r22	; 0x04
     71e:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     720:	20 87       	std	Z+8, r18	; 0x08
     722:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
     724:	f9 01       	movw	r30, r18
     726:	80 81       	ld	r24, Z
     728:	8f 5f       	subi	r24, 0xFF	; 255
     72a:	80 83       	st	Z, r24
}
     72c:	df 91       	pop	r29
     72e:	cf 91       	pop	r28
     730:	08 95       	ret

00000732 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     738:	48 81       	ld	r20, Y
     73a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     73c:	4f 3f       	cpi	r20, 0xFF	; 255
     73e:	2f ef       	ldi	r18, 0xFF	; 255
     740:	52 07       	cpc	r21, r18
     742:	21 f4       	brne	.+8      	; 0x74c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     744:	fc 01       	movw	r30, r24
     746:	a7 81       	ldd	r26, Z+7	; 0x07
     748:	b0 85       	ldd	r27, Z+8	; 0x08
     74a:	0d c0       	rjmp	.+26     	; 0x766 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     74c:	dc 01       	movw	r26, r24
     74e:	13 96       	adiw	r26, 0x03	; 3
     750:	01 c0       	rjmp	.+2      	; 0x754 <vListInsert+0x22>
     752:	df 01       	movw	r26, r30
     754:	12 96       	adiw	r26, 0x02	; 2
     756:	ed 91       	ld	r30, X+
     758:	fc 91       	ld	r31, X
     75a:	13 97       	sbiw	r26, 0x03	; 3
     75c:	20 81       	ld	r18, Z
     75e:	31 81       	ldd	r19, Z+1	; 0x01
     760:	42 17       	cp	r20, r18
     762:	53 07       	cpc	r21, r19
     764:	b0 f7       	brcc	.-20     	; 0x752 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     766:	12 96       	adiw	r26, 0x02	; 2
     768:	ed 91       	ld	r30, X+
     76a:	fc 91       	ld	r31, X
     76c:	13 97       	sbiw	r26, 0x03	; 3
     76e:	ea 83       	std	Y+2, r30	; 0x02
     770:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     772:	c4 83       	std	Z+4, r28	; 0x04
     774:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
     776:	ac 83       	std	Y+4, r26	; 0x04
     778:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
     77a:	12 96       	adiw	r26, 0x02	; 2
     77c:	cd 93       	st	X+, r28
     77e:	dc 93       	st	X, r29
     780:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     782:	88 87       	std	Y+8, r24	; 0x08
     784:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
     786:	fc 01       	movw	r30, r24
     788:	20 81       	ld	r18, Z
     78a:	2f 5f       	subi	r18, 0xFF	; 255
     78c:	20 83       	st	Z, r18
}
     78e:	df 91       	pop	r29
     790:	cf 91       	pop	r28
     792:	08 95       	ret

00000794 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
     798:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     79a:	a0 85       	ldd	r26, Z+8	; 0x08
     79c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     79e:	c2 81       	ldd	r28, Z+2	; 0x02
     7a0:	d3 81       	ldd	r29, Z+3	; 0x03
     7a2:	84 81       	ldd	r24, Z+4	; 0x04
     7a4:	95 81       	ldd	r25, Z+5	; 0x05
     7a6:	8c 83       	std	Y+4, r24	; 0x04
     7a8:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7aa:	c4 81       	ldd	r28, Z+4	; 0x04
     7ac:	d5 81       	ldd	r29, Z+5	; 0x05
     7ae:	82 81       	ldd	r24, Z+2	; 0x02
     7b0:	93 81       	ldd	r25, Z+3	; 0x03
     7b2:	8a 83       	std	Y+2, r24	; 0x02
     7b4:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7b6:	11 96       	adiw	r26, 0x01	; 1
     7b8:	cd 91       	ld	r28, X+
     7ba:	dc 91       	ld	r29, X
     7bc:	12 97       	sbiw	r26, 0x02	; 2
     7be:	ce 17       	cp	r28, r30
     7c0:	df 07       	cpc	r29, r31
     7c2:	31 f4       	brne	.+12     	; 0x7d0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7c4:	8c 81       	ldd	r24, Y+4	; 0x04
     7c6:	9d 81       	ldd	r25, Y+5	; 0x05
     7c8:	11 96       	adiw	r26, 0x01	; 1
     7ca:	8d 93       	st	X+, r24
     7cc:	9c 93       	st	X, r25
     7ce:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7d0:	10 86       	std	Z+8, r1	; 0x08
     7d2:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
     7d4:	8c 91       	ld	r24, X
     7d6:	81 50       	subi	r24, 0x01	; 1
     7d8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7da:	df 91       	pop	r29
     7dc:	cf 91       	pop	r28
     7de:	08 95       	ret

000007e0 <prvResetNextTaskUnblockTime>:
			}
		}
		( void ) xTaskResumeAll();

		return uxTask;
	}
     7e0:	e0 91 ef 92 	lds	r30, 0x92EF
     7e4:	f0 91 f0 92 	lds	r31, 0x92F0
     7e8:	80 81       	ld	r24, Z
     7ea:	81 11       	cpse	r24, r1
     7ec:	07 c0       	rjmp	.+14     	; 0x7fc <prvResetNextTaskUnblockTime+0x1c>
     7ee:	8f ef       	ldi	r24, 0xFF	; 255
     7f0:	9f ef       	ldi	r25, 0xFF	; 255
     7f2:	80 93 89 22 	sts	0x2289, r24
     7f6:	90 93 8a 22 	sts	0x228A, r25
     7fa:	08 95       	ret
     7fc:	e0 91 ef 92 	lds	r30, 0x92EF
     800:	f0 91 f0 92 	lds	r31, 0x92F0
     804:	05 80       	ldd	r0, Z+5	; 0x05
     806:	f6 81       	ldd	r31, Z+6	; 0x06
     808:	e0 2d       	mov	r30, r0
     80a:	06 80       	ldd	r0, Z+6	; 0x06
     80c:	f7 81       	ldd	r31, Z+7	; 0x07
     80e:	e0 2d       	mov	r30, r0
     810:	82 81       	ldd	r24, Z+2	; 0x02
     812:	93 81       	ldd	r25, Z+3	; 0x03
     814:	80 93 89 22 	sts	0x2289, r24
     818:	90 93 8a 22 	sts	0x228A, r25
     81c:	08 95       	ret

0000081e <prvAddCurrentTaskToDelayedList>:
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	ec 01       	movw	r28, r24
     824:	e0 91 27 93 	lds	r30, 0x9327
     828:	f0 91 28 93 	lds	r31, 0x9328
     82c:	82 83       	std	Z+2, r24	; 0x02
     82e:	93 83       	std	Z+3, r25	; 0x03
     830:	80 91 d7 92 	lds	r24, 0x92D7
     834:	90 91 d8 92 	lds	r25, 0x92D8
     838:	c8 17       	cp	r28, r24
     83a:	d9 07       	cpc	r29, r25
     83c:	68 f4       	brcc	.+26     	; 0x858 <prvAddCurrentTaskToDelayedList+0x3a>
     83e:	60 91 27 93 	lds	r22, 0x9327
     842:	70 91 28 93 	lds	r23, 0x9328
     846:	80 91 ed 92 	lds	r24, 0x92ED
     84a:	90 91 ee 92 	lds	r25, 0x92EE
     84e:	6e 5f       	subi	r22, 0xFE	; 254
     850:	7f 4f       	sbci	r23, 0xFF	; 255
     852:	0e 94 99 03 	call	0x732	; 0x732 <vListInsert>
     856:	17 c0       	rjmp	.+46     	; 0x886 <prvAddCurrentTaskToDelayedList+0x68>
     858:	60 91 27 93 	lds	r22, 0x9327
     85c:	70 91 28 93 	lds	r23, 0x9328
     860:	80 91 ef 92 	lds	r24, 0x92EF
     864:	90 91 f0 92 	lds	r25, 0x92F0
     868:	6e 5f       	subi	r22, 0xFE	; 254
     86a:	7f 4f       	sbci	r23, 0xFF	; 255
     86c:	0e 94 99 03 	call	0x732	; 0x732 <vListInsert>
     870:	80 91 89 22 	lds	r24, 0x2289
     874:	90 91 8a 22 	lds	r25, 0x228A
     878:	c8 17       	cp	r28, r24
     87a:	d9 07       	cpc	r29, r25
     87c:	20 f4       	brcc	.+8      	; 0x886 <prvAddCurrentTaskToDelayedList+0x68>
     87e:	c0 93 89 22 	sts	0x2289, r28
     882:	d0 93 8a 22 	sts	0x228A, r29
     886:	df 91       	pop	r29
     888:	cf 91       	pop	r28
     88a:	08 95       	ret

0000088c <xTaskGenericCreate>:
     88c:	4f 92       	push	r4
     88e:	5f 92       	push	r5
     890:	6f 92       	push	r6
     892:	7f 92       	push	r7
     894:	8f 92       	push	r8
     896:	9f 92       	push	r9
     898:	af 92       	push	r10
     89a:	bf 92       	push	r11
     89c:	cf 92       	push	r12
     89e:	df 92       	push	r13
     8a0:	ef 92       	push	r14
     8a2:	ff 92       	push	r15
     8a4:	0f 93       	push	r16
     8a6:	1f 93       	push	r17
     8a8:	cf 93       	push	r28
     8aa:	df 93       	push	r29
     8ac:	4c 01       	movw	r8, r24
     8ae:	eb 01       	movw	r28, r22
     8b0:	5a 01       	movw	r10, r20
     8b2:	29 01       	movw	r4, r18
     8b4:	83 e2       	ldi	r24, 0x23	; 35
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	0e 94 30 03 	call	0x660	; 0x660 <pvPortMalloc>
     8bc:	3c 01       	movw	r6, r24
     8be:	00 97       	sbiw	r24, 0x00	; 0
     8c0:	09 f4       	brne	.+2      	; 0x8c4 <xTaskGenericCreate+0x38>
     8c2:	e5 c0       	rjmp	.+458    	; 0xa8e <xTaskGenericCreate+0x202>
     8c4:	c1 14       	cp	r12, r1
     8c6:	d1 04       	cpc	r13, r1
     8c8:	09 f0       	breq	.+2      	; 0x8cc <xTaskGenericCreate+0x40>
     8ca:	dc c0       	rjmp	.+440    	; 0xa84 <xTaskGenericCreate+0x1f8>
     8cc:	c5 01       	movw	r24, r10
     8ce:	0e 94 30 03 	call	0x660	; 0x660 <pvPortMalloc>
     8d2:	f3 01       	movw	r30, r6
     8d4:	87 8b       	std	Z+23, r24	; 0x17
     8d6:	90 8f       	std	Z+24, r25	; 0x18
     8d8:	00 97       	sbiw	r24, 0x00	; 0
     8da:	21 f4       	brne	.+8      	; 0x8e4 <xTaskGenericCreate+0x58>
     8dc:	c3 01       	movw	r24, r6
     8de:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
     8e2:	d5 c0       	rjmp	.+426    	; 0xa8e <xTaskGenericCreate+0x202>
     8e4:	a5 01       	movw	r20, r10
     8e6:	65 ea       	ldi	r22, 0xA5	; 165
     8e8:	70 e0       	ldi	r23, 0x00	; 0
     8ea:	0e 94 44 13 	call	0x2688	; 0x2688 <memset>
     8ee:	f1 e0       	ldi	r31, 0x01	; 1
     8f0:	af 1a       	sub	r10, r31
     8f2:	b1 08       	sbc	r11, r1
     8f4:	f3 01       	movw	r30, r6
     8f6:	87 89       	ldd	r24, Z+23	; 0x17
     8f8:	90 8d       	ldd	r25, Z+24	; 0x18
     8fa:	a8 0e       	add	r10, r24
     8fc:	b9 1e       	adc	r11, r25
     8fe:	88 81       	ld	r24, Y
     900:	81 8f       	std	Z+25, r24	; 0x19
     902:	88 81       	ld	r24, Y
     904:	88 23       	and	r24, r24
     906:	81 f0       	breq	.+32     	; 0x928 <xTaskGenericCreate+0x9c>
     908:	d3 01       	movw	r26, r6
     90a:	5a 96       	adiw	r26, 0x1a	; 26
     90c:	fe 01       	movw	r30, r28
     90e:	31 96       	adiw	r30, 0x01	; 1
     910:	9e 01       	movw	r18, r28
     912:	28 5f       	subi	r18, 0xF8	; 248
     914:	3f 4f       	sbci	r19, 0xFF	; 255
     916:	ef 01       	movw	r28, r30
     918:	81 91       	ld	r24, Z+
     91a:	8d 93       	st	X+, r24
     91c:	88 81       	ld	r24, Y
     91e:	88 23       	and	r24, r24
     920:	19 f0       	breq	.+6      	; 0x928 <xTaskGenericCreate+0x9c>
     922:	e2 17       	cp	r30, r18
     924:	f3 07       	cpc	r31, r19
     926:	b9 f7       	brne	.-18     	; 0x916 <xTaskGenericCreate+0x8a>
     928:	f3 01       	movw	r30, r6
     92a:	10 a2       	std	Z+32, r1	; 0x20
     92c:	10 2f       	mov	r17, r16
     92e:	04 30       	cpi	r16, 0x04	; 4
     930:	08 f0       	brcs	.+2      	; 0x934 <xTaskGenericCreate+0xa8>
     932:	13 e0       	ldi	r17, 0x03	; 3
     934:	f3 01       	movw	r30, r6
     936:	16 8b       	std	Z+22, r17	; 0x16
     938:	e3 01       	movw	r28, r6
     93a:	22 96       	adiw	r28, 0x02	; 2
     93c:	ce 01       	movw	r24, r28
     93e:	0e 94 74 03 	call	0x6e8	; 0x6e8 <vListInitialiseItem>
     942:	c3 01       	movw	r24, r6
     944:	0c 96       	adiw	r24, 0x0c	; 12
     946:	0e 94 74 03 	call	0x6e8	; 0x6e8 <vListInitialiseItem>
     94a:	f3 01       	movw	r30, r6
     94c:	60 86       	std	Z+8, r6	; 0x08
     94e:	71 86       	std	Z+9, r7	; 0x09
     950:	84 e0       	ldi	r24, 0x04	; 4
     952:	90 e0       	ldi	r25, 0x00	; 0
     954:	81 1b       	sub	r24, r17
     956:	91 09       	sbc	r25, r1
     958:	84 87       	std	Z+12, r24	; 0x0c
     95a:	95 87       	std	Z+13, r25	; 0x0d
     95c:	62 8a       	std	Z+18, r6	; 0x12
     95e:	73 8a       	std	Z+19, r7	; 0x13
     960:	a2 01       	movw	r20, r4
     962:	b4 01       	movw	r22, r8
     964:	c5 01       	movw	r24, r10
     966:	0e 94 c8 01 	call	0x390	; 0x390 <pxPortInitialiseStack>
     96a:	f3 01       	movw	r30, r6
     96c:	80 83       	st	Z, r24
     96e:	91 83       	std	Z+1, r25	; 0x01
     970:	e1 14       	cp	r14, r1
     972:	f1 04       	cpc	r15, r1
     974:	19 f0       	breq	.+6      	; 0x97c <xTaskGenericCreate+0xf0>
     976:	f7 01       	movw	r30, r14
     978:	60 82       	st	Z, r6
     97a:	71 82       	std	Z+1, r7	; 0x01
     97c:	0f b6       	in	r0, 0x3f	; 63
     97e:	f8 94       	cli
     980:	0f 92       	push	r0
     982:	80 91 d9 92 	lds	r24, 0x92D9
     986:	8f 5f       	subi	r24, 0xFF	; 255
     988:	80 93 d9 92 	sts	0x92D9, r24
     98c:	80 91 27 93 	lds	r24, 0x9327
     990:	90 91 28 93 	lds	r25, 0x9328
     994:	89 2b       	or	r24, r25
     996:	a9 f5       	brne	.+106    	; 0xa02 <xTaskGenericCreate+0x176>
     998:	60 92 27 93 	sts	0x9327, r6
     99c:	70 92 28 93 	sts	0x9328, r7
     9a0:	80 91 d9 92 	lds	r24, 0x92D9
     9a4:	81 30       	cpi	r24, 0x01	; 1
     9a6:	e1 f5       	brne	.+120    	; 0xa20 <xTaskGenericCreate+0x194>
     9a8:	83 e0       	ldi	r24, 0x03	; 3
     9aa:	93 e9       	ldi	r25, 0x93	; 147
     9ac:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9b0:	8c e0       	ldi	r24, 0x0C	; 12
     9b2:	93 e9       	ldi	r25, 0x93	; 147
     9b4:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9b8:	85 e1       	ldi	r24, 0x15	; 21
     9ba:	93 e9       	ldi	r25, 0x93	; 147
     9bc:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9c0:	8e e1       	ldi	r24, 0x1E	; 30
     9c2:	93 e9       	ldi	r25, 0x93	; 147
     9c4:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9c8:	8a ef       	ldi	r24, 0xFA	; 250
     9ca:	92 e9       	ldi	r25, 0x92	; 146
     9cc:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9d0:	81 ef       	ldi	r24, 0xF1	; 241
     9d2:	92 e9       	ldi	r25, 0x92	; 146
     9d4:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9d8:	84 ee       	ldi	r24, 0xE4	; 228
     9da:	92 e9       	ldi	r25, 0x92	; 146
     9dc:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9e0:	8b ed       	ldi	r24, 0xDB	; 219
     9e2:	92 e9       	ldi	r25, 0x92	; 146
     9e4:	0e 94 66 03 	call	0x6cc	; 0x6cc <vListInitialise>
     9e8:	8a ef       	ldi	r24, 0xFA	; 250
     9ea:	92 e9       	ldi	r25, 0x92	; 146
     9ec:	80 93 ef 92 	sts	0x92EF, r24
     9f0:	90 93 f0 92 	sts	0x92F0, r25
     9f4:	81 ef       	ldi	r24, 0xF1	; 241
     9f6:	92 e9       	ldi	r25, 0x92	; 146
     9f8:	80 93 ed 92 	sts	0x92ED, r24
     9fc:	90 93 ee 92 	sts	0x92EE, r25
     a00:	0f c0       	rjmp	.+30     	; 0xa20 <xTaskGenericCreate+0x194>
     a02:	80 91 d5 92 	lds	r24, 0x92D5
     a06:	81 11       	cpse	r24, r1
     a08:	0b c0       	rjmp	.+22     	; 0xa20 <xTaskGenericCreate+0x194>
     a0a:	e0 91 27 93 	lds	r30, 0x9327
     a0e:	f0 91 28 93 	lds	r31, 0x9328
     a12:	86 89       	ldd	r24, Z+22	; 0x16
     a14:	08 17       	cp	r16, r24
     a16:	20 f0       	brcs	.+8      	; 0xa20 <xTaskGenericCreate+0x194>
     a18:	60 92 27 93 	sts	0x9327, r6
     a1c:	70 92 28 93 	sts	0x9328, r7
     a20:	80 91 d1 92 	lds	r24, 0x92D1
     a24:	8f 5f       	subi	r24, 0xFF	; 255
     a26:	80 93 d1 92 	sts	0x92D1, r24
     a2a:	f3 01       	movw	r30, r6
     a2c:	81 a3       	std	Z+33, r24	; 0x21
     a2e:	86 89       	ldd	r24, Z+22	; 0x16
     a30:	90 91 d6 92 	lds	r25, 0x92D6
     a34:	98 17       	cp	r25, r24
     a36:	10 f4       	brcc	.+4      	; 0xa3c <xTaskGenericCreate+0x1b0>
     a38:	80 93 d6 92 	sts	0x92D6, r24
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	9c 01       	movw	r18, r24
     a40:	22 0f       	add	r18, r18
     a42:	33 1f       	adc	r19, r19
     a44:	22 0f       	add	r18, r18
     a46:	33 1f       	adc	r19, r19
     a48:	22 0f       	add	r18, r18
     a4a:	33 1f       	adc	r19, r19
     a4c:	82 0f       	add	r24, r18
     a4e:	93 1f       	adc	r25, r19
     a50:	be 01       	movw	r22, r28
     a52:	8d 5f       	subi	r24, 0xFD	; 253
     a54:	9c 46       	sbci	r25, 0x6C	; 108
     a56:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vListInsertEnd>
     a5a:	0f 90       	pop	r0
     a5c:	0f be       	out	0x3f, r0	; 63
     a5e:	80 91 d5 92 	lds	r24, 0x92D5
     a62:	88 23       	and	r24, r24
     a64:	59 f0       	breq	.+22     	; 0xa7c <xTaskGenericCreate+0x1f0>
     a66:	e0 91 27 93 	lds	r30, 0x9327
     a6a:	f0 91 28 93 	lds	r31, 0x9328
     a6e:	86 89       	ldd	r24, Z+22	; 0x16
     a70:	80 17       	cp	r24, r16
     a72:	30 f4       	brcc	.+12     	; 0xa80 <xTaskGenericCreate+0x1f4>
     a74:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYield>
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	0a c0       	rjmp	.+20     	; 0xa90 <xTaskGenericCreate+0x204>
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	08 c0       	rjmp	.+16     	; 0xa90 <xTaskGenericCreate+0x204>
     a80:	81 e0       	ldi	r24, 0x01	; 1
     a82:	06 c0       	rjmp	.+12     	; 0xa90 <xTaskGenericCreate+0x204>
     a84:	fc 01       	movw	r30, r24
     a86:	c7 8a       	std	Z+23, r12	; 0x17
     a88:	d0 8e       	std	Z+24, r13	; 0x18
     a8a:	c6 01       	movw	r24, r12
     a8c:	2b cf       	rjmp	.-426    	; 0x8e4 <xTaskGenericCreate+0x58>
     a8e:	8f ef       	ldi	r24, 0xFF	; 255
     a90:	df 91       	pop	r29
     a92:	cf 91       	pop	r28
     a94:	1f 91       	pop	r17
     a96:	0f 91       	pop	r16
     a98:	ff 90       	pop	r15
     a9a:	ef 90       	pop	r14
     a9c:	df 90       	pop	r13
     a9e:	cf 90       	pop	r12
     aa0:	bf 90       	pop	r11
     aa2:	af 90       	pop	r10
     aa4:	9f 90       	pop	r9
     aa6:	8f 90       	pop	r8
     aa8:	7f 90       	pop	r7
     aaa:	6f 90       	pop	r6
     aac:	5f 90       	pop	r5
     aae:	4f 90       	pop	r4
     ab0:	08 95       	ret

00000ab2 <vTaskStartScheduler>:
     ab2:	af 92       	push	r10
     ab4:	bf 92       	push	r11
     ab6:	cf 92       	push	r12
     ab8:	df 92       	push	r13
     aba:	ef 92       	push	r14
     abc:	ff 92       	push	r15
     abe:	0f 93       	push	r16
     ac0:	a1 2c       	mov	r10, r1
     ac2:	b1 2c       	mov	r11, r1
     ac4:	c1 2c       	mov	r12, r1
     ac6:	d1 2c       	mov	r13, r1
     ac8:	e1 2c       	mov	r14, r1
     aca:	f1 2c       	mov	r15, r1
     acc:	00 e0       	ldi	r16, 0x00	; 0
     ace:	20 e0       	ldi	r18, 0x00	; 0
     ad0:	30 e0       	ldi	r19, 0x00	; 0
     ad2:	45 e5       	ldi	r20, 0x55	; 85
     ad4:	50 e0       	ldi	r21, 0x00	; 0
     ad6:	6c ea       	ldi	r22, 0xAC	; 172
     ad8:	72 e2       	ldi	r23, 0x22	; 34
     ada:	86 ee       	ldi	r24, 0xE6	; 230
     adc:	96 e0       	ldi	r25, 0x06	; 6
     ade:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
     ae2:	81 30       	cpi	r24, 0x01	; 1
     ae4:	49 f4       	brne	.+18     	; 0xaf8 <vTaskStartScheduler+0x46>
     ae6:	f8 94       	cli
     ae8:	80 93 d5 92 	sts	0x92D5, r24
     aec:	10 92 d7 92 	sts	0x92D7, r1
     af0:	10 92 d8 92 	sts	0x92D8, r1
     af4:	0e 94 36 02 	call	0x46c	; 0x46c <xPortStartScheduler>
     af8:	0f 91       	pop	r16
     afa:	ff 90       	pop	r15
     afc:	ef 90       	pop	r14
     afe:	df 90       	pop	r13
     b00:	cf 90       	pop	r12
     b02:	bf 90       	pop	r11
     b04:	af 90       	pop	r10
     b06:	08 95       	ret

00000b08 <vTaskSuspendAll>:
     b08:	80 91 d0 92 	lds	r24, 0x92D0
     b0c:	8f 5f       	subi	r24, 0xFF	; 255
     b0e:	80 93 d0 92 	sts	0x92D0, r24
     b12:	08 95       	ret

00000b14 <xTaskIncrementTick>:
     b14:	df 92       	push	r13
     b16:	ef 92       	push	r14
     b18:	ff 92       	push	r15
     b1a:	0f 93       	push	r16
     b1c:	1f 93       	push	r17
     b1e:	cf 93       	push	r28
     b20:	df 93       	push	r29
     b22:	80 91 d0 92 	lds	r24, 0x92D0
     b26:	81 11       	cpse	r24, r1
     b28:	9a c0       	rjmp	.+308    	; 0xc5e <xTaskIncrementTick+0x14a>
     b2a:	80 91 d7 92 	lds	r24, 0x92D7
     b2e:	90 91 d8 92 	lds	r25, 0x92D8
     b32:	01 96       	adiw	r24, 0x01	; 1
     b34:	80 93 d7 92 	sts	0x92D7, r24
     b38:	90 93 d8 92 	sts	0x92D8, r25
     b3c:	e0 90 d7 92 	lds	r14, 0x92D7
     b40:	f0 90 d8 92 	lds	r15, 0x92D8
     b44:	e1 14       	cp	r14, r1
     b46:	f1 04       	cpc	r15, r1
     b48:	b9 f4       	brne	.+46     	; 0xb78 <xTaskIncrementTick+0x64>
     b4a:	80 91 ef 92 	lds	r24, 0x92EF
     b4e:	90 91 f0 92 	lds	r25, 0x92F0
     b52:	20 91 ed 92 	lds	r18, 0x92ED
     b56:	30 91 ee 92 	lds	r19, 0x92EE
     b5a:	20 93 ef 92 	sts	0x92EF, r18
     b5e:	30 93 f0 92 	sts	0x92F0, r19
     b62:	80 93 ed 92 	sts	0x92ED, r24
     b66:	90 93 ee 92 	sts	0x92EE, r25
     b6a:	80 91 d2 92 	lds	r24, 0x92D2
     b6e:	8f 5f       	subi	r24, 0xFF	; 255
     b70:	80 93 d2 92 	sts	0x92D2, r24
     b74:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvResetNextTaskUnblockTime>
     b78:	80 91 89 22 	lds	r24, 0x2289
     b7c:	90 91 8a 22 	lds	r25, 0x228A
     b80:	e8 16       	cp	r14, r24
     b82:	f9 06       	cpc	r15, r25
     b84:	10 f4       	brcc	.+4      	; 0xb8a <xTaskIncrementTick+0x76>
     b86:	d1 2c       	mov	r13, r1
     b88:	52 c0       	rjmp	.+164    	; 0xc2e <xTaskIncrementTick+0x11a>
     b8a:	d1 2c       	mov	r13, r1
     b8c:	e0 91 ef 92 	lds	r30, 0x92EF
     b90:	f0 91 f0 92 	lds	r31, 0x92F0
     b94:	90 81       	ld	r25, Z
     b96:	91 11       	cpse	r25, r1
     b98:	07 c0       	rjmp	.+14     	; 0xba8 <xTaskIncrementTick+0x94>
     b9a:	8f ef       	ldi	r24, 0xFF	; 255
     b9c:	9f ef       	ldi	r25, 0xFF	; 255
     b9e:	80 93 89 22 	sts	0x2289, r24
     ba2:	90 93 8a 22 	sts	0x228A, r25
     ba6:	43 c0       	rjmp	.+134    	; 0xc2e <xTaskIncrementTick+0x11a>
     ba8:	e0 91 ef 92 	lds	r30, 0x92EF
     bac:	f0 91 f0 92 	lds	r31, 0x92F0
     bb0:	05 80       	ldd	r0, Z+5	; 0x05
     bb2:	f6 81       	ldd	r31, Z+6	; 0x06
     bb4:	e0 2d       	mov	r30, r0
     bb6:	c6 81       	ldd	r28, Z+6	; 0x06
     bb8:	d7 81       	ldd	r29, Z+7	; 0x07
     bba:	2a 81       	ldd	r18, Y+2	; 0x02
     bbc:	3b 81       	ldd	r19, Y+3	; 0x03
     bbe:	e2 16       	cp	r14, r18
     bc0:	f3 06       	cpc	r15, r19
     bc2:	28 f4       	brcc	.+10     	; 0xbce <xTaskIncrementTick+0xba>
     bc4:	20 93 89 22 	sts	0x2289, r18
     bc8:	30 93 8a 22 	sts	0x228A, r19
     bcc:	30 c0       	rjmp	.+96     	; 0xc2e <xTaskIncrementTick+0x11a>
     bce:	8e 01       	movw	r16, r28
     bd0:	0e 5f       	subi	r16, 0xFE	; 254
     bd2:	1f 4f       	sbci	r17, 0xFF	; 255
     bd4:	c8 01       	movw	r24, r16
     bd6:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     bda:	8c 89       	ldd	r24, Y+20	; 0x14
     bdc:	9d 89       	ldd	r25, Y+21	; 0x15
     bde:	89 2b       	or	r24, r25
     be0:	21 f0       	breq	.+8      	; 0xbea <xTaskIncrementTick+0xd6>
     be2:	ce 01       	movw	r24, r28
     be4:	0c 96       	adiw	r24, 0x0c	; 12
     be6:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     bea:	2e 89       	ldd	r18, Y+22	; 0x16
     bec:	80 91 d6 92 	lds	r24, 0x92D6
     bf0:	82 17       	cp	r24, r18
     bf2:	10 f4       	brcc	.+4      	; 0xbf8 <xTaskIncrementTick+0xe4>
     bf4:	20 93 d6 92 	sts	0x92D6, r18
     bf8:	30 e0       	ldi	r19, 0x00	; 0
     bfa:	c9 01       	movw	r24, r18
     bfc:	88 0f       	add	r24, r24
     bfe:	99 1f       	adc	r25, r25
     c00:	88 0f       	add	r24, r24
     c02:	99 1f       	adc	r25, r25
     c04:	88 0f       	add	r24, r24
     c06:	99 1f       	adc	r25, r25
     c08:	82 0f       	add	r24, r18
     c0a:	93 1f       	adc	r25, r19
     c0c:	b8 01       	movw	r22, r16
     c0e:	8d 5f       	subi	r24, 0xFD	; 253
     c10:	9c 46       	sbci	r25, 0x6C	; 108
     c12:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vListInsertEnd>
     c16:	e0 91 27 93 	lds	r30, 0x9327
     c1a:	f0 91 28 93 	lds	r31, 0x9328
     c1e:	9e 89       	ldd	r25, Y+22	; 0x16
     c20:	86 89       	ldd	r24, Z+22	; 0x16
     c22:	98 17       	cp	r25, r24
     c24:	08 f4       	brcc	.+2      	; 0xc28 <xTaskIncrementTick+0x114>
     c26:	b2 cf       	rjmp	.-156    	; 0xb8c <xTaskIncrementTick+0x78>
     c28:	dd 24       	eor	r13, r13
     c2a:	d3 94       	inc	r13
     c2c:	af cf       	rjmp	.-162    	; 0xb8c <xTaskIncrementTick+0x78>
     c2e:	e0 91 27 93 	lds	r30, 0x9327
     c32:	f0 91 28 93 	lds	r31, 0x9328
     c36:	86 89       	ldd	r24, Z+22	; 0x16
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	fc 01       	movw	r30, r24
     c3c:	ee 0f       	add	r30, r30
     c3e:	ff 1f       	adc	r31, r31
     c40:	ee 0f       	add	r30, r30
     c42:	ff 1f       	adc	r31, r31
     c44:	ee 0f       	add	r30, r30
     c46:	ff 1f       	adc	r31, r31
     c48:	8e 0f       	add	r24, r30
     c4a:	9f 1f       	adc	r25, r31
     c4c:	fc 01       	movw	r30, r24
     c4e:	ed 5f       	subi	r30, 0xFD	; 253
     c50:	fc 46       	sbci	r31, 0x6C	; 108
     c52:	80 81       	ld	r24, Z
     c54:	82 30       	cpi	r24, 0x02	; 2
     c56:	48 f0       	brcs	.+18     	; 0xc6a <xTaskIncrementTick+0x156>
     c58:	dd 24       	eor	r13, r13
     c5a:	d3 94       	inc	r13
     c5c:	06 c0       	rjmp	.+12     	; 0xc6a <xTaskIncrementTick+0x156>
     c5e:	80 91 d4 92 	lds	r24, 0x92D4
     c62:	8f 5f       	subi	r24, 0xFF	; 255
     c64:	80 93 d4 92 	sts	0x92D4, r24
     c68:	d1 2c       	mov	r13, r1
     c6a:	80 91 d3 92 	lds	r24, 0x92D3
     c6e:	88 23       	and	r24, r24
     c70:	11 f0       	breq	.+4      	; 0xc76 <xTaskIncrementTick+0x162>
     c72:	dd 24       	eor	r13, r13
     c74:	d3 94       	inc	r13
     c76:	8d 2d       	mov	r24, r13
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	1f 91       	pop	r17
     c7e:	0f 91       	pop	r16
     c80:	ff 90       	pop	r15
     c82:	ef 90       	pop	r14
     c84:	df 90       	pop	r13
     c86:	08 95       	ret

00000c88 <xTaskResumeAll>:
     c88:	df 92       	push	r13
     c8a:	ef 92       	push	r14
     c8c:	ff 92       	push	r15
     c8e:	0f 93       	push	r16
     c90:	1f 93       	push	r17
     c92:	cf 93       	push	r28
     c94:	df 93       	push	r29
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	0f 92       	push	r0
     c9c:	80 91 d0 92 	lds	r24, 0x92D0
     ca0:	81 50       	subi	r24, 0x01	; 1
     ca2:	80 93 d0 92 	sts	0x92D0, r24
     ca6:	80 91 d0 92 	lds	r24, 0x92D0
     caa:	81 11       	cpse	r24, r1
     cac:	62 c0       	rjmp	.+196    	; 0xd72 <xTaskResumeAll+0xea>
     cae:	80 91 d9 92 	lds	r24, 0x92D9
     cb2:	81 11       	cpse	r24, r1
     cb4:	33 c0       	rjmp	.+102    	; 0xd1c <xTaskResumeAll+0x94>
     cb6:	60 c0       	rjmp	.+192    	; 0xd78 <xTaskResumeAll+0xf0>
     cb8:	d7 01       	movw	r26, r14
     cba:	15 96       	adiw	r26, 0x05	; 5
     cbc:	ed 91       	ld	r30, X+
     cbe:	fc 91       	ld	r31, X
     cc0:	16 97       	sbiw	r26, 0x06	; 6
     cc2:	c6 81       	ldd	r28, Z+6	; 0x06
     cc4:	d7 81       	ldd	r29, Z+7	; 0x07
     cc6:	ce 01       	movw	r24, r28
     cc8:	0c 96       	adiw	r24, 0x0c	; 12
     cca:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     cce:	8e 01       	movw	r16, r28
     cd0:	0e 5f       	subi	r16, 0xFE	; 254
     cd2:	1f 4f       	sbci	r17, 0xFF	; 255
     cd4:	c8 01       	movw	r24, r16
     cd6:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     cda:	2e 89       	ldd	r18, Y+22	; 0x16
     cdc:	80 91 d6 92 	lds	r24, 0x92D6
     ce0:	82 17       	cp	r24, r18
     ce2:	10 f4       	brcc	.+4      	; 0xce8 <xTaskResumeAll+0x60>
     ce4:	20 93 d6 92 	sts	0x92D6, r18
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	c9 01       	movw	r24, r18
     cec:	88 0f       	add	r24, r24
     cee:	99 1f       	adc	r25, r25
     cf0:	88 0f       	add	r24, r24
     cf2:	99 1f       	adc	r25, r25
     cf4:	88 0f       	add	r24, r24
     cf6:	99 1f       	adc	r25, r25
     cf8:	82 0f       	add	r24, r18
     cfa:	93 1f       	adc	r25, r19
     cfc:	b8 01       	movw	r22, r16
     cfe:	8d 5f       	subi	r24, 0xFD	; 253
     d00:	9c 46       	sbci	r25, 0x6C	; 108
     d02:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vListInsertEnd>
     d06:	e0 91 27 93 	lds	r30, 0x9327
     d0a:	f0 91 28 93 	lds	r31, 0x9328
     d0e:	9e 89       	ldd	r25, Y+22	; 0x16
     d10:	86 89       	ldd	r24, Z+22	; 0x16
     d12:	98 17       	cp	r25, r24
     d14:	58 f0       	brcs	.+22     	; 0xd2c <xTaskResumeAll+0xa4>
     d16:	d0 92 d3 92 	sts	0x92D3, r13
     d1a:	08 c0       	rjmp	.+16     	; 0xd2c <xTaskResumeAll+0xa4>
     d1c:	0f 2e       	mov	r0, r31
     d1e:	f4 ee       	ldi	r31, 0xE4	; 228
     d20:	ef 2e       	mov	r14, r31
     d22:	f2 e9       	ldi	r31, 0x92	; 146
     d24:	ff 2e       	mov	r15, r31
     d26:	f0 2d       	mov	r31, r0
     d28:	dd 24       	eor	r13, r13
     d2a:	d3 94       	inc	r13
     d2c:	f7 01       	movw	r30, r14
     d2e:	80 81       	ld	r24, Z
     d30:	81 11       	cpse	r24, r1
     d32:	c2 cf       	rjmp	.-124    	; 0xcb8 <xTaskResumeAll+0x30>
     d34:	80 91 d4 92 	lds	r24, 0x92D4
     d38:	88 23       	and	r24, r24
     d3a:	99 f0       	breq	.+38     	; 0xd62 <xTaskResumeAll+0xda>
     d3c:	80 91 d4 92 	lds	r24, 0x92D4
     d40:	88 23       	and	r24, r24
     d42:	79 f0       	breq	.+30     	; 0xd62 <xTaskResumeAll+0xda>
     d44:	c1 e0       	ldi	r28, 0x01	; 1
     d46:	0e 94 8a 05 	call	0xb14	; 0xb14 <xTaskIncrementTick>
     d4a:	81 11       	cpse	r24, r1
     d4c:	c0 93 d3 92 	sts	0x92D3, r28
     d50:	80 91 d4 92 	lds	r24, 0x92D4
     d54:	81 50       	subi	r24, 0x01	; 1
     d56:	80 93 d4 92 	sts	0x92D4, r24
     d5a:	80 91 d4 92 	lds	r24, 0x92D4
     d5e:	81 11       	cpse	r24, r1
     d60:	f2 cf       	rjmp	.-28     	; 0xd46 <xTaskResumeAll+0xbe>
     d62:	80 91 d3 92 	lds	r24, 0x92D3
     d66:	81 30       	cpi	r24, 0x01	; 1
     d68:	31 f4       	brne	.+12     	; 0xd76 <xTaskResumeAll+0xee>
     d6a:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYield>
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	03 c0       	rjmp	.+6      	; 0xd78 <xTaskResumeAll+0xf0>
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	01 c0       	rjmp	.+2      	; 0xd78 <xTaskResumeAll+0xf0>
     d76:	80 e0       	ldi	r24, 0x00	; 0
     d78:	0f 90       	pop	r0
     d7a:	0f be       	out	0x3f, r0	; 63
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	ff 90       	pop	r15
     d86:	ef 90       	pop	r14
     d88:	df 90       	pop	r13
     d8a:	08 95       	ret

00000d8c <vTaskDelay>:
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	ec 01       	movw	r28, r24
     d92:	89 2b       	or	r24, r25
     d94:	b1 f0       	breq	.+44     	; 0xdc2 <vTaskDelay+0x36>
     d96:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
     d9a:	80 91 d7 92 	lds	r24, 0x92D7
     d9e:	90 91 d8 92 	lds	r25, 0x92D8
     da2:	c8 0f       	add	r28, r24
     da4:	d9 1f       	adc	r29, r25
     da6:	80 91 27 93 	lds	r24, 0x9327
     daa:	90 91 28 93 	lds	r25, 0x9328
     dae:	02 96       	adiw	r24, 0x02	; 2
     db0:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     db4:	ce 01       	movw	r24, r28
     db6:	0e 94 0f 04 	call	0x81e	; 0x81e <prvAddCurrentTaskToDelayedList>
     dba:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
     dbe:	81 11       	cpse	r24, r1
     dc0:	02 c0       	rjmp	.+4      	; 0xdc6 <vTaskDelay+0x3a>
     dc2:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYield>
     dc6:	df 91       	pop	r29
     dc8:	cf 91       	pop	r28
     dca:	08 95       	ret

00000dcc <prvIdleTask>:
     dcc:	0b ed       	ldi	r16, 0xDB	; 219
     dce:	12 e9       	ldi	r17, 0x92	; 146
     dd0:	29 c0       	rjmp	.+82     	; 0xe24 <prvIdleTask+0x58>
     dd2:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
     dd6:	d8 01       	movw	r26, r16
     dd8:	cc 91       	ld	r28, X
     dda:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
     dde:	cc 23       	and	r28, r28
     de0:	09 f1       	breq	.+66     	; 0xe24 <prvIdleTask+0x58>
     de2:	0f b6       	in	r0, 0x3f	; 63
     de4:	f8 94       	cli
     de6:	0f 92       	push	r0
     de8:	d8 01       	movw	r26, r16
     dea:	15 96       	adiw	r26, 0x05	; 5
     dec:	ed 91       	ld	r30, X+
     dee:	fc 91       	ld	r31, X
     df0:	16 97       	sbiw	r26, 0x06	; 6
     df2:	c6 81       	ldd	r28, Z+6	; 0x06
     df4:	d7 81       	ldd	r29, Z+7	; 0x07
     df6:	ce 01       	movw	r24, r28
     df8:	02 96       	adiw	r24, 0x02	; 2
     dfa:	0e 94 ca 03 	call	0x794	; 0x794 <uxListRemove>
     dfe:	80 91 d9 92 	lds	r24, 0x92D9
     e02:	81 50       	subi	r24, 0x01	; 1
     e04:	80 93 d9 92 	sts	0x92D9, r24
     e08:	80 91 da 92 	lds	r24, 0x92DA
     e0c:	81 50       	subi	r24, 0x01	; 1
     e0e:	80 93 da 92 	sts	0x92DA, r24
     e12:	0f 90       	pop	r0
     e14:	0f be       	out	0x3f, r0	; 63
     e16:	8f 89       	ldd	r24, Y+23	; 0x17
     e18:	98 8d       	ldd	r25, Y+24	; 0x18
     e1a:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
     e1e:	ce 01       	movw	r24, r28
     e20:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
     e24:	80 91 da 92 	lds	r24, 0x92DA
     e28:	81 11       	cpse	r24, r1
     e2a:	d3 cf       	rjmp	.-90     	; 0xdd2 <prvIdleTask+0x6>
     e2c:	fb cf       	rjmp	.-10     	; 0xe24 <prvIdleTask+0x58>

00000e2e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     e2e:	80 91 d0 92 	lds	r24, 0x92D0
     e32:	88 23       	and	r24, r24
     e34:	21 f0       	breq	.+8      	; 0xe3e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     e36:	81 e0       	ldi	r24, 0x01	; 1
     e38:	80 93 d3 92 	sts	0x92D3, r24
     e3c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     e3e:	10 92 d3 92 	sts	0x92D3, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     e42:	80 91 d6 92 	lds	r24, 0x92D6
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	fc 01       	movw	r30, r24
     e4a:	ee 0f       	add	r30, r30
     e4c:	ff 1f       	adc	r31, r31
     e4e:	ee 0f       	add	r30, r30
     e50:	ff 1f       	adc	r31, r31
     e52:	ee 0f       	add	r30, r30
     e54:	ff 1f       	adc	r31, r31
     e56:	8e 0f       	add	r24, r30
     e58:	9f 1f       	adc	r25, r31
     e5a:	fc 01       	movw	r30, r24
     e5c:	ed 5f       	subi	r30, 0xFD	; 253
     e5e:	fc 46       	sbci	r31, 0x6C	; 108
     e60:	80 81       	ld	r24, Z
     e62:	81 11       	cpse	r24, r1
     e64:	17 c0       	rjmp	.+46     	; 0xe94 <vTaskSwitchContext+0x66>
     e66:	80 91 d6 92 	lds	r24, 0x92D6
     e6a:	81 50       	subi	r24, 0x01	; 1
     e6c:	80 93 d6 92 	sts	0x92D6, r24
     e70:	80 91 d6 92 	lds	r24, 0x92D6
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	fc 01       	movw	r30, r24
     e78:	ee 0f       	add	r30, r30
     e7a:	ff 1f       	adc	r31, r31
     e7c:	ee 0f       	add	r30, r30
     e7e:	ff 1f       	adc	r31, r31
     e80:	ee 0f       	add	r30, r30
     e82:	ff 1f       	adc	r31, r31
     e84:	8e 0f       	add	r24, r30
     e86:	9f 1f       	adc	r25, r31
     e88:	fc 01       	movw	r30, r24
     e8a:	ed 5f       	subi	r30, 0xFD	; 253
     e8c:	fc 46       	sbci	r31, 0x6C	; 108
     e8e:	80 81       	ld	r24, Z
     e90:	88 23       	and	r24, r24
     e92:	49 f3       	breq	.-46     	; 0xe66 <vTaskSwitchContext+0x38>
     e94:	80 91 d6 92 	lds	r24, 0x92D6
     e98:	90 e0       	ldi	r25, 0x00	; 0
     e9a:	9c 01       	movw	r18, r24
     e9c:	22 0f       	add	r18, r18
     e9e:	33 1f       	adc	r19, r19
     ea0:	22 0f       	add	r18, r18
     ea2:	33 1f       	adc	r19, r19
     ea4:	22 0f       	add	r18, r18
     ea6:	33 1f       	adc	r19, r19
     ea8:	28 0f       	add	r18, r24
     eaa:	39 1f       	adc	r19, r25
     eac:	d9 01       	movw	r26, r18
     eae:	ad 5f       	subi	r26, 0xFD	; 253
     eb0:	bc 46       	sbci	r27, 0x6C	; 108
     eb2:	11 96       	adiw	r26, 0x01	; 1
     eb4:	ed 91       	ld	r30, X+
     eb6:	fc 91       	ld	r31, X
     eb8:	12 97       	sbiw	r26, 0x02	; 2
     eba:	02 80       	ldd	r0, Z+2	; 0x02
     ebc:	f3 81       	ldd	r31, Z+3	; 0x03
     ebe:	e0 2d       	mov	r30, r0
     ec0:	11 96       	adiw	r26, 0x01	; 1
     ec2:	ed 93       	st	X+, r30
     ec4:	fc 93       	st	X, r31
     ec6:	12 97       	sbiw	r26, 0x02	; 2
     ec8:	2a 5f       	subi	r18, 0xFA	; 250
     eca:	3c 46       	sbci	r19, 0x6C	; 108
     ecc:	e2 17       	cp	r30, r18
     ece:	f3 07       	cpc	r31, r19
     ed0:	29 f4       	brne	.+10     	; 0xedc <vTaskSwitchContext+0xae>
     ed2:	22 81       	ldd	r18, Z+2	; 0x02
     ed4:	33 81       	ldd	r19, Z+3	; 0x03
     ed6:	fd 01       	movw	r30, r26
     ed8:	21 83       	std	Z+1, r18	; 0x01
     eda:	32 83       	std	Z+2, r19	; 0x02
     edc:	fc 01       	movw	r30, r24
     ede:	ee 0f       	add	r30, r30
     ee0:	ff 1f       	adc	r31, r31
     ee2:	ee 0f       	add	r30, r30
     ee4:	ff 1f       	adc	r31, r31
     ee6:	ee 0f       	add	r30, r30
     ee8:	ff 1f       	adc	r31, r31
     eea:	8e 0f       	add	r24, r30
     eec:	9f 1f       	adc	r25, r31
     eee:	fc 01       	movw	r30, r24
     ef0:	ed 5f       	subi	r30, 0xFD	; 253
     ef2:	fc 46       	sbci	r31, 0x6C	; 108
     ef4:	01 80       	ldd	r0, Z+1	; 0x01
     ef6:	f2 81       	ldd	r31, Z+2	; 0x02
     ef8:	e0 2d       	mov	r30, r0
     efa:	86 81       	ldd	r24, Z+6	; 0x06
     efc:	97 81       	ldd	r25, Z+7	; 0x07
     efe:	80 93 27 93 	sts	0x9327, r24
     f02:	90 93 28 93 	sts	0x9328, r25
     f06:	08 95       	ret

00000f08 <CDC_Device_ConfigureEndpoints>:

void CDC_Device_CreateBlockingStream(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                                     FILE* const Stream)
{
	*Stream = (FILE)FDEV_SETUP_STREAM(CDC_Device_putchar, CDC_Device_getchar_Blocking, _FDEV_SETUP_RW);
	fdev_set_udata(Stream, CDCInterfaceInfo);
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	ec 01       	movw	r28, r24
     f0e:	fc 01       	movw	r30, r24
     f10:	70 96       	adiw	r30, 0x10	; 16
     f12:	8b e0       	ldi	r24, 0x0B	; 11
     f14:	df 01       	movw	r26, r30
     f16:	1d 92       	st	X+, r1
     f18:	8a 95       	dec	r24
     f1a:	e9 f7       	brne	.-6      	; 0xf16 <CDC_Device_ConfigureEndpoints+0xe>
     f1c:	82 e0       	ldi	r24, 0x02	; 2
     f1e:	8c 83       	std	Y+4, r24	; 0x04
     f20:	89 87       	std	Y+9, r24	; 0x09
     f22:	83 e0       	ldi	r24, 0x03	; 3
     f24:	8e 87       	std	Y+14, r24	; 0x0e
     f26:	61 e0       	ldi	r22, 0x01	; 1
     f28:	ce 01       	movw	r24, r28
     f2a:	01 96       	adiw	r24, 0x01	; 1
     f2c:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <Endpoint_ConfigureEndpointTable>
     f30:	88 23       	and	r24, r24
     f32:	61 f0       	breq	.+24     	; 0xf4c <CDC_Device_ConfigureEndpoints+0x44>
     f34:	61 e0       	ldi	r22, 0x01	; 1
     f36:	ce 01       	movw	r24, r28
     f38:	06 96       	adiw	r24, 0x06	; 6
     f3a:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <Endpoint_ConfigureEndpointTable>
     f3e:	88 23       	and	r24, r24
     f40:	29 f0       	breq	.+10     	; 0xf4c <CDC_Device_ConfigureEndpoints+0x44>
     f42:	61 e0       	ldi	r22, 0x01	; 1
     f44:	ce 01       	movw	r24, r28
     f46:	0b 96       	adiw	r24, 0x0b	; 11
     f48:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <Endpoint_ConfigureEndpointTable>
     f4c:	df 91       	pop	r29
     f4e:	cf 91       	pop	r28
     f50:	08 95       	ret

00000f52 <CDC_Device_SendByte>:
     f52:	cf 93       	push	r28
     f54:	fc 01       	movw	r30, r24
     f56:	90 91 3d 95 	lds	r25, 0x953D
     f5a:	94 30       	cpi	r25, 0x04	; 4
     f5c:	19 f5       	brne	.+70     	; 0xfa4 <CDC_Device_SendByte+0x52>
     f5e:	84 89       	ldd	r24, Z+20	; 0x14
     f60:	95 89       	ldd	r25, Z+21	; 0x15
     f62:	a6 89       	ldd	r26, Z+22	; 0x16
     f64:	b7 89       	ldd	r27, Z+23	; 0x17
     f66:	89 2b       	or	r24, r25
     f68:	8a 2b       	or	r24, r26
     f6a:	8b 2b       	or	r24, r27
     f6c:	e9 f0       	breq	.+58     	; 0xfa8 <CDC_Device_SendByte+0x56>
     f6e:	c6 2f       	mov	r28, r22
     f70:	81 81       	ldd	r24, Z+1	; 0x01
     f72:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
     f76:	80 91 46 95 	lds	r24, 0x9546
     f7a:	90 91 47 95 	lds	r25, 0x9547
     f7e:	fc 01       	movw	r30, r24
     f80:	ef 5b       	subi	r30, 0xBF	; 191
     f82:	ff 4f       	sbci	r31, 0xFF	; 255
     f84:	20 81       	ld	r18, Z
     f86:	31 97       	sbiw	r30, 0x01	; 1
     f88:	80 81       	ld	r24, Z
     f8a:	28 17       	cp	r18, r24
     f8c:	30 f0       	brcs	.+12     	; 0xf9a <CDC_Device_SendByte+0x48>
     f8e:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>
     f92:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <Endpoint_WaitUntilReady>
     f96:	81 11       	cpse	r24, r1
     f98:	08 c0       	rjmp	.+16     	; 0xfaa <CDC_Device_SendByte+0x58>
     f9a:	8c 2f       	mov	r24, r28
     f9c:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	03 c0       	rjmp	.+6      	; 0xfaa <CDC_Device_SendByte+0x58>
     fa4:	82 e0       	ldi	r24, 0x02	; 2
     fa6:	01 c0       	rjmp	.+2      	; 0xfaa <CDC_Device_SendByte+0x58>
     fa8:	82 e0       	ldi	r24, 0x02	; 2
     faa:	cf 91       	pop	r28
     fac:	08 95       	ret

00000fae <CDC_Device_putchar>:
     fae:	fb 01       	movw	r30, r22
     fb0:	68 2f       	mov	r22, r24
     fb2:	84 85       	ldd	r24, Z+12	; 0x0c
     fb4:	95 85       	ldd	r25, Z+13	; 0x0d
     fb6:	0e 94 a9 07 	call	0xf52	; 0xf52 <CDC_Device_SendByte>
     fba:	21 e0       	ldi	r18, 0x01	; 1
     fbc:	30 e0       	ldi	r19, 0x00	; 0
     fbe:	81 11       	cpse	r24, r1
     fc0:	02 c0       	rjmp	.+4      	; 0xfc6 <CDC_Device_putchar+0x18>
     fc2:	20 e0       	ldi	r18, 0x00	; 0
     fc4:	30 e0       	ldi	r19, 0x00	; 0
     fc6:	88 27       	eor	r24, r24
     fc8:	99 27       	eor	r25, r25
     fca:	82 1b       	sub	r24, r18
     fcc:	93 0b       	sbc	r25, r19
     fce:	08 95       	ret

00000fd0 <CDC_Device_Flush>:
     fd0:	cf 93       	push	r28
     fd2:	df 93       	push	r29
     fd4:	fc 01       	movw	r30, r24
     fd6:	90 91 3d 95 	lds	r25, 0x953D
     fda:	94 30       	cpi	r25, 0x04	; 4
     fdc:	f1 f5       	brne	.+124    	; 0x105a <CDC_Device_Flush+0x8a>
     fde:	84 89       	ldd	r24, Z+20	; 0x14
     fe0:	95 89       	ldd	r25, Z+21	; 0x15
     fe2:	a6 89       	ldd	r26, Z+22	; 0x16
     fe4:	b7 89       	ldd	r27, Z+23	; 0x17
     fe6:	89 2b       	or	r24, r25
     fe8:	8a 2b       	or	r24, r26
     fea:	8b 2b       	or	r24, r27
     fec:	c1 f1       	breq	.+112    	; 0x105e <CDC_Device_Flush+0x8e>
     fee:	81 81       	ldd	r24, Z+1	; 0x01
     ff0:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
     ff4:	80 91 4a 95 	lds	r24, 0x954A
     ff8:	88 23       	and	r24, r24
     ffa:	4c f4       	brge	.+18     	; 0x100e <CDC_Device_Flush+0x3e>
     ffc:	e0 91 46 95 	lds	r30, 0x9546
    1000:	f0 91 47 95 	lds	r31, 0x9547
    1004:	ef 5b       	subi	r30, 0xBF	; 191
    1006:	ff 4f       	sbci	r31, 0xFF	; 255
    1008:	80 81       	ld	r24, Z
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	0d c0       	rjmp	.+26     	; 0x1028 <CDC_Device_Flush+0x58>
    100e:	20 91 46 95 	lds	r18, 0x9546
    1012:	30 91 47 95 	lds	r19, 0x9547
    1016:	f9 01       	movw	r30, r18
    1018:	e0 5c       	subi	r30, 0xC0	; 192
    101a:	ff 4f       	sbci	r31, 0xFF	; 255
    101c:	80 81       	ld	r24, Z
    101e:	31 96       	adiw	r30, 0x01	; 1
    1020:	20 81       	ld	r18, Z
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	82 1b       	sub	r24, r18
    1026:	91 09       	sbc	r25, r1
    1028:	89 2b       	or	r24, r25
    102a:	d9 f0       	breq	.+54     	; 0x1062 <CDC_Device_Flush+0x92>
    102c:	80 91 46 95 	lds	r24, 0x9546
    1030:	90 91 47 95 	lds	r25, 0x9547
    1034:	fc 01       	movw	r30, r24
    1036:	ef 5b       	subi	r30, 0xBF	; 191
    1038:	ff 4f       	sbci	r31, 0xFF	; 255
    103a:	d0 81       	ld	r29, Z
    103c:	31 97       	sbiw	r30, 0x01	; 1
    103e:	c0 81       	ld	r28, Z
    1040:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>
    1044:	dc 17       	cp	r29, r28
    1046:	78 f0       	brcs	.+30     	; 0x1066 <CDC_Device_Flush+0x96>
    1048:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <Endpoint_WaitUntilReady>
    104c:	c8 2f       	mov	r28, r24
    104e:	81 11       	cpse	r24, r1
    1050:	0c c0       	rjmp	.+24     	; 0x106a <CDC_Device_Flush+0x9a>
    1052:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>
    1056:	8c 2f       	mov	r24, r28
    1058:	08 c0       	rjmp	.+16     	; 0x106a <CDC_Device_Flush+0x9a>
    105a:	82 e0       	ldi	r24, 0x02	; 2
    105c:	06 c0       	rjmp	.+12     	; 0x106a <CDC_Device_Flush+0x9a>
    105e:	82 e0       	ldi	r24, 0x02	; 2
    1060:	04 c0       	rjmp	.+8      	; 0x106a <CDC_Device_Flush+0x9a>
    1062:	80 e0       	ldi	r24, 0x00	; 0
    1064:	02 c0       	rjmp	.+4      	; 0x106a <CDC_Device_Flush+0x9a>
    1066:	80 e0       	ldi	r24, 0x00	; 0
    1068:	00 c0       	rjmp	.+0      	; 0x106a <CDC_Device_Flush+0x9a>
    106a:	df 91       	pop	r29
    106c:	cf 91       	pop	r28
    106e:	08 95       	ret

00001070 <CDC_Device_USBTask>:
    1070:	cf 93       	push	r28
    1072:	df 93       	push	r29
    1074:	fc 01       	movw	r30, r24
    1076:	90 91 3d 95 	lds	r25, 0x953D
    107a:	94 30       	cpi	r25, 0x04	; 4
    107c:	99 f4       	brne	.+38     	; 0x10a4 <CDC_Device_USBTask+0x34>
    107e:	84 89       	ldd	r24, Z+20	; 0x14
    1080:	95 89       	ldd	r25, Z+21	; 0x15
    1082:	a6 89       	ldd	r26, Z+22	; 0x16
    1084:	b7 89       	ldd	r27, Z+23	; 0x17
    1086:	89 2b       	or	r24, r25
    1088:	8a 2b       	or	r24, r26
    108a:	8b 2b       	or	r24, r27
    108c:	59 f0       	breq	.+22     	; 0x10a4 <CDC_Device_USBTask+0x34>
    108e:	ef 01       	movw	r28, r30
    1090:	81 81       	ldd	r24, Z+1	; 0x01
    1092:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
    1096:	0e 94 a9 0c 	call	0x1952	; 0x1952 <Endpoint_IsINReady>
    109a:	88 23       	and	r24, r24
    109c:	19 f0       	breq	.+6      	; 0x10a4 <CDC_Device_USBTask+0x34>
    109e:	ce 01       	movw	r24, r28
    10a0:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <CDC_Device_Flush>
    10a4:	df 91       	pop	r29
    10a6:	cf 91       	pop	r28
    10a8:	08 95       	ret

000010aa <CDC_Device_ReceiveByte>:
    10aa:	cf 93       	push	r28
    10ac:	df 93       	push	r29
    10ae:	20 91 3d 95 	lds	r18, 0x953D
    10b2:	24 30       	cpi	r18, 0x04	; 4
    10b4:	09 f0       	breq	.+2      	; 0x10b8 <CDC_Device_ReceiveByte+0xe>
    10b6:	56 c0       	rjmp	.+172    	; 0x1164 <CDC_Device_ReceiveByte+0xba>
    10b8:	fc 01       	movw	r30, r24
    10ba:	44 89       	ldd	r20, Z+20	; 0x14
    10bc:	55 89       	ldd	r21, Z+21	; 0x15
    10be:	66 89       	ldd	r22, Z+22	; 0x16
    10c0:	77 89       	ldd	r23, Z+23	; 0x17
    10c2:	45 2b       	or	r20, r21
    10c4:	46 2b       	or	r20, r22
    10c6:	47 2b       	or	r20, r23
    10c8:	09 f4       	brne	.+2      	; 0x10cc <CDC_Device_ReceiveByte+0x22>
    10ca:	4f c0       	rjmp	.+158    	; 0x116a <CDC_Device_ReceiveByte+0xc0>
    10cc:	86 81       	ldd	r24, Z+6	; 0x06
    10ce:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
    10d2:	0e 94 b6 0c 	call	0x196c	; 0x196c <Endpoint_IsOUTReceived>
    10d6:	88 23       	and	r24, r24
    10d8:	09 f4       	brne	.+2      	; 0x10dc <CDC_Device_ReceiveByte+0x32>
    10da:	4a c0       	rjmp	.+148    	; 0x1170 <CDC_Device_ReceiveByte+0xc6>
    10dc:	80 91 4a 95 	lds	r24, 0x954A
    10e0:	88 23       	and	r24, r24
    10e2:	4c f4       	brge	.+18     	; 0x10f6 <CDC_Device_ReceiveByte+0x4c>
    10e4:	e0 91 46 95 	lds	r30, 0x9546
    10e8:	f0 91 47 95 	lds	r31, 0x9547
    10ec:	ef 5b       	subi	r30, 0xBF	; 191
    10ee:	ff 4f       	sbci	r31, 0xFF	; 255
    10f0:	80 81       	ld	r24, Z
    10f2:	90 e0       	ldi	r25, 0x00	; 0
    10f4:	0d c0       	rjmp	.+26     	; 0x1110 <CDC_Device_ReceiveByte+0x66>
    10f6:	20 91 46 95 	lds	r18, 0x9546
    10fa:	30 91 47 95 	lds	r19, 0x9547
    10fe:	f9 01       	movw	r30, r18
    1100:	e0 5c       	subi	r30, 0xC0	; 192
    1102:	ff 4f       	sbci	r31, 0xFF	; 255
    1104:	80 81       	ld	r24, Z
    1106:	31 96       	adiw	r30, 0x01	; 1
    1108:	20 81       	ld	r18, Z
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	82 1b       	sub	r24, r18
    110e:	91 09       	sbc	r25, r1
    1110:	89 2b       	or	r24, r25
    1112:	29 f0       	breq	.+10     	; 0x111e <CDC_Device_ReceiveByte+0x74>
    1114:	0e 94 49 0c 	call	0x1892	; 0x1892 <Endpoint_Read_8>
    1118:	c8 2f       	mov	r28, r24
    111a:	d0 e0       	ldi	r29, 0x00	; 0
    111c:	02 c0       	rjmp	.+4      	; 0x1122 <CDC_Device_ReceiveByte+0x78>
    111e:	cf ef       	ldi	r28, 0xFF	; 255
    1120:	df ef       	ldi	r29, 0xFF	; 255
    1122:	80 91 4a 95 	lds	r24, 0x954A
    1126:	88 23       	and	r24, r24
    1128:	4c f4       	brge	.+18     	; 0x113c <CDC_Device_ReceiveByte+0x92>
    112a:	e0 91 46 95 	lds	r30, 0x9546
    112e:	f0 91 47 95 	lds	r31, 0x9547
    1132:	ef 5b       	subi	r30, 0xBF	; 191
    1134:	ff 4f       	sbci	r31, 0xFF	; 255
    1136:	20 81       	ld	r18, Z
    1138:	30 e0       	ldi	r19, 0x00	; 0
    113a:	0d c0       	rjmp	.+26     	; 0x1156 <CDC_Device_ReceiveByte+0xac>
    113c:	40 91 46 95 	lds	r20, 0x9546
    1140:	50 91 47 95 	lds	r21, 0x9547
    1144:	fa 01       	movw	r30, r20
    1146:	e0 5c       	subi	r30, 0xC0	; 192
    1148:	ff 4f       	sbci	r31, 0xFF	; 255
    114a:	20 81       	ld	r18, Z
    114c:	31 96       	adiw	r30, 0x01	; 1
    114e:	80 81       	ld	r24, Z
    1150:	30 e0       	ldi	r19, 0x00	; 0
    1152:	28 1b       	sub	r18, r24
    1154:	31 09       	sbc	r19, r1
    1156:	23 2b       	or	r18, r19
    1158:	71 f4       	brne	.+28     	; 0x1176 <CDC_Device_ReceiveByte+0xcc>
    115a:	0e 94 3a 0c 	call	0x1874	; 0x1874 <Endpoint_ClearOUT>
    115e:	8c 2f       	mov	r24, r28
    1160:	9d 2f       	mov	r25, r29
    1162:	0b c0       	rjmp	.+22     	; 0x117a <CDC_Device_ReceiveByte+0xd0>
    1164:	8f ef       	ldi	r24, 0xFF	; 255
    1166:	9f ef       	ldi	r25, 0xFF	; 255
    1168:	08 c0       	rjmp	.+16     	; 0x117a <CDC_Device_ReceiveByte+0xd0>
    116a:	8f ef       	ldi	r24, 0xFF	; 255
    116c:	9f ef       	ldi	r25, 0xFF	; 255
    116e:	05 c0       	rjmp	.+10     	; 0x117a <CDC_Device_ReceiveByte+0xd0>
    1170:	8f ef       	ldi	r24, 0xFF	; 255
    1172:	9f ef       	ldi	r25, 0xFF	; 255
    1174:	02 c0       	rjmp	.+4      	; 0x117a <CDC_Device_ReceiveByte+0xd0>
    1176:	8c 2f       	mov	r24, r28
    1178:	9d 2f       	mov	r25, r29
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	08 95       	ret

00001180 <CDC_Device_getchar>:
    1180:	fc 01       	movw	r30, r24
    1182:	84 85       	ldd	r24, Z+12	; 0x0c
    1184:	95 85       	ldd	r25, Z+13	; 0x0d
    1186:	0e 94 55 08 	call	0x10aa	; 0x10aa <CDC_Device_ReceiveByte>
    118a:	99 23       	and	r25, r25
    118c:	14 f4       	brge	.+4      	; 0x1192 <CDC_Device_getchar+0x12>
    118e:	8e ef       	ldi	r24, 0xFE	; 254
    1190:	9f ef       	ldi	r25, 0xFF	; 255
    1192:	08 95       	ret

00001194 <CDC_Device_CreateStream>:
    1194:	fb 01       	movw	r30, r22
    1196:	2e e0       	ldi	r18, 0x0E	; 14
    1198:	db 01       	movw	r26, r22
    119a:	1d 92       	st	X+, r1
    119c:	2a 95       	dec	r18
    119e:	e9 f7       	brne	.-6      	; 0x119a <CDC_Device_CreateStream+0x6>
    11a0:	23 e0       	ldi	r18, 0x03	; 3
    11a2:	23 83       	std	Z+3, r18	; 0x03
    11a4:	27 ed       	ldi	r18, 0xD7	; 215
    11a6:	37 e0       	ldi	r19, 0x07	; 7
    11a8:	20 87       	std	Z+8, r18	; 0x08
    11aa:	31 87       	std	Z+9, r19	; 0x09
    11ac:	20 ec       	ldi	r18, 0xC0	; 192
    11ae:	38 e0       	ldi	r19, 0x08	; 8
    11b0:	22 87       	std	Z+10, r18	; 0x0a
    11b2:	33 87       	std	Z+11, r19	; 0x0b
    11b4:	84 87       	std	Z+12, r24	; 0x0c
    11b6:	95 87       	std	Z+13, r25	; 0x0d
    11b8:	08 95       	ret

000011ba <CDC_Device_Event_Stub>:
	return ReceivedByte;
}
#endif

void CDC_Device_Event_Stub(void)
{
    11ba:	08 95       	ret

000011bc <CDC_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_CDC_DRIVER
#define  __INCLUDE_FROM_CDC_DEVICE_C
#include "CDCClassDevice.h"

void CDC_Device_ProcessControlRequest(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    11bc:	ff 92       	push	r15
    11be:	0f 93       	push	r16
    11c0:	1f 93       	push	r17
    11c2:	cf 93       	push	r28
    11c4:	df 93       	push	r29
    11c6:	ec 01       	movw	r28, r24
	if (!(Endpoint_IsSETUPReceived()))
    11c8:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <Endpoint_IsSETUPReceived>
    11cc:	88 23       	and	r24, r24
    11ce:	09 f4       	brne	.+2      	; 0x11d2 <CDC_Device_ProcessControlRequest+0x16>
    11d0:	9b c0       	rjmp	.+310    	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
	  return;

	if (USB_ControlRequest.wIndex != CDCInterfaceInfo->Config.ControlInterfaceNumber)
    11d2:	28 81       	ld	r18, Y
    11d4:	30 e0       	ldi	r19, 0x00	; 0
    11d6:	80 91 42 95 	lds	r24, 0x9542
    11da:	90 91 43 95 	lds	r25, 0x9543
    11de:	82 17       	cp	r24, r18
    11e0:	93 07       	cpc	r25, r19
    11e2:	09 f0       	breq	.+2      	; 0x11e6 <CDC_Device_ProcessControlRequest+0x2a>
    11e4:	91 c0       	rjmp	.+290    	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
	  return;

	switch (USB_ControlRequest.bRequest)
    11e6:	80 91 3f 95 	lds	r24, 0x953F
    11ea:	81 32       	cpi	r24, 0x21	; 33
    11ec:	59 f0       	breq	.+22     	; 0x1204 <CDC_Device_ProcessControlRequest+0x48>
    11ee:	18 f4       	brcc	.+6      	; 0x11f6 <CDC_Device_ProcessControlRequest+0x3a>
    11f0:	80 32       	cpi	r24, 0x20	; 32
    11f2:	81 f1       	breq	.+96     	; 0x1254 <CDC_Device_ProcessControlRequest+0x98>
    11f4:	89 c0       	rjmp	.+274    	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
    11f6:	82 32       	cpi	r24, 0x22	; 34
    11f8:	09 f4       	brne	.+2      	; 0x11fc <CDC_Device_ProcessControlRequest+0x40>
    11fa:	67 c0       	rjmp	.+206    	; 0x12ca <CDC_Device_ProcessControlRequest+0x10e>
    11fc:	83 32       	cpi	r24, 0x23	; 35
    11fe:	09 f4       	brne	.+2      	; 0x1202 <CDC_Device_ProcessControlRequest+0x46>
    1200:	76 c0       	rjmp	.+236    	; 0x12ee <CDC_Device_ProcessControlRequest+0x132>
    1202:	82 c0       	rjmp	.+260    	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
	{
		case CDC_REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    1204:	80 91 3e 95 	lds	r24, 0x953E
    1208:	81 3a       	cpi	r24, 0xA1	; 161
    120a:	09 f0       	breq	.+2      	; 0x120e <CDC_Device_ProcessControlRequest+0x52>
    120c:	7d c0       	rjmp	.+250    	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    120e:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>

				while (!(Endpoint_IsINReady()));
    1212:	0e 94 a9 0c 	call	0x1952	; 0x1952 <Endpoint_IsINReady>
    1216:	88 23       	and	r24, r24
    1218:	e1 f3       	breq	.-8      	; 0x1212 <CDC_Device_ProcessControlRequest+0x56>

				Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
    121a:	8c 89       	ldd	r24, Y+20	; 0x14
    121c:	fd 88       	ldd	r15, Y+21	; 0x15
    121e:	0e 89       	ldd	r16, Y+22	; 0x16
    1220:	1f 89       	ldd	r17, Y+23	; 0x17
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_32_LE(const uint32_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_32_LE(const uint32_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    1222:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    1226:	8f 2d       	mov	r24, r15
    1228:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 16);
    122c:	80 2f       	mov	r24, r16
    122e:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 24);
    1232:	81 2f       	mov	r24, r17
    1234:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
    1238:	88 8d       	ldd	r24, Y+24	; 0x18
    123a:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
    123e:	89 8d       	ldd	r24, Y+25	; 0x19
    1240:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
    1244:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1246:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>

				Endpoint_ClearIN();
    124a:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>
				Endpoint_ClearStatusStage();
    124e:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <Endpoint_ClearStatusStage>
    1252:	5a c0       	rjmp	.+180    	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    1254:	80 91 3e 95 	lds	r24, 0x953E
    1258:	81 32       	cpi	r24, 0x21	; 33
    125a:	09 f0       	breq	.+2      	; 0x125e <CDC_Device_ProcessControlRequest+0xa2>
    125c:	55 c0       	rjmp	.+170    	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    125e:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>

				while (!(Endpoint_IsOUTReceived()))
    1262:	05 c0       	rjmp	.+10     	; 0x126e <CDC_Device_ProcessControlRequest+0xb2>
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    1264:	80 91 3d 95 	lds	r24, 0x953D
    1268:	88 23       	and	r24, r24
    126a:	09 f4       	brne	.+2      	; 0x126e <CDC_Device_ProcessControlRequest+0xb2>
    126c:	4d c0       	rjmp	.+154    	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSETUP();

				while (!(Endpoint_IsOUTReceived()))
    126e:	0e 94 b6 0c 	call	0x196c	; 0x196c <Endpoint_IsOUTReceived>
    1272:	88 23       	and	r24, r24
    1274:	b9 f3       	breq	.-18     	; 0x1264 <CDC_Device_ProcessControlRequest+0xa8>
			 *  \return Next four bytes in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
    1276:	0e 94 49 0c 	call	0x1892	; 0x1892 <Endpoint_Read_8>
    127a:	f8 2e       	mov	r15, r24
				uint32_t Byte1 = Endpoint_Read_8();
    127c:	0e 94 49 0c 	call	0x1892	; 0x1892 <Endpoint_Read_8>
    1280:	18 2f       	mov	r17, r24
				uint32_t Byte2 = Endpoint_Read_8();
    1282:	0e 94 49 0c 	call	0x1892	; 0x1892 <Endpoint_Read_8>
    1286:	08 2f       	mov	r16, r24
				uint32_t Byte3 = Endpoint_Read_8();
    1288:	0e 94 49 0c 	call	0x1892	; 0x1892 <Endpoint_Read_8>
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
				uint32_t Byte1 = Endpoint_Read_8();
				uint32_t Byte2 = Endpoint_Read_8();
    128c:	40 2f       	mov	r20, r16
    128e:	50 e0       	ldi	r21, 0x00	; 0
    1290:	60 e0       	ldi	r22, 0x00	; 0
    1292:	70 e0       	ldi	r23, 0x00	; 0
				uint32_t Byte3 = Endpoint_Read_8();

				return ((Byte3 << 24) | (Byte2 << 16) | (Byte1 << 8) | Byte0);
    1294:	ba 01       	movw	r22, r20
    1296:	55 27       	eor	r21, r21
    1298:	44 27       	eor	r20, r20
    129a:	78 2b       	or	r23, r24
    129c:	4f 29       	or	r20, r15
    129e:	51 2b       	or	r21, r17
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
					  return;
				}

				CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
    12a0:	4c 8b       	std	Y+20, r20	; 0x14
    12a2:	5d 8b       	std	Y+21, r21	; 0x15
    12a4:	6e 8b       	std	Y+22, r22	; 0x16
    12a6:	7f 8b       	std	Y+23, r23	; 0x17
				CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
    12a8:	0e 94 49 0c 	call	0x1892	; 0x1892 <Endpoint_Read_8>
    12ac:	88 8f       	std	Y+24, r24	; 0x18
				CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
    12ae:	0e 94 49 0c 	call	0x1892	; 0x1892 <Endpoint_Read_8>
    12b2:	89 8f       	std	Y+25, r24	; 0x19
				CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
    12b4:	0e 94 49 0c 	call	0x1892	; 0x1892 <Endpoint_Read_8>
    12b8:	8a 8f       	std	Y+26, r24	; 0x1a

				Endpoint_ClearOUT();
    12ba:	0e 94 3a 0c 	call	0x1874	; 0x1874 <Endpoint_ClearOUT>
				Endpoint_ClearStatusStage();
    12be:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_LineEncodingChanged(CDCInterfaceInfo);
    12c2:	ce 01       	movw	r24, r28
    12c4:	0e 94 dd 08 	call	0x11ba	; 0x11ba <CDC_Device_Event_Stub>
    12c8:	1f c0       	rjmp	.+62     	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SetControlLineState:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    12ca:	80 91 3e 95 	lds	r24, 0x953E
    12ce:	81 32       	cpi	r24, 0x21	; 33
    12d0:	d9 f4       	brne	.+54     	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    12d2:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    12d6:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <Endpoint_ClearStatusStage>

				CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
    12da:	80 91 40 95 	lds	r24, 0x9540
    12de:	90 91 41 95 	lds	r25, 0x9541
    12e2:	88 8b       	std	Y+16, r24	; 0x10
    12e4:	99 8b       	std	Y+17, r25	; 0x11

				EVENT_CDC_Device_ControLineStateChanged(CDCInterfaceInfo);
    12e6:	ce 01       	movw	r24, r28
    12e8:	0e 94 3f 12 	call	0x247e	; 0x247e <EVENT_CDC_Device_ControLineStateChanged>
    12ec:	0d c0       	rjmp	.+26     	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
			}

			break;
		case CDC_REQ_SendBreak:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    12ee:	80 91 3e 95 	lds	r24, 0x953E
    12f2:	81 32       	cpi	r24, 0x21	; 33
    12f4:	49 f4       	brne	.+18     	; 0x1308 <CDC_Device_ProcessControlRequest+0x14c>
			{
				Endpoint_ClearSETUP();
    12f6:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    12fa:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
    12fe:	60 91 40 95 	lds	r22, 0x9540
    1302:	ce 01       	movw	r24, r28
    1304:	0e 94 dd 08 	call	0x11ba	; 0x11ba <CDC_Device_Event_Stub>
			}

			break;
	}
}
    1308:	df 91       	pop	r29
    130a:	cf 91       	pop	r28
    130c:	1f 91       	pop	r17
    130e:	0f 91       	pop	r16
    1310:	ff 90       	pop	r15
    1312:	08 95       	ret

00001314 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1314:	ef 92       	push	r14
    1316:	ff 92       	push	r15
    1318:	0f 93       	push	r16
    131a:	1f 93       	push	r17
    131c:	cf 93       	push	r28
    131e:	df 93       	push	r29
    1320:	cd b7       	in	r28, 0x3d	; 61
    1322:	de b7       	in	r29, 0x3e	; 62
    1324:	ea 97       	sbiw	r28, 0x3a	; 58
    1326:	cd bf       	out	0x3d, r28	; 61
    1328:	de bf       	out	0x3e, r29	; 62
    132a:	0e e3       	ldi	r16, 0x3E	; 62
    132c:	15 e9       	ldi	r17, 0x95	; 149
    132e:	0f 2e       	mov	r0, r31
    1330:	f6 e4       	ldi	r31, 0x46	; 70
    1332:	ef 2e       	mov	r14, r31
    1334:	f5 e9       	ldi	r31, 0x95	; 149
    1336:	ff 2e       	mov	r15, r31
    1338:	f0 2d       	mov	r31, r0
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    133a:	0e 94 49 0c 	call	0x1892	; 0x1892 <Endpoint_Read_8>
    133e:	f8 01       	movw	r30, r16
    1340:	81 93       	st	Z+, r24
    1342:	8f 01       	movw	r16, r30
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1344:	ee 15       	cp	r30, r14
    1346:	ff 05       	cpc	r31, r15
    1348:	c1 f7       	brne	.-16     	; 0x133a <USB_Device_ProcessControlRequest+0x26>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    134a:	0e 94 3a 12 	call	0x2474	; 0x2474 <EVENT_USB_Device_ControlRequest>

	if (Endpoint_IsSETUPReceived())
    134e:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <Endpoint_IsSETUPReceived>
    1352:	88 23       	and	r24, r24
    1354:	09 f4       	brne	.+2      	; 0x1358 <USB_Device_ProcessControlRequest+0x44>
    1356:	13 c1       	rjmp	.+550    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1358:	ee e3       	ldi	r30, 0x3E	; 62
    135a:	f5 e9       	ldi	r31, 0x95	; 149
    135c:	20 81       	ld	r18, Z

		switch (USB_ControlRequest.bRequest)
    135e:	31 81       	ldd	r19, Z+1	; 0x01
    1360:	83 2f       	mov	r24, r19
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	8a 30       	cpi	r24, 0x0A	; 10
    1366:	91 05       	cpc	r25, r1
    1368:	08 f0       	brcs	.+2      	; 0x136c <USB_Device_ProcessControlRequest+0x58>
    136a:	09 c1       	rjmp	.+530    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
    136c:	fc 01       	movw	r30, r24
    136e:	88 27       	eor	r24, r24
    1370:	e2 50       	subi	r30, 0x02	; 2
    1372:	ff 4f       	sbci	r31, 0xFF	; 255
    1374:	8f 4f       	sbci	r24, 0xFF	; 255
    1376:	0c 94 3c 13 	jmp	0x2678	; 0x2678 <__tablejump2__>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    137a:	20 38       	cpi	r18, 0x80	; 128
    137c:	21 f0       	breq	.+8      	; 0x1386 <USB_Device_ProcessControlRequest+0x72>
    137e:	22 38       	cpi	r18, 0x82	; 130
    1380:	09 f0       	breq	.+2      	; 0x1384 <USB_Device_ProcessControlRequest+0x70>
    1382:	fd c0       	rjmp	.+506    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
    1384:	08 c0       	rjmp	.+16     	; 0x1396 <USB_Device_ProcessControlRequest+0x82>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    1386:	10 91 3a 95 	lds	r17, 0x953A
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    138a:	80 91 3b 95 	lds	r24, 0x953B
    138e:	88 23       	and	r24, r24
    1390:	91 f0       	breq	.+36     	; 0x13b6 <USB_Device_ProcessControlRequest+0xa2>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    1392:	12 60       	ori	r17, 0x02	; 2
    1394:	10 c0       	rjmp	.+32     	; 0x13b6 <USB_Device_ProcessControlRequest+0xa2>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1396:	80 91 42 95 	lds	r24, 0x9542
    139a:	8f 70       	andi	r24, 0x0F	; 15
    139c:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    13a0:	e0 91 48 95 	lds	r30, 0x9548
    13a4:	f0 91 49 95 	lds	r31, 0x9549
    13a8:	11 81       	ldd	r17, Z+1	; 0x01
    13aa:	12 fb       	bst	r17, 2
    13ac:	11 27       	eor	r17, r17
    13ae:	10 f9       	bld	r17, 0

			CurrentStatus = Endpoint_IsStalled();

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    13b0:	80 e0       	ldi	r24, 0x00	; 0
    13b2:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
			break;
		default:
			return;
	}

	Endpoint_ClearSETUP();
    13b6:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    13ba:	81 2f       	mov	r24, r17
    13bc:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    13c0:	80 e0       	ldi	r24, 0x00	; 0
    13c2:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();
    13c6:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>

	Endpoint_ClearStatusStage();
    13ca:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <Endpoint_ClearStatusStage>
    13ce:	d7 c0       	rjmp	.+430    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    13d0:	22 23       	and	r18, r18
    13d2:	09 f4       	brne	.+2      	; 0x13d6 <USB_Device_ProcessControlRequest+0xc2>
    13d4:	dd c0       	rjmp	.+442    	; 0x1590 <USB_Device_ProcessControlRequest+0x27c>
    13d6:	22 30       	cpi	r18, 0x02	; 2
    13d8:	09 f0       	breq	.+2      	; 0x13dc <USB_Device_ProcessControlRequest+0xc8>
    13da:	d1 c0       	rjmp	.+418    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
    13dc:	de c0       	rjmp	.+444    	; 0x159a <USB_Device_ProcessControlRequest+0x286>
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	33 30       	cpi	r19, 0x03	; 3
    13e2:	09 f0       	breq	.+2      	; 0x13e6 <USB_Device_ProcessControlRequest+0xd2>
    13e4:	80 e0       	ldi	r24, 0x00	; 0
    13e6:	80 93 3b 95 	sts	0x953B, r24
    13ea:	25 c0       	rjmp	.+74     	; 0x1436 <USB_Device_ProcessControlRequest+0x122>
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    13ec:	e0 91 42 95 	lds	r30, 0x9542
    13f0:	1e 2f       	mov	r17, r30
    13f2:	1f 70       	andi	r17, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    13f4:	09 f4       	brne	.+2      	; 0x13f8 <USB_Device_ProcessControlRequest+0xe4>
    13f6:	c3 c0       	rjmp	.+390    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
    13f8:	81 2f       	mov	r24, r17
    13fa:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>

				if (Endpoint_IsEnabled())
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    13fe:	80 91 3f 95 	lds	r24, 0x953F
    1402:	83 30       	cpi	r24, 0x03	; 3
    1404:	19 f4       	brne	.+6      	; 0x140c <USB_Device_ProcessControlRequest+0xf8>
					{
						Endpoint_StallTransaction();
    1406:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <Endpoint_StallTransaction>
    140a:	15 c0       	rjmp	.+42     	; 0x1436 <USB_Device_ProcessControlRequest+0x122>
			 *  \ingroup Group_EndpointPacketManagement_XMEGA
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				USB_Endpoint_SelectedHandle->CTRL &= ~USB_EP_STALL_bm;
    140c:	e0 91 48 95 	lds	r30, 0x9548
    1410:	f0 91 49 95 	lds	r31, 0x9549
    1414:	81 81       	ldd	r24, Z+1	; 0x01
    1416:	8b 7f       	andi	r24, 0xFB	; 251
    1418:	81 83       	std	Z+1, r24	; 0x01
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				if (Address & ENDPOINT_DIR_IN)
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].IN.Position  = 0;
				else
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].OUT.Position = 0;
    141a:	24 e8       	ldi	r18, 0x84	; 132
    141c:	12 9f       	mul	r17, r18
    141e:	f0 01       	movw	r30, r0
    1420:	11 24       	eor	r1, r1
    1422:	e4 57       	subi	r30, 0x74	; 116
    1424:	fa 46       	sbci	r31, 0x6A	; 106
    1426:	10 82       	st	Z, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				USB_Endpoint_SelectedHandle->STATUS &= ~USB_EP_TOGGLE_bm;
    1428:	e0 91 48 95 	lds	r30, 0x9548
    142c:	f0 91 49 95 	lds	r31, 0x9549
    1430:	80 81       	ld	r24, Z
    1432:	8e 7f       	andi	r24, 0xFE	; 254
    1434:	80 83       	st	Z, r24
		#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    1436:	80 e0       	ldi	r24, 0x00	; 0
    1438:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>

	Endpoint_ClearSETUP();
    143c:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    1440:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <Endpoint_ClearStatusStage>
    1444:	9c c0       	rjmp	.+312    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    1446:	21 11       	cpse	r18, r1
    1448:	9a c0       	rjmp	.+308    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    144a:	10 91 40 95 	lds	r17, 0x9540
    144e:	1f 77       	andi	r17, 0x7F	; 127

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();
    1450:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    1454:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <Endpoint_ClearStatusStage>

	while (!(Endpoint_IsINReady()));
    1458:	0e 94 a9 0c 	call	0x1952	; 0x1952 <Endpoint_IsINReady>
    145c:	88 23       	and	r24, r24
    145e:	e1 f3       	breq	.-8      	; 0x1458 <USB_Device_ProcessControlRequest+0x144>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    1460:	10 93 c3 04 	sts	0x04C3, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    1464:	11 11       	cpse	r17, r1
    1466:	02 c0       	rjmp	.+4      	; 0x146c <USB_Device_ProcessControlRequest+0x158>
    1468:	82 e0       	ldi	r24, 0x02	; 2
    146a:	01 c0       	rjmp	.+2      	; 0x146e <USB_Device_ProcessControlRequest+0x15a>
    146c:	83 e0       	ldi	r24, 0x03	; 3
    146e:	80 93 3d 95 	sts	0x953D, r24
    1472:	85 c0       	rjmp	.+266    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1474:	20 58       	subi	r18, 0x80	; 128
    1476:	22 30       	cpi	r18, 0x02	; 2
    1478:	08 f0       	brcs	.+2      	; 0x147c <USB_Device_ProcessControlRequest+0x168>
    147a:	81 c0       	rjmp	.+258    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    147c:	80 91 40 95 	lds	r24, 0x9540
    1480:	90 91 41 95 	lds	r25, 0x9541
    1484:	8c 3d       	cpi	r24, 0xDC	; 220
    1486:	e3 e0       	ldi	r30, 0x03	; 3
    1488:	9e 07       	cpc	r25, r30
    148a:	b9 f5       	brne	.+110    	; 0x14fa <USB_Device_ProcessControlRequest+0x1e6>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    148c:	83 e0       	ldi	r24, 0x03	; 3
    148e:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    1490:	8a e3       	ldi	r24, 0x3A	; 58
    1492:	89 83       	std	Y+1, r24	; 0x01
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    1494:	7f b7       	in	r23, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    1496:	f8 94       	cli
				#endif

				GCC_MEMORY_BARRIER();
    1498:	ae 01       	movw	r20, r28
    149a:	4d 5f       	subi	r20, 0xFD	; 253
    149c:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    149e:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    14a0:	38 e0       	ldi	r19, 0x08	; 8

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte;

					NVM.CMD    = NVM_CMD_READ_CALIB_ROW_gc;
    14a2:	a0 ec       	ldi	r26, 0xC0	; 192
    14a4:	b1 e0       	ldi	r27, 0x01	; 1
    14a6:	62 e0       	ldi	r22, 0x02	; 2
    14a8:	1a 96       	adiw	r26, 0x0a	; 10
    14aa:	6c 93       	st	X, r22
    14ac:	1a 97       	sbiw	r26, 0x0a	; 10
					SerialByte = pgm_read_byte(SigReadAddress);
    14ae:	e3 2f       	mov	r30, r19
    14b0:	f0 e0       	ldi	r31, 0x00	; 0
    14b2:	84 91       	lpm	r24, Z
					NVM.CMD    = 0;
    14b4:	1a 96       	adiw	r26, 0x0a	; 10
    14b6:	1c 92       	st	X, r1
    14b8:	1a 97       	sbiw	r26, 0x0a	; 10

					if (SerialCharNum & 0x01)
    14ba:	20 ff       	sbrs	r18, 0
    14bc:	03 c0       	rjmp	.+6      	; 0x14c4 <USB_Device_ProcessControlRequest+0x1b0>
					{
						SerialByte >>= 4;
    14be:	82 95       	swap	r24
    14c0:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    14c2:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    14c4:	8f 70       	andi	r24, 0x0F	; 15

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    14c6:	8a 30       	cpi	r24, 0x0A	; 10
    14c8:	18 f0       	brcs	.+6      	; 0x14d0 <USB_Device_ProcessControlRequest+0x1bc>
    14ca:	90 e0       	ldi	r25, 0x00	; 0
    14cc:	c7 96       	adiw	r24, 0x37	; 55
    14ce:	02 c0       	rjmp	.+4      	; 0x14d4 <USB_Device_ProcessControlRequest+0x1c0>
    14d0:	90 e0       	ldi	r25, 0x00	; 0
    14d2:	c0 96       	adiw	r24, 0x30	; 48
    14d4:	fa 01       	movw	r30, r20
    14d6:	81 93       	st	Z+, r24
    14d8:	91 93       	st	Z+, r25
    14da:	af 01       	movw	r20, r30
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    14dc:	2f 5f       	subi	r18, 0xFF	; 255
    14de:	2c 31       	cpi	r18, 0x1C	; 28
    14e0:	19 f7       	brne	.-58     	; 0x14a8 <USB_Device_ProcessControlRequest+0x194>
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    14e2:	7f bf       	out	0x3f, r23	; 63

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();
    14e4:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    14e8:	6a e3       	ldi	r22, 0x3A	; 58
    14ea:	70 e0       	ldi	r23, 0x00	; 0
    14ec:	ce 01       	movw	r24, r28
    14ee:	01 96       	adiw	r24, 0x01	; 1
    14f0:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <Endpoint_Write_Control_Stream_LE>
	Endpoint_ClearOUT();
    14f4:	0e 94 3a 0c 	call	0x1874	; 0x1874 <Endpoint_ClearOUT>
    14f8:	42 c0       	rjmp	.+132    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    14fa:	ae 01       	movw	r20, r28
    14fc:	4f 5f       	subi	r20, 0xFF	; 255
    14fe:	5f 4f       	sbci	r21, 0xFF	; 255
    1500:	60 91 42 95 	lds	r22, 0x9542
    1504:	0e 94 8b 01 	call	0x316	; 0x316 <CALLBACK_USB_GetDescriptor>
    1508:	8c 01       	movw	r16, r24
    150a:	89 2b       	or	r24, r25
    150c:	c1 f1       	breq	.+112    	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
													 )) == NO_DESCRIPTOR)
	{
		return;
	}

	Endpoint_ClearSETUP();
    150e:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    1512:	b8 01       	movw	r22, r16
    1514:	89 81       	ldd	r24, Y+1	; 0x01
    1516:	9a 81       	ldd	r25, Y+2	; 0x02
    1518:	0e 94 88 0b 	call	0x1710	; 0x1710 <Endpoint_Write_Control_PStream_LE>
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
    151c:	0e 94 3a 0c 	call	0x1874	; 0x1874 <Endpoint_ClearOUT>
    1520:	2e c0       	rjmp	.+92     	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    1522:	20 38       	cpi	r18, 0x80	; 128
    1524:	61 f5       	brne	.+88     	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
	EVENT_USB_Device_ConfigurationChanged();
}

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
    1526:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    152a:	80 91 39 95 	lds	r24, 0x9539
    152e:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
	Endpoint_ClearIN();
    1532:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>

	Endpoint_ClearStatusStage();
    1536:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <Endpoint_ClearStatusStage>
    153a:	21 c0       	rjmp	.+66     	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    153c:	21 11       	cpse	r18, r1
    153e:	1f c0       	rjmp	.+62     	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    1540:	80 91 40 95 	lds	r24, 0x9540
    1544:	82 30       	cpi	r24, 0x02	; 2
    1546:	d8 f4       	brcc	.+54     	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
	if ((uint8_t)USB_ControlRequest.wValue > DevDescriptorPtr->NumberOfConfigurations)
	  return;
	#endif
	#endif

	Endpoint_ClearSETUP();
    1548:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    154c:	80 91 40 95 	lds	r24, 0x9540
    1550:	80 93 39 95 	sts	0x9539, r24

	Endpoint_ClearStatusStage();
    1554:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    1558:	80 91 39 95 	lds	r24, 0x9539
    155c:	88 23       	and	r24, r24
    155e:	21 f0       	breq	.+8      	; 0x1568 <USB_Device_ProcessControlRequest+0x254>
	  USB_DeviceState = DEVICE_STATE_Configured;
    1560:	84 e0       	ldi	r24, 0x04	; 4
    1562:	80 93 3d 95 	sts	0x953D, r24
    1566:	09 c0       	rjmp	.+18     	; 0x157a <USB_Device_ProcessControlRequest+0x266>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    1568:	80 91 c3 04 	lds	r24, 0x04C3
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    156c:	81 11       	cpse	r24, r1
    156e:	02 c0       	rjmp	.+4      	; 0x1574 <USB_Device_ProcessControlRequest+0x260>
    1570:	81 e0       	ldi	r24, 0x01	; 1
    1572:	01 c0       	rjmp	.+2      	; 0x1576 <USB_Device_ProcessControlRequest+0x262>
    1574:	84 e0       	ldi	r24, 0x04	; 4
    1576:	80 93 3d 95 	sts	0x953D, r24

	EVENT_USB_Device_ConfigurationChanged();
    157a:	0e 94 23 12 	call	0x2446	; 0x2446 <EVENT_USB_Device_ConfigurationChanged>
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    157e:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <Endpoint_IsSETUPReceived>
    1582:	88 23       	and	r24, r24
    1584:	81 f0       	breq	.+32     	; 0x15a6 <USB_Device_ProcessControlRequest+0x292>
	{
		Endpoint_ClearSETUP();
    1586:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <Endpoint_ClearSETUP>
		Endpoint_StallTransaction();
    158a:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <Endpoint_StallTransaction>
    158e:	0b c0       	rjmp	.+22     	; 0x15a6 <USB_Device_ProcessControlRequest+0x292>
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    1590:	80 91 40 95 	lds	r24, 0x9540
    1594:	81 30       	cpi	r24, 0x01	; 1
    1596:	99 f7       	brne	.-26     	; 0x157e <USB_Device_ProcessControlRequest+0x26a>
    1598:	22 cf       	rjmp	.-444    	; 0x13de <USB_Device_ProcessControlRequest+0xca>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    159a:	80 91 40 95 	lds	r24, 0x9540
    159e:	88 23       	and	r24, r24
    15a0:	09 f4       	brne	.+2      	; 0x15a4 <USB_Device_ProcessControlRequest+0x290>
    15a2:	24 cf       	rjmp	.-440    	; 0x13ec <USB_Device_ProcessControlRequest+0xd8>
    15a4:	48 cf       	rjmp	.-368    	; 0x1436 <USB_Device_ProcessControlRequest+0x122>
	if (Endpoint_IsSETUPReceived())
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    15a6:	ea 96       	adiw	r28, 0x3a	; 58
    15a8:	cd bf       	out	0x3d, r28	; 61
    15aa:	de bf       	out	0x3e, r29	; 62
    15ac:	df 91       	pop	r29
    15ae:	cf 91       	pop	r28
    15b0:	1f 91       	pop	r17
    15b2:	0f 91       	pop	r16
    15b4:	ff 90       	pop	r15
    15b6:	ef 90       	pop	r14
    15b8:	08 95       	ret

000015ba <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    15ba:	08 95       	ret

000015bc <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    15bc:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    15be:	80 91 3d 95 	lds	r24, 0x953D
    15c2:	88 23       	and	r24, r24
    15c4:	69 f0       	breq	.+26     	; 0x15e0 <USB_USBTask+0x24>
			 *  \return Index of the currently selected endpoint.
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				return USB_Endpoint_SelectedEndpoint;
    15c6:	c0 91 4a 95 	lds	r28, 0x954A
	  return;

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>

	if (Endpoint_IsSETUPReceived())
    15d0:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <Endpoint_IsSETUPReceived>
    15d4:	81 11       	cpse	r24, r1
	  USB_Device_ProcessControlRequest();
    15d6:	0e 94 8a 09 	call	0x1314	; 0x1314 <USB_Device_ProcessControlRequest>

	Endpoint_SelectEndpoint(PrevEndpoint);
    15da:	8c 2f       	mov	r24, r28
    15dc:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    15e0:	cf 91       	pop	r28
    15e2:	08 95       	ret

000015e4 <Endpoint_Write_Control_Stream_LE>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    15e4:	cf 92       	push	r12
    15e6:	df 92       	push	r13
    15e8:	ef 92       	push	r14
    15ea:	ff 92       	push	r15
    15ec:	0f 93       	push	r16
    15ee:	1f 93       	push	r17
    15f0:	cf 93       	push	r28
    15f2:	df 93       	push	r29
    15f4:	c8 2e       	mov	r12, r24
    15f6:	d9 2e       	mov	r13, r25
    15f8:	8b 01       	movw	r16, r22
    15fa:	80 91 4a 95 	lds	r24, 0x954A
    15fe:	80 68       	ori	r24, 0x80	; 128
    1600:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
    1604:	c0 91 44 95 	lds	r28, 0x9544
    1608:	d0 91 45 95 	lds	r29, 0x9545
    160c:	c0 17       	cp	r28, r16
    160e:	d1 07       	cpc	r29, r17
    1610:	40 f0       	brcs	.+16     	; 0x1622 <Endpoint_Write_Control_Stream_LE+0x3e>
    1612:	01 15       	cp	r16, r1
    1614:	11 05       	cpc	r17, r1
    1616:	21 f4       	brne	.+8      	; 0x1620 <Endpoint_Write_Control_Stream_LE+0x3c>
    1618:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>
    161c:	e8 01       	movw	r28, r16
    161e:	01 c0       	rjmp	.+2      	; 0x1622 <Endpoint_Write_Control_Stream_LE+0x3e>
    1620:	e8 01       	movw	r28, r16
    1622:	ec 2c       	mov	r14, r12
    1624:	fd 2c       	mov	r15, r13
    1626:	d1 2c       	mov	r13, r1
    1628:	49 c0       	rjmp	.+146    	; 0x16bc <Endpoint_Write_Control_Stream_LE+0xd8>
    162a:	80 91 3d 95 	lds	r24, 0x953D
    162e:	88 23       	and	r24, r24
    1630:	09 f4       	brne	.+2      	; 0x1634 <Endpoint_Write_Control_Stream_LE+0x50>
    1632:	5a c0       	rjmp	.+180    	; 0x16e8 <Endpoint_Write_Control_Stream_LE+0x104>
    1634:	85 30       	cpi	r24, 0x05	; 5
    1636:	09 f4       	brne	.+2      	; 0x163a <Endpoint_Write_Control_Stream_LE+0x56>
    1638:	59 c0       	rjmp	.+178    	; 0x16ec <Endpoint_Write_Control_Stream_LE+0x108>
    163a:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <Endpoint_IsSETUPReceived>
    163e:	81 11       	cpse	r24, r1
    1640:	57 c0       	rjmp	.+174    	; 0x16f0 <Endpoint_Write_Control_Stream_LE+0x10c>
    1642:	0e 94 b6 0c 	call	0x196c	; 0x196c <Endpoint_IsOUTReceived>
    1646:	81 11       	cpse	r24, r1
    1648:	49 c0       	rjmp	.+146    	; 0x16dc <Endpoint_Write_Control_Stream_LE+0xf8>
    164a:	0e 94 a9 0c 	call	0x1952	; 0x1952 <Endpoint_IsINReady>
    164e:	88 23       	and	r24, r24
    1650:	a9 f1       	breq	.+106    	; 0x16bc <Endpoint_Write_Control_Stream_LE+0xd8>
    1652:	80 91 4a 95 	lds	r24, 0x954A
    1656:	88 23       	and	r24, r24
    1658:	74 f4       	brge	.+28     	; 0x1676 <Endpoint_Write_Control_Stream_LE+0x92>
    165a:	e0 91 46 95 	lds	r30, 0x9546
    165e:	f0 91 47 95 	lds	r31, 0x9547
    1662:	ef 5b       	subi	r30, 0xBF	; 191
    1664:	ff 4f       	sbci	r31, 0xFF	; 255
    1666:	00 81       	ld	r16, Z
    1668:	10 e0       	ldi	r17, 0x00	; 0
    166a:	20 97       	sbiw	r28, 0x00	; 0
    166c:	f9 f0       	breq	.+62     	; 0x16ac <Endpoint_Write_Control_Stream_LE+0xc8>
    166e:	08 30       	cpi	r16, 0x08	; 8
    1670:	11 05       	cpc	r17, r1
    1672:	78 f0       	brcs	.+30     	; 0x1692 <Endpoint_Write_Control_Stream_LE+0xae>
    1674:	1b c0       	rjmp	.+54     	; 0x16ac <Endpoint_Write_Control_Stream_LE+0xc8>
    1676:	80 91 46 95 	lds	r24, 0x9546
    167a:	90 91 47 95 	lds	r25, 0x9547
    167e:	fc 01       	movw	r30, r24
    1680:	e0 5c       	subi	r30, 0xC0	; 192
    1682:	ff 4f       	sbci	r31, 0xFF	; 255
    1684:	00 81       	ld	r16, Z
    1686:	31 96       	adiw	r30, 0x01	; 1
    1688:	80 81       	ld	r24, Z
    168a:	10 e0       	ldi	r17, 0x00	; 0
    168c:	08 1b       	sub	r16, r24
    168e:	11 09       	sbc	r17, r1
    1690:	ec cf       	rjmp	.-40     	; 0x166a <Endpoint_Write_Control_Stream_LE+0x86>
    1692:	f7 01       	movw	r30, r14
    1694:	81 91       	ld	r24, Z+
    1696:	7f 01       	movw	r14, r30
    1698:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
    169c:	21 97       	sbiw	r28, 0x01	; 1
    169e:	0f 5f       	subi	r16, 0xFF	; 255
    16a0:	1f 4f       	sbci	r17, 0xFF	; 255
    16a2:	20 97       	sbiw	r28, 0x00	; 0
    16a4:	19 f0       	breq	.+6      	; 0x16ac <Endpoint_Write_Control_Stream_LE+0xc8>
    16a6:	08 30       	cpi	r16, 0x08	; 8
    16a8:	11 05       	cpc	r17, r1
    16aa:	99 f7       	brne	.-26     	; 0x1692 <Endpoint_Write_Control_Stream_LE+0xae>
    16ac:	dd 24       	eor	r13, r13
    16ae:	d3 94       	inc	r13
    16b0:	08 30       	cpi	r16, 0x08	; 8
    16b2:	11 05       	cpc	r17, r1
    16b4:	09 f0       	breq	.+2      	; 0x16b8 <Endpoint_Write_Control_Stream_LE+0xd4>
    16b6:	d1 2c       	mov	r13, r1
    16b8:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>
    16bc:	20 97       	sbiw	r28, 0x00	; 0
    16be:	09 f0       	breq	.+2      	; 0x16c2 <Endpoint_Write_Control_Stream_LE+0xde>
    16c0:	b4 cf       	rjmp	.-152    	; 0x162a <Endpoint_Write_Control_Stream_LE+0x46>
    16c2:	d1 10       	cpse	r13, r1
    16c4:	b2 cf       	rjmp	.-156    	; 0x162a <Endpoint_Write_Control_Stream_LE+0x46>
    16c6:	0a c0       	rjmp	.+20     	; 0x16dc <Endpoint_Write_Control_Stream_LE+0xf8>
    16c8:	80 91 3d 95 	lds	r24, 0x953D
    16cc:	88 23       	and	r24, r24
    16ce:	91 f0       	breq	.+36     	; 0x16f4 <Endpoint_Write_Control_Stream_LE+0x110>
    16d0:	85 30       	cpi	r24, 0x05	; 5
    16d2:	91 f0       	breq	.+36     	; 0x16f8 <Endpoint_Write_Control_Stream_LE+0x114>
    16d4:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <Endpoint_IsSETUPReceived>
    16d8:	81 11       	cpse	r24, r1
    16da:	10 c0       	rjmp	.+32     	; 0x16fc <Endpoint_Write_Control_Stream_LE+0x118>
    16dc:	0e 94 b6 0c 	call	0x196c	; 0x196c <Endpoint_IsOUTReceived>
    16e0:	88 23       	and	r24, r24
    16e2:	91 f3       	breq	.-28     	; 0x16c8 <Endpoint_Write_Control_Stream_LE+0xe4>
    16e4:	80 e0       	ldi	r24, 0x00	; 0
    16e6:	0b c0       	rjmp	.+22     	; 0x16fe <Endpoint_Write_Control_Stream_LE+0x11a>
    16e8:	82 e0       	ldi	r24, 0x02	; 2
    16ea:	09 c0       	rjmp	.+18     	; 0x16fe <Endpoint_Write_Control_Stream_LE+0x11a>
    16ec:	83 e0       	ldi	r24, 0x03	; 3
    16ee:	07 c0       	rjmp	.+14     	; 0x16fe <Endpoint_Write_Control_Stream_LE+0x11a>
    16f0:	81 e0       	ldi	r24, 0x01	; 1
    16f2:	05 c0       	rjmp	.+10     	; 0x16fe <Endpoint_Write_Control_Stream_LE+0x11a>
    16f4:	82 e0       	ldi	r24, 0x02	; 2
    16f6:	03 c0       	rjmp	.+6      	; 0x16fe <Endpoint_Write_Control_Stream_LE+0x11a>
    16f8:	83 e0       	ldi	r24, 0x03	; 3
    16fa:	01 c0       	rjmp	.+2      	; 0x16fe <Endpoint_Write_Control_Stream_LE+0x11a>
    16fc:	81 e0       	ldi	r24, 0x01	; 1
    16fe:	df 91       	pop	r29
    1700:	cf 91       	pop	r28
    1702:	1f 91       	pop	r17
    1704:	0f 91       	pop	r16
    1706:	ff 90       	pop	r15
    1708:	ef 90       	pop	r14
    170a:	df 90       	pop	r13
    170c:	cf 90       	pop	r12
    170e:	08 95       	ret

00001710 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    1710:	df 92       	push	r13
    1712:	ef 92       	push	r14
    1714:	ff 92       	push	r15
    1716:	0f 93       	push	r16
    1718:	1f 93       	push	r17
    171a:	cf 93       	push	r28
    171c:	df 93       	push	r29
    171e:	e8 2e       	mov	r14, r24
    1720:	f9 2e       	mov	r15, r25
    1722:	8b 01       	movw	r16, r22
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    1724:	80 91 4a 95 	lds	r24, 0x954A
    1728:	80 68       	ori	r24, 0x80	; 128
    172a:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>

	if (Length > USB_ControlRequest.wLength)
    172e:	c0 91 44 95 	lds	r28, 0x9544
    1732:	d0 91 45 95 	lds	r29, 0x9545
    1736:	c0 17       	cp	r28, r16
    1738:	d1 07       	cpc	r29, r17
    173a:	40 f0       	brcs	.+16     	; 0x174c <Endpoint_Write_Control_PStream_LE+0x3c>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    173c:	01 15       	cp	r16, r1
    173e:	11 05       	cpc	r17, r1
    1740:	21 f4       	brne	.+8      	; 0x174a <Endpoint_Write_Control_PStream_LE+0x3a>
	  Endpoint_ClearIN();
    1742:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>
    1746:	e8 01       	movw	r28, r16
    1748:	01 c0       	rjmp	.+2      	; 0x174c <Endpoint_Write_Control_PStream_LE+0x3c>
    174a:	e8 01       	movw	r28, r16
    174c:	0e 2d       	mov	r16, r14
    174e:	1f 2d       	mov	r17, r15
    1750:	d1 2c       	mov	r13, r1
    1752:	4e c0       	rjmp	.+156    	; 0x17f0 <Endpoint_Write_Control_PStream_LE+0xe0>

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1754:	80 91 3d 95 	lds	r24, 0x953D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1758:	88 23       	and	r24, r24
    175a:	09 f4       	brne	.+2      	; 0x175e <Endpoint_Write_Control_PStream_LE+0x4e>
    175c:	5f c0       	rjmp	.+190    	; 0x181c <Endpoint_Write_Control_PStream_LE+0x10c>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    175e:	85 30       	cpi	r24, 0x05	; 5
    1760:	09 f4       	brne	.+2      	; 0x1764 <Endpoint_Write_Control_PStream_LE+0x54>
    1762:	5e c0       	rjmp	.+188    	; 0x1820 <Endpoint_Write_Control_PStream_LE+0x110>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1764:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <Endpoint_IsSETUPReceived>
    1768:	81 11       	cpse	r24, r1
    176a:	5c c0       	rjmp	.+184    	; 0x1824 <Endpoint_Write_Control_PStream_LE+0x114>
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    176c:	0e 94 b6 0c 	call	0x196c	; 0x196c <Endpoint_IsOUTReceived>
    1770:	81 11       	cpse	r24, r1
    1772:	4e c0       	rjmp	.+156    	; 0x1810 <Endpoint_Write_Control_PStream_LE+0x100>
		  break;

		if (Endpoint_IsINReady())
    1774:	0e 94 a9 0c 	call	0x1952	; 0x1952 <Endpoint_IsINReady>
    1778:	88 23       	and	r24, r24
    177a:	d1 f1       	breq	.+116    	; 0x17f0 <Endpoint_Write_Control_PStream_LE+0xe0>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    177c:	80 91 4a 95 	lds	r24, 0x954A
    1780:	88 23       	and	r24, r24
    1782:	7c f4       	brge	.+30     	; 0x17a2 <Endpoint_Write_Control_PStream_LE+0x92>
				  return USB_Endpoint_SelectedFIFO->Position;
    1784:	e0 91 46 95 	lds	r30, 0x9546
    1788:	f0 91 47 95 	lds	r31, 0x9547
    178c:	ef 5b       	subi	r30, 0xBF	; 191
    178e:	ff 4f       	sbci	r31, 0xFF	; 255
    1790:	e0 80       	ld	r14, Z
    1792:	f1 2c       	mov	r15, r1
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1794:	20 97       	sbiw	r28, 0x00	; 0
    1796:	19 f1       	breq	.+70     	; 0x17de <Endpoint_Write_Control_PStream_LE+0xce>
    1798:	88 e0       	ldi	r24, 0x08	; 8
    179a:	e8 16       	cp	r14, r24
    179c:	f1 04       	cpc	r15, r1
    179e:	78 f0       	brcs	.+30     	; 0x17be <Endpoint_Write_Control_PStream_LE+0xae>
    17a0:	1e c0       	rjmp	.+60     	; 0x17de <Endpoint_Write_Control_PStream_LE+0xce>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    17a2:	80 91 46 95 	lds	r24, 0x9546
    17a6:	90 91 47 95 	lds	r25, 0x9547
    17aa:	fc 01       	movw	r30, r24
    17ac:	e0 5c       	subi	r30, 0xC0	; 192
    17ae:	ff 4f       	sbci	r31, 0xFF	; 255
    17b0:	e0 80       	ld	r14, Z
    17b2:	31 96       	adiw	r30, 0x01	; 1
    17b4:	80 81       	ld	r24, Z
    17b6:	f1 2c       	mov	r15, r1
    17b8:	e8 1a       	sub	r14, r24
    17ba:	f1 08       	sbc	r15, r1
    17bc:	eb cf       	rjmp	.-42     	; 0x1794 <Endpoint_Write_Control_PStream_LE+0x84>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    17be:	f8 01       	movw	r30, r16
    17c0:	84 91       	lpm	r24, Z
    17c2:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <Endpoint_Write_8>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    17c6:	0f 5f       	subi	r16, 0xFF	; 255
    17c8:	1f 4f       	sbci	r17, 0xFF	; 255
				Length--;
    17ca:	21 97       	sbiw	r28, 0x01	; 1
				BytesInEndpoint++;
    17cc:	ff ef       	ldi	r31, 0xFF	; 255
    17ce:	ef 1a       	sub	r14, r31
    17d0:	ff 0a       	sbc	r15, r31

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    17d2:	20 97       	sbiw	r28, 0x00	; 0
    17d4:	21 f0       	breq	.+8      	; 0x17de <Endpoint_Write_Control_PStream_LE+0xce>
    17d6:	88 e0       	ldi	r24, 0x08	; 8
    17d8:	e8 16       	cp	r14, r24
    17da:	f1 04       	cpc	r15, r1
    17dc:	81 f7       	brne	.-32     	; 0x17be <Endpoint_Write_Control_PStream_LE+0xae>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    17de:	dd 24       	eor	r13, r13
    17e0:	d3 94       	inc	r13
    17e2:	e8 e0       	ldi	r30, 0x08	; 8
    17e4:	ee 16       	cp	r14, r30
    17e6:	f1 04       	cpc	r15, r1
    17e8:	09 f0       	breq	.+2      	; 0x17ec <Endpoint_Write_Control_PStream_LE+0xdc>
    17ea:	d1 2c       	mov	r13, r1
			Endpoint_ClearIN();
    17ec:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    17f0:	20 97       	sbiw	r28, 0x00	; 0
    17f2:	09 f0       	breq	.+2      	; 0x17f6 <Endpoint_Write_Control_PStream_LE+0xe6>
    17f4:	af cf       	rjmp	.-162    	; 0x1754 <Endpoint_Write_Control_PStream_LE+0x44>
    17f6:	d1 10       	cpse	r13, r1
    17f8:	ad cf       	rjmp	.-166    	; 0x1754 <Endpoint_Write_Control_PStream_LE+0x44>
    17fa:	0a c0       	rjmp	.+20     	; 0x1810 <Endpoint_Write_Control_PStream_LE+0x100>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    17fc:	80 91 3d 95 	lds	r24, 0x953D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1800:	88 23       	and	r24, r24
    1802:	91 f0       	breq	.+36     	; 0x1828 <Endpoint_Write_Control_PStream_LE+0x118>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1804:	85 30       	cpi	r24, 0x05	; 5
    1806:	91 f0       	breq	.+36     	; 0x182c <Endpoint_Write_Control_PStream_LE+0x11c>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1808:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <Endpoint_IsSETUPReceived>
    180c:	81 11       	cpse	r24, r1
    180e:	10 c0       	rjmp	.+32     	; 0x1830 <Endpoint_Write_Control_PStream_LE+0x120>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1810:	0e 94 b6 0c 	call	0x196c	; 0x196c <Endpoint_IsOUTReceived>
    1814:	88 23       	and	r24, r24
    1816:	91 f3       	breq	.-28     	; 0x17fc <Endpoint_Write_Control_PStream_LE+0xec>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1818:	80 e0       	ldi	r24, 0x00	; 0
    181a:	0b c0       	rjmp	.+22     	; 0x1832 <Endpoint_Write_Control_PStream_LE+0x122>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    181c:	82 e0       	ldi	r24, 0x02	; 2
    181e:	09 c0       	rjmp	.+18     	; 0x1832 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1820:	83 e0       	ldi	r24, 0x03	; 3
    1822:	07 c0       	rjmp	.+14     	; 0x1832 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1824:	81 e0       	ldi	r24, 0x01	; 1
    1826:	05 c0       	rjmp	.+10     	; 0x1832 <Endpoint_Write_Control_PStream_LE+0x122>
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1828:	82 e0       	ldi	r24, 0x02	; 2
    182a:	03 c0       	rjmp	.+6      	; 0x1832 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    182c:	83 e0       	ldi	r24, 0x03	; 3
    182e:	01 c0       	rjmp	.+2      	; 0x1832 <Endpoint_Write_Control_PStream_LE+0x122>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1830:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1832:	df 91       	pop	r29
    1834:	cf 91       	pop	r28
    1836:	1f 91       	pop	r17
    1838:	0f 91       	pop	r16
    183a:	ff 90       	pop	r15
    183c:	ef 90       	pop	r14
    183e:	df 90       	pop	r13
    1840:	08 95       	ret

00001842 <Endpoint_ClearIN>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_ClearIN(void)
{
	USB_Endpoint_SelectedHandle->CNT     = USB_Endpoint_SelectedFIFO->Position;
    1842:	e0 91 48 95 	lds	r30, 0x9548
    1846:	f0 91 49 95 	lds	r31, 0x9549
    184a:	a0 91 46 95 	lds	r26, 0x9546
    184e:	b0 91 47 95 	lds	r27, 0x9547
    1852:	af 5b       	subi	r26, 0xBF	; 191
    1854:	bf 4f       	sbci	r27, 0xFF	; 255
    1856:	8c 91       	ld	r24, X
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	82 83       	std	Z+2, r24	; 0x02
    185c:	93 83       	std	Z+3, r25	; 0x03
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    185e:	80 81       	ld	r24, Z
    1860:	8d 79       	andi	r24, 0x9D	; 157
    1862:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1864:	e0 91 46 95 	lds	r30, 0x9546
    1868:	f0 91 47 95 	lds	r31, 0x9547
    186c:	ef 5b       	subi	r30, 0xBF	; 191
    186e:	ff 4f       	sbci	r31, 0xFF	; 255
    1870:	10 82       	st	Z, r1
    1872:	08 95       	ret

00001874 <Endpoint_ClearOUT>:
}

void Endpoint_ClearOUT(void)
{
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    1874:	e0 91 48 95 	lds	r30, 0x9548
    1878:	f0 91 49 95 	lds	r31, 0x9549
    187c:	80 81       	ld	r24, Z
    187e:	8d 79       	andi	r24, 0x9D	; 157
    1880:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1882:	e0 91 46 95 	lds	r30, 0x9546
    1886:	f0 91 47 95 	lds	r31, 0x9547
    188a:	ef 5b       	subi	r30, 0xBF	; 191
    188c:	ff 4f       	sbci	r31, 0xFF	; 255
    188e:	10 82       	st	Z, r1
    1890:	08 95       	ret

00001892 <Endpoint_Read_8>:
	}
}

uint8_t Endpoint_Read_8(void)
{
	return USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++];
    1892:	80 91 46 95 	lds	r24, 0x9546
    1896:	90 91 47 95 	lds	r25, 0x9547
    189a:	fc 01       	movw	r30, r24
    189c:	ef 5b       	subi	r30, 0xBF	; 191
    189e:	ff 4f       	sbci	r31, 0xFF	; 255
    18a0:	20 81       	ld	r18, Z
    18a2:	31 e0       	ldi	r19, 0x01	; 1
    18a4:	32 0f       	add	r19, r18
    18a6:	30 83       	st	Z, r19
    18a8:	fc 01       	movw	r30, r24
    18aa:	e2 0f       	add	r30, r18
    18ac:	f1 1d       	adc	r31, r1
    18ae:	80 81       	ld	r24, Z
}
    18b0:	08 95       	ret

000018b2 <Endpoint_Write_8>:

void Endpoint_Write_8(const uint8_t Data)
{
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
    18b2:	20 91 46 95 	lds	r18, 0x9546
    18b6:	30 91 47 95 	lds	r19, 0x9547
    18ba:	f9 01       	movw	r30, r18
    18bc:	ef 5b       	subi	r30, 0xBF	; 191
    18be:	ff 4f       	sbci	r31, 0xFF	; 255
    18c0:	90 81       	ld	r25, Z
    18c2:	41 e0       	ldi	r20, 0x01	; 1
    18c4:	49 0f       	add	r20, r25
    18c6:	40 83       	st	Z, r20
    18c8:	f9 01       	movw	r30, r18
    18ca:	e9 0f       	add	r30, r25
    18cc:	f1 1d       	adc	r31, r1
    18ce:	80 83       	st	Z, r24
    18d0:	08 95       	ret

000018d2 <Endpoint_SelectEndpoint>:

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);

	USB_Endpoint_SelectedEndpoint = Address;
    18d2:	80 93 4a 95 	sts	0x954A, r24
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
}

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);
    18d6:	28 2f       	mov	r18, r24
    18d8:	2f 70       	andi	r18, 0x0F	; 15

	USB_Endpoint_SelectedEndpoint = Address;

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
    18da:	30 e0       	ldi	r19, 0x00	; 0
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;
    18dc:	40 91 c6 04 	lds	r20, 0x04C6
    18e0:	50 91 c7 04 	lds	r21, 0x04C7

	if (Address & ENDPOINT_DIR_IN)
    18e4:	88 23       	and	r24, r24
    18e6:	e4 f4       	brge	.+56     	; 0x1920 <Endpoint_SelectEndpoint+0x4e>
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
    18e8:	64 e8       	ldi	r22, 0x84	; 132
    18ea:	62 9f       	mul	r22, r18
    18ec:	c0 01       	movw	r24, r0
    18ee:	63 9f       	mul	r22, r19
    18f0:	90 0d       	add	r25, r0
    18f2:	11 24       	eor	r1, r1
    18f4:	83 57       	subi	r24, 0x73	; 115
    18f6:	9a 46       	sbci	r25, 0x6A	; 106
    18f8:	80 93 46 95 	sts	0x9546, r24
    18fc:	90 93 47 95 	sts	0x9547, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].IN;
    1900:	c9 01       	movw	r24, r18
    1902:	82 95       	swap	r24
    1904:	92 95       	swap	r25
    1906:	90 7f       	andi	r25, 0xF0	; 240
    1908:	98 27       	eor	r25, r24
    190a:	80 7f       	andi	r24, 0xF0	; 240
    190c:	98 27       	eor	r25, r24
    190e:	08 96       	adiw	r24, 0x08	; 8
    1910:	9a 01       	movw	r18, r20
    1912:	28 0f       	add	r18, r24
    1914:	39 1f       	adc	r19, r25
    1916:	20 93 48 95 	sts	0x9548, r18
    191a:	30 93 49 95 	sts	0x9549, r19
    191e:	08 95       	ret
	}
	else
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->OUT;
    1920:	64 e8       	ldi	r22, 0x84	; 132
    1922:	62 9f       	mul	r22, r18
    1924:	c0 01       	movw	r24, r0
    1926:	63 9f       	mul	r22, r19
    1928:	90 0d       	add	r25, r0
    192a:	11 24       	eor	r1, r1
    192c:	85 5b       	subi	r24, 0xB5	; 181
    192e:	9a 46       	sbci	r25, 0x6A	; 106
    1930:	80 93 46 95 	sts	0x9546, r24
    1934:	90 93 47 95 	sts	0x9547, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].OUT;
    1938:	22 95       	swap	r18
    193a:	32 95       	swap	r19
    193c:	30 7f       	andi	r19, 0xF0	; 240
    193e:	32 27       	eor	r19, r18
    1940:	20 7f       	andi	r18, 0xF0	; 240
    1942:	32 27       	eor	r19, r18
    1944:	24 0f       	add	r18, r20
    1946:	35 1f       	adc	r19, r21
    1948:	20 93 48 95 	sts	0x9548, r18
    194c:	30 93 49 95 	sts	0x9549, r19
    1950:	08 95       	ret

00001952 <Endpoint_IsINReady>:
volatile USB_EP_t*        USB_Endpoint_SelectedHandle;
volatile Endpoint_FIFO_t* USB_Endpoint_SelectedFIFO;

bool Endpoint_IsINReady(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    1952:	80 91 4a 95 	lds	r24, 0x954A
    1956:	80 68       	ori	r24, 0x80	; 128
    1958:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>

	return ((USB_Endpoint_SelectedHandle->STATUS & USB_EP_BUSNACK0_bm) ? true : false);
    195c:	e0 91 48 95 	lds	r30, 0x9548
    1960:	f0 91 49 95 	lds	r31, 0x9549
    1964:	80 81       	ld	r24, Z
}
    1966:	86 95       	lsr	r24
    1968:	81 70       	andi	r24, 0x01	; 1
    196a:	08 95       	ret

0000196c <Endpoint_IsOUTReceived>:

bool Endpoint_IsOUTReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    196c:	80 91 4a 95 	lds	r24, 0x954A
    1970:	8f 77       	andi	r24, 0x7F	; 127
    1972:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_TRNCOMPL0_bm)
    1976:	e0 91 48 95 	lds	r30, 0x9548
    197a:	f0 91 49 95 	lds	r31, 0x9549
    197e:	80 81       	ld	r24, Z
    1980:	85 ff       	sbrs	r24, 5
    1982:	0c c0       	rjmp	.+24     	; 0x199c <Endpoint_IsOUTReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    1984:	80 91 46 95 	lds	r24, 0x9546
    1988:	90 91 47 95 	lds	r25, 0x9547
    198c:	22 81       	ldd	r18, Z+2	; 0x02
    198e:	33 81       	ldd	r19, Z+3	; 0x03
    1990:	fc 01       	movw	r30, r24
    1992:	e0 5c       	subi	r30, 0xC0	; 192
    1994:	ff 4f       	sbci	r31, 0xFF	; 255
    1996:	20 83       	st	Z, r18
		return true;
    1998:	81 e0       	ldi	r24, 0x01	; 1
    199a:	08 95       	ret
	}

	return false;
    199c:	80 e0       	ldi	r24, 0x00	; 0
}
    199e:	08 95       	ret

000019a0 <Endpoint_IsSETUPReceived>:

bool Endpoint_IsSETUPReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    19a0:	80 91 4a 95 	lds	r24, 0x954A
    19a4:	8f 77       	andi	r24, 0x7F	; 127
    19a6:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_SETUP_bm)
    19aa:	e0 91 48 95 	lds	r30, 0x9548
    19ae:	f0 91 49 95 	lds	r31, 0x9549
    19b2:	80 81       	ld	r24, Z
    19b4:	84 ff       	sbrs	r24, 4
    19b6:	0c c0       	rjmp	.+24     	; 0x19d0 <Endpoint_IsSETUPReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    19b8:	80 91 46 95 	lds	r24, 0x9546
    19bc:	90 91 47 95 	lds	r25, 0x9547
    19c0:	22 81       	ldd	r18, Z+2	; 0x02
    19c2:	33 81       	ldd	r19, Z+3	; 0x03
    19c4:	fc 01       	movw	r30, r24
    19c6:	e0 5c       	subi	r30, 0xC0	; 192
    19c8:	ff 4f       	sbci	r31, 0xFF	; 255
    19ca:	20 83       	st	Z, r18
		return true;
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	08 95       	ret
	}

	return false;
    19d0:	80 e0       	ldi	r24, 0x00	; 0
}
    19d2:	08 95       	ret

000019d4 <Endpoint_ClearSETUP>:

void Endpoint_ClearSETUP(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    19d4:	80 91 4a 95 	lds	r24, 0x954A
    19d8:	8f 77       	andi	r24, 0x7F	; 127
    19da:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_SETUP_bm | USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    19de:	e0 91 48 95 	lds	r30, 0x9548
    19e2:	f0 91 49 95 	lds	r31, 0x9549
    19e6:	80 81       	ld	r24, Z
    19e8:	8d 78       	andi	r24, 0x8D	; 141
    19ea:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    19ec:	e0 91 48 95 	lds	r30, 0x9548
    19f0:	f0 91 49 95 	lds	r31, 0x9549
    19f4:	80 81       	ld	r24, Z
    19f6:	81 60       	ori	r24, 0x01	; 1
    19f8:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    19fa:	e0 91 46 95 	lds	r30, 0x9546
    19fe:	f0 91 47 95 	lds	r31, 0x9547
    1a02:	ef 5b       	subi	r30, 0xBF	; 191
    1a04:	ff 4f       	sbci	r31, 0xFF	; 255
    1a06:	10 82       	st	Z, r1

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    1a08:	80 91 4a 95 	lds	r24, 0x954A
    1a0c:	80 68       	ori	r24, 0x80	; 128
    1a0e:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    1a12:	e0 91 48 95 	lds	r30, 0x9548
    1a16:	f0 91 49 95 	lds	r31, 0x9549
    1a1a:	80 81       	ld	r24, Z
    1a1c:	81 60       	ori	r24, 0x01	; 1
    1a1e:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1a20:	e0 91 46 95 	lds	r30, 0x9546
    1a24:	f0 91 47 95 	lds	r31, 0x9547
    1a28:	ef 5b       	subi	r30, 0xBF	; 191
    1a2a:	ff 4f       	sbci	r31, 0xFF	; 255
    1a2c:	10 82       	st	Z, r1
    1a2e:	08 95       	ret

00001a30 <Endpoint_StallTransaction>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_StallTransaction(void)
{
	USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    1a30:	e0 91 48 95 	lds	r30, 0x9548
    1a34:	f0 91 49 95 	lds	r31, 0x9549
    1a38:	81 81       	ldd	r24, Z+1	; 0x01
    1a3a:	84 60       	ori	r24, 0x04	; 4
    1a3c:	81 83       	std	Z+1, r24	; 0x01

	if ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_TYPE_gm) == USB_EP_TYPE_CONTROL_gc)
    1a3e:	e0 91 48 95 	lds	r30, 0x9548
    1a42:	f0 91 49 95 	lds	r31, 0x9549
    1a46:	81 81       	ldd	r24, Z+1	; 0x01
    1a48:	80 7c       	andi	r24, 0xC0	; 192
    1a4a:	80 34       	cpi	r24, 0x40	; 64
    1a4c:	61 f4       	brne	.+24     	; 0x1a66 <Endpoint_StallTransaction+0x36>
	{
		Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint ^ ENDPOINT_DIR_IN);
    1a4e:	80 91 4a 95 	lds	r24, 0x954A
    1a52:	80 58       	subi	r24, 0x80	; 128
    1a54:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>
		USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    1a58:	e0 91 48 95 	lds	r30, 0x9548
    1a5c:	f0 91 49 95 	lds	r31, 0x9549
    1a60:	81 81       	ldd	r24, Z+1	; 0x01
    1a62:	84 60       	ori	r24, 0x04	; 4
    1a64:	81 83       	std	Z+1, r24	; 0x01
    1a66:	08 95       	ret

00001a68 <Endpoint_ConfigureEndpoint_PRV>:
}

bool Endpoint_ConfigureEndpoint_PRV(const uint8_t Address,
                                    const uint8_t Config,
                                    const uint8_t Size)
{
    1a68:	1f 93       	push	r17
    1a6a:	cf 93       	push	r28
    1a6c:	df 93       	push	r29
    1a6e:	d8 2f       	mov	r29, r24
    1a70:	16 2f       	mov	r17, r22
    1a72:	c4 2f       	mov	r28, r20
	Endpoint_SelectEndpoint(Address);
    1a74:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <Endpoint_SelectEndpoint>

	USB_Endpoint_SelectedHandle->CTRL    = 0;
    1a78:	e0 91 48 95 	lds	r30, 0x9548
    1a7c:	f0 91 49 95 	lds	r31, 0x9549
    1a80:	11 82       	std	Z+1, r1	; 0x01
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    1a82:	e0 91 48 95 	lds	r30, 0x9548
    1a86:	f0 91 49 95 	lds	r31, 0x9549
    1a8a:	dd 23       	and	r29, r29
    1a8c:	a4 f0       	brlt	.+40     	; 0x1ab6 <Endpoint_ConfigureEndpoint_PRV+0x4e>
    1a8e:	10 82       	st	Z, r1
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    1a90:	e0 91 48 95 	lds	r30, 0x9548
    1a94:	f0 91 49 95 	lds	r31, 0x9549
    1a98:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    1a9a:	e0 91 48 95 	lds	r30, 0x9548
    1a9e:	f0 91 49 95 	lds	r31, 0x9549
    1aa2:	12 82       	std	Z+2, r1	; 0x02
    1aa4:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    1aa6:	80 91 46 95 	lds	r24, 0x9546
    1aaa:	90 91 47 95 	lds	r25, 0x9547
    1aae:	84 83       	std	Z+4, r24	; 0x04
    1ab0:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    1ab2:	40 e0       	ldi	r20, 0x00	; 0
    1ab4:	14 c0       	rjmp	.+40     	; 0x1ade <Endpoint_ConfigureEndpoint_PRV+0x76>
                                    const uint8_t Size)
{
	Endpoint_SelectEndpoint(Address);

	USB_Endpoint_SelectedHandle->CTRL    = 0;
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    1ab6:	82 e0       	ldi	r24, 0x02	; 2
    1ab8:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    1aba:	e0 91 48 95 	lds	r30, 0x9548
    1abe:	f0 91 49 95 	lds	r31, 0x9549
    1ac2:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    1ac4:	e0 91 48 95 	lds	r30, 0x9548
    1ac8:	f0 91 49 95 	lds	r31, 0x9549
    1acc:	12 82       	std	Z+2, r1	; 0x02
    1ace:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    1ad0:	80 91 46 95 	lds	r24, 0x9546
    1ad4:	90 91 47 95 	lds	r25, 0x9547
    1ad8:	84 83       	std	Z+4, r24	; 0x04
    1ada:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    1adc:	4c 2f       	mov	r20, r28
    1ade:	fc 01       	movw	r30, r24
    1ae0:	e0 5c       	subi	r30, 0xC0	; 192
    1ae2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ae4:	40 83       	st	Z, r20
	USB_Endpoint_SelectedFIFO->Position  = 0;
    1ae6:	31 96       	adiw	r30, 0x01	; 1
    1ae8:	10 82       	st	Z, r1

	return true;
}
    1aea:	81 e0       	ldi	r24, 0x01	; 1
    1aec:	df 91       	pop	r29
    1aee:	cf 91       	pop	r28
    1af0:	1f 91       	pop	r17
    1af2:	08 95       	ret

00001af4 <Endpoint_ConfigureEndpointTable>:
	}
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    1af4:	af 92       	push	r10
    1af6:	bf 92       	push	r11
    1af8:	cf 92       	push	r12
    1afa:	df 92       	push	r13
    1afc:	ef 92       	push	r14
    1afe:	ff 92       	push	r15
    1b00:	0f 93       	push	r16
    1b02:	1f 93       	push	r17
    1b04:	cf 93       	push	r28
    1b06:	df 93       	push	r29
	for (uint8_t i = 0; i < Entries; i++)
    1b08:	66 23       	and	r22, r22
    1b0a:	09 f4       	brne	.+2      	; 0x1b0e <Endpoint_ConfigureEndpointTable+0x1a>
    1b0c:	57 c0       	rjmp	.+174    	; 0x1bbc <Endpoint_ConfigureEndpointTable+0xc8>
    1b0e:	a6 2e       	mov	r10, r22
    1b10:	7c 01       	movw	r14, r24
    1b12:	8c 01       	movw	r16, r24
    1b14:	84 e0       	ldi	r24, 0x04	; 4
    1b16:	e8 0e       	add	r14, r24
    1b18:	f1 1c       	adc	r15, r1
    1b1a:	b1 2c       	mov	r11, r1
	{
		if (!(Table[i].Address))
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	c0 80       	ld	r12, Z
    1b20:	cc 20       	and	r12, r12
    1b22:	09 f4       	brne	.+2      	; 0x1b26 <Endpoint_ConfigureEndpointTable+0x32>
    1b24:	41 c0       	rjmp	.+130    	; 0x1ba8 <Endpoint_ConfigureEndpointTable+0xb4>
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    1b26:	c1 81       	ldd	r28, Z+1	; 0x01
    1b28:	d2 81       	ldd	r29, Z+2	; 0x02
    1b2a:	f7 01       	movw	r30, r14
    1b2c:	31 97       	sbiw	r30, 0x01	; 1
    1b2e:	80 81       	ld	r24, Z
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    1b30:	f7 01       	movw	r30, r14
    1b32:	90 81       	ld	r25, Z
    1b34:	92 30       	cpi	r25, 0x02	; 2
    1b36:	10 f4       	brcc	.+4      	; 0x1b3c <Endpoint_ConfigureEndpointTable+0x48>
    1b38:	48 e0       	ldi	r20, 0x08	; 8
    1b3a:	01 c0       	rjmp	.+2      	; 0x1b3e <Endpoint_ConfigureEndpointTable+0x4a>
    1b3c:	48 e1       	ldi	r20, 0x18	; 24
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    1b3e:	c9 30       	cpi	r28, 0x09	; 9
    1b40:	d1 05       	cpc	r29, r1
    1b42:	50 f0       	brcs	.+20     	; 0x1b58 <Endpoint_ConfigureEndpointTable+0x64>
    1b44:	28 e0       	ldi	r18, 0x08	; 8
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	90 e0       	ldi	r25, 0x00	; 0
				{
					MaskVal++;
    1b4a:	9f 5f       	subi	r25, 0xFF	; 255
					CheckBytes <<= 1;
    1b4c:	22 0f       	add	r18, r18
    1b4e:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    1b50:	2c 17       	cp	r18, r28
    1b52:	3d 07       	cpc	r19, r29
    1b54:	d0 f3       	brcs	.-12     	; 0x1b4a <Endpoint_ConfigureEndpointTable+0x56>
    1b56:	01 c0       	rjmp	.+2      	; 0x1b5a <Endpoint_ConfigureEndpointTable+0x66>
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    1b58:	90 e0       	ldi	r25, 0x00	; 0
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    1b5a:	94 2b       	or	r25, r20

				if ((Address & ENDPOINT_EPNUM_MASK) >= ENDPOINT_TOTAL_ENDPOINTS)
    1b5c:	2c 2d       	mov	r18, r12
    1b5e:	2f 70       	andi	r18, 0x0F	; 15
    1b60:	30 e0       	ldi	r19, 0x00	; 0
    1b62:	25 30       	cpi	r18, 0x05	; 5
    1b64:	31 05       	cpc	r19, r1
    1b66:	64 f5       	brge	.+88     	; 0x1bc0 <Endpoint_ConfigureEndpointTable+0xcc>
				  return false;

				// TODO - Fix once limitations are lifted
				EPConfigMask &= ~USB_EP_PINGPONG_bm;
    1b68:	9f 7e       	andi	r25, 0xEF	; 239
				if (Size > 64)
    1b6a:	c1 34       	cpi	r28, 0x41	; 65
    1b6c:	d1 05       	cpc	r29, r1
    1b6e:	50 f5       	brcc	.+84     	; 0x1bc4 <Endpoint_ConfigureEndpointTable+0xd0>
				  return false;

				switch (Type)
    1b70:	88 23       	and	r24, r24
    1b72:	19 f0       	breq	.+6      	; 0x1b7a <Endpoint_ConfigureEndpointTable+0x86>
    1b74:	81 30       	cpi	r24, 0x01	; 1
    1b76:	21 f0       	breq	.+8      	; 0x1b80 <Endpoint_ConfigureEndpointTable+0x8c>
    1b78:	06 c0       	rjmp	.+12     	; 0x1b86 <Endpoint_ConfigureEndpointTable+0x92>
				{
					case EP_TYPE_CONTROL:
						EPConfigMask |= USB_EP_TYPE_CONTROL_gc;
    1b7a:	90 64       	ori	r25, 0x40	; 64
    1b7c:	d9 2e       	mov	r13, r25
    1b7e:	07 c0       	rjmp	.+14     	; 0x1b8e <Endpoint_ConfigureEndpointTable+0x9a>
						break;
					case EP_TYPE_ISOCHRONOUS:
						EPConfigMask |= USB_EP_TYPE_ISOCHRONOUS_gc;
    1b80:	90 6c       	ori	r25, 0xC0	; 192
    1b82:	d9 2e       	mov	r13, r25
    1b84:	0a c0       	rjmp	.+20     	; 0x1b9a <Endpoint_ConfigureEndpointTable+0xa6>
						break;
					default:
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
    1b86:	90 68       	ori	r25, 0x80	; 128
    1b88:	d9 2e       	mov	r13, r25
						break;
				}

				if (Type == EP_TYPE_CONTROL)
    1b8a:	81 11       	cpse	r24, r1
    1b8c:	06 c0       	rjmp	.+12     	; 0x1b9a <Endpoint_ConfigureEndpointTable+0xa6>
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    1b8e:	4c 2f       	mov	r20, r28
    1b90:	6d 2d       	mov	r22, r13
    1b92:	80 e8       	ldi	r24, 0x80	; 128
    1b94:	8c 0d       	add	r24, r12
    1b96:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    1b9a:	4c 2f       	mov	r20, r28
    1b9c:	6d 2d       	mov	r22, r13
    1b9e:	8c 2d       	mov	r24, r12
    1ba0:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <Endpoint_ConfigureEndpoint_PRV>
    1ba4:	88 23       	and	r24, r24
    1ba6:	79 f0       	breq	.+30     	; 0x1bc6 <Endpoint_ConfigureEndpointTable+0xd2>
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    1ba8:	b3 94       	inc	r11
    1baa:	0b 5f       	subi	r16, 0xFB	; 251
    1bac:	1f 4f       	sbci	r17, 0xFF	; 255
    1bae:	f5 e0       	ldi	r31, 0x05	; 5
    1bb0:	ef 0e       	add	r14, r31
    1bb2:	f1 1c       	adc	r15, r1
    1bb4:	ba 10       	cpse	r11, r10
    1bb6:	b2 cf       	rjmp	.-156    	; 0x1b1c <Endpoint_ConfigureEndpointTable+0x28>
		{
			return false;
		}
	}

	return true;
    1bb8:	81 e0       	ldi	r24, 0x01	; 1
    1bba:	05 c0       	rjmp	.+10     	; 0x1bc6 <Endpoint_ConfigureEndpointTable+0xd2>
    1bbc:	81 e0       	ldi	r24, 0x01	; 1
    1bbe:	03 c0       	rjmp	.+6      	; 0x1bc6 <Endpoint_ConfigureEndpointTable+0xd2>
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		{
			return false;
    1bc0:	80 e0       	ldi	r24, 0x00	; 0
    1bc2:	01 c0       	rjmp	.+2      	; 0x1bc6 <Endpoint_ConfigureEndpointTable+0xd2>
    1bc4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return true;
}
    1bc6:	df 91       	pop	r29
    1bc8:	cf 91       	pop	r28
    1bca:	1f 91       	pop	r17
    1bcc:	0f 91       	pop	r16
    1bce:	ff 90       	pop	r15
    1bd0:	ef 90       	pop	r14
    1bd2:	df 90       	pop	r13
    1bd4:	cf 90       	pop	r12
    1bd6:	bf 90       	pop	r11
    1bd8:	af 90       	pop	r10
    1bda:	08 95       	ret

00001bdc <Endpoint_ClearEndpoints>:

	return true;
}

void Endpoint_ClearEndpoints(void)
{
    1bdc:	20 e0       	ldi	r18, 0x00	; 0
    1bde:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
    1be0:	a0 ec       	ldi	r26, 0xC0	; 192
    1be2:	b4 e0       	ldi	r27, 0x04	; 4
    1be4:	16 96       	adiw	r26, 0x06	; 6
    1be6:	ed 91       	ld	r30, X+
    1be8:	fc 91       	ld	r31, X
    1bea:	17 97       	sbiw	r26, 0x07	; 7
    1bec:	c9 01       	movw	r24, r18
    1bee:	82 95       	swap	r24
    1bf0:	92 95       	swap	r25
    1bf2:	90 7f       	andi	r25, 0xF0	; 240
    1bf4:	98 27       	eor	r25, r24
    1bf6:	80 7f       	andi	r24, 0xF0	; 240
    1bf8:	98 27       	eor	r25, r24
    1bfa:	e8 0f       	add	r30, r24
    1bfc:	f9 1f       	adc	r31, r25
    1bfe:	11 86       	std	Z+9, r1	; 0x09
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
    1c00:	16 96       	adiw	r26, 0x06	; 6
    1c02:	4d 91       	ld	r20, X+
    1c04:	5c 91       	ld	r21, X
    1c06:	17 97       	sbiw	r26, 0x07	; 7
    1c08:	fa 01       	movw	r30, r20
    1c0a:	e8 0f       	add	r30, r24
    1c0c:	f9 1f       	adc	r31, r25
    1c0e:	11 82       	std	Z+1, r1	; 0x01
    1c10:	2f 5f       	subi	r18, 0xFF	; 255
    1c12:	3f 4f       	sbci	r19, 0xFF	; 255
	return true;
}

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1c14:	25 30       	cpi	r18, 0x05	; 5
    1c16:	31 05       	cpc	r19, r1
    1c18:	29 f7       	brne	.-54     	; 0x1be4 <Endpoint_ClearEndpoints+0x8>
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
	}
}
    1c1a:	08 95       	ret

00001c1c <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1c1c:	80 91 3e 95 	lds	r24, 0x953E
    1c20:	88 23       	and	r24, r24
    1c22:	84 f4       	brge	.+32     	; 0x1c44 <Endpoint_ClearStatusStage+0x28>
    1c24:	04 c0       	rjmp	.+8      	; 0x1c2e <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c26:	80 91 3d 95 	lds	r24, 0x953D
    1c2a:	88 23       	and	r24, r24
    1c2c:	89 f0       	breq	.+34     	; 0x1c50 <Endpoint_ClearStatusStage+0x34>

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1c2e:	0e 94 b6 0c 	call	0x196c	; 0x196c <Endpoint_IsOUTReceived>
    1c32:	88 23       	and	r24, r24
    1c34:	c1 f3       	breq	.-16     	; 0x1c26 <Endpoint_ClearStatusStage+0xa>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearOUT();
    1c36:	0e 94 3a 0c 	call	0x1874	; 0x1874 <Endpoint_ClearOUT>
    1c3a:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c3c:	80 91 3d 95 	lds	r24, 0x953D
    1c40:	88 23       	and	r24, r24
    1c42:	31 f0       	breq	.+12     	; 0x1c50 <Endpoint_ClearStatusStage+0x34>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1c44:	0e 94 a9 0c 	call	0x1952	; 0x1952 <Endpoint_IsINReady>
    1c48:	88 23       	and	r24, r24
    1c4a:	c1 f3       	breq	.-16     	; 0x1c3c <Endpoint_ClearStatusStage+0x20>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearIN();
    1c4c:	0e 94 21 0c 	call	0x1842	; 0x1842 <Endpoint_ClearIN>
    1c50:	08 95       	ret

00001c52 <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    1c52:	ff 92       	push	r15
    1c54:	0f 93       	push	r16
    1c56:	1f 93       	push	r17
    1c58:	cf 93       	push	r28
    1c5a:	df 93       	push	r29
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return ((USB_EndpointTable_t*)USB.EPPTR)->FrameNum;
    1c5c:	e0 91 c6 04 	lds	r30, 0x04C6
    1c60:	f0 91 c7 04 	lds	r31, 0x04C7
    1c64:	e0 5b       	subi	r30, 0xB0	; 176
    1c66:	ff 4f       	sbci	r31, 0xFF	; 255
    1c68:	c0 81       	ld	r28, Z
    1c6a:	d1 81       	ldd	r29, Z+1	; 0x01
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    1c6c:	0f 2e       	mov	r0, r31
    1c6e:	f4 e6       	ldi	r31, 0x64	; 100
    1c70:	ff 2e       	mov	r15, r31
    1c72:	f0 2d       	mov	r31, r0
    1c74:	00 ec       	ldi	r16, 0xC0	; 192
    1c76:	14 e0       	ldi	r17, 0x04	; 4
    1c78:	02 c0       	rjmp	.+4      	; 0x1c7e <Endpoint_WaitUntilReady+0x2c>

		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1c7a:	f2 2e       	mov	r15, r18
    1c7c:	ec 01       	movw	r28, r24
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN);
    1c7e:	80 91 4a 95 	lds	r24, 0x954A

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    1c82:	88 23       	and	r24, r24
    1c84:	2c f4       	brge	.+10     	; 0x1c90 <Endpoint_WaitUntilReady+0x3e>
		{
			if (Endpoint_IsINReady())
    1c86:	0e 94 a9 0c 	call	0x1952	; 0x1952 <Endpoint_IsINReady>
    1c8a:	88 23       	and	r24, r24
    1c8c:	29 f0       	breq	.+10     	; 0x1c98 <Endpoint_WaitUntilReady+0x46>
    1c8e:	23 c0       	rjmp	.+70     	; 0x1cd6 <Endpoint_WaitUntilReady+0x84>
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1c90:	0e 94 b6 0c 	call	0x196c	; 0x196c <Endpoint_IsOUTReceived>
    1c94:	81 11       	cpse	r24, r1
    1c96:	21 c0       	rjmp	.+66     	; 0x1cda <Endpoint_WaitUntilReady+0x88>
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1c98:	80 91 3d 95 	lds	r24, 0x953D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1c9c:	88 23       	and	r24, r24
    1c9e:	f9 f0       	breq	.+62     	; 0x1cde <Endpoint_WaitUntilReady+0x8c>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1ca0:	85 30       	cpi	r24, 0x05	; 5
    1ca2:	f9 f0       	breq	.+62     	; 0x1ce2 <Endpoint_WaitUntilReady+0x90>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    1ca4:	e0 91 48 95 	lds	r30, 0x9548
    1ca8:	f0 91 49 95 	lds	r31, 0x9549
    1cac:	81 81       	ldd	r24, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1cae:	82 fd       	sbrc	r24, 2
    1cb0:	1a c0       	rjmp	.+52     	; 0x1ce6 <Endpoint_WaitUntilReady+0x94>
    1cb2:	d8 01       	movw	r26, r16
    1cb4:	16 96       	adiw	r26, 0x06	; 6
    1cb6:	ed 91       	ld	r30, X+
    1cb8:	fc 91       	ld	r31, X
    1cba:	17 97       	sbiw	r26, 0x07	; 7
    1cbc:	e0 5b       	subi	r30, 0xB0	; 176
    1cbe:	ff 4f       	sbci	r31, 0xFF	; 255
    1cc0:	80 81       	ld	r24, Z
    1cc2:	91 81       	ldd	r25, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1cc4:	c8 17       	cp	r28, r24
    1cc6:	d9 07       	cpc	r29, r25
    1cc8:	c9 f2       	breq	.-78     	; 0x1c7c <Endpoint_WaitUntilReady+0x2a>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1cca:	2f ef       	ldi	r18, 0xFF	; 255
    1ccc:	2f 0d       	add	r18, r15
    1cce:	f1 10       	cpse	r15, r1
    1cd0:	d4 cf       	rjmp	.-88     	; 0x1c7a <Endpoint_WaitUntilReady+0x28>
			  return ENDPOINT_READYWAIT_Timeout;
    1cd2:	84 e0       	ldi	r24, 0x04	; 4
    1cd4:	09 c0       	rjmp	.+18     	; 0x1ce8 <Endpoint_WaitUntilReady+0x96>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    1cd6:	80 e0       	ldi	r24, 0x00	; 0
    1cd8:	07 c0       	rjmp	.+14     	; 0x1ce8 <Endpoint_WaitUntilReady+0x96>
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    1cda:	80 e0       	ldi	r24, 0x00	; 0
    1cdc:	05 c0       	rjmp	.+10     	; 0x1ce8 <Endpoint_WaitUntilReady+0x96>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    1cde:	82 e0       	ldi	r24, 0x02	; 2
    1ce0:	03 c0       	rjmp	.+6      	; 0x1ce8 <Endpoint_WaitUntilReady+0x96>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    1ce2:	83 e0       	ldi	r24, 0x03	; 3
    1ce4:	01 c0       	rjmp	.+2      	; 0x1ce8 <Endpoint_WaitUntilReady+0x96>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    1ce6:	81 e0       	ldi	r24, 0x01	; 1

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1ce8:	df 91       	pop	r29
    1cea:	cf 91       	pop	r28
    1cec:	1f 91       	pop	r17
    1cee:	0f 91       	pop	r16
    1cf0:	ff 90       	pop	r15
    1cf2:	08 95       	ret

00001cf4 <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    1cf4:	cf 93       	push	r28
    1cf6:	df 93       	push	r29
	{
		DividerIndex++;
		PrescalerNeeded >>= 1;
	}

	CLK.USBCTRL = (DividerIndex - 1) << CLK_USBPSDIV_gp;
    1cf8:	e0 e4       	ldi	r30, 0x40	; 64
    1cfa:	f0 e0       	ldi	r31, 0x00	; 0
    1cfc:	14 82       	std	Z+4, r1	; 0x04

	if (USB_Options & USB_OPT_PLLCLKSRC)
	  CLK.USBCTRL |= (CLK_USBSRC_PLL_gc   | CLK_USBSEN_bm);
	else
	  CLK.USBCTRL |= (CLK_USBSRC_RC32M_gc | CLK_USBSEN_bm);
    1cfe:	84 81       	ldd	r24, Z+4	; 0x04
    1d00:	83 60       	ori	r24, 0x03	; 3
    1d02:	84 83       	std	Z+4, r24	; 0x04

	USB_Device_SetDeviceAddress(0);

	USB_INT_DisableAllInterrupts();
    1d04:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1d08:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USB.CTRLA &= ~USB_ENABLE_bm;
    1d0c:	c0 ec       	ldi	r28, 0xC0	; 192
    1d0e:	d4 e0       	ldi	r29, 0x04	; 4
    1d10:	88 81       	ld	r24, Y
    1d12:	8f 77       	andi	r24, 0x7F	; 127
    1d14:	88 83       	st	Y, r24
				USB.CTRLA |=  USB_ENABLE_bm;
    1d16:	88 81       	ld	r24, Y
    1d18:	80 68       	ori	r24, 0x80	; 128
    1d1a:	88 83       	st	Y, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1d1c:	10 92 3d 95 	sts	0x953D, r1
	USB_Device_ConfigurationNumber  = 0;
    1d20:	10 92 39 95 	sts	0x9539, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1d24:	10 92 3b 95 	sts	0x953B, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1d28:	10 92 3a 95 	sts	0x953A, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				USB.CTRLA |=  USB_SPEED_bm;
    1d2c:	88 81       	ld	r24, Y
    1d2e:	80 64       	ori	r24, 0x40	; 64
    1d30:	88 83       	st	Y, r24
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    1d32:	48 e0       	ldi	r20, 0x08	; 8
    1d34:	68 e4       	ldi	r22, 0x48	; 72
    1d36:	80 e8       	ldi	r24, 0x80	; 128
    1d38:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    1d3c:	48 e0       	ldi	r20, 0x08	; 8
    1d3e:	68 e4       	ldi	r22, 0x48	; 72
    1d40:	80 e0       	ldi	r24, 0x00	; 0
    1d42:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <Endpoint_ConfigureEndpoint_PRV>
			static inline void USB_INT_Enable(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						USB.INTCTRLA |= USB_BUSEVIE_bm;
    1d46:	88 85       	ldd	r24, Y+8	; 0x08
    1d48:	80 64       	ori	r24, 0x40	; 64
    1d4a:	88 87       	std	Y+8, r24	; 0x08
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				USB.CTRLB |= USB_ATTACH_bm;
    1d4c:	89 81       	ldd	r24, Y+1	; 0x01
    1d4e:	81 60       	ori	r24, 0x01	; 1
    1d50:	89 83       	std	Y+1, r24	; 0x01
	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();

	USB_Controller_Reset();
	USB_Init_Device();
}
    1d52:	df 91       	pop	r29
    1d54:	cf 91       	pop	r28
    1d56:	08 95       	ret

00001d58 <USB_Init>:

               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
    1d58:	cf 93       	push	r28
    1d5a:	df 93       	push	r29
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    1d5c:	2f b7       	in	r18, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    1d5e:	f8 94       	cli
	#endif

	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();

	NVM.CMD  = NVM_CMD_READ_CALIB_ROW_gc;
    1d60:	c0 ec       	ldi	r28, 0xC0	; 192
    1d62:	d1 e0       	ldi	r29, 0x01	; 1
    1d64:	82 e0       	ldi	r24, 0x02	; 2
    1d66:	8a 87       	std	Y+10, r24	; 0x0a
	USB.CAL0 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL0));
    1d68:	ea e1       	ldi	r30, 0x1A	; 26
    1d6a:	f0 e0       	ldi	r31, 0x00	; 0
    1d6c:	e4 91       	lpm	r30, Z
    1d6e:	a0 ec       	ldi	r26, 0xC0	; 192
    1d70:	b4 e0       	ldi	r27, 0x04	; 4
    1d72:	da 96       	adiw	r26, 0x3a	; 58
    1d74:	ec 93       	st	X, r30
    1d76:	da 97       	sbiw	r26, 0x3a	; 58
	USB.CAL1 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL1));
    1d78:	eb e1       	ldi	r30, 0x1B	; 27
    1d7a:	f0 e0       	ldi	r31, 0x00	; 0
    1d7c:	e4 91       	lpm	r30, Z
    1d7e:	db 96       	adiw	r26, 0x3b	; 59
    1d80:	ec 93       	st	X, r30
    1d82:	db 97       	sbiw	r26, 0x3b	; 59
	NVM.CMD  = NVM_CMD_NO_OPERATION_gc;
    1d84:	1a 86       	std	Y+10, r1	; 0x0a

	/* Ugly workaround to ensure an aligned table, since __BIGGEST_ALIGNMENT__ == 1 for the 8-bit AVR-GCC toolchain */
	USB.EPPTR = ((intptr_t)&USB_EndpointTable[1] & ~(1 << 0));
    1d86:	80 ee       	ldi	r24, 0xE0	; 224
    1d88:	97 e9       	ldi	r25, 0x97	; 151
    1d8a:	8e 7f       	andi	r24, 0xFE	; 254
    1d8c:	16 96       	adiw	r26, 0x06	; 6
    1d8e:	8d 93       	st	X+, r24
    1d90:	9c 93       	st	X, r25
    1d92:	17 97       	sbiw	r26, 0x07	; 7
	USB.CTRLA = (USB_STFRNUM_bm | ((ENDPOINT_TOTAL_ENDPOINTS - 1) << USB_MAXEP_gp));
    1d94:	84 e1       	ldi	r24, 0x14	; 20
    1d96:	8c 93       	st	X, r24

	if ((USB_Options & USB_OPT_BUSEVENT_PRIHIGH) == USB_OPT_BUSEVENT_PRIHIGH)
	  USB.INTCTRLA = (3 << USB_INTLVL_gp);
    1d98:	83 e0       	ldi	r24, 0x03	; 3
    1d9a:	18 96       	adiw	r26, 0x08	; 8
    1d9c:	8c 93       	st	X, r24
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    1d9e:	2f bf       	out	0x3f, r18	; 63

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;
    1da0:	81 e0       	ldi	r24, 0x01	; 1
    1da2:	80 93 3c 95 	sts	0x953C, r24

	USB_ResetInterface();
    1da6:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <USB_ResetInterface>
}
    1daa:	df 91       	pop	r29
    1dac:	cf 91       	pop	r28
    1dae:	08 95       	ret

00001db0 <USB_INT_DisableAllInterrupts>:
#define  __INCLUDE_FROM_USB_DRIVER
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	USB.INTCTRLA    &= USB_INTLVL_gm;
    1db0:	e0 ec       	ldi	r30, 0xC0	; 192
    1db2:	f4 e0       	ldi	r31, 0x04	; 4
    1db4:	80 85       	ldd	r24, Z+8	; 0x08
    1db6:	83 70       	andi	r24, 0x03	; 3
    1db8:	80 87       	std	Z+8, r24	; 0x08
	USB.INTCTRLB     = 0;
    1dba:	11 86       	std	Z+9, r1	; 0x09
    1dbc:	08 95       	ret

00001dbe <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	USB.INTFLAGSACLR = 0xFF;
    1dbe:	e0 ec       	ldi	r30, 0xC0	; 192
    1dc0:	f4 e0       	ldi	r31, 0x04	; 4
    1dc2:	8f ef       	ldi	r24, 0xFF	; 255
    1dc4:	82 87       	std	Z+10, r24	; 0x0a
	USB.INTFLAGSBCLR = 0xFF;
    1dc6:	84 87       	std	Z+12, r24	; 0x0c
    1dc8:	08 95       	ret

00001dca <__vector_125>:
}

ISR(USB_BUSEVENT_vect)
{
    1dca:	1f 92       	push	r1
    1dcc:	0f 92       	push	r0
    1dce:	0f b6       	in	r0, 0x3f	; 63
    1dd0:	0f 92       	push	r0
    1dd2:	11 24       	eor	r1, r1
    1dd4:	0b b6       	in	r0, 0x3b	; 59
    1dd6:	0f 92       	push	r0
    1dd8:	2f 93       	push	r18
    1dda:	3f 93       	push	r19
    1ddc:	4f 93       	push	r20
    1dde:	5f 93       	push	r21
    1de0:	6f 93       	push	r22
    1de2:	7f 93       	push	r23
    1de4:	8f 93       	push	r24
    1de6:	9f 93       	push	r25
    1de8:	af 93       	push	r26
    1dea:	bf 93       	push	r27
    1dec:	ef 93       	push	r30
    1dee:	ff 93       	push	r31
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTFLAGSACLR & USB_SOFIF_bm) ? true : false);
    1df0:	80 91 ca 04 	lds	r24, 0x04CA
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1df4:	88 23       	and	r24, r24
    1df6:	4c f4       	brge	.+18     	; 0x1e0a <__vector_125+0x40>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						return ((USB.INTCTRLA & USB_BUSEVIE_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTCTRLA & USB_SOFIE_bm) ? true : false);
    1df8:	80 91 c8 04 	lds	r24, 0x04C8
    1dfc:	88 23       	and	r24, r24
    1dfe:	2c f4       	brge	.+10     	; 0x1e0a <__vector_125+0x40>
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
						break;
					case USB_INT_SOFI:
						USB.INTFLAGSACLR = USB_SOFIF_bm;
    1e00:	80 e8       	ldi	r24, 0x80	; 128
    1e02:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1e06:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <USB_Event_Stub>
			static inline bool USB_INT_HasOccurred(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
    1e0a:	80 91 ca 04 	lds	r24, 0x04CA
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Suspend))
    1e0e:	86 ff       	sbrs	r24, 6
    1e10:	07 c0       	rjmp	.+14     	; 0x1e20 <__vector_125+0x56>
			static inline void USB_INT_Clear(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
    1e12:	80 e4       	ldi	r24, 0x40	; 64
    1e14:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Suspend);

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    1e18:	10 92 3d 95 	sts	0x953D, r1
		EVENT_USB_Device_Disconnect();
    1e1c:	0e 94 17 12 	call	0x242e	; 0x242e <EVENT_USB_Device_Disconnect>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
    1e20:	80 91 ca 04 	lds	r24, 0x04CA
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Resume))
    1e24:	85 ff       	sbrs	r24, 5
    1e26:	16 c0       	rjmp	.+44     	; 0x1e54 <__vector_125+0x8a>
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
    1e28:	80 e2       	ldi	r24, 0x20	; 32
    1e2a:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Resume);

		if (USB_Device_ConfigurationNumber)
    1e2e:	80 91 39 95 	lds	r24, 0x9539
    1e32:	88 23       	and	r24, r24
    1e34:	21 f0       	breq	.+8      	; 0x1e3e <__vector_125+0x74>
		  USB_DeviceState = DEVICE_STATE_Configured;
    1e36:	84 e0       	ldi	r24, 0x04	; 4
    1e38:	80 93 3d 95 	sts	0x953D, r24
    1e3c:	09 c0       	rjmp	.+18     	; 0x1e50 <__vector_125+0x86>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    1e3e:	80 91 c3 04 	lds	r24, 0x04C3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    1e42:	81 11       	cpse	r24, r1
    1e44:	02 c0       	rjmp	.+4      	; 0x1e4a <__vector_125+0x80>
    1e46:	81 e0       	ldi	r24, 0x01	; 1
    1e48:	01 c0       	rjmp	.+2      	; 0x1e4c <__vector_125+0x82>
    1e4a:	83 e0       	ldi	r24, 0x03	; 3
    1e4c:	80 93 3d 95 	sts	0x953D, r24

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
    1e50:	0e 94 0a 12 	call	0x2414	; 0x2414 <EVENT_USB_Device_Connect>
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
    1e54:	80 91 ca 04 	lds	r24, 0x04CA
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Reset))
    1e58:	84 ff       	sbrs	r24, 4
    1e5a:	18 c0       	rjmp	.+48     	; 0x1e8c <__vector_125+0xc2>
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
    1e5c:	e0 ec       	ldi	r30, 0xC0	; 192
    1e5e:	f4 e0       	ldi	r31, 0x04	; 4
    1e60:	80 e1       	ldi	r24, 0x10	; 16
    1e62:	82 87       	std	Z+10, r24	; 0x0a
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Reset);

		USB_DeviceState                = DEVICE_STATE_Default;
    1e64:	82 e0       	ldi	r24, 0x02	; 2
    1e66:	80 93 3d 95 	sts	0x953D, r24
		USB_Device_ConfigurationNumber = 0;
    1e6a:	10 92 39 95 	sts	0x9539, r1
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    1e6e:	13 82       	std	Z+3, r1	; 0x03

		USB_Device_EnableDeviceAddress(0);

		Endpoint_ClearEndpoints();
    1e70:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <Endpoint_ClearEndpoints>
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    1e74:	48 e0       	ldi	r20, 0x08	; 8
    1e76:	68 e4       	ldi	r22, 0x48	; 72
    1e78:	80 e8       	ldi	r24, 0x80	; 128
    1e7a:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    1e7e:	48 e0       	ldi	r20, 0x08	; 8
    1e80:	68 e4       	ldi	r22, 0x48	; 72
    1e82:	80 e0       	ldi	r24, 0x00	; 0
    1e84:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <Endpoint_ConfigureEndpoint_PRV>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           USB_Device_ControlEndpointSize, 1);

		EVENT_USB_Device_Reset();
    1e88:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <USB_Event_Stub>
	}
}
    1e8c:	ff 91       	pop	r31
    1e8e:	ef 91       	pop	r30
    1e90:	bf 91       	pop	r27
    1e92:	af 91       	pop	r26
    1e94:	9f 91       	pop	r25
    1e96:	8f 91       	pop	r24
    1e98:	7f 91       	pop	r23
    1e9a:	6f 91       	pop	r22
    1e9c:	5f 91       	pop	r21
    1e9e:	4f 91       	pop	r20
    1ea0:	3f 91       	pop	r19
    1ea2:	2f 91       	pop	r18
    1ea4:	0f 90       	pop	r0
    1ea6:	0b be       	out	0x3b, r0	; 59
    1ea8:	0f 90       	pop	r0
    1eaa:	0f be       	out	0x3f, r0	; 63
    1eac:	0f 90       	pop	r0
    1eae:	1f 90       	pop	r1
    1eb0:	18 95       	reti

00001eb2 <USBThread>:
		temp ^= pixel_mask;
		break;
	}

	gfx_mono_put_byte(page, column, temp);
}
    1eb2:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
    1eb6:	8b e8       	ldi	r24, 0x8B	; 139
    1eb8:	92 e2       	ldi	r25, 0x22	; 34
    1eba:	0e 94 38 08 	call	0x1070	; 0x1070 <CDC_Device_USBTask>
    1ebe:	0e 94 de 0a 	call	0x15bc	; 0x15bc <USB_USBTask>
    1ec2:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
    1ec6:	81 e0       	ldi	r24, 0x01	; 1
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vTaskDelay>
    1ece:	f1 cf       	rjmp	.-30     	; 0x1eb2 <USBThread>

00001ed0 <thread_2>:
    1ed0:	84 e6       	ldi	r24, 0x64	; 100
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vTaskDelay>
    1ed8:	86 ea       	ldi	r24, 0xA6	; 166
    1eda:	92 e2       	ldi	r25, 0x22	; 34
    1edc:	0e 94 52 12 	call	0x24a4	; 0x24a4 <DigitalPin_ToggleValue>
    1ee0:	f7 cf       	rjmp	.-18     	; 0x1ed0 <thread_2>

00001ee2 <thread_1>:
    1ee2:	84 ef       	ldi	r24, 0xF4	; 244
    1ee4:	91 e0       	ldi	r25, 0x01	; 1
    1ee6:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vTaskDelay>
    1eea:	89 ea       	ldi	r24, 0xA9	; 169
    1eec:	92 e2       	ldi	r25, 0x22	; 34
    1eee:	0e 94 52 12 	call	0x24a4	; 0x24a4 <DigitalPin_ToggleValue>
    1ef2:	0e 94 84 05 	call	0xb08	; 0xb08 <vTaskSuspendAll>
    1ef6:	29 e2       	ldi	r18, 0x29	; 41
    1ef8:	33 e9       	ldi	r19, 0x93	; 147
    1efa:	4a e0       	ldi	r20, 0x0A	; 10
    1efc:	50 e0       	ldi	r21, 0x00	; 0
    1efe:	61 e0       	ldi	r22, 0x01	; 1
    1f00:	70 e0       	ldi	r23, 0x00	; 0
    1f02:	81 eb       	ldi	r24, 0xB1	; 177
    1f04:	92 e2       	ldi	r25, 0x22	; 34
    1f06:	0e 94 4b 13 	call	0x2696	; 0x2696 <fwrite>
    1f0a:	0e 94 44 06 	call	0xc88	; 0xc88 <xTaskResumeAll>
    1f0e:	e9 cf       	rjmp	.-46     	; 0x1ee2 <thread_1>

00001f10 <usart_spi_transmit_receive>:
    1f10:	fc 01       	movw	r30, r24
    1f12:	81 81       	ldd	r24, Z+1	; 0x01
    1f14:	85 ff       	sbrs	r24, 5
    1f16:	fd cf       	rjmp	.-6      	; 0x1f12 <usart_spi_transmit_receive+0x2>
    1f18:	60 83       	st	Z, r22
    1f1a:	81 81       	ldd	r24, Z+1	; 0x01
    1f1c:	86 ff       	sbrs	r24, 6
    1f1e:	fd cf       	rjmp	.-6      	; 0x1f1a <usart_spi_transmit_receive+0xa>
    1f20:	80 e4       	ldi	r24, 0x40	; 64
    1f22:	81 83       	std	Z+1, r24	; 0x01
    1f24:	80 81       	ld	r24, Z
    1f26:	08 95       	ret

00001f28 <ssd1306_write_command>:
    1f28:	1f 93       	push	r17
    1f2a:	cf 93       	push	r28
    1f2c:	df 93       	push	r29
    1f2e:	c0 ea       	ldi	r28, 0xA0	; 160
    1f30:	d6 e0       	ldi	r29, 0x06	; 6
    1f32:	18 e0       	ldi	r17, 0x08	; 8
    1f34:	1e 83       	std	Y+6, r17	; 0x06
    1f36:	e0 e6       	ldi	r30, 0x60	; 96
    1f38:	f6 e0       	ldi	r31, 0x06	; 6
    1f3a:	91 e0       	ldi	r25, 0x01	; 1
    1f3c:	96 83       	std	Z+6, r25	; 0x06
    1f3e:	96 83       	std	Z+6, r25	; 0x06
    1f40:	68 2f       	mov	r22, r24
    1f42:	80 ea       	ldi	r24, 0xA0	; 160
    1f44:	99 e0       	ldi	r25, 0x09	; 9
    1f46:	0e 94 88 0f 	call	0x1f10	; 0x1f10 <usart_spi_transmit_receive>
    1f4a:	1d 83       	std	Y+5, r17	; 0x05
    1f4c:	df 91       	pop	r29
    1f4e:	cf 91       	pop	r28
    1f50:	1f 91       	pop	r17
    1f52:	08 95       	ret

00001f54 <ssd1306_write_data>:
    1f54:	ef 92       	push	r14
    1f56:	ff 92       	push	r15
    1f58:	0f 93       	push	r16
    1f5a:	1f 93       	push	r17
    1f5c:	cf 93       	push	r28
    1f5e:	df 93       	push	r29
    1f60:	c0 ea       	ldi	r28, 0xA0	; 160
    1f62:	d6 e0       	ldi	r29, 0x06	; 6
    1f64:	18 e0       	ldi	r17, 0x08	; 8
    1f66:	1e 83       	std	Y+6, r17	; 0x06
    1f68:	0f 2e       	mov	r0, r31
    1f6a:	f0 e6       	ldi	r31, 0x60	; 96
    1f6c:	ef 2e       	mov	r14, r31
    1f6e:	f6 e0       	ldi	r31, 0x06	; 6
    1f70:	ff 2e       	mov	r15, r31
    1f72:	f0 2d       	mov	r31, r0
    1f74:	01 e0       	ldi	r16, 0x01	; 1
    1f76:	f7 01       	movw	r30, r14
    1f78:	05 83       	std	Z+5, r16	; 0x05
    1f7a:	68 2f       	mov	r22, r24
    1f7c:	80 ea       	ldi	r24, 0xA0	; 160
    1f7e:	99 e0       	ldi	r25, 0x09	; 9
    1f80:	0e 94 88 0f 	call	0x1f10	; 0x1f10 <usart_spi_transmit_receive>
    1f84:	f7 01       	movw	r30, r14
    1f86:	06 83       	std	Z+6, r16	; 0x06
    1f88:	1d 83       	std	Y+5, r17	; 0x05
    1f8a:	df 91       	pop	r29
    1f8c:	cf 91       	pop	r28
    1f8e:	1f 91       	pop	r17
    1f90:	0f 91       	pop	r16
    1f92:	ff 90       	pop	r15
    1f94:	ef 90       	pop	r14
    1f96:	08 95       	ret

00001f98 <ssd1306_set_page_address>:
    1f98:	87 70       	andi	r24, 0x07	; 7
    1f9a:	80 6b       	ori	r24, 0xB0	; 176
    1f9c:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    1fa0:	08 95       	ret

00001fa2 <ssd1306_set_column_address>:
    1fa2:	cf 93       	push	r28
    1fa4:	c8 2f       	mov	r28, r24
    1fa6:	98 2f       	mov	r25, r24
    1fa8:	9f 77       	andi	r25, 0x7F	; 127
    1faa:	89 2f       	mov	r24, r25
    1fac:	82 95       	swap	r24
    1fae:	8f 70       	andi	r24, 0x0F	; 15
    1fb0:	80 61       	ori	r24, 0x10	; 16
    1fb2:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    1fb6:	8c 2f       	mov	r24, r28
    1fb8:	8f 70       	andi	r24, 0x0F	; 15
    1fba:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    1fbe:	cf 91       	pop	r28
    1fc0:	08 95       	ret

00001fc2 <usart_init_spi>:
    1fc2:	cf 93       	push	r28
    1fc4:	df 93       	push	r29
    1fc6:	ec 01       	movw	r28, r24
    1fc8:	fb 01       	movw	r30, r22
    1fca:	8c 81       	ldd	r24, Y+4	; 0x04
    1fcc:	8f 7e       	andi	r24, 0xEF	; 239
    1fce:	8c 83       	std	Y+4, r24	; 0x04
    1fd0:	a0 e6       	ldi	r26, 0x60	; 96
    1fd2:	b6 e0       	ldi	r27, 0x06	; 6
    1fd4:	82 e0       	ldi	r24, 0x02	; 2
    1fd6:	11 96       	adiw	r26, 0x01	; 1
    1fd8:	8c 93       	st	X, r24
    1fda:	11 97       	sbiw	r26, 0x01	; 1
    1fdc:	15 96       	adiw	r26, 0x05	; 5
    1fde:	8c 93       	st	X, r24
    1fe0:	8d 81       	ldd	r24, Y+5	; 0x05
    1fe2:	80 6c       	ori	r24, 0xC0	; 192
    1fe4:	8d 83       	std	Y+5, r24	; 0x05
    1fe6:	84 81       	ldd	r24, Z+4	; 0x04
    1fe8:	8d 7f       	andi	r24, 0xFD	; 253
    1fea:	81 30       	cpi	r24, 0x01	; 1
    1fec:	21 f4       	brne	.+8      	; 0x1ff6 <usart_init_spi+0x34>
    1fee:	8d 81       	ldd	r24, Y+5	; 0x05
    1ff0:	82 60       	ori	r24, 0x02	; 2
    1ff2:	8d 83       	std	Y+5, r24	; 0x05
    1ff4:	03 c0       	rjmp	.+6      	; 0x1ffc <usart_init_spi+0x3a>
    1ff6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ff8:	8d 7f       	andi	r24, 0xFD	; 253
    1ffa:	8d 83       	std	Y+5, r24	; 0x05
    1ffc:	85 81       	ldd	r24, Z+5	; 0x05
    1ffe:	88 23       	and	r24, r24
    2000:	21 f0       	breq	.+8      	; 0x200a <usart_init_spi+0x48>
    2002:	8d 81       	ldd	r24, Y+5	; 0x05
    2004:	84 60       	ori	r24, 0x04	; 4
    2006:	8d 83       	std	Y+5, r24	; 0x05
    2008:	03 c0       	rjmp	.+6      	; 0x2010 <usart_init_spi+0x4e>
    200a:	8d 81       	ldd	r24, Y+5	; 0x05
    200c:	8b 7f       	andi	r24, 0xFB	; 251
    200e:	8d 83       	std	Y+5, r24	; 0x05
    2010:	80 81       	ld	r24, Z
    2012:	91 81       	ldd	r25, Z+1	; 0x01
    2014:	a2 81       	ldd	r26, Z+2	; 0x02
    2016:	b3 81       	ldd	r27, Z+3	; 0x03
    2018:	9c 01       	movw	r18, r24
    201a:	ad 01       	movw	r20, r26
    201c:	22 0f       	add	r18, r18
    201e:	33 1f       	adc	r19, r19
    2020:	44 1f       	adc	r20, r20
    2022:	55 1f       	adc	r21, r21
    2024:	60 e0       	ldi	r22, 0x00	; 0
    2026:	78 e4       	ldi	r23, 0x48	; 72
    2028:	88 ee       	ldi	r24, 0xE8	; 232
    202a:	91 e0       	ldi	r25, 0x01	; 1
    202c:	0e 94 1a 13 	call	0x2634	; 0x2634 <__udivmodsi4>
    2030:	21 50       	subi	r18, 0x01	; 1
    2032:	31 09       	sbc	r19, r1
    2034:	83 2f       	mov	r24, r19
    2036:	8f 70       	andi	r24, 0x0F	; 15
    2038:	8f 83       	std	Y+7, r24	; 0x07
    203a:	2e 83       	std	Y+6, r18	; 0x06
    203c:	8c 81       	ldd	r24, Y+4	; 0x04
    203e:	88 60       	ori	r24, 0x08	; 8
    2040:	8c 83       	std	Y+4, r24	; 0x04
    2042:	df 91       	pop	r29
    2044:	cf 91       	pop	r28
    2046:	08 95       	ret

00002048 <ssd1306_init>:
    2048:	cf 93       	push	r28
    204a:	df 93       	push	r29
    204c:	00 d0       	rcall	.+0      	; 0x204e <ssd1306_init+0x6>
    204e:	00 d0       	rcall	.+0      	; 0x2050 <ssd1306_init+0x8>
    2050:	cd b7       	in	r28, 0x3d	; 61
    2052:	de b7       	in	r29, 0x3e	; 62
    2054:	20 ea       	ldi	r18, 0xA0	; 160
    2056:	36 e0       	ldi	r19, 0x06	; 6
    2058:	88 e0       	ldi	r24, 0x08	; 8
    205a:	d9 01       	movw	r26, r18
    205c:	11 96       	adiw	r26, 0x01	; 1
    205e:	8c 93       	st	X, r24
    2060:	a0 e6       	ldi	r26, 0x60	; 96
    2062:	b6 e0       	ldi	r27, 0x06	; 6
    2064:	91 e0       	ldi	r25, 0x01	; 1
    2066:	11 96       	adiw	r26, 0x01	; 1
    2068:	9c 93       	st	X, r25
    206a:	11 97       	sbiw	r26, 0x01	; 1
    206c:	e0 e0       	ldi	r30, 0x00	; 0
    206e:	f6 e0       	ldi	r31, 0x06	; 6
    2070:	81 83       	std	Z+1, r24	; 0x01
    2072:	92 e0       	ldi	r25, 0x02	; 2
    2074:	11 96       	adiw	r26, 0x01	; 1
    2076:	9c 93       	st	X, r25
    2078:	11 97       	sbiw	r26, 0x01	; 1
    207a:	11 96       	adiw	r26, 0x01	; 1
    207c:	8c 93       	st	X, r24
    207e:	d9 01       	movw	r26, r18
    2080:	15 96       	adiw	r26, 0x05	; 5
    2082:	8c 93       	st	X, r24
    2084:	86 83       	std	Z+6, r24	; 0x06
    2086:	ba e6       	ldi	r27, 0x6A	; 106
    2088:	ba 95       	dec	r27
    208a:	f1 f7       	brne	.-4      	; 0x2088 <ssd1306_init+0x40>
    208c:	00 c0       	rjmp	.+0      	; 0x208e <ssd1306_init+0x46>
    208e:	85 83       	std	Z+5, r24	; 0x05
    2090:	ea e6       	ldi	r30, 0x6A	; 106
    2092:	ea 95       	dec	r30
    2094:	f1 f7       	brne	.-4      	; 0x2092 <ssd1306_init+0x4a>
    2096:	00 c0       	rjmp	.+0      	; 0x2098 <ssd1306_init+0x50>
    2098:	e0 e7       	ldi	r30, 0x70	; 112
    209a:	f0 e0       	ldi	r31, 0x00	; 0
    209c:	84 81       	ldd	r24, Z+4	; 0x04
    209e:	8f 7e       	andi	r24, 0xEF	; 239
    20a0:	84 83       	std	Z+4, r24	; 0x04
    20a2:	80 e0       	ldi	r24, 0x00	; 0
    20a4:	9b e1       	ldi	r25, 0x1B	; 27
    20a6:	a7 eb       	ldi	r26, 0xB7	; 183
    20a8:	b0 e0       	ldi	r27, 0x00	; 0
    20aa:	89 83       	std	Y+1, r24	; 0x01
    20ac:	9a 83       	std	Y+2, r25	; 0x02
    20ae:	ab 83       	std	Y+3, r26	; 0x03
    20b0:	bc 83       	std	Y+4, r27	; 0x04
    20b2:	1d 82       	std	Y+5, r1	; 0x05
    20b4:	1e 82       	std	Y+6, r1	; 0x06
    20b6:	be 01       	movw	r22, r28
    20b8:	6f 5f       	subi	r22, 0xFF	; 255
    20ba:	7f 4f       	sbci	r23, 0xFF	; 255
    20bc:	80 ea       	ldi	r24, 0xA0	; 160
    20be:	99 e0       	ldi	r25, 0x09	; 9
    20c0:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <usart_init_spi>
    20c4:	88 ea       	ldi	r24, 0xA8	; 168
    20c6:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    20ca:	8f e1       	ldi	r24, 0x1F	; 31
    20cc:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    20d0:	83 ed       	ldi	r24, 0xD3	; 211
    20d2:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    20d6:	80 e0       	ldi	r24, 0x00	; 0
    20d8:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    20dc:	80 e4       	ldi	r24, 0x40	; 64
    20de:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    20e2:	81 ea       	ldi	r24, 0xA1	; 161
    20e4:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    20e8:	88 ec       	ldi	r24, 0xC8	; 200
    20ea:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    20ee:	8a ed       	ldi	r24, 0xDA	; 218
    20f0:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    20f4:	82 e0       	ldi	r24, 0x02	; 2
    20f6:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    20fa:	81 e8       	ldi	r24, 0x81	; 129
    20fc:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    2100:	8f e8       	ldi	r24, 0x8F	; 143
    2102:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    2106:	84 ea       	ldi	r24, 0xA4	; 164
    2108:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    210c:	86 ea       	ldi	r24, 0xA6	; 166
    210e:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    2112:	85 ed       	ldi	r24, 0xD5	; 213
    2114:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    2118:	80 e8       	ldi	r24, 0x80	; 128
    211a:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    211e:	8d e8       	ldi	r24, 0x8D	; 141
    2120:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    2124:	84 e1       	ldi	r24, 0x14	; 20
    2126:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    212a:	8b ed       	ldi	r24, 0xDB	; 219
    212c:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    2130:	80 e4       	ldi	r24, 0x40	; 64
    2132:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    2136:	89 ed       	ldi	r24, 0xD9	; 217
    2138:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    213c:	81 ef       	ldi	r24, 0xF1	; 241
    213e:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    2142:	8f ea       	ldi	r24, 0xAF	; 175
    2144:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
    2148:	26 96       	adiw	r28, 0x06	; 6
    214a:	cd bf       	out	0x3d, r28	; 61
    214c:	de bf       	out	0x3e, r29	; 62
    214e:	df 91       	pop	r29
    2150:	cf 91       	pop	r28
    2152:	08 95       	ret

00002154 <ssd1306_write_text>:
    2154:	ef 92       	push	r14
    2156:	ff 92       	push	r15
    2158:	0f 93       	push	r16
    215a:	1f 93       	push	r17
    215c:	cf 93       	push	r28
    215e:	dc 01       	movw	r26, r24
    2160:	ec 91       	ld	r30, X
    2162:	ee 23       	and	r30, r30
    2164:	29 f1       	breq	.+74     	; 0x21b0 <ssd1306_write_text+0x5c>
    2166:	7c 01       	movw	r14, r24
    2168:	bf ef       	ldi	r27, 0xFF	; 255
    216a:	eb 1a       	sub	r14, r27
    216c:	fb 0a       	sbc	r15, r27
    216e:	ef 37       	cpi	r30, 0x7F	; 127
    2170:	d0 f4       	brcc	.+52     	; 0x21a6 <ssd1306_write_text+0x52>
    2172:	f0 e0       	ldi	r31, 0x00	; 0
    2174:	ee 0f       	add	r30, r30
    2176:	ff 1f       	adc	r31, r31
    2178:	e5 57       	subi	r30, 0x75	; 117
    217a:	fe 4d       	sbci	r31, 0xDE	; 222
    217c:	00 81       	ld	r16, Z
    217e:	11 81       	ldd	r17, Z+1	; 0x01
    2180:	f8 01       	movw	r30, r16
    2182:	80 81       	ld	r24, Z
    2184:	88 23       	and	r24, r24
    2186:	61 f0       	breq	.+24     	; 0x21a0 <ssd1306_write_text+0x4c>
    2188:	c1 e0       	ldi	r28, 0x01	; 1
    218a:	f8 01       	movw	r30, r16
    218c:	ec 0f       	add	r30, r28
    218e:	f1 1d       	adc	r31, r1
    2190:	80 81       	ld	r24, Z
    2192:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <ssd1306_write_data>
    2196:	cf 5f       	subi	r28, 0xFF	; 255
    2198:	d8 01       	movw	r26, r16
    219a:	9c 91       	ld	r25, X
    219c:	9c 17       	cp	r25, r28
    219e:	a8 f7       	brcc	.-22     	; 0x218a <ssd1306_write_text+0x36>
    21a0:	80 e0       	ldi	r24, 0x00	; 0
    21a2:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <ssd1306_write_data>
    21a6:	d7 01       	movw	r26, r14
    21a8:	ed 91       	ld	r30, X+
    21aa:	7d 01       	movw	r14, r26
    21ac:	e1 11       	cpse	r30, r1
    21ae:	df cf       	rjmp	.-66     	; 0x216e <ssd1306_write_text+0x1a>
    21b0:	cf 91       	pop	r28
    21b2:	1f 91       	pop	r17
    21b4:	0f 91       	pop	r16
    21b6:	ff 90       	pop	r15
    21b8:	ef 90       	pop	r14
    21ba:	08 95       	ret

000021bc <gfx_mono_framebuffer_put_byte>:
    21bc:	20 e8       	ldi	r18, 0x80	; 128
    21be:	82 9f       	mul	r24, r18
    21c0:	c0 01       	movw	r24, r0
    21c2:	11 24       	eor	r1, r1
    21c4:	86 0f       	add	r24, r22
    21c6:	91 1d       	adc	r25, r1
    21c8:	e0 91 37 93 	lds	r30, 0x9337
    21cc:	f0 91 38 93 	lds	r31, 0x9338
    21d0:	e8 0f       	add	r30, r24
    21d2:	f9 1f       	adc	r31, r25
    21d4:	40 83       	st	Z, r20
    21d6:	08 95       	ret

000021d8 <gfx_mono_framebuffer_get_byte>:
    21d8:	20 e8       	ldi	r18, 0x80	; 128
    21da:	82 9f       	mul	r24, r18
    21dc:	c0 01       	movw	r24, r0
    21de:	11 24       	eor	r1, r1
    21e0:	86 0f       	add	r24, r22
    21e2:	91 1d       	adc	r25, r1
    21e4:	e0 91 37 93 	lds	r30, 0x9337
    21e8:	f0 91 38 93 	lds	r31, 0x9338
    21ec:	e8 0f       	add	r30, r24
    21ee:	f9 1f       	adc	r31, r25
    21f0:	80 81       	ld	r24, Z
    21f2:	08 95       	ret

000021f4 <gfx_mono_ssd1306_put_byte>:
    21f4:	1f 93       	push	r17
    21f6:	cf 93       	push	r28
    21f8:	df 93       	push	r29
    21fa:	18 2f       	mov	r17, r24
    21fc:	d6 2f       	mov	r29, r22
    21fe:	c4 2f       	mov	r28, r20
    2200:	21 11       	cpse	r18, r1
    2202:	04 c0       	rjmp	.+8      	; 0x220c <gfx_mono_ssd1306_put_byte+0x18>
    2204:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <gfx_mono_framebuffer_get_byte>
    2208:	8c 17       	cp	r24, r28
    220a:	71 f0       	breq	.+28     	; 0x2228 <gfx_mono_ssd1306_put_byte+0x34>
    220c:	4c 2f       	mov	r20, r28
    220e:	6d 2f       	mov	r22, r29
    2210:	81 2f       	mov	r24, r17
    2212:	0e 94 de 10 	call	0x21bc	; 0x21bc <gfx_mono_framebuffer_put_byte>
    2216:	81 2f       	mov	r24, r17
    2218:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <ssd1306_set_page_address>
    221c:	8d 2f       	mov	r24, r29
    221e:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <ssd1306_set_column_address>
    2222:	8c 2f       	mov	r24, r28
    2224:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <ssd1306_write_data>
    2228:	df 91       	pop	r29
    222a:	cf 91       	pop	r28
    222c:	1f 91       	pop	r17
    222e:	08 95       	ret

00002230 <SetupHardware>:
}


/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
    2230:	cf 93       	push	r28
    2232:	df 93       	push	r29
				  return false;

				switch (Source)
				{
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.PLLCTRL = (OSC_PLLSRC_RC2M_gc  | MulFactor);
    2234:	e0 e5       	ldi	r30, 0x50	; 80
    2236:	f0 e0       	ldi	r31, 0x00	; 0
    2238:	80 e1       	ldi	r24, 0x10	; 16
    223a:	85 83       	std	Z+5, r24	; 0x05
						break;
					default:
						return false;
				}

				OSC.CTRL |= OSC_PLLEN_bm;
    223c:	80 81       	ld	r24, Z
    223e:	80 61       	ori	r24, 0x10	; 16
    2240:	80 83       	st	Z, r24

				while (!(OSC.STATUS & OSC_PLLRDY_bm));
    2242:	81 81       	ldd	r24, Z+1	; 0x01
    2244:	84 ff       	sbrs	r24, 4
    2246:	fd cf       	rjmp	.-6      	; 0x2242 <SetupHardware+0x12>
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    2248:	8f b7       	in	r24, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    224a:	f8 94       	cli
			 *  \param[in] Value    Value to write to the protected location
			 */
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value) ATTR_NON_NULL_PTR_ARG(1) ATTR_ALWAYS_INLINE;
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value)
			{
				__asm__ __volatile__ (
    224c:	a0 e4       	ldi	r26, 0x40	; 64
    224e:	b0 e0       	ldi	r27, 0x00	; 0
    2250:	94 e0       	ldi	r25, 0x04	; 4
    2252:	28 ed       	ldi	r18, 0xD8	; 216
    2254:	30 e0       	ldi	r19, 0x00	; 0
    2256:	1b be       	out	0x3b, r1	; 59
    2258:	fd 01       	movw	r30, r26
    225a:	24 bf       	out	0x34, r18	; 52
    225c:	90 83       	st	Z, r25
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    225e:	8f bf       	out	0x3f, r24	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2260:	8f e3       	ldi	r24, 0x3F	; 63
    2262:	9f e1       	ldi	r25, 0x1F	; 31
    2264:	01 97       	sbiw	r24, 0x01	; 1
    2266:	f1 f7       	brne	.-4      	; 0x2264 <SetupHardware+0x34>
    2268:	00 c0       	rjmp	.+0      	; 0x226a <SetupHardware+0x3a>
    226a:	00 00       	nop
				XMEGACLK_CCP_Write(&CLK.CTRL, ClockSourceMask);

				SetGlobalInterruptMask(CurrentGlobalInt);

				Delay_MS(1);
				return (CLK.CTRL == ClockSourceMask);
    226c:	8c 91       	ld	r24, X
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.CTRL |= OSC_RC2MEN_bm;
						while (!(OSC.STATUS & OSC_RC2MRDY_bm));
						return true;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.CTRL |= OSC_RC32MEN_bm;
    226e:	e0 e5       	ldi	r30, 0x50	; 80
    2270:	f0 e0       	ldi	r31, 0x00	; 0
    2272:	80 81       	ld	r24, Z
    2274:	82 60       	ori	r24, 0x02	; 2
    2276:	80 83       	st	Z, r24
						while (!(OSC.STATUS & OSC_RC32MRDY_bm));
    2278:	81 81       	ldd	r24, Z+1	; 0x01
    227a:	81 ff       	sbrs	r24, 1
    227c:	fd cf       	rjmp	.-6      	; 0x2278 <SetupHardware+0x48>
						DFLLRC2M.COMP1  = (DFLLCompare & 0xFF);
						DFLLRC2M.COMP2  = (DFLLCompare >> 8);
						DFLLRC2M.CTRL   = DFLL_ENABLE_bm;
						break;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.DFLLCTRL   |= (Reference << OSC_RC32MCREF_gp);
    227e:	e0 e5       	ldi	r30, 0x50	; 80
    2280:	f0 e0       	ldi	r31, 0x00	; 0
    2282:	86 81       	ldd	r24, Z+6	; 0x06
    2284:	84 60       	ori	r24, 0x04	; 4
    2286:	86 83       	std	Z+6, r24	; 0x06
						DFLLRC32M.COMP1 = (DFLLCompare & 0xFF);
    2288:	a0 e6       	ldi	r26, 0x60	; 96
    228a:	b0 e0       	ldi	r27, 0x00	; 0
    228c:	8b e1       	ldi	r24, 0x1B	; 27
    228e:	15 96       	adiw	r26, 0x05	; 5
    2290:	8c 93       	st	X, r24
    2292:	15 97       	sbiw	r26, 0x05	; 5
						DFLLRC32M.COMP2 = (DFLLCompare >> 8);
    2294:	87 eb       	ldi	r24, 0xB7	; 183
    2296:	16 96       	adiw	r26, 0x06	; 6
    2298:	8c 93       	st	X, r24
    229a:	16 97       	sbiw	r26, 0x06	; 6

						if (Reference == DFLL_REF_INT_USBSOF)
						{
							NVM.CMD        = NVM_CMD_READ_CALIB_ROW_gc;
    229c:	c0 ec       	ldi	r28, 0xC0	; 192
    229e:	d1 e0       	ldi	r29, 0x01	; 1
    22a0:	82 e0       	ldi	r24, 0x02	; 2
    22a2:	8a 87       	std	Y+10, r24	; 0x0a
							DFLLRC32M.CALA = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSCA));
    22a4:	ed e1       	ldi	r30, 0x1D	; 29
    22a6:	f0 e0       	ldi	r31, 0x00	; 0
    22a8:	e4 91       	lpm	r30, Z
    22aa:	12 96       	adiw	r26, 0x02	; 2
    22ac:	ec 93       	st	X, r30
    22ae:	12 97       	sbiw	r26, 0x02	; 2
							DFLLRC32M.CALB = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSC));
    22b0:	ec e1       	ldi	r30, 0x1C	; 28
    22b2:	f0 e0       	ldi	r31, 0x00	; 0
    22b4:	e4 91       	lpm	r30, Z
    22b6:	13 96       	adiw	r26, 0x03	; 3
    22b8:	ec 93       	st	X, r30
    22ba:	13 97       	sbiw	r26, 0x03	; 3
							NVM.CMD        = 0;
    22bc:	1a 86       	std	Y+10, r1	; 0x0a
						}

						DFLLRC32M.CTRL  = DFLL_ENABLE_bm;
    22be:	81 e0       	ldi	r24, 0x01	; 1
    22c0:	8c 93       	st	X, r24

	/* Start the 32MHz internal RC oscillator and start the DFLL to increase it to 48MHz using the USB SOF as a reference */
	XMEGACLK_StartInternalOscillator(CLOCK_SRC_INT_RC32MHZ);
	XMEGACLK_StartDFLL(CLOCK_SRC_INT_RC32MHZ, DFLL_REF_INT_USBSOF, F_USB);

	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
    22c2:	87 e0       	ldi	r24, 0x07	; 7
    22c4:	80 93 a2 00 	sts	0x00A2, r24

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				PORTR.DIRSET    = LEDS_PORTR_LEDS;
    22c8:	e0 ee       	ldi	r30, 0xE0	; 224
    22ca:	f7 e0       	ldi	r31, 0x07	; 7
    22cc:	83 e0       	ldi	r24, 0x03	; 3
    22ce:	81 83       	std	Z+1, r24	; 0x01
				PORTR.OUTCLR    = LEDS_PORTR_LEDS;
    22d0:	86 83       	std	Z+6, r24	; 0x06

				PORTCFG.MPCMASK = LEDS_PORTR_LEDS;
    22d2:	80 93 b0 00 	sts	0x00B0, r24
				PORTR.PIN0CTRL  = PORT_INVEN_bm;
    22d6:	80 e4       	ldi	r24, 0x40	; 64
    22d8:	80 8b       	std	Z+16, r24	; 0x10

				PORTD.DIRSET    = LEDS_PORTD_LEDS;
    22da:	e0 e6       	ldi	r30, 0x60	; 96
    22dc:	f6 e0       	ldi	r31, 0x06	; 6
    22de:	90 e3       	ldi	r25, 0x30	; 48
    22e0:	91 83       	std	Z+1, r25	; 0x01
				PORTD.OUTCLR    = LEDS_PORTD_LEDS;
    22e2:	96 83       	std	Z+6, r25	; 0x06

				PORTD.PIN4CTRL  = PORT_INVEN_bm;
    22e4:	84 8b       	std	Z+20, r24	; 0x14
#endif

	/* Hardware Initialization */
	LEDs_Init();
	USB_Init();
    22e6:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <USB_Init>
}
    22ea:	df 91       	pop	r29
    22ec:	cf 91       	pop	r28
    22ee:	08 95       	ret

000022f0 <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
		DigitalPin_SetDIr(&led,1);
    22f0:	61 e0       	ldi	r22, 0x01	; 1
    22f2:	89 ea       	ldi	r24, 0xA9	; 169
    22f4:	92 e2       	ldi	r25, 0x22	; 34
    22f6:	0e 94 40 12 	call	0x2480	; 0x2480 <DigitalPin_SetDIr>
		DigitalPin_SetDIr(&led2,1);
    22fa:	61 e0       	ldi	r22, 0x01	; 1
    22fc:	86 ea       	ldi	r24, 0xA6	; 166
    22fe:	92 e2       	ldi	r25, 0x22	; 34
    2300:	0e 94 40 12 	call	0x2480	; 0x2480 <DigitalPin_SetDIr>
	
		
		
		
	SetupHardware();
    2304:	0e 94 18 11 	call	0x2230	; 0x2230 <SetupHardware>
	gfx_mono_set_framebuffer(framebuffer);
\endcode
 */
void gfx_mono_set_framebuffer(uint8_t *framebuffer)
{
	fbpointer = framebuffer;
    2308:	89 e3       	ldi	r24, 0x39	; 57
    230a:	93 e9       	ldi	r25, 0x93	; 147
    230c:	80 93 37 93 	sts	0x9337, r24
    2310:	90 93 38 93 	sts	0x9338, r25


	uint8_t page;
	uint8_t column;
	gfx_mono_set_framebuffer(framebuffer);
	ssd1306_init();
    2314:	0e 94 24 10 	call	0x2048	; 0x2048 <ssd1306_init>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    2318:	d0 e0       	ldi	r29, 0x00	; 0
    231a:	0f c0       	rjmp	.+30     	; 0x233a <main+0x4a>
	{
		for (col = 0; col < 128; ++col)
		{
			ssd1306_set_page_address(page);
    231c:	8d 2f       	mov	r24, r29
    231e:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <ssd1306_set_page_address>
			ssd1306_set_column_address(col);
    2322:	8c 2f       	mov	r24, r28
    2324:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <ssd1306_set_column_address>
			ssd1306_write_data(0x00);
    2328:	80 e0       	ldi	r24, 0x00	; 0
    232a:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <ssd1306_write_data>
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
	{
		for (col = 0; col < 128; ++col)
    232e:	cf 5f       	subi	r28, 0xFF	; 255
    2330:	c0 38       	cpi	r28, 0x80	; 128
    2332:	a1 f7       	brne	.-24     	; 0x231c <main+0x2c>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    2334:	df 5f       	subi	r29, 0xFF	; 255
    2336:	d4 30       	cpi	r29, 0x04	; 4
    2338:	11 f0       	breq	.+4      	; 0x233e <main+0x4e>

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
    233a:	c0 e0       	ldi	r28, 0x00	; 0
    233c:	ef cf       	rjmp	.-34     	; 0x231c <main+0x2c>
 */
static inline void ssd1306_set_display_start_line_address(uint8_t address)
{
	// Make sure address is 6 bits
	address &= 0x3F;
	ssd1306_write_command(SSD1306_CMD_SET_START_LINE(address));
    233e:	80 e4       	ldi	r24, 0x40	; 64
    2340:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <ssd1306_write_command>
	uint8_t column;
	gfx_mono_set_framebuffer(framebuffer);
	ssd1306_init();
	ssd1306_clear();
	ssd1306_set_display_start_line_address(0);
 	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    2344:	d0 e0       	ldi	r29, 0x00	; 0
    2346:	0c c0       	rjmp	.+24     	; 0x2360 <main+0x70>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
    2348:	21 e0       	ldi	r18, 0x01	; 1
    234a:	40 e0       	ldi	r20, 0x00	; 0
    234c:	6c 2f       	mov	r22, r28
    234e:	8d 2f       	mov	r24, r29
    2350:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <gfx_mono_ssd1306_put_byte>
	gfx_mono_set_framebuffer(framebuffer);
	ssd1306_init();
	ssd1306_clear();
	ssd1306_set_display_start_line_address(0);
 	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    2354:	cf 5f       	subi	r28, 0xFF	; 255
    2356:	c0 38       	cpi	r28, 0x80	; 128
    2358:	b9 f7       	brne	.-18     	; 0x2348 <main+0x58>
	uint8_t column;
	gfx_mono_set_framebuffer(framebuffer);
	ssd1306_init();
	ssd1306_clear();
	ssd1306_set_display_start_line_address(0);
 	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    235a:	df 5f       	subi	r29, 0xFF	; 255
    235c:	d4 30       	cpi	r29, 0x04	; 4
    235e:	11 f0       	breq	.+4      	; 0x2364 <main+0x74>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    2360:	c0 e0       	ldi	r28, 0x00	; 0
    2362:	f2 cf       	rjmp	.-28     	; 0x2348 <main+0x58>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
		}
	}

	asm("nop");
    2364:	00 00       	nop
	ssd1306_set_page_address(0);
    2366:	80 e0       	ldi	r24, 0x00	; 0
    2368:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <ssd1306_set_page_address>
	ssd1306_write_text("EMON");
    236c:	8c eb       	ldi	r24, 0xBC	; 188
    236e:	92 e2       	ldi	r25, 0x22	; 34
    2370:	0e 94 aa 10 	call	0x2154	; 0x2154 <ssd1306_write_text>


	DigitalPin_SetDIr(&led,1);
    2374:	61 e0       	ldi	r22, 0x01	; 1
    2376:	89 ea       	ldi	r24, 0xA9	; 169
    2378:	92 e2       	ldi	r25, 0x22	; 34
    237a:	0e 94 40 12 	call	0x2480	; 0x2480 <DigitalPin_SetDIr>
	DigitalPin_SetDIr(&led2,1);
    237e:	61 e0       	ldi	r22, 0x01	; 1
    2380:	86 ea       	ldi	r24, 0xA6	; 166
    2382:	92 e2       	ldi	r25, 0x22	; 34
    2384:	0e 94 40 12 	call	0x2480	; 0x2480 <DigitalPin_SetDIr>
	//PORT_SetDirection(&PORTR,(1<<0));

	CLKSYS_Enable( OSC_RC32MEN_bm );
    2388:	e0 e5       	ldi	r30, 0x50	; 80
    238a:	f0 e0       	ldi	r31, 0x00	; 0
    238c:	80 81       	ld	r24, Z
    238e:	82 60       	ori	r24, 0x02	; 2
    2390:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC32MRDY_bm ) == 0 );
    2392:	81 81       	ldd	r24, Z+1	; 0x01
    2394:	81 ff       	sbrs	r24, 1
    2396:	fd cf       	rjmp	.-6      	; 0x2392 <main+0xa2>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    2398:	81 e0       	ldi	r24, 0x01	; 1
    239a:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    239e:	81 e0       	ldi	r24, 0x01	; 1
    23a0:	0e 94 ef 12 	call	0x25de	; 0x25de <CLKSYS_Disable>

	char time_string[20];
	uint8_t rxData[33];


	PORTR.DIRSET = (1<<0);
    23a4:	e0 ee       	ldi	r30, 0xE0	; 224
    23a6:	f7 e0       	ldi	r31, 0x07	; 7
    23a8:	81 e0       	ldi	r24, 0x01	; 1
    23aa:	81 83       	std	Z+1, r24	; 0x01
	PORTR.DIRSET = (1<<1);
    23ac:	82 e0       	ldi	r24, 0x02	; 2
    23ae:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = (1<<4);
    23b0:	80 e1       	ldi	r24, 0x10	; 16
    23b2:	80 93 61 06 	sts	0x0661, r24


	CDC_Device_CreateStream(&VirtualSerial_CDC_Interface, &USBSerialStream);
    23b6:	69 e2       	ldi	r22, 0x29	; 41
    23b8:	73 e9       	ldi	r23, 0x93	; 147
    23ba:	8b e8       	ldi	r24, 0x8B	; 139
    23bc:	92 e2       	ldi	r25, 0x22	; 34
    23be:	0e 94 ca 08 	call	0x1194	; 0x1194 <CDC_Device_CreateStream>
				#if (ARCH == ARCH_AVR8)
				sei();
				#elif (ARCH == ARCH_UC3)
				__builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				sei();
    23c2:	78 94       	sei
	//creating the threads
	//xTaskCreate(thread_1, (const char*) "t1", 100, NULL, tskIDLE_PRIORITY, NULL );
	//xTaskCreate(thread_2,(const char *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
	//
	
	xTaskCreate(thread_1,(signed portCHAR *) "t1", 100, NULL, tskIDLE_PRIORITY, NULL );
    23c4:	a1 2c       	mov	r10, r1
    23c6:	b1 2c       	mov	r11, r1
    23c8:	c1 2c       	mov	r12, r1
    23ca:	d1 2c       	mov	r13, r1
    23cc:	e1 2c       	mov	r14, r1
    23ce:	f1 2c       	mov	r15, r1
    23d0:	00 e0       	ldi	r16, 0x00	; 0
    23d2:	20 e0       	ldi	r18, 0x00	; 0
    23d4:	30 e0       	ldi	r19, 0x00	; 0
    23d6:	44 e6       	ldi	r20, 0x64	; 100
    23d8:	50 e0       	ldi	r21, 0x00	; 0
    23da:	61 ec       	ldi	r22, 0xC1	; 193
    23dc:	72 e2       	ldi	r23, 0x22	; 34
    23de:	81 e7       	ldi	r24, 0x71	; 113
    23e0:	9f e0       	ldi	r25, 0x0F	; 15
    23e2:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	xTaskCreate(thread_2,(signed portCHAR *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
    23e6:	20 e0       	ldi	r18, 0x00	; 0
    23e8:	30 e0       	ldi	r19, 0x00	; 0
    23ea:	44 e6       	ldi	r20, 0x64	; 100
    23ec:	50 e0       	ldi	r21, 0x00	; 0
    23ee:	64 ec       	ldi	r22, 0xC4	; 196
    23f0:	72 e2       	ldi	r23, 0x22	; 34
    23f2:	88 e6       	ldi	r24, 0x68	; 104
    23f4:	9f e0       	ldi	r25, 0x0F	; 15
    23f6:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	xTaskCreate(USBThread,(signed portCHAR *) "usb", 200, NULL, tskIDLE_PRIORITY, NULL );
    23fa:	20 e0       	ldi	r18, 0x00	; 0
    23fc:	30 e0       	ldi	r19, 0x00	; 0
    23fe:	48 ec       	ldi	r20, 0xC8	; 200
    2400:	50 e0       	ldi	r21, 0x00	; 0
    2402:	67 ec       	ldi	r22, 0xC7	; 199
    2404:	72 e2       	ldi	r23, 0x22	; 34
    2406:	89 e5       	ldi	r24, 0x59	; 89
    2408:	9f e0       	ldi	r25, 0x0F	; 15
    240a:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	

	//starting the scheduler
	vTaskStartScheduler();
    240e:	0e 94 59 05 	call	0xab2	; 0xab2 <vTaskStartScheduler>

	for (;;)
	{
// 		CDC_Device_USBTask(&VirtualSerial_CDC_Interface);
// 		USB_USBTask();
	}
    2412:	ff cf       	rjmp	.-2      	; 0x2412 <main+0x122>

00002414 <EVENT_USB_Device_Connect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    2414:	83 e0       	ldi	r24, 0x03	; 3
    2416:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    241a:	80 e3       	ldi	r24, 0x30	; 48
    241c:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    2420:	82 e0       	ldi	r24, 0x02	; 2
    2422:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    2426:	80 e1       	ldi	r24, 0x10	; 16
    2428:	80 93 65 06 	sts	0x0665, r24
    242c:	08 95       	ret

0000242e <EVENT_USB_Device_Disconnect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    242e:	83 e0       	ldi	r24, 0x03	; 3
    2430:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    2434:	80 e3       	ldi	r24, 0x30	; 48
    2436:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    243a:	81 e0       	ldi	r24, 0x01	; 1
    243c:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    2440:	10 92 65 06 	sts	0x0665, r1
    2444:	08 95       	ret

00002446 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= CDC_Device_ConfigureEndpoints(&VirtualSerial_CDC_Interface);
    2446:	8b e8       	ldi	r24, 0x8B	; 139
    2448:	92 e2       	ldi	r25, 0x22	; 34
    244a:	0e 94 84 07 	call	0xf08	; 0xf08 <CDC_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
    244e:	81 11       	cpse	r24, r1
    2450:	02 c0       	rjmp	.+4      	; 0x2456 <EVENT_USB_Device_ConfigurationChanged+0x10>
    2452:	81 e1       	ldi	r24, 0x11	; 17
    2454:	01 c0       	rjmp	.+2      	; 0x2458 <EVENT_USB_Device_ConfigurationChanged+0x12>
    2456:	82 e2       	ldi	r24, 0x22	; 34
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
    2458:	93 e0       	ldi	r25, 0x03	; 3
    245a:	90 93 e6 07 	sts	0x07E6, r25
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
    245e:	90 e3       	ldi	r25, 0x30	; 48
    2460:	90 93 66 06 	sts	0x0666, r25

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
    2464:	98 2f       	mov	r25, r24
    2466:	93 70       	andi	r25, 0x03	; 3
    2468:	90 93 e5 07 	sts	0x07E5, r25
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
    246c:	80 73       	andi	r24, 0x30	; 48
    246e:	80 93 65 06 	sts	0x0665, r24
    2472:	08 95       	ret

00002474 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	CDC_Device_ProcessControlRequest(&VirtualSerial_CDC_Interface);
    2474:	8b e8       	ldi	r24, 0x8B	; 139
    2476:	92 e2       	ldi	r25, 0x22	; 34
    2478:	0e 94 de 08 	call	0x11bc	; 0x11bc <CDC_Device_ProcessControlRequest>
    247c:	08 95       	ret

0000247e <EVENT_CDC_Device_ControLineStateChanged>:
 *  control lines sent from the host..
 *
 *  \param[in] CDCInterfaceInfo  Pointer to the CDC class interface configuration structure being referenced
 */
void EVENT_CDC_Device_ControLineStateChanged(USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo)
{
    247e:	08 95       	ret

00002480 <DigitalPin_SetDIr>:
void DigitalPin_SetValue(DigitalPin_t *pin){
	pin->_port->OUTSET = (1<< pin->_pin);
}

void DigitalPin_ClearValue(DigitalPin_t *pin){
	pin->_port->OUTCLR = (1<< pin->_pin);
    2480:	66 23       	and	r22, r22
    2482:	79 f0       	breq	.+30     	; 0x24a2 <DigitalPin_SetDIr+0x22>
    2484:	dc 01       	movw	r26, r24
    2486:	ed 91       	ld	r30, X+
    2488:	fc 91       	ld	r31, X
    248a:	11 97       	sbiw	r26, 0x01	; 1
    248c:	21 e0       	ldi	r18, 0x01	; 1
    248e:	30 e0       	ldi	r19, 0x00	; 0
    2490:	a9 01       	movw	r20, r18
    2492:	12 96       	adiw	r26, 0x02	; 2
    2494:	0c 90       	ld	r0, X
    2496:	02 c0       	rjmp	.+4      	; 0x249c <DigitalPin_SetDIr+0x1c>
    2498:	44 0f       	add	r20, r20
    249a:	55 1f       	adc	r21, r21
    249c:	0a 94       	dec	r0
    249e:	e2 f7       	brpl	.-8      	; 0x2498 <DigitalPin_SetDIr+0x18>
    24a0:	41 83       	std	Z+1, r20	; 0x01
    24a2:	08 95       	ret

000024a4 <DigitalPin_ToggleValue>:
}

void DigitalPin_ToggleValue(DigitalPin_t *pin){
	pin->_port->OUTTGL = (1<< pin->_pin);
    24a4:	dc 01       	movw	r26, r24
    24a6:	ed 91       	ld	r30, X+
    24a8:	fc 91       	ld	r31, X
    24aa:	11 97       	sbiw	r26, 0x01	; 1
    24ac:	21 e0       	ldi	r18, 0x01	; 1
    24ae:	30 e0       	ldi	r19, 0x00	; 0
    24b0:	a9 01       	movw	r20, r18
    24b2:	12 96       	adiw	r26, 0x02	; 2
    24b4:	0c 90       	ld	r0, X
    24b6:	02 c0       	rjmp	.+4      	; 0x24bc <DigitalPin_ToggleValue+0x18>
    24b8:	44 0f       	add	r20, r20
    24ba:	55 1f       	adc	r21, r21
    24bc:	0a 94       	dec	r0
    24be:	e2 f7       	brpl	.-8      	; 0x24b8 <DigitalPin_ToggleValue+0x14>
    24c0:	47 83       	std	Z+7, r20	; 0x07
    24c2:	08 95       	ret

000024c4 <__vector_25>:


}

#if defined(USARTC0)
ISR(USARTC0_RXC_vect){
    24c4:	1f 92       	push	r1
    24c6:	0f 92       	push	r0
    24c8:	0f b6       	in	r0, 0x3f	; 63
    24ca:	0f 92       	push	r0
    24cc:	11 24       	eor	r1, r1

}
    24ce:	0f 90       	pop	r0
    24d0:	0f be       	out	0x3f, r0	; 63
    24d2:	0f 90       	pop	r0
    24d4:	1f 90       	pop	r1
    24d6:	18 95       	reti

000024d8 <__vector_27>:

ISR(USARTC0_TXC_vect){
    24d8:	1f 92       	push	r1
    24da:	0f 92       	push	r0
    24dc:	0f b6       	in	r0, 0x3f	; 63
    24de:	0f 92       	push	r0
    24e0:	11 24       	eor	r1, r1
	
}
    24e2:	0f 90       	pop	r0
    24e4:	0f be       	out	0x3f, r0	; 63
    24e6:	0f 90       	pop	r0
    24e8:	1f 90       	pop	r1
    24ea:	18 95       	reti

000024ec <__vector_26>:

ISR(USARTC0_DRE_vect){
    24ec:	1f 92       	push	r1
    24ee:	0f 92       	push	r0
    24f0:	0f b6       	in	r0, 0x3f	; 63
    24f2:	0f 92       	push	r0
    24f4:	11 24       	eor	r1, r1
	
}
    24f6:	0f 90       	pop	r0
    24f8:	0f be       	out	0x3f, r0	; 63
    24fa:	0f 90       	pop	r0
    24fc:	1f 90       	pop	r1
    24fe:	18 95       	reti

00002500 <__vector_28>:
#endif


#if defined(USARTC1)
ISR(USARTC1_RXC_vect){
    2500:	1f 92       	push	r1
    2502:	0f 92       	push	r0
    2504:	0f b6       	in	r0, 0x3f	; 63
    2506:	0f 92       	push	r0
    2508:	11 24       	eor	r1, r1
	
}
    250a:	0f 90       	pop	r0
    250c:	0f be       	out	0x3f, r0	; 63
    250e:	0f 90       	pop	r0
    2510:	1f 90       	pop	r1
    2512:	18 95       	reti

00002514 <__vector_30>:

ISR(USARTC1_TXC_vect){
    2514:	1f 92       	push	r1
    2516:	0f 92       	push	r0
    2518:	0f b6       	in	r0, 0x3f	; 63
    251a:	0f 92       	push	r0
    251c:	11 24       	eor	r1, r1
	
}
    251e:	0f 90       	pop	r0
    2520:	0f be       	out	0x3f, r0	; 63
    2522:	0f 90       	pop	r0
    2524:	1f 90       	pop	r1
    2526:	18 95       	reti

00002528 <__vector_29>:

ISR(USARTC1_DRE_vect){
    2528:	1f 92       	push	r1
    252a:	0f 92       	push	r0
    252c:	0f b6       	in	r0, 0x3f	; 63
    252e:	0f 92       	push	r0
    2530:	11 24       	eor	r1, r1
	
}
    2532:	0f 90       	pop	r0
    2534:	0f be       	out	0x3f, r0	; 63
    2536:	0f 90       	pop	r0
    2538:	1f 90       	pop	r1
    253a:	18 95       	reti

0000253c <__vector_88>:
#endif


#if defined(USARTD0)
ISR(USARTD0_RXC_vect){
    253c:	1f 92       	push	r1
    253e:	0f 92       	push	r0
    2540:	0f b6       	in	r0, 0x3f	; 63
    2542:	0f 92       	push	r0
    2544:	11 24       	eor	r1, r1
	
}
    2546:	0f 90       	pop	r0
    2548:	0f be       	out	0x3f, r0	; 63
    254a:	0f 90       	pop	r0
    254c:	1f 90       	pop	r1
    254e:	18 95       	reti

00002550 <__vector_90>:

ISR(USARTD0_TXC_vect){
    2550:	1f 92       	push	r1
    2552:	0f 92       	push	r0
    2554:	0f b6       	in	r0, 0x3f	; 63
    2556:	0f 92       	push	r0
    2558:	11 24       	eor	r1, r1
	
}
    255a:	0f 90       	pop	r0
    255c:	0f be       	out	0x3f, r0	; 63
    255e:	0f 90       	pop	r0
    2560:	1f 90       	pop	r1
    2562:	18 95       	reti

00002564 <__vector_89>:

ISR(USARTD0_DRE_vect){
    2564:	1f 92       	push	r1
    2566:	0f 92       	push	r0
    2568:	0f b6       	in	r0, 0x3f	; 63
    256a:	0f 92       	push	r0
    256c:	11 24       	eor	r1, r1
	
}
    256e:	0f 90       	pop	r0
    2570:	0f be       	out	0x3f, r0	; 63
    2572:	0f 90       	pop	r0
    2574:	1f 90       	pop	r1
    2576:	18 95       	reti

00002578 <__vector_58>:
	
}
#endif

#if defined(USARTE0)
ISR(USARTE0_RXC_vect){
    2578:	1f 92       	push	r1
    257a:	0f 92       	push	r0
    257c:	0f b6       	in	r0, 0x3f	; 63
    257e:	0f 92       	push	r0
    2580:	11 24       	eor	r1, r1
	
}
    2582:	0f 90       	pop	r0
    2584:	0f be       	out	0x3f, r0	; 63
    2586:	0f 90       	pop	r0
    2588:	1f 90       	pop	r1
    258a:	18 95       	reti

0000258c <__vector_60>:

ISR(USARTE0_TXC_vect){
    258c:	1f 92       	push	r1
    258e:	0f 92       	push	r0
    2590:	0f b6       	in	r0, 0x3f	; 63
    2592:	0f 92       	push	r0
    2594:	11 24       	eor	r1, r1
	
}
    2596:	0f 90       	pop	r0
    2598:	0f be       	out	0x3f, r0	; 63
    259a:	0f 90       	pop	r0
    259c:	1f 90       	pop	r1
    259e:	18 95       	reti

000025a0 <__vector_59>:

ISR(USARTE0_DRE_vect){
    25a0:	1f 92       	push	r1
    25a2:	0f 92       	push	r0
    25a4:	0f b6       	in	r0, 0x3f	; 63
    25a6:	0f 92       	push	r0
    25a8:	11 24       	eor	r1, r1
	
}
    25aa:	0f 90       	pop	r0
    25ac:	0f be       	out	0x3f, r0	; 63
    25ae:	0f 90       	pop	r0
    25b0:	1f 90       	pop	r1
    25b2:	18 95       	reti

000025b4 <CCPWrite>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
    25b4:	0f 93       	push	r16
    25b6:	cf 93       	push	r28
    25b8:	df 93       	push	r29
    25ba:	1f 92       	push	r1
    25bc:	cd b7       	in	r28, 0x3d	; 61
    25be:	de b7       	in	r29, 0x3e	; 62
    25c0:	2f b7       	in	r18, 0x3f	; 63
    25c2:	29 83       	std	Y+1, r18	; 0x01
    25c4:	f8 94       	cli
    25c6:	1b be       	out	0x3b, r1	; 59
    25c8:	fc 01       	movw	r30, r24
    25ca:	08 ed       	ldi	r16, 0xD8	; 216
    25cc:	04 bf       	out	0x34, r16	; 52
    25ce:	60 83       	st	Z, r22
    25d0:	89 81       	ldd	r24, Y+1	; 0x01
    25d2:	8f bf       	out	0x3f, r24	; 63
    25d4:	0f 90       	pop	r0
    25d6:	df 91       	pop	r29
    25d8:	cf 91       	pop	r28
    25da:	0f 91       	pop	r16
    25dc:	08 95       	ret

000025de <CLKSYS_Disable>:
    25de:	e0 e5       	ldi	r30, 0x50	; 80
    25e0:	f0 e0       	ldi	r31, 0x00	; 0
    25e2:	90 81       	ld	r25, Z
    25e4:	28 2f       	mov	r18, r24
    25e6:	20 95       	com	r18
    25e8:	92 23       	and	r25, r18
    25ea:	90 83       	st	Z, r25
    25ec:	90 81       	ld	r25, Z
    25ee:	89 23       	and	r24, r25
    25f0:	08 95       	ret

000025f2 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    25f2:	0f 93       	push	r16
    25f4:	1f 93       	push	r17
    25f6:	cf 93       	push	r28
    25f8:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    25fa:	00 e4       	ldi	r16, 0x40	; 64
    25fc:	10 e0       	ldi	r17, 0x00	; 0
    25fe:	f8 01       	movw	r30, r16
    2600:	60 81       	ld	r22, Z
    2602:	68 7f       	andi	r22, 0xF8	; 248
    2604:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    2606:	80 e4       	ldi	r24, 0x40	; 64
    2608:	90 e0       	ldi	r25, 0x00	; 0
    260a:	0e 94 da 12 	call	0x25b4	; 0x25b4 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    260e:	f8 01       	movw	r30, r16
    2610:	80 81       	ld	r24, Z
	return clkCtrl;
}
    2612:	8c 23       	and	r24, r28
    2614:	cf 91       	pop	r28
    2616:	1f 91       	pop	r17
    2618:	0f 91       	pop	r16
    261a:	08 95       	ret

0000261c <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
    261c:	fc 01       	movw	r30, r24
    261e:	90 81       	ld	r25, Z
    2620:	90 7f       	andi	r25, 0xF0	; 240
    2622:	69 2b       	or	r22, r25
    2624:	60 83       	st	Z, r22
    2626:	08 95       	ret

00002628 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
    2628:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    262a:	96 81       	ldd	r25, Z+6	; 0x06
    262c:	9c 7f       	andi	r25, 0xFC	; 252
    262e:	69 2b       	or	r22, r25
    2630:	66 83       	std	Z+6, r22	; 0x06
    2632:	08 95       	ret

00002634 <__udivmodsi4>:
    2634:	a1 e2       	ldi	r26, 0x21	; 33
    2636:	1a 2e       	mov	r1, r26
    2638:	aa 1b       	sub	r26, r26
    263a:	bb 1b       	sub	r27, r27
    263c:	fd 01       	movw	r30, r26
    263e:	0d c0       	rjmp	.+26     	; 0x265a <__udivmodsi4_ep>

00002640 <__udivmodsi4_loop>:
    2640:	aa 1f       	adc	r26, r26
    2642:	bb 1f       	adc	r27, r27
    2644:	ee 1f       	adc	r30, r30
    2646:	ff 1f       	adc	r31, r31
    2648:	a2 17       	cp	r26, r18
    264a:	b3 07       	cpc	r27, r19
    264c:	e4 07       	cpc	r30, r20
    264e:	f5 07       	cpc	r31, r21
    2650:	20 f0       	brcs	.+8      	; 0x265a <__udivmodsi4_ep>
    2652:	a2 1b       	sub	r26, r18
    2654:	b3 0b       	sbc	r27, r19
    2656:	e4 0b       	sbc	r30, r20
    2658:	f5 0b       	sbc	r31, r21

0000265a <__udivmodsi4_ep>:
    265a:	66 1f       	adc	r22, r22
    265c:	77 1f       	adc	r23, r23
    265e:	88 1f       	adc	r24, r24
    2660:	99 1f       	adc	r25, r25
    2662:	1a 94       	dec	r1
    2664:	69 f7       	brne	.-38     	; 0x2640 <__udivmodsi4_loop>
    2666:	60 95       	com	r22
    2668:	70 95       	com	r23
    266a:	80 95       	com	r24
    266c:	90 95       	com	r25
    266e:	9b 01       	movw	r18, r22
    2670:	ac 01       	movw	r20, r24
    2672:	bd 01       	movw	r22, r26
    2674:	cf 01       	movw	r24, r30
    2676:	08 95       	ret

00002678 <__tablejump2__>:
    2678:	ee 0f       	add	r30, r30
    267a:	ff 1f       	adc	r31, r31
    267c:	88 1f       	adc	r24, r24
    267e:	8b bf       	out	0x3b, r24	; 59
    2680:	07 90       	elpm	r0, Z+
    2682:	f6 91       	elpm	r31, Z
    2684:	e0 2d       	mov	r30, r0
    2686:	19 94       	eijmp

00002688 <memset>:
    2688:	dc 01       	movw	r26, r24
    268a:	01 c0       	rjmp	.+2      	; 0x268e <memset+0x6>
    268c:	6d 93       	st	X+, r22
    268e:	41 50       	subi	r20, 0x01	; 1
    2690:	50 40       	sbci	r21, 0x00	; 0
    2692:	e0 f7       	brcc	.-8      	; 0x268c <memset+0x4>
    2694:	08 95       	ret

00002696 <fwrite>:
    2696:	8f 92       	push	r8
    2698:	9f 92       	push	r9
    269a:	af 92       	push	r10
    269c:	bf 92       	push	r11
    269e:	cf 92       	push	r12
    26a0:	df 92       	push	r13
    26a2:	ef 92       	push	r14
    26a4:	ff 92       	push	r15
    26a6:	0f 93       	push	r16
    26a8:	1f 93       	push	r17
    26aa:	cf 93       	push	r28
    26ac:	df 93       	push	r29
    26ae:	5b 01       	movw	r10, r22
    26b0:	4a 01       	movw	r8, r20
    26b2:	79 01       	movw	r14, r18
    26b4:	d9 01       	movw	r26, r18
    26b6:	13 96       	adiw	r26, 0x03	; 3
    26b8:	2c 91       	ld	r18, X
    26ba:	21 ff       	sbrs	r18, 1
    26bc:	1d c0       	rjmp	.+58     	; 0x26f8 <fwrite+0x62>
    26be:	c0 e0       	ldi	r28, 0x00	; 0
    26c0:	d0 e0       	ldi	r29, 0x00	; 0
    26c2:	c8 15       	cp	r28, r8
    26c4:	d9 05       	cpc	r29, r9
    26c6:	d9 f0       	breq	.+54     	; 0x26fe <fwrite+0x68>
    26c8:	8c 01       	movw	r16, r24
    26ca:	6c 01       	movw	r12, r24
    26cc:	ca 0c       	add	r12, r10
    26ce:	db 1c       	adc	r13, r11
    26d0:	c8 01       	movw	r24, r16
    26d2:	0c 15       	cp	r16, r12
    26d4:	1d 05       	cpc	r17, r13
    26d6:	71 f0       	breq	.+28     	; 0x26f4 <fwrite+0x5e>
    26d8:	0f 5f       	subi	r16, 0xFF	; 255
    26da:	1f 4f       	sbci	r17, 0xFF	; 255
    26dc:	d7 01       	movw	r26, r14
    26de:	18 96       	adiw	r26, 0x08	; 8
    26e0:	ed 91       	ld	r30, X+
    26e2:	fc 91       	ld	r31, X
    26e4:	19 97       	sbiw	r26, 0x09	; 9
    26e6:	b7 01       	movw	r22, r14
    26e8:	dc 01       	movw	r26, r24
    26ea:	8c 91       	ld	r24, X
    26ec:	19 95       	eicall
    26ee:	89 2b       	or	r24, r25
    26f0:	79 f3       	breq	.-34     	; 0x26d0 <fwrite+0x3a>
    26f2:	05 c0       	rjmp	.+10     	; 0x26fe <fwrite+0x68>
    26f4:	21 96       	adiw	r28, 0x01	; 1
    26f6:	e5 cf       	rjmp	.-54     	; 0x26c2 <fwrite+0x2c>
    26f8:	80 e0       	ldi	r24, 0x00	; 0
    26fa:	90 e0       	ldi	r25, 0x00	; 0
    26fc:	01 c0       	rjmp	.+2      	; 0x2700 <fwrite+0x6a>
    26fe:	ce 01       	movw	r24, r28
    2700:	df 91       	pop	r29
    2702:	cf 91       	pop	r28
    2704:	1f 91       	pop	r17
    2706:	0f 91       	pop	r16
    2708:	ff 90       	pop	r15
    270a:	ef 90       	pop	r14
    270c:	df 90       	pop	r13
    270e:	cf 90       	pop	r12
    2710:	bf 90       	pop	r11
    2712:	af 90       	pop	r10
    2714:	9f 90       	pop	r9
    2716:	8f 90       	pop	r8
    2718:	08 95       	ret

0000271a <_exit>:
    271a:	f8 94       	cli

0000271c <__stop_program>:
    271c:	ff cf       	rjmp	.-2      	; 0x271c <__stop_program>
