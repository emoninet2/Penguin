
penguin.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001a4c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002b2  00802000  00001a4c  00001ae0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000862  008022b2  008022b2  00001d92  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001d92  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001dc4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000009a8  00000000  00000000  00001e04  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000cf68  00000000  00000000  000027ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002574  00000000  00000000  0000f714  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000377b  00000000  00000000  00011c88  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c8c  00000000  00000000  00015404  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000051d5  00000000  00000000  00017090  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007185  00000000  00000000  0001c265  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009e0  00000000  00000000  000233ea  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
       0:	0c 94 06 01 	jmp	0x20c	; 0x20c <__ctors_end>
       4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
       8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
       c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      10:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      14:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      18:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      1c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      20:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      24:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
      28:	0c 94 a7 0c 	jmp	0x194e	; 0x194e <__vector_10>
      2c:	0c 94 e4 0c 	jmp	0x19c8	; 0x19c8 <__vector_11>
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
      30:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      34:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
      38:	0c 94 d7 03 	jmp	0x7ae	; 0x7ae <__vector_14>

	if (Endpoint_IsSETUPReceived())
      3c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      40:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
      44:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      48:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

		switch (USB_ControlRequest.bRequest)
      4c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      50:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      54:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      58:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      5c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      60:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      64:	0c 94 b9 0a 	jmp	0x1572	; 0x1572 <__vector_25>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
      68:	0c 94 cd 0a 	jmp	0x159a	; 0x159a <__vector_26>
      6c:	0c 94 c3 0a 	jmp	0x1586	; 0x1586 <__vector_27>
      70:	0c 94 d7 0a 	jmp	0x15ae	; 0x15ae <__vector_28>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
      74:	0c 94 eb 0a 	jmp	0x15d6	; 0x15d6 <__vector_29>
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
      78:	0c 94 e1 0a 	jmp	0x15c2	; 0x15c2 <__vector_30>
      7c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
      80:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
      84:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      88:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
      8c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      90:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      94:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      98:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

			CurrentStatus = Endpoint_IsStalled();

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
      9c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      a0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
			break;
		default:
			return;
	}

	Endpoint_ClearSETUP();
      a4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
      a8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
				Endpoint_Write_8(Data >> 8);
      ac:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      b0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();
      b4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	Endpoint_ClearStatusStage();
      b8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
      bc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      c0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      c4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      c8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
      cc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      d0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      d4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
      d8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      dc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

				if (EndpointIndex == ENDPOINT_CONTROLEP)
      e0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
      e4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      e8:	0c 94 13 0b 	jmp	0x1626	; 0x1626 <__vector_58>

				if (Endpoint_IsEnabled())
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
      ec:	0c 94 27 0b 	jmp	0x164e	; 0x164e <__vector_59>
      f0:	0c 94 1d 0b 	jmp	0x163a	; 0x163a <__vector_60>
					{
						Endpoint_StallTransaction();
      f4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
			 *  \ingroup Group_EndpointPacketManagement_XMEGA
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				USB_Endpoint_SelectedHandle->CTRL &= ~USB_EP_STALL_bm;
      f8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
      fc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     100:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     104:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				if (Address & ENDPOINT_DIR_IN)
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].IN.Position  = 0;
				else
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].OUT.Position = 0;
     108:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     10c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     110:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				USB_Endpoint_SelectedHandle->STATUS &= ~USB_EP_TOGGLE_bm;
     114:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     118:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     11c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     120:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
		#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
     124:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	Endpoint_ClearSETUP();
     128:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	Endpoint_ClearStatusStage();
     12c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     130:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
     134:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
     138:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();
     13c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	Endpoint_ClearStatusStage();
     140:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	while (!(Endpoint_IsINReady()));
     144:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     148:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
     14c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
     150:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     154:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     158:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     15c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
     160:	0c 94 f5 0a 	jmp	0x15ea	; 0x15ea <__vector_88>
     164:	0c 94 09 0b 	jmp	0x1612	; 0x1612 <__vector_89>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
     168:	0c 94 ff 0a 	jmp	0x15fe	; 0x15fe <__vector_90>
     16c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     170:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     174:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
     178:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
     17c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
     180:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
     184:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     188:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
     18c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte;

					NVM.CMD    = NVM_CMD_READ_CALIB_ROW_gc;
     190:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     194:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     198:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
					SerialByte = pgm_read_byte(SigReadAddress);
     19c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
					NVM.CMD    = 0;
     1a0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1a4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

					if (SerialCharNum & 0x01)
     1a8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
					{
						SerialByte >>= 4;
     1ac:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
						SigReadAddress++;
					}

					SerialByte &= 0x0F;
     1b0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
     1b4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1b8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1bc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1c0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1c4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
     1c8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1cc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();
     1d0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
     1d4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1d8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1dc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
	Endpoint_ClearOUT();
     1e0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1e4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
     1e8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1ec:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1f0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
     1f4:	0c 94 0c 0c 	jmp	0x1818	; 0x1818 <__vector_125>
     1f8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

000001fc <__trampolines_start>:
													 )) == NO_DESCRIPTOR)
	{
		return;
	}

	Endpoint_ClearSETUP();
     1fc:	0c 94 9a 04 	jmp	0x934	; 0x934 <prvIdleTask>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
     200:	0c 94 f0 07 	jmp	0xfe0	; 0xfe0 <thread_1>
     204:	0c 94 04 08 	jmp	0x1008	; 0x1008 <thread_2>
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
     208:	0c 94 18 08 	jmp	0x1030	; 0x1030 <thread_3>

0000020c <__ctors_end>:
     20c:	11 24       	eor	r1, r1
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
     20e:	1f be       	out	0x3f, r1	; 63
     210:	cf ef       	ldi	r28, 0xFF	; 255
	EVENT_USB_Device_ConfigurationChanged();
}

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
     212:	cd bf       	out	0x3d, r28	; 61
     214:	df e9       	ldi	r29, 0x9F	; 159

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
     216:	de bf       	out	0x3e, r29	; 62
     218:	00 e0       	ldi	r16, 0x00	; 0
     21a:	0c bf       	out	0x3c, r16	; 60

0000021c <__do_copy_data>:
     21c:	12 e2       	ldi	r17, 0x22	; 34
	Endpoint_ClearIN();
     21e:	a0 e0       	ldi	r26, 0x00	; 0
     220:	b0 e2       	ldi	r27, 0x20	; 32

	Endpoint_ClearStatusStage();
     222:	ec e4       	ldi	r30, 0x4C	; 76
     224:	fa e1       	ldi	r31, 0x1A	; 26
     226:	00 e0       	ldi	r16, 0x00	; 0
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
     228:	0b bf       	out	0x3b, r16	; 59
     22a:	02 c0       	rjmp	.+4      	; 0x230 <__do_copy_data+0x14>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
     22c:	07 90       	elpm	r0, Z+
     22e:	0d 92       	st	X+, r0
     230:	a2 3b       	cpi	r26, 0xB2	; 178
     232:	b1 07       	cpc	r27, r17
	if ((uint8_t)USB_ControlRequest.wValue > DevDescriptorPtr->NumberOfConfigurations)
	  return;
	#endif
	#endif

	Endpoint_ClearSETUP();
     234:	d9 f7       	brne	.-10     	; 0x22c <__do_copy_data+0x10>

00000236 <__do_clear_bss>:
     236:	2b e2       	ldi	r18, 0x2B	; 43

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
     238:	a2 eb       	ldi	r26, 0xB2	; 178
     23a:	b2 e2       	ldi	r27, 0x22	; 34
     23c:	01 c0       	rjmp	.+2      	; 0x240 <.do_clear_bss_start>

0000023e <.do_clear_bss_loop>:
     23e:	1d 92       	st	X+, r1

00000240 <.do_clear_bss_start>:

	Endpoint_ClearStatusStage();
     240:	a4 31       	cpi	r26, 0x14	; 20
     242:	b2 07       	cpc	r27, r18

	if (USB_Device_ConfigurationNumber)
     244:	e1 f7       	brne	.-8      	; 0x23e <.do_clear_bss_loop>
     246:	0e 94 bc 09 	call	0x1378	; 0x1378 <main>
     24a:	0c 94 24 0d 	jmp	0x1a48	; 0x1a48 <_exit>

0000024e <__bad_interrupt>:
	  USB_DeviceState = DEVICE_STATE_Configured;
     24e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000252 <arch_spi_master_transmit_byte_val>:
}


static uint8_t arch_spi_master_transmit_byte_val(uint8_t data)
{
	NRF24L01P_SPI.DATA = data;
     252:	80 93 c3 08 	sts	0x08C3, r24
	while(!(SPIC.STATUS &(1<<SPI_IF_bp)));
     256:	e0 ec       	ldi	r30, 0xC0	; 192
     258:	f8 e0       	ldi	r31, 0x08	; 8
     25a:	82 81       	ldd	r24, Z+2	; 0x02
     25c:	88 23       	and	r24, r24
     25e:	ec f7       	brge	.-6      	; 0x25a <arch_spi_master_transmit_byte_val+0x8>
	return SPIC.DATA;
     260:	80 91 c3 08 	lds	r24, 0x08C3
}
     264:	08 95       	ret

00000266 <arch_spi_master_transmit_byte_ref>:

static uint8_t arch_spi_master_transmit_byte_ref(uint8_t *data)
{
	NRF24L01P_SPI.DATA = *data;
     266:	fc 01       	movw	r30, r24
     268:	80 81       	ld	r24, Z
     26a:	80 93 c3 08 	sts	0x08C3, r24
	while(!(NRF24L01P_SPI.STATUS &(1<<SPI_IF_bp)));
     26e:	e0 ec       	ldi	r30, 0xC0	; 192
     270:	f8 e0       	ldi	r31, 0x08	; 8
     272:	82 81       	ldd	r24, Z+2	; 0x02
     274:	88 23       	and	r24, r24
     276:	ec f7       	brge	.-6      	; 0x272 <arch_spi_master_transmit_byte_ref+0xc>
	return NRF24L01P_SPI.DATA;
     278:	80 91 c3 08 	lds	r24, 0x08C3
}
     27c:	08 95       	ret

0000027e <_nrf24l01p_csn_pin>:

void _nrf24l01p_ce_pin(bool state){
	arch_nrf24l01p_ce_pin(state);
	ce_value = state;
}
void _nrf24l01p_csn_pin(bool state){
     27e:	cf 93       	push	r28
     280:	c8 2f       	mov	r28, r24

static void arch_nrf24l01p_csn_pin(bool state){
// 	if(state) NRF24L01P_CSN_PIN_PORT.OUTSET = (1<<NRF24L01P_CSN_PIN_BIT) ;
// 	else NRF24L01P_CSN_PIN_PORT.OUTCLR = (1<<NRF24L01P_CSN_PIN_BIT);

	if(state) DigitalPin_SetValue(&nrf24l01p_csn_pin) ;
     282:	88 23       	and	r24, r24
     284:	29 f0       	breq	.+10     	; 0x290 <_nrf24l01p_csn_pin+0x12>
     286:	80 e0       	ldi	r24, 0x00	; 0
     288:	90 e2       	ldi	r25, 0x20	; 32
     28a:	0e 94 99 0a 	call	0x1532	; 0x1532 <DigitalPin_SetValue>
     28e:	04 c0       	rjmp	.+8      	; 0x298 <_nrf24l01p_csn_pin+0x1a>
	else DigitalPin_ClearValue(&nrf24l01p_csn_pin);
     290:	80 e0       	ldi	r24, 0x00	; 0
     292:	90 e2       	ldi	r25, 0x20	; 32
     294:	0e 94 a9 0a 	call	0x1552	; 0x1552 <DigitalPin_ClearValue>

	arch_nrf24l01p_csn_pin(state);
	csn_value = state;
     298:	c0 93 61 28 	sts	0x2861, r28
}
     29c:	cf 91       	pop	r28
     29e:	08 95       	ret

000002a0 <_nrf24l01p_read_register>:
	_nrf24l01p_disable_dynamic_payload_all_pipe();/////////ALSO CREEATE FOR DISABLE AUTO ACK FOR ALL PIPE
	_nrf24l01p_startup();
	
}

void _nrf24l01p_read_register(uint8_t address, uint8_t *dataout, int len){
     2a0:	ef 92       	push	r14
     2a2:	ff 92       	push	r15
     2a4:	0f 93       	push	r16
     2a6:	1f 93       	push	r17
     2a8:	cf 93       	push	r28
     2aa:	df 93       	push	r29
     2ac:	c8 2f       	mov	r28, r24
     2ae:	7b 01       	movw	r14, r22
     2b0:	8a 01       	movw	r16, r20
	_nrf24l01p_csn_pin(0);
     2b2:	80 e0       	ldi	r24, 0x00	; 0
     2b4:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(address&(_NRF24L01P_REG_ADDRESS_MASK));
     2b8:	8c 2f       	mov	r24, r28
     2ba:	8f 71       	andi	r24, 0x1F	; 31
     2bc:	0e 94 29 01 	call	0x252	; 0x252 <arch_spi_master_transmit_byte_val>
	for(int i=0;i<len;i++){
     2c0:	10 16       	cp	r1, r16
     2c2:	11 06       	cpc	r1, r17
     2c4:	94 f4       	brge	.+36     	; 0x2ea <_nrf24l01p_read_register+0x4a>
     2c6:	e7 01       	movw	r28, r14
     2c8:	0e 0d       	add	r16, r14
     2ca:	1f 1d       	adc	r17, r15
}

static void arch_spi_master_receive_byte_ref(uint8_t *data){
	//transmit dummy byte
	arch_spi_master_transmit_byte_val(0xFF);
	*data = NRF24L01P_SPI.DATA;
     2cc:	0f 2e       	mov	r0, r31
     2ce:	f0 ec       	ldi	r31, 0xC0	; 192
     2d0:	ef 2e       	mov	r14, r31
     2d2:	f8 e0       	ldi	r31, 0x08	; 8
     2d4:	ff 2e       	mov	r15, r31
     2d6:	f0 2d       	mov	r31, r0
	return NRF24L01P_SPI.DATA;
}

static void arch_spi_master_receive_byte_ref(uint8_t *data){
	//transmit dummy byte
	arch_spi_master_transmit_byte_val(0xFF);
     2d8:	8f ef       	ldi	r24, 0xFF	; 255
     2da:	0e 94 29 01 	call	0x252	; 0x252 <arch_spi_master_transmit_byte_val>
	*data = NRF24L01P_SPI.DATA;
     2de:	f7 01       	movw	r30, r14
     2e0:	83 81       	ldd	r24, Z+3	; 0x03
     2e2:	89 93       	st	Y+, r24
     2e4:	c0 17       	cp	r28, r16
     2e6:	d1 07       	cpc	r29, r17
     2e8:	b9 f7       	brne	.-18     	; 0x2d8 <_nrf24l01p_read_register+0x38>
		arch_spi_master_receive_byte_ref(dataout+ i);
	}
	_nrf24l01p_csn_pin(1);
     2ea:	81 e0       	ldi	r24, 0x01	; 1
     2ec:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
}
     2f0:	df 91       	pop	r29
     2f2:	cf 91       	pop	r28
     2f4:	1f 91       	pop	r17
     2f6:	0f 91       	pop	r16
     2f8:	ff 90       	pop	r15
     2fa:	ef 90       	pop	r14
     2fc:	08 95       	ret

000002fe <_nrf24l01p_write_register>:

void _nrf24l01p_write_register(uint8_t address, uint8_t *datain, int len){
     2fe:	ef 92       	push	r14
     300:	ff 92       	push	r15
     302:	0f 93       	push	r16
     304:	1f 93       	push	r17
     306:	cf 93       	push	r28
     308:	df 93       	push	r29
     30a:	c8 2f       	mov	r28, r24
     30c:	7b 01       	movw	r14, r22
     30e:	8a 01       	movw	r16, r20
	_nrf24l01p_csn_pin(0);
     310:	80 e0       	ldi	r24, 0x00	; 0
     312:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(( _NRF24L01P_SPI_CMD_WR_REG | (address&(_NRF24L01P_REG_ADDRESS_MASK))));
     316:	8c 2f       	mov	r24, r28
     318:	8f 71       	andi	r24, 0x1F	; 31
     31a:	80 62       	ori	r24, 0x20	; 32
     31c:	0e 94 29 01 	call	0x252	; 0x252 <arch_spi_master_transmit_byte_val>
	for(int i=0;i<len;i++){
     320:	10 16       	cp	r1, r16
     322:	11 06       	cpc	r1, r17
     324:	54 f4       	brge	.+20     	; 0x33a <_nrf24l01p_write_register+0x3c>
     326:	e7 01       	movw	r28, r14
     328:	0e 0d       	add	r16, r14
     32a:	1f 1d       	adc	r17, r15
		arch_spi_master_transmit_byte_ref(datain+i);
     32c:	ce 01       	movw	r24, r28
     32e:	0e 94 33 01 	call	0x266	; 0x266 <arch_spi_master_transmit_byte_ref>
     332:	21 96       	adiw	r28, 0x01	; 1
}

void _nrf24l01p_write_register(uint8_t address, uint8_t *datain, int len){
	_nrf24l01p_csn_pin(0);
	arch_spi_master_transmit_byte_val(( _NRF24L01P_SPI_CMD_WR_REG | (address&(_NRF24L01P_REG_ADDRESS_MASK))));
	for(int i=0;i<len;i++){
     334:	c0 17       	cp	r28, r16
     336:	d1 07       	cpc	r29, r17
     338:	c9 f7       	brne	.-14     	; 0x32c <_nrf24l01p_write_register+0x2e>
		arch_spi_master_transmit_byte_ref(datain+i);
	}
	_nrf24l01p_csn_pin(1);
     33a:	81 e0       	ldi	r24, 0x01	; 1
     33c:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
}
     340:	df 91       	pop	r29
     342:	cf 91       	pop	r28
     344:	1f 91       	pop	r17
     346:	0f 91       	pop	r16
     348:	ff 90       	pop	r15
     34a:	ef 90       	pop	r14
     34c:	08 95       	ret

0000034e <_nrf24l01p_read_rx_payload>:



void _nrf24l01p_read_rx_payload(uint8_t *dataout, int pay_len){
     34e:	ef 92       	push	r14
     350:	ff 92       	push	r15
     352:	0f 93       	push	r16
     354:	1f 93       	push	r17
     356:	cf 93       	push	r28
     358:	df 93       	push	r29
     35a:	7c 01       	movw	r14, r24
     35c:	8b 01       	movw	r16, r22
	_nrf24l01p_csn_pin(0);
     35e:	80 e0       	ldi	r24, 0x00	; 0
     360:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_RD_RX_PAYLOAD);
     364:	81 e6       	ldi	r24, 0x61	; 97
     366:	0e 94 29 01 	call	0x252	; 0x252 <arch_spi_master_transmit_byte_val>
	for(int i=0;i<pay_len;i++){
     36a:	10 16       	cp	r1, r16
     36c:	11 06       	cpc	r1, r17
     36e:	94 f4       	brge	.+36     	; 0x394 <_nrf24l01p_read_rx_payload+0x46>
     370:	e7 01       	movw	r28, r14
     372:	0e 0d       	add	r16, r14
     374:	1f 1d       	adc	r17, r15
     376:	0f 2e       	mov	r0, r31
     378:	f0 ec       	ldi	r31, 0xC0	; 192
     37a:	ef 2e       	mov	r14, r31
     37c:	f8 e0       	ldi	r31, 0x08	; 8
     37e:	ff 2e       	mov	r15, r31
     380:	f0 2d       	mov	r31, r0
	return NRF24L01P_SPI.DATA;
}

static void arch_spi_master_receive_byte_ref(uint8_t *data){
	//transmit dummy byte
	arch_spi_master_transmit_byte_val(0xFF);
     382:	8f ef       	ldi	r24, 0xFF	; 255
     384:	0e 94 29 01 	call	0x252	; 0x252 <arch_spi_master_transmit_byte_val>
	*data = NRF24L01P_SPI.DATA;
     388:	f7 01       	movw	r30, r14
     38a:	93 81       	ldd	r25, Z+3	; 0x03
     38c:	99 93       	st	Y+, r25
     38e:	c0 17       	cp	r28, r16
     390:	d1 07       	cpc	r29, r17
     392:	b9 f7       	brne	.-18     	; 0x382 <_nrf24l01p_read_rx_payload+0x34>
		arch_spi_master_receive_byte_ref(dataout+ i);
	}
	_nrf24l01p_csn_pin(1);
     394:	81 e0       	ldi	r24, 0x01	; 1
     396:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
}
     39a:	df 91       	pop	r29
     39c:	cf 91       	pop	r28
     39e:	1f 91       	pop	r17
     3a0:	0f 91       	pop	r16
     3a2:	ff 90       	pop	r15
     3a4:	ef 90       	pop	r14
     3a6:	08 95       	ret

000003a8 <_nrf24l01p_flush_rx>:
	_nrf24l01p_csn_pin(0);
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_FLUSH_TX);
	_nrf24l01p_csn_pin(1);
}
void _nrf24l01p_flush_rx(){
	_nrf24l01p_csn_pin(0);
     3a8:	80 e0       	ldi	r24, 0x00	; 0
     3aa:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_FLUSH_RX);
     3ae:	82 ee       	ldi	r24, 0xE2	; 226
     3b0:	0e 94 29 01 	call	0x252	; 0x252 <arch_spi_master_transmit_byte_val>
	_nrf24l01p_csn_pin(1);
     3b4:	81 e0       	ldi	r24, 0x01	; 1
     3b6:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
     3ba:	08 95       	ret

000003bc <_nrf24l01p_read_rx_payload_width>:
void _nrf24l01p_reuse_tx_payload(){
	_nrf24l01p_csn_pin(0);
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_REUSE_TX_PL);
	_nrf24l01p_csn_pin(1);
}
int _nrf24l01p_read_rx_payload_width(){
     3bc:	cf 93       	push	r28
	_nrf24l01p_csn_pin(0);
     3be:	80 e0       	ldi	r24, 0x00	; 0
     3c0:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_R_RX_PL_WID);
     3c4:	80 e6       	ldi	r24, 0x60	; 96
     3c6:	0e 94 29 01 	call	0x252	; 0x252 <arch_spi_master_transmit_byte_val>
	uint8_t temp =  arch_spi_master_transmit_byte_val(0xFF);
     3ca:	8f ef       	ldi	r24, 0xFF	; 255
     3cc:	0e 94 29 01 	call	0x252	; 0x252 <arch_spi_master_transmit_byte_val>
     3d0:	c8 2f       	mov	r28, r24
	_nrf24l01p_csn_pin(1);
     3d2:	81 e0       	ldi	r24, 0x01	; 1
     3d4:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
	return temp;
}
     3d8:	8c 2f       	mov	r24, r28
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	cf 91       	pop	r28
     3de:	08 95       	ret

000003e0 <_nrf24l01p_get_status>:
		arch_spi_master_transmit_byte_ref(datain+i);
	}
	_nrf24l01p_csn_pin(1);
}

int _nrf24l01p_get_status(){
     3e0:	cf 93       	push	r28
	_nrf24l01p_csn_pin(0);
     3e2:	80 e0       	ldi	r24, 0x00	; 0
     3e4:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
	int temp = arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_NOP);
     3e8:	8f ef       	ldi	r24, 0xFF	; 255
     3ea:	0e 94 29 01 	call	0x252	; 0x252 <arch_spi_master_transmit_byte_val>
     3ee:	c8 2f       	mov	r28, r24
	_nrf24l01p_csn_pin(1);
     3f0:	81 e0       	ldi	r24, 0x01	; 1
     3f2:	0e 94 3f 01 	call	0x27e	; 0x27e <_nrf24l01p_csn_pin>
	
	return temp;
}
     3f6:	8c 2f       	mov	r24, r28
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	cf 91       	pop	r28
     3fc:	08 95       	ret

000003fe <_nrf24l01p_clear_data_ready_flag>:
	if(_nrf24l01p_get_status()&_NRF24L01P_STATUS_RX_DR)flag = 1  ;
	else flag = 0;
	return flag;
}

void _nrf24l01p_clear_data_ready_flag(){
     3fe:	cf 93       	push	r28
     400:	df 93       	push	r29
     402:	1f 92       	push	r1
     404:	cd b7       	in	r28, 0x3d	; 61
     406:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp = _nrf24l01p_get_status();
     408:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_nrf24l01p_get_status>
	temp |= _NRF24L01P_STATUS_RX_DR;
     40c:	80 64       	ori	r24, 0x40	; 64
     40e:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_STATUS,&temp,sizeof(temp));
     410:	41 e0       	ldi	r20, 0x01	; 1
     412:	50 e0       	ldi	r21, 0x00	; 0
     414:	be 01       	movw	r22, r28
     416:	6f 5f       	subi	r22, 0xFF	; 255
     418:	7f 4f       	sbci	r23, 0xFF	; 255
     41a:	87 e0       	ldi	r24, 0x07	; 7
     41c:	0e 94 7f 01 	call	0x2fe	; 0x2fe <_nrf24l01p_write_register>
}
     420:	0f 90       	pop	r0
     422:	df 91       	pop	r29
     424:	cf 91       	pop	r28
     426:	08 95       	ret

00000428 <_nrf24l01p_get_fifo_flag_rx_empty>:
uint8_t _nrf24l01p_get_RX_pipe_width(_nrf24l01p_pipe_t pipe){
	uint8_t temp;
	_nrf24l01p_read_register((_NRF24L01P_REG_RX_PW_P0+pipe),&temp,sizeof(temp));
	return (temp&(0x3F));
}
bool _nrf24l01p_get_fifo_flag_rx_empty(){
     428:	cf 93       	push	r28
     42a:	df 93       	push	r29
     42c:	1f 92       	push	r1
     42e:	cd b7       	in	r28, 0x3d	; 61
     430:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	bool flag;
	_nrf24l01p_read_register(_NRF24L01P_REG_FIFO_STATUS,&temp,sizeof(temp));
     432:	41 e0       	ldi	r20, 0x01	; 1
     434:	50 e0       	ldi	r21, 0x00	; 0
     436:	be 01       	movw	r22, r28
     438:	6f 5f       	subi	r22, 0xFF	; 255
     43a:	7f 4f       	sbci	r23, 0xFF	; 255
     43c:	87 e1       	ldi	r24, 0x17	; 23
     43e:	0e 94 50 01 	call	0x2a0	; 0x2a0 <_nrf24l01p_read_register>
	if(temp&_NRF24L01P_FIFO_STATUS_RX_EMPTY) flag = 1 ;
     442:	89 81       	ldd	r24, Y+1	; 0x01
	else flag = 0;
	return flag;
	
}
     444:	81 70       	andi	r24, 0x01	; 1
     446:	0f 90       	pop	r0
     448:	df 91       	pop	r29
     44a:	cf 91       	pop	r28
     44c:	08 95       	ret

0000044e <_nrf24l01p_readable>:
	_nrf24l01p_ce_pin(1);

}


bool _nrf24l01p_readable(_nrf24l01p_pipe_t pipe){
     44e:	cf 93       	push	r28
	bool flag = 0;
	if((pipe >=0)   && (pipe <=5)){
     450:	86 30       	cpi	r24, 0x06	; 6
     452:	90 f4       	brcc	.+36     	; 0x478 <_nrf24l01p_readable+0x2a>
     454:	c8 2f       	mov	r28, r24
		int status = _nrf24l01p_get_status();
     456:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <_nrf24l01p_get_status>
		if(   (status&_NRF24L01P_STATUS_RX_DR)  && ((status&_NRF24L01P_STATUS_RX_P_NO)>>1)==pipe){
     45a:	86 ff       	sbrs	r24, 6
     45c:	0f c0       	rjmp	.+30     	; 0x47c <_nrf24l01p_readable+0x2e>
     45e:	8e 70       	andi	r24, 0x0E	; 14
     460:	99 27       	eor	r25, r25
     462:	ac 01       	movw	r20, r24
     464:	55 95       	asr	r21
     466:	47 95       	ror	r20
     468:	2c 2f       	mov	r18, r28
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	42 17       	cp	r20, r18
     470:	53 07       	cpc	r21, r19
     472:	29 f0       	breq	.+10     	; 0x47e <_nrf24l01p_readable+0x30>
     474:	80 e0       	ldi	r24, 0x00	; 0
     476:	03 c0       	rjmp	.+6      	; 0x47e <_nrf24l01p_readable+0x30>

}


bool _nrf24l01p_readable(_nrf24l01p_pipe_t pipe){
	bool flag = 0;
     478:	80 e0       	ldi	r24, 0x00	; 0
     47a:	01 c0       	rjmp	.+2      	; 0x47e <_nrf24l01p_readable+0x30>
		int status = _nrf24l01p_get_status();
		if(   (status&_NRF24L01P_STATUS_RX_DR)  && ((status&_NRF24L01P_STATUS_RX_P_NO)>>1)==pipe){
			flag = 1;
		}
		else{
			flag = 0;
     47c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return flag;
}
     47e:	cf 91       	pop	r28
     480:	08 95       	ret

00000482 <_nrf24l01p_read_dyn_pld>:
	else {//if pipe not readable
		return 0;
	}
	return 0;	
}
int _nrf24l01p_read_dyn_pld(_nrf24l01p_pipe_t pipe, uint8_t *data){
     482:	0f 93       	push	r16
     484:	1f 93       	push	r17
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
	
	int rxPayloadWidth;
	
	if ( ( pipe < 0 ) || ( pipe > 5 ) ) {
     48a:	86 30       	cpi	r24, 0x06	; 6
     48c:	f0 f4       	brcc	.+60     	; 0x4ca <_nrf24l01p_read_dyn_pld+0x48>
     48e:	eb 01       	movw	r28, r22
		return -1;
	}
	
	if (_nrf24l01p_readable(pipe) ) {
     490:	0e 94 27 02 	call	0x44e	; 0x44e <_nrf24l01p_readable>
     494:	88 23       	and	r24, r24
     496:	e1 f0       	breq	.+56     	; 0x4d0 <_nrf24l01p_read_dyn_pld+0x4e>
		asm("nop");
     498:	00 00       	nop
		rxPayloadWidth = _nrf24l01p_read_rx_payload_width();
     49a:	0e 94 de 01 	call	0x3bc	; 0x3bc <_nrf24l01p_read_rx_payload_width>
     49e:	8c 01       	movw	r16, r24
	
		if ( ( rxPayloadWidth < 0 ) || ( rxPayloadWidth > _NRF24L01P_RX_FIFO_SIZE ) ) {
     4a0:	81 32       	cpi	r24, 0x21	; 33
     4a2:	91 05       	cpc	r25, r1
     4a4:	28 f0       	brcs	.+10     	; 0x4b0 <_nrf24l01p_read_dyn_pld+0x2e>
			_nrf24l01p_flush_rx();
     4a6:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <_nrf24l01p_flush_rx>
			if(_nrf24l01p_get_fifo_flag_rx_empty()) {
				_nrf24l01p_clear_data_ready_flag();
			}
		}

		return rxPayloadWidth;
     4aa:	80 2f       	mov	r24, r16
     4ac:	91 2f       	mov	r25, r17
     4ae:	15 c0       	rjmp	.+42     	; 0x4da <_nrf24l01p_read_dyn_pld+0x58>
	
		if ( ( rxPayloadWidth < 0 ) || ( rxPayloadWidth > _NRF24L01P_RX_FIFO_SIZE ) ) {
			_nrf24l01p_flush_rx();
		}
		else{
			_nrf24l01p_read_rx_payload(data,rxPayloadWidth);
     4b0:	bc 01       	movw	r22, r24
     4b2:	ce 01       	movw	r24, r28
     4b4:	0e 94 a7 01 	call	0x34e	; 0x34e <_nrf24l01p_read_rx_payload>
					
			if(_nrf24l01p_get_fifo_flag_rx_empty()) {
     4b8:	0e 94 14 02 	call	0x428	; 0x428 <_nrf24l01p_get_fifo_flag_rx_empty>
     4bc:	88 23       	and	r24, r24
     4be:	59 f0       	breq	.+22     	; 0x4d6 <_nrf24l01p_read_dyn_pld+0x54>
				_nrf24l01p_clear_data_ready_flag();
     4c0:	0e 94 ff 01 	call	0x3fe	; 0x3fe <_nrf24l01p_clear_data_ready_flag>
			}
		}

		return rxPayloadWidth;
     4c4:	80 2f       	mov	r24, r16
     4c6:	91 2f       	mov	r25, r17
     4c8:	08 c0       	rjmp	.+16     	; 0x4da <_nrf24l01p_read_dyn_pld+0x58>
int _nrf24l01p_read_dyn_pld(_nrf24l01p_pipe_t pipe, uint8_t *data){
	
	int rxPayloadWidth;
	
	if ( ( pipe < 0 ) || ( pipe > 5 ) ) {
		return -1;
     4ca:	8f ef       	ldi	r24, 0xFF	; 255
     4cc:	9f ef       	ldi	r25, 0xFF	; 255
     4ce:	05 c0       	rjmp	.+10     	; 0x4da <_nrf24l01p_read_dyn_pld+0x58>
// 			_nrf24l01p_clear_data_ready_flag();
// 		}
// 		return rxPayloadWidth;
//	}
	else {//if pipe not readable
		return 0;
     4d0:	80 e0       	ldi	r24, 0x00	; 0
     4d2:	90 e0       	ldi	r25, 0x00	; 0
     4d4:	02 c0       	rjmp	.+4      	; 0x4da <_nrf24l01p_read_dyn_pld+0x58>
			if(_nrf24l01p_get_fifo_flag_rx_empty()) {
				_nrf24l01p_clear_data_ready_flag();
			}
		}

		return rxPayloadWidth;
     4d6:	80 2f       	mov	r24, r16
     4d8:	91 2f       	mov	r25, r17
//	}
	else {//if pipe not readable
		return 0;
	}
	return 0;
}
     4da:	df 91       	pop	r29
     4dc:	cf 91       	pop	r28
     4de:	1f 91       	pop	r17
     4e0:	0f 91       	pop	r16
     4e2:	08 95       	ret

000004e4 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     4e4:	31 e1       	ldi	r19, 0x11	; 17
     4e6:	fc 01       	movw	r30, r24
     4e8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     4ea:	31 97       	sbiw	r30, 0x01	; 1
     4ec:	22 e2       	ldi	r18, 0x22	; 34
     4ee:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     4f0:	31 97       	sbiw	r30, 0x01	; 1
     4f2:	a3 e3       	ldi	r26, 0x33	; 51
     4f4:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	70 83       	st	Z, r23
	pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__) && __AVR_3_BYTE_PC__
	*pxTopOfStack = (portSTACK_TYPE ) 0;
     4fe:	31 97       	sbiw	r30, 0x01	; 1
     500:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     506:	31 97       	sbiw	r30, 0x01	; 1
     508:	60 e8       	ldi	r22, 0x80	; 128
     50a:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     50c:	31 97       	sbiw	r30, 0x01	; 1
     50e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     510:	31 97       	sbiw	r30, 0x01	; 1
     512:	62 e0       	ldi	r22, 0x02	; 2
     514:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     516:	31 97       	sbiw	r30, 0x01	; 1
     518:	63 e0       	ldi	r22, 0x03	; 3
     51a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     51c:	31 97       	sbiw	r30, 0x01	; 1
     51e:	64 e0       	ldi	r22, 0x04	; 4
     520:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     522:	31 97       	sbiw	r30, 0x01	; 1
     524:	65 e0       	ldi	r22, 0x05	; 5
     526:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     528:	31 97       	sbiw	r30, 0x01	; 1
     52a:	66 e0       	ldi	r22, 0x06	; 6
     52c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     52e:	31 97       	sbiw	r30, 0x01	; 1
     530:	67 e0       	ldi	r22, 0x07	; 7
     532:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	68 e0       	ldi	r22, 0x08	; 8
     538:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     53a:	31 97       	sbiw	r30, 0x01	; 1
     53c:	69 e0       	ldi	r22, 0x09	; 9
     53e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	60 e1       	ldi	r22, 0x10	; 16
     544:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     546:	31 97       	sbiw	r30, 0x01	; 1
     548:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     54a:	31 97       	sbiw	r30, 0x01	; 1
     54c:	32 e1       	ldi	r19, 0x12	; 18
     54e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     550:	31 97       	sbiw	r30, 0x01	; 1
     552:	33 e1       	ldi	r19, 0x13	; 19
     554:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	34 e1       	ldi	r19, 0x14	; 20
     55a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     55c:	31 97       	sbiw	r30, 0x01	; 1
     55e:	35 e1       	ldi	r19, 0x15	; 21
     560:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     562:	31 97       	sbiw	r30, 0x01	; 1
     564:	36 e1       	ldi	r19, 0x16	; 22
     566:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     568:	31 97       	sbiw	r30, 0x01	; 1
     56a:	37 e1       	ldi	r19, 0x17	; 23
     56c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     56e:	31 97       	sbiw	r30, 0x01	; 1
     570:	38 e1       	ldi	r19, 0x18	; 24
     572:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     574:	31 97       	sbiw	r30, 0x01	; 1
     576:	39 e1       	ldi	r19, 0x19	; 25
     578:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     57a:	31 97       	sbiw	r30, 0x01	; 1
     57c:	30 e2       	ldi	r19, 0x20	; 32
     57e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     580:	31 97       	sbiw	r30, 0x01	; 1
     582:	31 e2       	ldi	r19, 0x21	; 33
     584:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     586:	31 97       	sbiw	r30, 0x01	; 1
     588:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     58a:	31 97       	sbiw	r30, 0x01	; 1
     58c:	23 e2       	ldi	r18, 0x23	; 35
     58e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     590:	31 97       	sbiw	r30, 0x01	; 1
     592:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     594:	31 97       	sbiw	r30, 0x01	; 1
     596:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     598:	31 97       	sbiw	r30, 0x01	; 1
     59a:	26 e2       	ldi	r18, 0x26	; 38
     59c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     59e:	31 97       	sbiw	r30, 0x01	; 1
     5a0:	27 e2       	ldi	r18, 0x27	; 39
     5a2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     5a4:	31 97       	sbiw	r30, 0x01	; 1
     5a6:	28 e2       	ldi	r18, 0x28	; 40
     5a8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     5aa:	31 97       	sbiw	r30, 0x01	; 1
     5ac:	29 e2       	ldi	r18, 0x29	; 41
     5ae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     5b0:	31 97       	sbiw	r30, 0x01	; 1
     5b2:	20 e3       	ldi	r18, 0x30	; 48
     5b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     5b6:	31 97       	sbiw	r30, 0x01	; 1
     5b8:	21 e3       	ldi	r18, 0x31	; 49
     5ba:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     5bc:	87 97       	sbiw	r24, 0x27	; 39
     5be:	08 95       	ret

000005c0 <xPortStartScheduler>:
static void prvSetupTimerInterrupt( void )
{
    //Use TCC0 as a tick counter. If this is to be changed, change ISR as well
    TC0_t * tickTimer = &TCC0;
    //select the clock source and pre-scale by 64
    TC0_ConfigClockSource(tickTimer, TC_CLKSEL_DIV64_gc);
     5c0:	65 e0       	ldi	r22, 0x05	; 5
     5c2:	80 e0       	ldi	r24, 0x00	; 0
     5c4:	98 e0       	ldi	r25, 0x08	; 8
     5c6:	0e 94 80 0c 	call	0x1900	; 0x1900 <TC0_ConfigClockSource>
    //set period of counter
    tickTimer->PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 64 - 1;
     5ca:	83 ef       	ldi	r24, 0xF3	; 243
     5cc:	91 e0       	ldi	r25, 0x01	; 1
     5ce:	80 93 26 08 	sts	0x0826, r24
     5d2:	90 93 27 08 	sts	0x0827, r25

    //enable interrupt and set low level
    TC0_SetOverflowIntLevel(tickTimer, TC_OVFINTLVL_LO_gc);
     5d6:	61 e0       	ldi	r22, 0x01	; 1
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	98 e0       	ldi	r25, 0x08	; 8
     5dc:	0e 94 86 0c 	call	0x190c	; 0x190c <TC0_SetOverflowIntLevel>
    //enable low level interrupts
    PMIC_EnableLowLevel();
     5e0:	e0 ea       	ldi	r30, 0xA0	; 160
     5e2:	f0 e0       	ldi	r31, 0x00	; 0
     5e4:	82 81       	ldd	r24, Z+2	; 0x02
     5e6:	81 60       	ori	r24, 0x01	; 1
     5e8:	82 83       	std	Z+2, r24	; 0x02
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     5ea:	a0 91 55 26 	lds	r26, 0x2655
     5ee:	b0 91 56 26 	lds	r27, 0x2656
     5f2:	cd 91       	ld	r28, X+
     5f4:	cd bf       	out	0x3d, r28	; 61
     5f6:	dd 91       	ld	r29, X+
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	ff 91       	pop	r31
     5fc:	ef 91       	pop	r30
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	bf 91       	pop	r27
     604:	af 91       	pop	r26
     606:	9f 91       	pop	r25
     608:	8f 91       	pop	r24
     60a:	7f 91       	pop	r23
     60c:	6f 91       	pop	r22
     60e:	5f 91       	pop	r21
     610:	4f 91       	pop	r20
     612:	3f 91       	pop	r19
     614:	2f 91       	pop	r18
     616:	1f 91       	pop	r17
     618:	0f 91       	pop	r16
     61a:	ff 90       	pop	r15
     61c:	ef 90       	pop	r14
     61e:	df 90       	pop	r13
     620:	cf 90       	pop	r12
     622:	bf 90       	pop	r11
     624:	af 90       	pop	r10
     626:	9f 90       	pop	r9
     628:	8f 90       	pop	r8
     62a:	7f 90       	pop	r7
     62c:	6f 90       	pop	r6
     62e:	5f 90       	pop	r5
     630:	4f 90       	pop	r4
     632:	3f 90       	pop	r3
     634:	2f 90       	pop	r2
     636:	1f 90       	pop	r1
     638:	0f 90       	pop	r0
     63a:	0f be       	out	0x3f, r0	; 63
     63c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     63e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     640:	81 e0       	ldi	r24, 0x01	; 1
     642:	08 95       	ret

00000644 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     644:	0f 92       	push	r0
     646:	0f b6       	in	r0, 0x3f	; 63
     648:	f8 94       	cli
     64a:	0f 92       	push	r0
     64c:	1f 92       	push	r1
     64e:	11 24       	eor	r1, r1
     650:	2f 92       	push	r2
     652:	3f 92       	push	r3
     654:	4f 92       	push	r4
     656:	5f 92       	push	r5
     658:	6f 92       	push	r6
     65a:	7f 92       	push	r7
     65c:	8f 92       	push	r8
     65e:	9f 92       	push	r9
     660:	af 92       	push	r10
     662:	bf 92       	push	r11
     664:	cf 92       	push	r12
     666:	df 92       	push	r13
     668:	ef 92       	push	r14
     66a:	ff 92       	push	r15
     66c:	0f 93       	push	r16
     66e:	1f 93       	push	r17
     670:	2f 93       	push	r18
     672:	3f 93       	push	r19
     674:	4f 93       	push	r20
     676:	5f 93       	push	r21
     678:	6f 93       	push	r22
     67a:	7f 93       	push	r23
     67c:	8f 93       	push	r24
     67e:	9f 93       	push	r25
     680:	af 93       	push	r26
     682:	bf 93       	push	r27
     684:	cf 93       	push	r28
     686:	df 93       	push	r29
     688:	ef 93       	push	r30
     68a:	ff 93       	push	r31
     68c:	a0 91 55 26 	lds	r26, 0x2655
     690:	b0 91 56 26 	lds	r27, 0x2656
     694:	0d b6       	in	r0, 0x3d	; 61
     696:	0d 92       	st	X+, r0
     698:	0e b6       	in	r0, 0x3e	; 62
     69a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     69c:	0e 94 83 07 	call	0xf06	; 0xf06 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     6a0:	a0 91 55 26 	lds	r26, 0x2655
     6a4:	b0 91 56 26 	lds	r27, 0x2656
     6a8:	cd 91       	ld	r28, X+
     6aa:	cd bf       	out	0x3d, r28	; 61
     6ac:	dd 91       	ld	r29, X+
     6ae:	de bf       	out	0x3e, r29	; 62
     6b0:	ff 91       	pop	r31
     6b2:	ef 91       	pop	r30
     6b4:	df 91       	pop	r29
     6b6:	cf 91       	pop	r28
     6b8:	bf 91       	pop	r27
     6ba:	af 91       	pop	r26
     6bc:	9f 91       	pop	r25
     6be:	8f 91       	pop	r24
     6c0:	7f 91       	pop	r23
     6c2:	6f 91       	pop	r22
     6c4:	5f 91       	pop	r21
     6c6:	4f 91       	pop	r20
     6c8:	3f 91       	pop	r19
     6ca:	2f 91       	pop	r18
     6cc:	1f 91       	pop	r17
     6ce:	0f 91       	pop	r16
     6d0:	ff 90       	pop	r15
     6d2:	ef 90       	pop	r14
     6d4:	df 90       	pop	r13
     6d6:	cf 90       	pop	r12
     6d8:	bf 90       	pop	r11
     6da:	af 90       	pop	r10
     6dc:	9f 90       	pop	r9
     6de:	8f 90       	pop	r8
     6e0:	7f 90       	pop	r7
     6e2:	6f 90       	pop	r6
     6e4:	5f 90       	pop	r5
     6e6:	4f 90       	pop	r4
     6e8:	3f 90       	pop	r3
     6ea:	2f 90       	pop	r2
     6ec:	1f 90       	pop	r1
     6ee:	0f 90       	pop	r0
     6f0:	0f be       	out	0x3f, r0	; 63
     6f2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6f4:	08 95       	ret

000006f6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     6f6:	0f 92       	push	r0
     6f8:	0f b6       	in	r0, 0x3f	; 63
     6fa:	f8 94       	cli
     6fc:	0f 92       	push	r0
     6fe:	1f 92       	push	r1
     700:	11 24       	eor	r1, r1
     702:	2f 92       	push	r2
     704:	3f 92       	push	r3
     706:	4f 92       	push	r4
     708:	5f 92       	push	r5
     70a:	6f 92       	push	r6
     70c:	7f 92       	push	r7
     70e:	8f 92       	push	r8
     710:	9f 92       	push	r9
     712:	af 92       	push	r10
     714:	bf 92       	push	r11
     716:	cf 92       	push	r12
     718:	df 92       	push	r13
     71a:	ef 92       	push	r14
     71c:	ff 92       	push	r15
     71e:	0f 93       	push	r16
     720:	1f 93       	push	r17
     722:	2f 93       	push	r18
     724:	3f 93       	push	r19
     726:	4f 93       	push	r20
     728:	5f 93       	push	r21
     72a:	6f 93       	push	r22
     72c:	7f 93       	push	r23
     72e:	8f 93       	push	r24
     730:	9f 93       	push	r25
     732:	af 93       	push	r26
     734:	bf 93       	push	r27
     736:	cf 93       	push	r28
     738:	df 93       	push	r29
     73a:	ef 93       	push	r30
     73c:	ff 93       	push	r31
     73e:	a0 91 55 26 	lds	r26, 0x2655
     742:	b0 91 56 26 	lds	r27, 0x2656
     746:	0d b6       	in	r0, 0x3d	; 61
     748:	0d 92       	st	X+, r0
     74a:	0e b6       	in	r0, 0x3e	; 62
     74c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     74e:	0e 94 0b 06 	call	0xc16	; 0xc16 <xTaskIncrementTick>
     752:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     754:	0e 94 83 07 	call	0xf06	; 0xf06 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     758:	a0 91 55 26 	lds	r26, 0x2655
     75c:	b0 91 56 26 	lds	r27, 0x2656
     760:	cd 91       	ld	r28, X+
     762:	cd bf       	out	0x3d, r28	; 61
     764:	dd 91       	ld	r29, X+
     766:	de bf       	out	0x3e, r29	; 62
     768:	ff 91       	pop	r31
     76a:	ef 91       	pop	r30
     76c:	df 91       	pop	r29
     76e:	cf 91       	pop	r28
     770:	bf 91       	pop	r27
     772:	af 91       	pop	r26
     774:	9f 91       	pop	r25
     776:	8f 91       	pop	r24
     778:	7f 91       	pop	r23
     77a:	6f 91       	pop	r22
     77c:	5f 91       	pop	r21
     77e:	4f 91       	pop	r20
     780:	3f 91       	pop	r19
     782:	2f 91       	pop	r18
     784:	1f 91       	pop	r17
     786:	0f 91       	pop	r16
     788:	ff 90       	pop	r15
     78a:	ef 90       	pop	r14
     78c:	df 90       	pop	r13
     78e:	cf 90       	pop	r12
     790:	bf 90       	pop	r11
     792:	af 90       	pop	r10
     794:	9f 90       	pop	r9
     796:	8f 90       	pop	r8
     798:	7f 90       	pop	r7
     79a:	6f 90       	pop	r6
     79c:	5f 90       	pop	r5
     79e:	4f 90       	pop	r4
     7a0:	3f 90       	pop	r3
     7a2:	2f 90       	pop	r2
     7a4:	1f 90       	pop	r1
     7a6:	0f 90       	pop	r0
     7a8:	0f be       	out	0x3f, r0	; 63
     7aa:	0f 90       	pop	r0

	asm volatile ( "ret" );
     7ac:	08 95       	ret

000007ae <__vector_14>:
	 */
	
	void TCC0_OVF_vect( void ) __attribute__ ( ( signal, naked ) );
	void TCC0_OVF_vect( void )
	{
		vPortYieldFromTick();
     7ae:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <vPortYieldFromTick>
		asm volatile ( "reti" );
     7b2:	18 95       	reti

000007b4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     7ba:	0e 94 05 06 	call	0xc0a	; 0xc0a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     7be:	80 91 b2 22 	lds	r24, 0x22B2
     7c2:	90 91 b3 22 	lds	r25, 0x22B3
     7c6:	89 2b       	or	r24, r25
     7c8:	31 f4       	brne	.+12     	; 0x7d6 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     7ca:	87 eb       	ldi	r24, 0xB7	; 183
     7cc:	92 e2       	ldi	r25, 0x22	; 34
     7ce:	80 93 b2 22 	sts	0x22B2, r24
     7d2:	90 93 b3 22 	sts	0x22B3, r25
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     7d6:	20 91 b4 22 	lds	r18, 0x22B4
     7da:	30 91 b5 22 	lds	r19, 0x22B5
     7de:	ce 01       	movw	r24, r28
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	81 35       	cpi	r24, 0x51	; 81
     7e6:	43 e0       	ldi	r20, 0x03	; 3
     7e8:	94 07       	cpc	r25, r20
     7ea:	70 f4       	brcc	.+28     	; 0x808 <pvPortMalloc+0x54>
     7ec:	28 17       	cp	r18, r24
     7ee:	39 07       	cpc	r19, r25
     7f0:	70 f4       	brcc	.+28     	; 0x80e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     7f2:	c0 91 b2 22 	lds	r28, 0x22B2
     7f6:	d0 91 b3 22 	lds	r29, 0x22B3
     7fa:	c2 0f       	add	r28, r18
     7fc:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     7fe:	80 93 b4 22 	sts	0x22B4, r24
     802:	90 93 b5 22 	sts	0x22B5, r25
     806:	05 c0       	rjmp	.+10     	; 0x812 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     808:	c0 e0       	ldi	r28, 0x00	; 0
     80a:	d0 e0       	ldi	r29, 0x00	; 0
     80c:	02 c0       	rjmp	.+4      	; 0x812 <pvPortMalloc+0x5e>
     80e:	c0 e0       	ldi	r28, 0x00	; 0
     810:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     812:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     816:	ce 01       	movw	r24, r28
     818:	df 91       	pop	r29
     81a:	cf 91       	pop	r28
     81c:	08 95       	ret

0000081e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     81e:	08 95       	ret

00000820 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     820:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     822:	03 96       	adiw	r24, 0x03	; 3
     824:	81 83       	std	Z+1, r24	; 0x01
     826:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     828:	2f ef       	ldi	r18, 0xFF	; 255
     82a:	3f ef       	ldi	r19, 0xFF	; 255
     82c:	23 83       	std	Z+3, r18	; 0x03
     82e:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     830:	85 83       	std	Z+5, r24	; 0x05
     832:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     834:	87 83       	std	Z+7, r24	; 0x07
     836:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     838:	10 82       	st	Z, r1
     83a:	08 95       	ret

0000083c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     83c:	fc 01       	movw	r30, r24
     83e:	10 86       	std	Z+8, r1	; 0x08
     840:	11 86       	std	Z+9, r1	; 0x09
     842:	08 95       	ret

00000844 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     844:	cf 93       	push	r28
     846:	df 93       	push	r29
     848:	9c 01       	movw	r18, r24
     84a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     84c:	dc 01       	movw	r26, r24
     84e:	11 96       	adiw	r26, 0x01	; 1
     850:	cd 91       	ld	r28, X+
     852:	dc 91       	ld	r29, X
     854:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     856:	c2 83       	std	Z+2, r28	; 0x02
     858:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     85a:	8c 81       	ldd	r24, Y+4	; 0x04
     85c:	9d 81       	ldd	r25, Y+5	; 0x05
     85e:	84 83       	std	Z+4, r24	; 0x04
     860:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     862:	8c 81       	ldd	r24, Y+4	; 0x04
     864:	9d 81       	ldd	r25, Y+5	; 0x05
     866:	dc 01       	movw	r26, r24
     868:	12 96       	adiw	r26, 0x02	; 2
     86a:	6d 93       	st	X+, r22
     86c:	7c 93       	st	X, r23
     86e:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
     870:	6c 83       	std	Y+4, r22	; 0x04
     872:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     874:	20 87       	std	Z+8, r18	; 0x08
     876:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
     878:	f9 01       	movw	r30, r18
     87a:	80 81       	ld	r24, Z
     87c:	8f 5f       	subi	r24, 0xFF	; 255
     87e:	80 83       	st	Z, r24
}
     880:	df 91       	pop	r29
     882:	cf 91       	pop	r28
     884:	08 95       	ret

00000886 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     886:	cf 93       	push	r28
     888:	df 93       	push	r29
     88a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     88c:	48 81       	ld	r20, Y
     88e:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     890:	4f 3f       	cpi	r20, 0xFF	; 255
     892:	2f ef       	ldi	r18, 0xFF	; 255
     894:	52 07       	cpc	r21, r18
     896:	21 f4       	brne	.+8      	; 0x8a0 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     898:	fc 01       	movw	r30, r24
     89a:	a7 81       	ldd	r26, Z+7	; 0x07
     89c:	b0 85       	ldd	r27, Z+8	; 0x08
     89e:	0d c0       	rjmp	.+26     	; 0x8ba <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8a0:	dc 01       	movw	r26, r24
     8a2:	13 96       	adiw	r26, 0x03	; 3
     8a4:	01 c0       	rjmp	.+2      	; 0x8a8 <vListInsert+0x22>
     8a6:	df 01       	movw	r26, r30
     8a8:	12 96       	adiw	r26, 0x02	; 2
     8aa:	ed 91       	ld	r30, X+
     8ac:	fc 91       	ld	r31, X
     8ae:	13 97       	sbiw	r26, 0x03	; 3
     8b0:	20 81       	ld	r18, Z
     8b2:	31 81       	ldd	r19, Z+1	; 0x01
     8b4:	42 17       	cp	r20, r18
     8b6:	53 07       	cpc	r21, r19
     8b8:	b0 f7       	brcc	.-20     	; 0x8a6 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     8ba:	12 96       	adiw	r26, 0x02	; 2
     8bc:	ed 91       	ld	r30, X+
     8be:	fc 91       	ld	r31, X
     8c0:	13 97       	sbiw	r26, 0x03	; 3
     8c2:	ea 83       	std	Y+2, r30	; 0x02
     8c4:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     8c6:	c4 83       	std	Z+4, r28	; 0x04
     8c8:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
     8ca:	ac 83       	std	Y+4, r26	; 0x04
     8cc:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
     8ce:	12 96       	adiw	r26, 0x02	; 2
     8d0:	cd 93       	st	X+, r28
     8d2:	dc 93       	st	X, r29
     8d4:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8d6:	88 87       	std	Y+8, r24	; 0x08
     8d8:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
     8da:	fc 01       	movw	r30, r24
     8dc:	20 81       	ld	r18, Z
     8de:	2f 5f       	subi	r18, 0xFF	; 255
     8e0:	20 83       	st	Z, r18
}
     8e2:	df 91       	pop	r29
     8e4:	cf 91       	pop	r28
     8e6:	08 95       	ret

000008e8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     8e8:	cf 93       	push	r28
     8ea:	df 93       	push	r29
     8ec:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     8ee:	a0 85       	ldd	r26, Z+8	; 0x08
     8f0:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     8f2:	c2 81       	ldd	r28, Z+2	; 0x02
     8f4:	d3 81       	ldd	r29, Z+3	; 0x03
     8f6:	84 81       	ldd	r24, Z+4	; 0x04
     8f8:	95 81       	ldd	r25, Z+5	; 0x05
     8fa:	8c 83       	std	Y+4, r24	; 0x04
     8fc:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     8fe:	c4 81       	ldd	r28, Z+4	; 0x04
     900:	d5 81       	ldd	r29, Z+5	; 0x05
     902:	82 81       	ldd	r24, Z+2	; 0x02
     904:	93 81       	ldd	r25, Z+3	; 0x03
     906:	8a 83       	std	Y+2, r24	; 0x02
     908:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     90a:	11 96       	adiw	r26, 0x01	; 1
     90c:	cd 91       	ld	r28, X+
     90e:	dc 91       	ld	r29, X
     910:	12 97       	sbiw	r26, 0x02	; 2
     912:	ce 17       	cp	r28, r30
     914:	df 07       	cpc	r29, r31
     916:	31 f4       	brne	.+12     	; 0x924 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     918:	8c 81       	ldd	r24, Y+4	; 0x04
     91a:	9d 81       	ldd	r25, Y+5	; 0x05
     91c:	11 96       	adiw	r26, 0x01	; 1
     91e:	8d 93       	st	X+, r24
     920:	9c 93       	st	X, r25
     922:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     924:	10 86       	std	Z+8, r1	; 0x08
     926:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
     928:	8c 91       	ld	r24, X
     92a:	81 50       	subi	r24, 0x01	; 1
     92c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	08 95       	ret

00000934 <prvIdleTask>:
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     934:	ff cf       	rjmp	.-2      	; 0x934 <prvIdleTask>

00000936 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     936:	cf 93       	push	r28
     938:	df 93       	push	r29
     93a:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     93c:	e0 91 55 26 	lds	r30, 0x2655
     940:	f0 91 56 26 	lds	r31, 0x2656
     944:	82 83       	std	Z+2, r24	; 0x02
     946:	93 83       	std	Z+3, r25	; 0x03

	if( xTimeToWake < xTickCount )
     948:	80 91 0f 26 	lds	r24, 0x260F
     94c:	90 91 10 26 	lds	r25, 0x2610
     950:	c8 17       	cp	r28, r24
     952:	d9 07       	cpc	r29, r25
     954:	68 f4       	brcc	.+26     	; 0x970 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     956:	60 91 55 26 	lds	r22, 0x2655
     95a:	70 91 56 26 	lds	r23, 0x2656
     95e:	80 91 1b 26 	lds	r24, 0x261B
     962:	90 91 1c 26 	lds	r25, 0x261C
     966:	6e 5f       	subi	r22, 0xFE	; 254
     968:	7f 4f       	sbci	r23, 0xFF	; 255
     96a:	0e 94 43 04 	call	0x886	; 0x886 <vListInsert>
     96e:	17 c0       	rjmp	.+46     	; 0x99e <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     970:	60 91 55 26 	lds	r22, 0x2655
     974:	70 91 56 26 	lds	r23, 0x2656
     978:	80 91 1d 26 	lds	r24, 0x261D
     97c:	90 91 1e 26 	lds	r25, 0x261E
     980:	6e 5f       	subi	r22, 0xFE	; 254
     982:	7f 4f       	sbci	r23, 0xFF	; 255
     984:	0e 94 43 04 	call	0x886	; 0x886 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     988:	80 91 8c 22 	lds	r24, 0x228C
     98c:	90 91 8d 22 	lds	r25, 0x228D
     990:	c8 17       	cp	r28, r24
     992:	d9 07       	cpc	r29, r25
     994:	20 f4       	brcc	.+8      	; 0x99e <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     996:	c0 93 8c 22 	sts	0x228C, r28
     99a:	d0 93 8d 22 	sts	0x228D, r29
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     99e:	df 91       	pop	r29
     9a0:	cf 91       	pop	r28
     9a2:	08 95       	ret

000009a4 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     9a4:	4f 92       	push	r4
     9a6:	5f 92       	push	r5
     9a8:	6f 92       	push	r6
     9aa:	7f 92       	push	r7
     9ac:	8f 92       	push	r8
     9ae:	9f 92       	push	r9
     9b0:	af 92       	push	r10
     9b2:	bf 92       	push	r11
     9b4:	cf 92       	push	r12
     9b6:	df 92       	push	r13
     9b8:	ef 92       	push	r14
     9ba:	ff 92       	push	r15
     9bc:	0f 93       	push	r16
     9be:	1f 93       	push	r17
     9c0:	cf 93       	push	r28
     9c2:	df 93       	push	r29
     9c4:	4c 01       	movw	r8, r24
     9c6:	eb 01       	movw	r28, r22
     9c8:	5a 01       	movw	r10, r20
     9ca:	29 01       	movw	r4, r18
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     9cc:	81 e2       	ldi	r24, 0x21	; 33
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	0e 94 da 03 	call	0x7b4	; 0x7b4 <pvPortMalloc>
     9d4:	3c 01       	movw	r6, r24

	if( pxNewTCB != NULL )
     9d6:	00 97       	sbiw	r24, 0x00	; 0
     9d8:	09 f4       	brne	.+2      	; 0x9dc <xTaskGenericCreate+0x38>
     9da:	da c0       	rjmp	.+436    	; 0xb90 <xTaskGenericCreate+0x1ec>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     9dc:	c1 14       	cp	r12, r1
     9de:	d1 04       	cpc	r13, r1
     9e0:	09 f0       	breq	.+2      	; 0x9e4 <xTaskGenericCreate+0x40>
     9e2:	d2 c0       	rjmp	.+420    	; 0xb88 <xTaskGenericCreate+0x1e4>
     9e4:	c5 01       	movw	r24, r10
     9e6:	0e 94 da 03 	call	0x7b4	; 0x7b4 <pvPortMalloc>
     9ea:	f3 01       	movw	r30, r6
     9ec:	87 8b       	std	Z+23, r24	; 0x17
     9ee:	90 8f       	std	Z+24, r25	; 0x18

		if( pxNewTCB->pxStack == NULL )
     9f0:	89 2b       	or	r24, r25
     9f2:	21 f4       	brne	.+8      	; 0x9fc <xTaskGenericCreate+0x58>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
     9f4:	c3 01       	movw	r24, r6
     9f6:	0e 94 0f 04 	call	0x81e	; 0x81e <vPortFree>
     9fa:	ca c0       	rjmp	.+404    	; 0xb90 <xTaskGenericCreate+0x1ec>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     9fc:	f1 e0       	ldi	r31, 0x01	; 1
     9fe:	af 1a       	sub	r10, r31
     a00:	b1 08       	sbc	r11, r1
     a02:	f3 01       	movw	r30, r6
     a04:	87 89       	ldd	r24, Z+23	; 0x17
     a06:	90 8d       	ldd	r25, Z+24	; 0x18
     a08:	a8 0e       	add	r10, r24
     a0a:	b9 1e       	adc	r11, r25
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     a0c:	88 81       	ld	r24, Y
     a0e:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     a10:	88 81       	ld	r24, Y
     a12:	88 23       	and	r24, r24
     a14:	81 f0       	breq	.+32     	; 0xa36 <xTaskGenericCreate+0x92>
     a16:	d3 01       	movw	r26, r6
     a18:	5a 96       	adiw	r26, 0x1a	; 26
     a1a:	fe 01       	movw	r30, r28
     a1c:	31 96       	adiw	r30, 0x01	; 1
     a1e:	9e 01       	movw	r18, r28
     a20:	28 5f       	subi	r18, 0xF8	; 248
     a22:	3f 4f       	sbci	r19, 0xFF	; 255
     a24:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     a26:	81 91       	ld	r24, Z+
     a28:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     a2a:	88 81       	ld	r24, Y
     a2c:	88 23       	and	r24, r24
     a2e:	19 f0       	breq	.+6      	; 0xa36 <xTaskGenericCreate+0x92>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     a30:	e2 17       	cp	r30, r18
     a32:	f3 07       	cpc	r31, r19
     a34:	b9 f7       	brne	.-18     	; 0xa24 <xTaskGenericCreate+0x80>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     a36:	f3 01       	movw	r30, r6
     a38:	10 a2       	std	Z+32, r1	; 0x20
     a3a:	10 2f       	mov	r17, r16
     a3c:	04 30       	cpi	r16, 0x04	; 4
     a3e:	08 f0       	brcs	.+2      	; 0xa42 <xTaskGenericCreate+0x9e>
     a40:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     a42:	f3 01       	movw	r30, r6
     a44:	16 8b       	std	Z+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     a46:	e3 01       	movw	r28, r6
     a48:	22 96       	adiw	r28, 0x02	; 2
     a4a:	ce 01       	movw	r24, r28
     a4c:	0e 94 1e 04 	call	0x83c	; 0x83c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     a50:	c3 01       	movw	r24, r6
     a52:	0c 96       	adiw	r24, 0x0c	; 12
     a54:	0e 94 1e 04 	call	0x83c	; 0x83c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     a58:	f3 01       	movw	r30, r6
     a5a:	60 86       	std	Z+8, r6	; 0x08
     a5c:	71 86       	std	Z+9, r7	; 0x09

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     a5e:	84 e0       	ldi	r24, 0x04	; 4
     a60:	90 e0       	ldi	r25, 0x00	; 0
     a62:	81 1b       	sub	r24, r17
     a64:	91 09       	sbc	r25, r1
     a66:	84 87       	std	Z+12, r24	; 0x0c
     a68:	95 87       	std	Z+13, r25	; 0x0d
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     a6a:	62 8a       	std	Z+18, r6	; 0x12
     a6c:	73 8a       	std	Z+19, r7	; 0x13
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     a6e:	a2 01       	movw	r20, r4
     a70:	b4 01       	movw	r22, r8
     a72:	c5 01       	movw	r24, r10
     a74:	0e 94 72 02 	call	0x4e4	; 0x4e4 <pxPortInitialiseStack>
     a78:	f3 01       	movw	r30, r6
     a7a:	80 83       	st	Z, r24
     a7c:	91 83       	std	Z+1, r25	; 0x01
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     a7e:	e1 14       	cp	r14, r1
     a80:	f1 04       	cpc	r15, r1
     a82:	19 f0       	breq	.+6      	; 0xa8a <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     a84:	f7 01       	movw	r30, r14
     a86:	60 82       	st	Z, r6
     a88:	71 82       	std	Z+1, r7	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     a90:	80 91 11 26 	lds	r24, 0x2611
     a94:	8f 5f       	subi	r24, 0xFF	; 255
     a96:	80 93 11 26 	sts	0x2611, r24
			if( pxCurrentTCB == NULL )
     a9a:	80 91 55 26 	lds	r24, 0x2655
     a9e:	90 91 56 26 	lds	r25, 0x2656
     aa2:	89 2b       	or	r24, r25
     aa4:	89 f5       	brne	.+98     	; 0xb08 <xTaskGenericCreate+0x164>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     aa6:	60 92 55 26 	sts	0x2655, r6
     aaa:	70 92 56 26 	sts	0x2656, r7

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     aae:	80 91 11 26 	lds	r24, 0x2611
     ab2:	81 30       	cpi	r24, 0x01	; 1
     ab4:	c1 f5       	brne	.+112    	; 0xb26 <xTaskGenericCreate+0x182>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     ab6:	81 e3       	ldi	r24, 0x31	; 49
     ab8:	96 e2       	ldi	r25, 0x26	; 38
     aba:	0e 94 10 04 	call	0x820	; 0x820 <vListInitialise>
     abe:	8a e3       	ldi	r24, 0x3A	; 58
     ac0:	96 e2       	ldi	r25, 0x26	; 38
     ac2:	0e 94 10 04 	call	0x820	; 0x820 <vListInitialise>
     ac6:	83 e4       	ldi	r24, 0x43	; 67
     ac8:	96 e2       	ldi	r25, 0x26	; 38
     aca:	0e 94 10 04 	call	0x820	; 0x820 <vListInitialise>
     ace:	8c e4       	ldi	r24, 0x4C	; 76
     ad0:	96 e2       	ldi	r25, 0x26	; 38
     ad2:	0e 94 10 04 	call	0x820	; 0x820 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     ad6:	88 e2       	ldi	r24, 0x28	; 40
     ad8:	96 e2       	ldi	r25, 0x26	; 38
     ada:	0e 94 10 04 	call	0x820	; 0x820 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     ade:	8f e1       	ldi	r24, 0x1F	; 31
     ae0:	96 e2       	ldi	r25, 0x26	; 38
     ae2:	0e 94 10 04 	call	0x820	; 0x820 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     ae6:	82 e1       	ldi	r24, 0x12	; 18
     ae8:	96 e2       	ldi	r25, 0x26	; 38
     aea:	0e 94 10 04 	call	0x820	; 0x820 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     aee:	88 e2       	ldi	r24, 0x28	; 40
     af0:	96 e2       	ldi	r25, 0x26	; 38
     af2:	80 93 1d 26 	sts	0x261D, r24
     af6:	90 93 1e 26 	sts	0x261E, r25
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     afa:	8f e1       	ldi	r24, 0x1F	; 31
     afc:	96 e2       	ldi	r25, 0x26	; 38
     afe:	80 93 1b 26 	sts	0x261B, r24
     b02:	90 93 1c 26 	sts	0x261C, r25
     b06:	0f c0       	rjmp	.+30     	; 0xb26 <xTaskGenericCreate+0x182>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     b08:	80 91 0d 26 	lds	r24, 0x260D
     b0c:	81 11       	cpse	r24, r1
     b0e:	0b c0       	rjmp	.+22     	; 0xb26 <xTaskGenericCreate+0x182>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     b10:	e0 91 55 26 	lds	r30, 0x2655
     b14:	f0 91 56 26 	lds	r31, 0x2656
     b18:	86 89       	ldd	r24, Z+22	; 0x16
     b1a:	08 17       	cp	r16, r24
     b1c:	20 f0       	brcs	.+8      	; 0xb26 <xTaskGenericCreate+0x182>
					{
						pxCurrentTCB = pxNewTCB;
     b1e:	60 92 55 26 	sts	0x2655, r6
     b22:	70 92 56 26 	sts	0x2656, r7
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     b26:	80 91 09 26 	lds	r24, 0x2609
     b2a:	8f 5f       	subi	r24, 0xFF	; 255
     b2c:	80 93 09 26 	sts	0x2609, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     b30:	f3 01       	movw	r30, r6
     b32:	86 89       	ldd	r24, Z+22	; 0x16
     b34:	90 91 0e 26 	lds	r25, 0x260E
     b38:	98 17       	cp	r25, r24
     b3a:	10 f4       	brcc	.+4      	; 0xb40 <xTaskGenericCreate+0x19c>
     b3c:	80 93 0e 26 	sts	0x260E, r24
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	9c 01       	movw	r18, r24
     b44:	22 0f       	add	r18, r18
     b46:	33 1f       	adc	r19, r19
     b48:	22 0f       	add	r18, r18
     b4a:	33 1f       	adc	r19, r19
     b4c:	22 0f       	add	r18, r18
     b4e:	33 1f       	adc	r19, r19
     b50:	82 0f       	add	r24, r18
     b52:	93 1f       	adc	r25, r19
     b54:	be 01       	movw	r22, r28
     b56:	8f 5c       	subi	r24, 0xCF	; 207
     b58:	99 4d       	sbci	r25, 0xD9	; 217
     b5a:	0e 94 22 04 	call	0x844	; 0x844 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     b5e:	0f 90       	pop	r0
     b60:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     b62:	80 91 0d 26 	lds	r24, 0x260D
     b66:	88 23       	and	r24, r24
     b68:	59 f0       	breq	.+22     	; 0xb80 <xTaskGenericCreate+0x1dc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     b6a:	e0 91 55 26 	lds	r30, 0x2655
     b6e:	f0 91 56 26 	lds	r31, 0x2656
     b72:	86 89       	ldd	r24, Z+22	; 0x16
     b74:	80 17       	cp	r24, r16
     b76:	30 f4       	brcc	.+12     	; 0xb84 <xTaskGenericCreate+0x1e0>
			{
				taskYIELD_IF_USING_PREEMPTION();
     b78:	0e 94 22 03 	call	0x644	; 0x644 <vPortYield>
     b7c:	81 e0       	ldi	r24, 0x01	; 1
     b7e:	09 c0       	rjmp	.+18     	; 0xb92 <xTaskGenericCreate+0x1ee>
     b80:	81 e0       	ldi	r24, 0x01	; 1
     b82:	07 c0       	rjmp	.+14     	; 0xb92 <xTaskGenericCreate+0x1ee>
     b84:	81 e0       	ldi	r24, 0x01	; 1
     b86:	05 c0       	rjmp	.+10     	; 0xb92 <xTaskGenericCreate+0x1ee>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b88:	fc 01       	movw	r30, r24
     b8a:	c7 8a       	std	Z+23, r12	; 0x17
     b8c:	d0 8e       	std	Z+24, r13	; 0x18
     b8e:	36 cf       	rjmp	.-404    	; 0x9fc <xTaskGenericCreate+0x58>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     b90:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
     b96:	1f 91       	pop	r17
     b98:	0f 91       	pop	r16
     b9a:	ff 90       	pop	r15
     b9c:	ef 90       	pop	r14
     b9e:	df 90       	pop	r13
     ba0:	cf 90       	pop	r12
     ba2:	bf 90       	pop	r11
     ba4:	af 90       	pop	r10
     ba6:	9f 90       	pop	r9
     ba8:	8f 90       	pop	r8
     baa:	7f 90       	pop	r7
     bac:	6f 90       	pop	r6
     bae:	5f 90       	pop	r5
     bb0:	4f 90       	pop	r4
     bb2:	08 95       	ret

00000bb4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     bb4:	af 92       	push	r10
     bb6:	bf 92       	push	r11
     bb8:	cf 92       	push	r12
     bba:	df 92       	push	r13
     bbc:	ef 92       	push	r14
     bbe:	ff 92       	push	r15
     bc0:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     bc2:	a1 2c       	mov	r10, r1
     bc4:	b1 2c       	mov	r11, r1
     bc6:	c1 2c       	mov	r12, r1
     bc8:	d1 2c       	mov	r13, r1
     bca:	e1 2c       	mov	r14, r1
     bcc:	f1 2c       	mov	r15, r1
     bce:	00 e0       	ldi	r16, 0x00	; 0
     bd0:	20 e0       	ldi	r18, 0x00	; 0
     bd2:	30 e0       	ldi	r19, 0x00	; 0
     bd4:	45 e5       	ldi	r20, 0x55	; 85
     bd6:	50 e0       	ldi	r21, 0x00	; 0
     bd8:	6e e8       	ldi	r22, 0x8E	; 142
     bda:	72 e2       	ldi	r23, 0x22	; 34
     bdc:	8a e9       	ldi	r24, 0x9A	; 154
     bde:	94 e0       	ldi	r25, 0x04	; 4
     be0:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     be4:	81 30       	cpi	r24, 0x01	; 1
     be6:	49 f4       	brne	.+18     	; 0xbfa <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     be8:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     bea:	80 93 0d 26 	sts	0x260D, r24
		xTickCount = ( TickType_t ) 0U;
     bee:	10 92 0f 26 	sts	0x260F, r1
     bf2:	10 92 10 26 	sts	0x2610, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     bf6:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     bfa:	0f 91       	pop	r16
     bfc:	ff 90       	pop	r15
     bfe:	ef 90       	pop	r14
     c00:	df 90       	pop	r13
     c02:	cf 90       	pop	r12
     c04:	bf 90       	pop	r11
     c06:	af 90       	pop	r10
     c08:	08 95       	ret

00000c0a <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     c0a:	80 91 08 26 	lds	r24, 0x2608
     c0e:	8f 5f       	subi	r24, 0xFF	; 255
     c10:	80 93 08 26 	sts	0x2608, r24
     c14:	08 95       	ret

00000c16 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     c16:	df 92       	push	r13
     c18:	ef 92       	push	r14
     c1a:	ff 92       	push	r15
     c1c:	0f 93       	push	r16
     c1e:	1f 93       	push	r17
     c20:	cf 93       	push	r28
     c22:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c24:	80 91 08 26 	lds	r24, 0x2608
     c28:	81 11       	cpse	r24, r1
     c2a:	b6 c0       	rjmp	.+364    	; 0xd98 <xTaskIncrementTick+0x182>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     c2c:	80 91 0f 26 	lds	r24, 0x260F
     c30:	90 91 10 26 	lds	r25, 0x2610
     c34:	01 96       	adiw	r24, 0x01	; 1
     c36:	80 93 0f 26 	sts	0x260F, r24
     c3a:	90 93 10 26 	sts	0x2610, r25

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     c3e:	e0 90 0f 26 	lds	r14, 0x260F
     c42:	f0 90 10 26 	lds	r15, 0x2610

			if( xConstTickCount == ( TickType_t ) 0U )
     c46:	e1 14       	cp	r14, r1
     c48:	f1 04       	cpc	r15, r1
     c4a:	99 f5       	brne	.+102    	; 0xcb2 <xTaskIncrementTick+0x9c>
			{
				taskSWITCH_DELAYED_LISTS();
     c4c:	80 91 1d 26 	lds	r24, 0x261D
     c50:	90 91 1e 26 	lds	r25, 0x261E
     c54:	20 91 1b 26 	lds	r18, 0x261B
     c58:	30 91 1c 26 	lds	r19, 0x261C
     c5c:	20 93 1d 26 	sts	0x261D, r18
     c60:	30 93 1e 26 	sts	0x261E, r19
     c64:	80 93 1b 26 	sts	0x261B, r24
     c68:	90 93 1c 26 	sts	0x261C, r25
     c6c:	80 91 0a 26 	lds	r24, 0x260A
     c70:	8f 5f       	subi	r24, 0xFF	; 255
     c72:	80 93 0a 26 	sts	0x260A, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     c76:	e0 91 1d 26 	lds	r30, 0x261D
     c7a:	f0 91 1e 26 	lds	r31, 0x261E
     c7e:	80 81       	ld	r24, Z
     c80:	81 11       	cpse	r24, r1
     c82:	07 c0       	rjmp	.+14     	; 0xc92 <xTaskIncrementTick+0x7c>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     c84:	8f ef       	ldi	r24, 0xFF	; 255
     c86:	9f ef       	ldi	r25, 0xFF	; 255
     c88:	80 93 8c 22 	sts	0x228C, r24
     c8c:	90 93 8d 22 	sts	0x228D, r25
     c90:	10 c0       	rjmp	.+32     	; 0xcb2 <xTaskIncrementTick+0x9c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     c92:	e0 91 1d 26 	lds	r30, 0x261D
     c96:	f0 91 1e 26 	lds	r31, 0x261E
     c9a:	05 80       	ldd	r0, Z+5	; 0x05
     c9c:	f6 81       	ldd	r31, Z+6	; 0x06
     c9e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     ca0:	06 80       	ldd	r0, Z+6	; 0x06
     ca2:	f7 81       	ldd	r31, Z+7	; 0x07
     ca4:	e0 2d       	mov	r30, r0
     ca6:	82 81       	ldd	r24, Z+2	; 0x02
     ca8:	93 81       	ldd	r25, Z+3	; 0x03
     caa:	80 93 8c 22 	sts	0x228C, r24
     cae:	90 93 8d 22 	sts	0x228D, r25

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     cb2:	80 91 8c 22 	lds	r24, 0x228C
     cb6:	90 91 8d 22 	lds	r25, 0x228D
     cba:	e8 16       	cp	r14, r24
     cbc:	f9 06       	cpc	r15, r25
     cbe:	10 f4       	brcc	.+4      	; 0xcc4 <xTaskIncrementTick+0xae>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     cc0:	d1 2c       	mov	r13, r1
     cc2:	52 c0       	rjmp	.+164    	; 0xd68 <xTaskIncrementTick+0x152>
     cc4:	d1 2c       	mov	r13, r1
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     cc6:	e0 91 1d 26 	lds	r30, 0x261D
     cca:	f0 91 1e 26 	lds	r31, 0x261E
     cce:	90 81       	ld	r25, Z
     cd0:	91 11       	cpse	r25, r1
     cd2:	07 c0       	rjmp	.+14     	; 0xce2 <xTaskIncrementTick+0xcc>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     cd4:	8f ef       	ldi	r24, 0xFF	; 255
     cd6:	9f ef       	ldi	r25, 0xFF	; 255
     cd8:	80 93 8c 22 	sts	0x228C, r24
     cdc:	90 93 8d 22 	sts	0x228D, r25
						break;
     ce0:	43 c0       	rjmp	.+134    	; 0xd68 <xTaskIncrementTick+0x152>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     ce2:	e0 91 1d 26 	lds	r30, 0x261D
     ce6:	f0 91 1e 26 	lds	r31, 0x261E
     cea:	05 80       	ldd	r0, Z+5	; 0x05
     cec:	f6 81       	ldd	r31, Z+6	; 0x06
     cee:	e0 2d       	mov	r30, r0
     cf0:	c6 81       	ldd	r28, Z+6	; 0x06
     cf2:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     cf4:	2a 81       	ldd	r18, Y+2	; 0x02
     cf6:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     cf8:	e2 16       	cp	r14, r18
     cfa:	f3 06       	cpc	r15, r19
     cfc:	28 f4       	brcc	.+10     	; 0xd08 <xTaskIncrementTick+0xf2>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     cfe:	20 93 8c 22 	sts	0x228C, r18
     d02:	30 93 8d 22 	sts	0x228D, r19
							break;
     d06:	30 c0       	rjmp	.+96     	; 0xd68 <xTaskIncrementTick+0x152>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     d08:	8e 01       	movw	r16, r28
     d0a:	0e 5f       	subi	r16, 0xFE	; 254
     d0c:	1f 4f       	sbci	r17, 0xFF	; 255
     d0e:	c8 01       	movw	r24, r16
     d10:	0e 94 74 04 	call	0x8e8	; 0x8e8 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     d14:	8c 89       	ldd	r24, Y+20	; 0x14
     d16:	9d 89       	ldd	r25, Y+21	; 0x15
     d18:	89 2b       	or	r24, r25
     d1a:	21 f0       	breq	.+8      	; 0xd24 <xTaskIncrementTick+0x10e>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     d1c:	ce 01       	movw	r24, r28
     d1e:	0c 96       	adiw	r24, 0x0c	; 12
     d20:	0e 94 74 04 	call	0x8e8	; 0x8e8 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     d24:	2e 89       	ldd	r18, Y+22	; 0x16
     d26:	80 91 0e 26 	lds	r24, 0x260E
     d2a:	82 17       	cp	r24, r18
     d2c:	10 f4       	brcc	.+4      	; 0xd32 <xTaskIncrementTick+0x11c>
     d2e:	20 93 0e 26 	sts	0x260E, r18
     d32:	30 e0       	ldi	r19, 0x00	; 0
     d34:	c9 01       	movw	r24, r18
     d36:	88 0f       	add	r24, r24
     d38:	99 1f       	adc	r25, r25
     d3a:	88 0f       	add	r24, r24
     d3c:	99 1f       	adc	r25, r25
     d3e:	88 0f       	add	r24, r24
     d40:	99 1f       	adc	r25, r25
     d42:	82 0f       	add	r24, r18
     d44:	93 1f       	adc	r25, r19
     d46:	b8 01       	movw	r22, r16
     d48:	8f 5c       	subi	r24, 0xCF	; 207
     d4a:	99 4d       	sbci	r25, 0xD9	; 217
     d4c:	0e 94 22 04 	call	0x844	; 0x844 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     d50:	e0 91 55 26 	lds	r30, 0x2655
     d54:	f0 91 56 26 	lds	r31, 0x2656
     d58:	9e 89       	ldd	r25, Y+22	; 0x16
     d5a:	86 89       	ldd	r24, Z+22	; 0x16
     d5c:	98 17       	cp	r25, r24
     d5e:	08 f4       	brcc	.+2      	; 0xd62 <xTaskIncrementTick+0x14c>
     d60:	b2 cf       	rjmp	.-156    	; 0xcc6 <xTaskIncrementTick+0xb0>
							{
								xSwitchRequired = pdTRUE;
     d62:	dd 24       	eor	r13, r13
     d64:	d3 94       	inc	r13
     d66:	af cf       	rjmp	.-162    	; 0xcc6 <xTaskIncrementTick+0xb0>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     d68:	e0 91 55 26 	lds	r30, 0x2655
     d6c:	f0 91 56 26 	lds	r31, 0x2656
     d70:	86 89       	ldd	r24, Z+22	; 0x16
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	fc 01       	movw	r30, r24
     d76:	ee 0f       	add	r30, r30
     d78:	ff 1f       	adc	r31, r31
     d7a:	ee 0f       	add	r30, r30
     d7c:	ff 1f       	adc	r31, r31
     d7e:	ee 0f       	add	r30, r30
     d80:	ff 1f       	adc	r31, r31
     d82:	8e 0f       	add	r24, r30
     d84:	9f 1f       	adc	r25, r31
     d86:	fc 01       	movw	r30, r24
     d88:	ef 5c       	subi	r30, 0xCF	; 207
     d8a:	f9 4d       	sbci	r31, 0xD9	; 217
     d8c:	80 81       	ld	r24, Z
     d8e:	82 30       	cpi	r24, 0x02	; 2
     d90:	48 f0       	brcs	.+18     	; 0xda4 <xTaskIncrementTick+0x18e>
			{
				xSwitchRequired = pdTRUE;
     d92:	dd 24       	eor	r13, r13
     d94:	d3 94       	inc	r13
     d96:	06 c0       	rjmp	.+12     	; 0xda4 <xTaskIncrementTick+0x18e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     d98:	80 91 0c 26 	lds	r24, 0x260C
     d9c:	8f 5f       	subi	r24, 0xFF	; 255
     d9e:	80 93 0c 26 	sts	0x260C, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     da2:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     da4:	80 91 0b 26 	lds	r24, 0x260B
     da8:	88 23       	and	r24, r24
     daa:	11 f0       	breq	.+4      	; 0xdb0 <xTaskIncrementTick+0x19a>
		{
			xSwitchRequired = pdTRUE;
     dac:	dd 24       	eor	r13, r13
     dae:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     db0:	8d 2d       	mov	r24, r13
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	0f 91       	pop	r16
     dba:	ff 90       	pop	r15
     dbc:	ef 90       	pop	r14
     dbe:	df 90       	pop	r13
     dc0:	08 95       	ret

00000dc2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     dc2:	df 92       	push	r13
     dc4:	ef 92       	push	r14
     dc6:	ff 92       	push	r15
     dc8:	0f 93       	push	r16
     dca:	1f 93       	push	r17
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     dd0:	0f b6       	in	r0, 0x3f	; 63
     dd2:	f8 94       	cli
     dd4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     dd6:	80 91 08 26 	lds	r24, 0x2608
     dda:	81 50       	subi	r24, 0x01	; 1
     ddc:	80 93 08 26 	sts	0x2608, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     de0:	80 91 08 26 	lds	r24, 0x2608
     de4:	81 11       	cpse	r24, r1
     de6:	62 c0       	rjmp	.+196    	; 0xeac <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     de8:	80 91 11 26 	lds	r24, 0x2611
     dec:	81 11       	cpse	r24, r1
     dee:	33 c0       	rjmp	.+102    	; 0xe56 <xTaskResumeAll+0x94>
     df0:	60 c0       	rjmp	.+192    	; 0xeb2 <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     df2:	d7 01       	movw	r26, r14
     df4:	15 96       	adiw	r26, 0x05	; 5
     df6:	ed 91       	ld	r30, X+
     df8:	fc 91       	ld	r31, X
     dfa:	16 97       	sbiw	r26, 0x06	; 6
     dfc:	c6 81       	ldd	r28, Z+6	; 0x06
     dfe:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     e00:	ce 01       	movw	r24, r28
     e02:	0c 96       	adiw	r24, 0x0c	; 12
     e04:	0e 94 74 04 	call	0x8e8	; 0x8e8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     e08:	8e 01       	movw	r16, r28
     e0a:	0e 5f       	subi	r16, 0xFE	; 254
     e0c:	1f 4f       	sbci	r17, 0xFF	; 255
     e0e:	c8 01       	movw	r24, r16
     e10:	0e 94 74 04 	call	0x8e8	; 0x8e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     e14:	2e 89       	ldd	r18, Y+22	; 0x16
     e16:	80 91 0e 26 	lds	r24, 0x260E
     e1a:	82 17       	cp	r24, r18
     e1c:	10 f4       	brcc	.+4      	; 0xe22 <xTaskResumeAll+0x60>
     e1e:	20 93 0e 26 	sts	0x260E, r18
     e22:	30 e0       	ldi	r19, 0x00	; 0
     e24:	c9 01       	movw	r24, r18
     e26:	88 0f       	add	r24, r24
     e28:	99 1f       	adc	r25, r25
     e2a:	88 0f       	add	r24, r24
     e2c:	99 1f       	adc	r25, r25
     e2e:	88 0f       	add	r24, r24
     e30:	99 1f       	adc	r25, r25
     e32:	82 0f       	add	r24, r18
     e34:	93 1f       	adc	r25, r19
     e36:	b8 01       	movw	r22, r16
     e38:	8f 5c       	subi	r24, 0xCF	; 207
     e3a:	99 4d       	sbci	r25, 0xD9	; 217
     e3c:	0e 94 22 04 	call	0x844	; 0x844 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     e40:	e0 91 55 26 	lds	r30, 0x2655
     e44:	f0 91 56 26 	lds	r31, 0x2656
     e48:	9e 89       	ldd	r25, Y+22	; 0x16
     e4a:	86 89       	ldd	r24, Z+22	; 0x16
     e4c:	98 17       	cp	r25, r24
     e4e:	58 f0       	brcs	.+22     	; 0xe66 <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
     e50:	d0 92 0b 26 	sts	0x260B, r13
     e54:	08 c0       	rjmp	.+16     	; 0xe66 <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     e56:	0f 2e       	mov	r0, r31
     e58:	f2 e1       	ldi	r31, 0x12	; 18
     e5a:	ef 2e       	mov	r14, r31
     e5c:	f6 e2       	ldi	r31, 0x26	; 38
     e5e:	ff 2e       	mov	r15, r31
     e60:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     e62:	dd 24       	eor	r13, r13
     e64:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     e66:	f7 01       	movw	r30, r14
     e68:	80 81       	ld	r24, Z
     e6a:	81 11       	cpse	r24, r1
     e6c:	c2 cf       	rjmp	.-124    	; 0xdf2 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     e6e:	80 91 0c 26 	lds	r24, 0x260C
     e72:	88 23       	and	r24, r24
     e74:	99 f0       	breq	.+38     	; 0xe9c <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     e76:	80 91 0c 26 	lds	r24, 0x260C
     e7a:	88 23       	and	r24, r24
     e7c:	79 f0       	breq	.+30     	; 0xe9c <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     e7e:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     e80:	0e 94 0b 06 	call	0xc16	; 0xc16 <xTaskIncrementTick>
     e84:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     e86:	c0 93 0b 26 	sts	0x260B, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     e8a:	80 91 0c 26 	lds	r24, 0x260C
     e8e:	81 50       	subi	r24, 0x01	; 1
     e90:	80 93 0c 26 	sts	0x260C, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     e94:	80 91 0c 26 	lds	r24, 0x260C
     e98:	81 11       	cpse	r24, r1
     e9a:	f2 cf       	rjmp	.-28     	; 0xe80 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     e9c:	80 91 0b 26 	lds	r24, 0x260B
     ea0:	81 30       	cpi	r24, 0x01	; 1
     ea2:	31 f4       	brne	.+12     	; 0xeb0 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     ea4:	0e 94 22 03 	call	0x644	; 0x644 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     ea8:	81 e0       	ldi	r24, 0x01	; 1
     eaa:	03 c0       	rjmp	.+6      	; 0xeb2 <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     eac:	80 e0       	ldi	r24, 0x00	; 0
     eae:	01 c0       	rjmp	.+2      	; 0xeb2 <xTaskResumeAll+0xf0>
     eb0:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     eb2:	0f 90       	pop	r0
     eb4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     eb6:	df 91       	pop	r29
     eb8:	cf 91       	pop	r28
     eba:	1f 91       	pop	r17
     ebc:	0f 91       	pop	r16
     ebe:	ff 90       	pop	r15
     ec0:	ef 90       	pop	r14
     ec2:	df 90       	pop	r13
     ec4:	08 95       	ret

00000ec6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     ec6:	cf 93       	push	r28
     ec8:	df 93       	push	r29
     eca:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     ecc:	89 2b       	or	r24, r25
     ece:	b1 f0       	breq	.+44     	; 0xefc <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     ed0:	0e 94 05 06 	call	0xc0a	; 0xc0a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     ed4:	80 91 0f 26 	lds	r24, 0x260F
     ed8:	90 91 10 26 	lds	r25, 0x2610
     edc:	c8 0f       	add	r28, r24
     ede:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     ee0:	80 91 55 26 	lds	r24, 0x2655
     ee4:	90 91 56 26 	lds	r25, 0x2656
     ee8:	02 96       	adiw	r24, 0x02	; 2
     eea:	0e 94 74 04 	call	0x8e8	; 0x8e8 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     eee:	ce 01       	movw	r24, r28
     ef0:	0e 94 9b 04 	call	0x936	; 0x936 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     ef4:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     ef8:	81 11       	cpse	r24, r1
     efa:	02 c0       	rjmp	.+4      	; 0xf00 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
     efc:	0e 94 22 03 	call	0x644	; 0x644 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     f00:	df 91       	pop	r29
     f02:	cf 91       	pop	r28
     f04:	08 95       	ret

00000f06 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     f06:	80 91 08 26 	lds	r24, 0x2608
     f0a:	88 23       	and	r24, r24
     f0c:	21 f0       	breq	.+8      	; 0xf16 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	80 93 0b 26 	sts	0x260B, r24
     f14:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     f16:	10 92 0b 26 	sts	0x260B, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     f1a:	80 91 0e 26 	lds	r24, 0x260E
     f1e:	90 e0       	ldi	r25, 0x00	; 0
     f20:	fc 01       	movw	r30, r24
     f22:	ee 0f       	add	r30, r30
     f24:	ff 1f       	adc	r31, r31
     f26:	ee 0f       	add	r30, r30
     f28:	ff 1f       	adc	r31, r31
     f2a:	ee 0f       	add	r30, r30
     f2c:	ff 1f       	adc	r31, r31
     f2e:	8e 0f       	add	r24, r30
     f30:	9f 1f       	adc	r25, r31
     f32:	fc 01       	movw	r30, r24
     f34:	ef 5c       	subi	r30, 0xCF	; 207
     f36:	f9 4d       	sbci	r31, 0xD9	; 217
     f38:	80 81       	ld	r24, Z
     f3a:	81 11       	cpse	r24, r1
     f3c:	17 c0       	rjmp	.+46     	; 0xf6c <vTaskSwitchContext+0x66>
     f3e:	80 91 0e 26 	lds	r24, 0x260E
     f42:	81 50       	subi	r24, 0x01	; 1
     f44:	80 93 0e 26 	sts	0x260E, r24
     f48:	80 91 0e 26 	lds	r24, 0x260E
     f4c:	90 e0       	ldi	r25, 0x00	; 0
     f4e:	fc 01       	movw	r30, r24
     f50:	ee 0f       	add	r30, r30
     f52:	ff 1f       	adc	r31, r31
     f54:	ee 0f       	add	r30, r30
     f56:	ff 1f       	adc	r31, r31
     f58:	ee 0f       	add	r30, r30
     f5a:	ff 1f       	adc	r31, r31
     f5c:	8e 0f       	add	r24, r30
     f5e:	9f 1f       	adc	r25, r31
     f60:	fc 01       	movw	r30, r24
     f62:	ef 5c       	subi	r30, 0xCF	; 207
     f64:	f9 4d       	sbci	r31, 0xD9	; 217
     f66:	80 81       	ld	r24, Z
     f68:	88 23       	and	r24, r24
     f6a:	49 f3       	breq	.-46     	; 0xf3e <vTaskSwitchContext+0x38>
     f6c:	80 91 0e 26 	lds	r24, 0x260E
     f70:	90 e0       	ldi	r25, 0x00	; 0
     f72:	9c 01       	movw	r18, r24
     f74:	22 0f       	add	r18, r18
     f76:	33 1f       	adc	r19, r19
     f78:	22 0f       	add	r18, r18
     f7a:	33 1f       	adc	r19, r19
     f7c:	22 0f       	add	r18, r18
     f7e:	33 1f       	adc	r19, r19
     f80:	28 0f       	add	r18, r24
     f82:	39 1f       	adc	r19, r25
     f84:	d9 01       	movw	r26, r18
     f86:	af 5c       	subi	r26, 0xCF	; 207
     f88:	b9 4d       	sbci	r27, 0xD9	; 217
     f8a:	11 96       	adiw	r26, 0x01	; 1
     f8c:	ed 91       	ld	r30, X+
     f8e:	fc 91       	ld	r31, X
     f90:	12 97       	sbiw	r26, 0x02	; 2
     f92:	02 80       	ldd	r0, Z+2	; 0x02
     f94:	f3 81       	ldd	r31, Z+3	; 0x03
     f96:	e0 2d       	mov	r30, r0
     f98:	11 96       	adiw	r26, 0x01	; 1
     f9a:	ed 93       	st	X+, r30
     f9c:	fc 93       	st	X, r31
     f9e:	12 97       	sbiw	r26, 0x02	; 2
     fa0:	2c 5c       	subi	r18, 0xCC	; 204
     fa2:	39 4d       	sbci	r19, 0xD9	; 217
     fa4:	e2 17       	cp	r30, r18
     fa6:	f3 07       	cpc	r31, r19
     fa8:	29 f4       	brne	.+10     	; 0xfb4 <vTaskSwitchContext+0xae>
     faa:	22 81       	ldd	r18, Z+2	; 0x02
     fac:	33 81       	ldd	r19, Z+3	; 0x03
     fae:	fd 01       	movw	r30, r26
     fb0:	21 83       	std	Z+1, r18	; 0x01
     fb2:	32 83       	std	Z+2, r19	; 0x02
     fb4:	fc 01       	movw	r30, r24
     fb6:	ee 0f       	add	r30, r30
     fb8:	ff 1f       	adc	r31, r31
     fba:	ee 0f       	add	r30, r30
     fbc:	ff 1f       	adc	r31, r31
     fbe:	ee 0f       	add	r30, r30
     fc0:	ff 1f       	adc	r31, r31
     fc2:	8e 0f       	add	r24, r30
     fc4:	9f 1f       	adc	r25, r31
     fc6:	fc 01       	movw	r30, r24
     fc8:	ef 5c       	subi	r30, 0xCF	; 207
     fca:	f9 4d       	sbci	r31, 0xD9	; 217
     fcc:	01 80       	ldd	r0, Z+1	; 0x01
     fce:	f2 81       	ldd	r31, Z+2	; 0x02
     fd0:	e0 2d       	mov	r30, r0
     fd2:	86 81       	ldd	r24, Z+6	; 0x06
     fd4:	97 81       	ldd	r25, Z+7	; 0x07
     fd6:	80 93 55 26 	sts	0x2655, r24
     fda:	90 93 56 26 	sts	0x2656, r25
     fde:	08 95       	ret

00000fe0 <thread_1>:
	while(1){
		//printf("hello world %d\n\r",i);
		//i++;
		asm("nop");
		t1var++;
		PORTR.OUTTGL = (1<<0);
     fe0:	00 ee       	ldi	r16, 0xE0	; 224
     fe2:	17 e0       	ldi	r17, 0x07	; 7
     fe4:	c1 e0       	ldi	r28, 0x01	; 1
	//serial_startup();
	int i = 0;
	while(1){
		//printf("hello world %d\n\r",i);
		//i++;
		asm("nop");
     fe6:	00 00       	nop
		t1var++;
     fe8:	80 91 5b 26 	lds	r24, 0x265B
     fec:	90 91 5c 26 	lds	r25, 0x265C
     ff0:	01 96       	adiw	r24, 0x01	; 1
     ff2:	80 93 5b 26 	sts	0x265B, r24
     ff6:	90 93 5c 26 	sts	0x265C, r25
		PORTR.OUTTGL = (1<<0);
     ffa:	f8 01       	movw	r30, r16
     ffc:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(1000); //wait 1 sec
     ffe:	88 ee       	ldi	r24, 0xE8	; 232
    1000:	93 e0       	ldi	r25, 0x03	; 3
    1002:	0e 94 63 07 	call	0xec6	; 0xec6 <vTaskDelay>
	}
    1006:	ef cf       	rjmp	.-34     	; 0xfe6 <thread_1+0x6>

00001008 <thread_2>:
	//DDRB |= (1<<DDB0); //set PORTB, PIN0 as output
	while(1){
		//PORTB ^= (1<<PORTB0); //toggle PORTB, PIN0
		asm("nop");
		t2var++;
		PORTR.OUTTGL = (1<<1);
    1008:	00 ee       	ldi	r16, 0xE0	; 224
    100a:	17 e0       	ldi	r17, 0x07	; 7
    100c:	c2 e0       	ldi	r28, 0x02	; 2
}
void thread_2( void *pvParameters ){
	//DDRB |= (1<<DDB0); //set PORTB, PIN0 as output
	while(1){
		//PORTB ^= (1<<PORTB0); //toggle PORTB, PIN0
		asm("nop");
    100e:	00 00       	nop
		t2var++;
    1010:	80 91 59 26 	lds	r24, 0x2659
    1014:	90 91 5a 26 	lds	r25, 0x265A
    1018:	01 96       	adiw	r24, 0x01	; 1
    101a:	80 93 59 26 	sts	0x2659, r24
    101e:	90 93 5a 26 	sts	0x265A, r25
		PORTR.OUTTGL = (1<<1);
    1022:	f8 01       	movw	r30, r16
    1024:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(2000); //wait 2 seconds
    1026:	80 ed       	ldi	r24, 0xD0	; 208
    1028:	97 e0       	ldi	r25, 0x07	; 7
    102a:	0e 94 63 07 	call	0xec6	; 0xec6 <vTaskDelay>
	}
    102e:	ef cf       	rjmp	.-34     	; 0x100e <thread_2+0x6>

00001030 <thread_3>:
	//DDRB |= (1<<DDB1); //set PORTB, PIN1 as output
	while(1){
		//PORTB ^= (1<<PORTB1); //togle PORTB, PIN0
		asm("nop");
		t3var++;
		PORTD.OUTTGL = (1<<4);
    1030:	00 e6       	ldi	r16, 0x60	; 96
    1032:	16 e0       	ldi	r17, 0x06	; 6
    1034:	c0 e1       	ldi	r28, 0x10	; 16
}
void thread_3( void *pvParameters ){
	//DDRB |= (1<<DDB1); //set PORTB, PIN1 as output
	while(1){
		//PORTB ^= (1<<PORTB1); //togle PORTB, PIN0
		asm("nop");
    1036:	00 00       	nop
		t3var++;
    1038:	80 91 57 26 	lds	r24, 0x2657
    103c:	90 91 58 26 	lds	r25, 0x2658
    1040:	01 96       	adiw	r24, 0x01	; 1
    1042:	80 93 57 26 	sts	0x2657, r24
    1046:	90 93 58 26 	sts	0x2658, r25
		PORTD.OUTTGL = (1<<4);
    104a:	f8 01       	movw	r30, r16
    104c:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(200); //wait 200 ms
    104e:	88 ec       	ldi	r24, 0xC8	; 200
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	0e 94 63 07 	call	0xec6	; 0xec6 <vTaskDelay>
	}
    1056:	ef cf       	rjmp	.-34     	; 0x1036 <thread_3+0x6>

00001058 <usart_spi_transmit_receive>:
 *
 * @param usart
 * @param txdata
 * @return data received from slave
 */
uint8_t usart_spi_transmit_receive(USART_t * usart,uint8_t txdata){
    1058:	fc 01       	movw	r30, r24
	
	while ((usart->STATUS & USART_DREIF_bm) == 0);
    105a:	81 81       	ldd	r24, Z+1	; 0x01
    105c:	85 ff       	sbrs	r24, 5
    105e:	fd cf       	rjmp	.-6      	; 0x105a <usart_spi_transmit_receive+0x2>
	usart->DATA = txdata;
    1060:	60 83       	st	Z, r22
	while((usart->STATUS & USART_TXCIF_bm) == 0);
    1062:	81 81       	ldd	r24, Z+1	; 0x01
    1064:	86 ff       	sbrs	r24, 6
    1066:	fd cf       	rjmp	.-6      	; 0x1062 <usart_spi_transmit_receive+0xa>
	(usart)->STATUS = USART_TXCIF_bm;
    1068:	80 e4       	ldi	r24, 0x40	; 64
    106a:	81 83       	std	Z+1, r24	; 0x01
	return (usart)->DATA;
    106c:	80 81       	ld	r24, Z
}
    106e:	08 95       	ret

00001070 <ssd1306_write_command>:
 * data write function is called based on the selected interface.
 *
 * \param command the command to write
 */
static void ssd1306_write_command(uint8_t command)
{
    1070:	1f 93       	push	r17
    1072:	cf 93       	push	r28
    1074:	df 93       	push	r29
	port_out_value_clear_mask(&PORTF,(1<<3));//select device
    1076:	c0 ea       	ldi	r28, 0xA0	; 160
    1078:	d6 e0       	ldi	r29, 0x06	; 6
    107a:	18 e0       	ldi	r17, 0x08	; 8
    107c:	1e 83       	std	Y+6, r17	; 0x06
	port_out_value_clear_mask(&PORTD,(1<<0));//select command
    107e:	e0 e6       	ldi	r30, 0x60	; 96
    1080:	f6 e0       	ldi	r31, 0x06	; 6
    1082:	91 e0       	ldi	r25, 0x01	; 1
    1084:	96 83       	std	Z+6, r25	; 0x06
	ssd1306_sel_cmd() ;
    1086:	96 83       	std	Z+6, r25	; 0x06
	usart_spi_transmit_receive(&USARTD0, command);//transmit
    1088:	68 2f       	mov	r22, r24
    108a:	80 ea       	ldi	r24, 0xA0	; 160
    108c:	99 e0       	ldi	r25, 0x09	; 9
    108e:	0e 94 2c 08 	call	0x1058	; 0x1058 <usart_spi_transmit_receive>
	port_out_value_set_mask(&PORTF,(1<<3));//deselect device
    1092:	1d 83       	std	Y+5, r17	; 0x05
	
}
    1094:	df 91       	pop	r29
    1096:	cf 91       	pop	r28
    1098:	1f 91       	pop	r17
    109a:	08 95       	ret

0000109c <ssd1306_write_data>:
 * data write function is called based on the selected interface.
 *
 * \param data the data to write
 */
void ssd1306_write_data(uint8_t data)
{
    109c:	ef 92       	push	r14
    109e:	ff 92       	push	r15
    10a0:	0f 93       	push	r16
    10a2:	1f 93       	push	r17
    10a4:	cf 93       	push	r28
    10a6:	df 93       	push	r29
	
	port_out_value_clear_mask(&PORTF,(1<<3));//select device
    10a8:	c0 ea       	ldi	r28, 0xA0	; 160
    10aa:	d6 e0       	ldi	r29, 0x06	; 6
    10ac:	18 e0       	ldi	r17, 0x08	; 8
    10ae:	1e 83       	std	Y+6, r17	; 0x06
	ssd1306_sel_data() ;
    10b0:	0f 2e       	mov	r0, r31
    10b2:	f0 e6       	ldi	r31, 0x60	; 96
    10b4:	ef 2e       	mov	r14, r31
    10b6:	f6 e0       	ldi	r31, 0x06	; 6
    10b8:	ff 2e       	mov	r15, r31
    10ba:	f0 2d       	mov	r31, r0
    10bc:	01 e0       	ldi	r16, 0x01	; 1
    10be:	f7 01       	movw	r30, r14
    10c0:	05 83       	std	Z+5, r16	; 0x05
	usart_spi_transmit_receive(&USARTD0, data);//transmit
    10c2:	68 2f       	mov	r22, r24
    10c4:	80 ea       	ldi	r24, 0xA0	; 160
    10c6:	99 e0       	ldi	r25, 0x09	; 9
    10c8:	0e 94 2c 08 	call	0x1058	; 0x1058 <usart_spi_transmit_receive>
	ssd1306_sel_cmd();
    10cc:	f7 01       	movw	r30, r14
    10ce:	06 83       	std	Z+6, r16	; 0x06
	port_out_value_set_mask(&PORTF,(1<<3));//deselect device
    10d0:	1d 83       	std	Y+5, r17	; 0x05

}
    10d2:	df 91       	pop	r29
    10d4:	cf 91       	pop	r28
    10d6:	1f 91       	pop	r17
    10d8:	0f 91       	pop	r16
    10da:	ff 90       	pop	r15
    10dc:	ef 90       	pop	r14
    10de:	08 95       	ret

000010e0 <ssd1306_set_page_address>:
 */
void ssd1306_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
    10e0:	87 70       	andi	r24, 0x07	; 7
    10e2:	80 6b       	ori	r24, 0xB0	; 176
    10e4:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
    10e8:	08 95       	ret

000010ea <ssd1306_set_column_address>:
 * \brief Set current column in display RAM
 *
 * \param address the column address
 */
void ssd1306_set_column_address(uint8_t address)
{
    10ea:	cf 93       	push	r28
    10ec:	c8 2f       	mov	r28, r24
	// Make sure the address is 7 bits
	address &= 0x7F;
    10ee:	98 2f       	mov	r25, r24
    10f0:	9f 77       	andi	r25, 0x7F	; 127
	ssd1306_write_command(SSD1306_CMD_SET_HIGH_COL(address >> 4));
    10f2:	89 2f       	mov	r24, r25
    10f4:	82 95       	swap	r24
    10f6:	8f 70       	andi	r24, 0x0F	; 15
    10f8:	80 61       	ori	r24, 0x10	; 16
    10fa:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_write_command(SSD1306_CMD_SET_LOW_COL(address & 0x0F));
    10fe:	8c 2f       	mov	r24, r28
    1100:	8f 70       	andi	r24, 0x0F	; 15
    1102:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
}
    1106:	cf 91       	pop	r28
    1108:	08 95       	ret

0000110a <usart_init_spi>:
	}
}


void usart_init_spi(USART_t *usart, const usart_spi_options_emon_t *opt)
{
    110a:	cf 93       	push	r28
    110c:	df 93       	push	r29
    110e:	ec 01       	movw	r28, r24
    1110:	fb 01       	movw	r30, r22
	//ioport_pin_t sck_pin;
	//uint8_t invert_sck;

	(usart)->CTRLB &= ~USART_RXEN_bm;
    1112:	8c 81       	ldd	r24, Y+4	; 0x04
    1114:	8f 7e       	andi	r24, 0xEF	; 239
    1116:	8c 83       	std	Y+4, r24	; 0x04

	//invert_sck = (opt->spimode == 2) || (opt->spimode == 3);

	PORTD.DIRSET = (1<<1);//sck pin output
    1118:	a0 e6       	ldi	r26, 0x60	; 96
    111a:	b6 e0       	ldi	r27, 0x06	; 6
    111c:	82 e0       	ldi	r24, 0x02	; 2
    111e:	11 96       	adiw	r26, 0x01	; 1
    1120:	8c 93       	st	X, r24
    1122:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.OUTSET = (1<<1);//sck pin output level high
    1124:	15 96       	adiw	r26, 0x05	; 5
    1126:	8c 93       	st	X, r24

	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | USART_CMODE_MSPI_gc;
    1128:	8d 81       	ldd	r24, Y+5	; 0x05
    112a:	80 6c       	ori	r24, 0xC0	; 192
    112c:	8d 83       	std	Y+5, r24	; 0x05

	if (opt->spimode == 1 || opt->spimode == 3) {
    112e:	84 81       	ldd	r24, Z+4	; 0x04
    1130:	8d 7f       	andi	r24, 0xFD	; 253
    1132:	81 30       	cpi	r24, 0x01	; 1
    1134:	21 f4       	brne	.+8      	; 0x113e <usart_init_spi+0x34>
		usart->CTRLC |= USART_UCPHA_bm;
    1136:	8d 81       	ldd	r24, Y+5	; 0x05
    1138:	82 60       	ori	r24, 0x02	; 2
    113a:	8d 83       	std	Y+5, r24	; 0x05
    113c:	03 c0       	rjmp	.+6      	; 0x1144 <usart_init_spi+0x3a>
	}
	else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    113e:	8d 81       	ldd	r24, Y+5	; 0x05
    1140:	8d 7f       	andi	r24, 0xFD	; 253
    1142:	8d 83       	std	Y+5, r24	; 0x05
	}
	
	if (opt->data_order) {
    1144:	85 81       	ldd	r24, Z+5	; 0x05
    1146:	88 23       	and	r24, r24
    1148:	21 f0       	breq	.+8      	; 0x1152 <usart_init_spi+0x48>
		(usart)->CTRLC |= USART_DORD_bm;
    114a:	8d 81       	ldd	r24, Y+5	; 0x05
    114c:	84 60       	ori	r24, 0x04	; 4
    114e:	8d 83       	std	Y+5, r24	; 0x05
    1150:	03 c0       	rjmp	.+6      	; 0x1158 <usart_init_spi+0x4e>
	}
	else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1152:	8d 81       	ldd	r24, Y+5	; 0x05
    1154:	8b 7f       	andi	r24, 0xFB	; 251
    1156:	8d 83       	std	Y+5, r24	; 0x05
	}


	uint16_t bsel_value = (32000000UL/ (opt->baudrate*2)) -1 ;
    1158:	80 81       	ld	r24, Z
    115a:	91 81       	ldd	r25, Z+1	; 0x01
    115c:	a2 81       	ldd	r26, Z+2	; 0x02
    115e:	b3 81       	ldd	r27, Z+3	; 0x03
    1160:	9c 01       	movw	r18, r24
    1162:	ad 01       	movw	r20, r26
    1164:	22 0f       	add	r18, r18
    1166:	33 1f       	adc	r19, r19
    1168:	44 1f       	adc	r20, r20
    116a:	55 1f       	adc	r21, r21
    116c:	60 e0       	ldi	r22, 0x00	; 0
    116e:	78 e4       	ldi	r23, 0x48	; 72
    1170:	88 ee       	ldi	r24, 0xE8	; 232
    1172:	91 e0       	ldi	r25, 0x01	; 1
    1174:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <__udivmodsi4>
    1178:	21 50       	subi	r18, 0x01	; 1
    117a:	31 09       	sbc	r19, r1
	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    117c:	83 2f       	mov	r24, r19
    117e:	8f 70       	andi	r24, 0x0F	; 15
    1180:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1182:	2e 83       	std	Y+6, r18	; 0x06
	
	(usart)->CTRLB |= USART_TXEN_bm;
    1184:	8c 81       	ldd	r24, Y+4	; 0x04
    1186:	88 60       	ori	r24, 0x08	; 8
    1188:	8c 83       	std	Y+4, r24	; 0x04

}
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	08 95       	ret

00001190 <ssd1306_init>:




void ssd1306_init(void)
{
    1190:	cf 93       	push	r28
    1192:	df 93       	push	r29
    1194:	00 d0       	rcall	.+0      	; 0x1196 <ssd1306_init+0x6>
    1196:	00 d0       	rcall	.+0      	; 0x1198 <ssd1306_init+0x8>
    1198:	cd b7       	in	r28, 0x3d	; 61
    119a:	de b7       	in	r29, 0x3e	; 62

	port_direction_set_mask(&PORTF,(1<<3));//ss
    119c:	20 ea       	ldi	r18, 0xA0	; 160
    119e:	36 e0       	ldi	r19, 0x06	; 6
    11a0:	88 e0       	ldi	r24, 0x08	; 8
    11a2:	d9 01       	movw	r26, r18
    11a4:	11 96       	adiw	r26, 0x01	; 1
    11a6:	8c 93       	st	X, r24
	port_direction_set_mask(&PORTD,(1<<0));//data_cmd
    11a8:	a0 e6       	ldi	r26, 0x60	; 96
    11aa:	b6 e0       	ldi	r27, 0x06	; 6
    11ac:	91 e0       	ldi	r25, 0x01	; 1
    11ae:	11 96       	adiw	r26, 0x01	; 1
    11b0:	9c 93       	st	X, r25
    11b2:	11 97       	sbiw	r26, 0x01	; 1
	port_direction_set_mask(&PORTA,(1<<3));//reset
    11b4:	e0 e0       	ldi	r30, 0x00	; 0
    11b6:	f6 e0       	ldi	r31, 0x06	; 6
    11b8:	81 83       	std	Z+1, r24	; 0x01
	port_direction_set_mask(&PORTD,(1<<1));//sck
    11ba:	92 e0       	ldi	r25, 0x02	; 2
    11bc:	11 96       	adiw	r26, 0x01	; 1
    11be:	9c 93       	st	X, r25
    11c0:	11 97       	sbiw	r26, 0x01	; 1
	port_direction_set_mask(&PORTD,(1<<3));//mosi
    11c2:	11 96       	adiw	r26, 0x01	; 1
    11c4:	8c 93       	st	X, r24
// 	
	port_out_value_set_mask(&PORTF,(1<<3));//ss
    11c6:	d9 01       	movw	r26, r18
    11c8:	15 96       	adiw	r26, 0x05	; 5
    11ca:	8c 93       	st	X, r24
 * \note this functions should not be confused with the \ref ssd1306_soft_reset()
 * function, this command will control the RST pin.
 */
static inline void ssd1306_hard_reset(void)
{
	PORTA.OUTCLR = (1<<3);
    11cc:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    11ce:	ba e6       	ldi	r27, 0x6A	; 106
    11d0:	ba 95       	dec	r27
    11d2:	f1 f7       	brne	.-4      	; 0x11d0 <ssd1306_init+0x40>
    11d4:	00 c0       	rjmp	.+0      	; 0x11d6 <ssd1306_init+0x46>
	delay_us(10); // At least 3us
	PORTA.OUTSET = (1<<3);
    11d6:	85 83       	std	Z+5, r24	; 0x05
    11d8:	ea e6       	ldi	r30, 0x6A	; 106
    11da:	ea 95       	dec	r30
    11dc:	f1 f7       	brne	.-4      	; 0x11da <ssd1306_init+0x4a>
    11de:	00 c0       	rjmp	.+0      	; 0x11e0 <ssd1306_init+0x50>
	spi_flags_t spi_flags = 0;
	//board_spi_select_id_t spi_select_id = 0;
	
	//irqflags_t flags = cpu_irq_save();
	//*((uint8_t *)&PR.PRGEN + SYSCLK_PORT_D) &= ~PR_USART0_bm;
	PR.PRPD &= ~PR_USART0_bm;
    11e0:	e0 e7       	ldi	r30, 0x70	; 112
    11e2:	f0 e0       	ldi	r31, 0x00	; 0
    11e4:	84 81       	ldd	r24, Z+4	; 0x04
    11e6:	8f 7e       	andi	r24, 0xEF	; 239
    11e8:	84 83       	std	Z+4, r24	; 0x04
	
	//cpu_irq_restore(flags);
	
	usart_spi_options_emon_t opt;
	opt.baudrate=12000000;
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	9b e1       	ldi	r25, 0x1B	; 27
    11ee:	a7 eb       	ldi	r26, 0xB7	; 183
    11f0:	b0 e0       	ldi	r27, 0x00	; 0
    11f2:	89 83       	std	Y+1, r24	; 0x01
    11f4:	9a 83       	std	Y+2, r25	; 0x02
    11f6:	ab 83       	std	Y+3, r26	; 0x03
    11f8:	bc 83       	std	Y+4, r27	; 0x04
	opt.spimode=spi_flags;
    11fa:	1d 82       	std	Y+5, r1	; 0x05
	opt.data_order=0;
    11fc:	1e 82       	std	Y+6, r1	; 0x06
	usart_init_spi(&USARTD0, &opt);
    11fe:	be 01       	movw	r22, r28
    1200:	6f 5f       	subi	r22, 0xFF	; 255
    1202:	7f 4f       	sbci	r23, 0xFF	; 255
    1204:	80 ea       	ldi	r24, 0xA0	; 160
    1206:	99 e0       	ldi	r25, 0x09	; 9
    1208:	0e 94 85 08 	call	0x110a	; 0x110a <usart_init_spi>
	

	// 1/32 Duty (0x0F~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_MULTIPLEX_RATIO);
    120c:	88 ea       	ldi	r24, 0xA8	; 168
    120e:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_write_command(0x1F);
    1212:	8f e1       	ldi	r24, 0x1F	; 31
    1214:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	// Shift Mapping RAM Counter (0x00~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_OFFSET);
    1218:	83 ed       	ldi	r24, 0xD3	; 211
    121a:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_write_command(0x00);
    121e:	80 e0       	ldi	r24, 0x00	; 0
    1220:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	// Set Mapping RAM Display Start Line (0x00~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_START_LINE(0x00));
    1224:	80 e4       	ldi	r24, 0x40	; 64
    1226:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	// Set Column Address 0 Mapped to SEG0
	ssd1306_write_command(SSD1306_CMD_SET_SEGMENT_RE_MAP_COL127_SEG0);
    122a:	81 ea       	ldi	r24, 0xA1	; 161
    122c:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	// Set COM/Row Scan Scan from COM63 to 0
	ssd1306_write_command(SSD1306_CMD_SET_COM_OUTPUT_SCAN_DOWN);
    1230:	88 ec       	ldi	r24, 0xC8	; 200
    1232:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	// Set COM Pins hardware configuration
	ssd1306_write_command(SSD1306_CMD_SET_COM_PINS);
    1236:	8a ed       	ldi	r24, 0xDA	; 218
    1238:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_write_command(0x02);
    123c:	82 e0       	ldi	r24, 0x02	; 2
    123e:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	//ssd1306_set_contrast(0x8F);
	ssd1306_write_command(SSD1306_CMD_SET_CONTRAST_CONTROL_FOR_BANK0);
    1242:	81 e8       	ldi	r24, 0x81	; 129
    1244:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_write_command(0x8F);
    1248:	8f e8       	ldi	r24, 0x8F	; 143
    124a:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

		
	// Disable Entire display On
	ssd1306_write_command(SSD1306_CMD_ENTIRE_DISPLAY_AND_GDDRAM_ON);
    124e:	84 ea       	ldi	r24, 0xA4	; 164
    1250:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	//ssd1306_display_invert_disable();
	ssd1306_write_command(SSD1306_CMD_SET_NORMAL_DISPLAY);
    1254:	86 ea       	ldi	r24, 0xA6	; 166
    1256:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	// Set Display Clock Divide Ratio / Oscillator Frequency (Default => 0x80)
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_CLOCK_DIVIDE_RATIO);
    125a:	85 ed       	ldi	r24, 0xD5	; 213
    125c:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_write_command(0x80);
    1260:	80 e8       	ldi	r24, 0x80	; 128
    1262:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	// Enable charge pump regulator
	ssd1306_write_command(SSD1306_CMD_SET_CHARGE_PUMP_SETTING);
    1266:	8d e8       	ldi	r24, 0x8D	; 141
    1268:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_write_command(0x14);
    126c:	84 e1       	ldi	r24, 0x14	; 20
    126e:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	// Set VCOMH Deselect Level
	ssd1306_write_command(SSD1306_CMD_SET_VCOMH_DESELECT_LEVEL);
    1272:	8b ed       	ldi	r24, 0xDB	; 219
    1274:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_write_command(0x40); // Default => 0x20 (0.77*VCC)
    1278:	80 e4       	ldi	r24, 0x40	; 64
    127a:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	// Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
	ssd1306_write_command(SSD1306_CMD_SET_PRE_CHARGE_PERIOD);
    127e:	89 ed       	ldi	r24, 0xD9	; 217
    1280:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_write_command(0xF1);
    1284:	81 ef       	ldi	r24, 0xF1	; 241
    1286:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>

	//ssd1306_display_on();
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_ON);
    128a:	8f ea       	ldi	r24, 0xAF	; 175
    128c:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
}
    1290:	26 96       	adiw	r28, 0x06	; 6
    1292:	cd bf       	out	0x3d, r28	; 61
    1294:	de bf       	out	0x3e, r29	; 62
    1296:	df 91       	pop	r29
    1298:	cf 91       	pop	r28
    129a:	08 95       	ret

0000129c <ssd1306_write_text>:
/**
 * \brief Display text on OLED screen.
 * \param string String to display.
 */
void ssd1306_write_text(char *string)
{
    129c:	ef 92       	push	r14
    129e:	ff 92       	push	r15
    12a0:	0f 93       	push	r16
    12a2:	1f 93       	push	r17
    12a4:	cf 93       	push	r28
	uint8_t *char_ptr;
	uint8_t i;

	while (*string != '\0') {
    12a6:	dc 01       	movw	r26, r24
    12a8:	ec 91       	ld	r30, X
    12aa:	ee 23       	and	r30, r30
    12ac:	29 f1       	breq	.+74     	; 0x12f8 <ssd1306_write_text+0x5c>
    12ae:	7c 01       	movw	r14, r24
    12b0:	bf ef       	ldi	r27, 0xFF	; 255
    12b2:	eb 1a       	sub	r14, r27
    12b4:	fb 0a       	sbc	r15, r27
		if (*string < 0x7F) {
    12b6:	ef 37       	cpi	r30, 0x7F	; 127
    12b8:	d0 f4       	brcc	.+52     	; 0x12ee <ssd1306_write_text+0x52>
			char_ptr = font_table[*string - 32];
    12ba:	f0 e0       	ldi	r31, 0x00	; 0
    12bc:	ee 0f       	add	r30, r30
    12be:	ff 1f       	adc	r31, r31
    12c0:	e2 57       	subi	r30, 0x72	; 114
    12c2:	fe 4d       	sbci	r31, 0xDE	; 222
    12c4:	00 81       	ld	r16, Z
    12c6:	11 81       	ldd	r17, Z+1	; 0x01
			for (i = 1; i <= char_ptr[0]; i++) {
    12c8:	f8 01       	movw	r30, r16
    12ca:	80 81       	ld	r24, Z
    12cc:	88 23       	and	r24, r24
    12ce:	61 f0       	breq	.+24     	; 0x12e8 <ssd1306_write_text+0x4c>
    12d0:	c1 e0       	ldi	r28, 0x01	; 1
				ssd1306_write_data(char_ptr[i]);
    12d2:	f8 01       	movw	r30, r16
    12d4:	ec 0f       	add	r30, r28
    12d6:	f1 1d       	adc	r31, r1
    12d8:	80 81       	ld	r24, Z
    12da:	0e 94 4e 08 	call	0x109c	; 0x109c <ssd1306_write_data>
	uint8_t i;

	while (*string != '\0') {
		if (*string < 0x7F) {
			char_ptr = font_table[*string - 32];
			for (i = 1; i <= char_ptr[0]; i++) {
    12de:	cf 5f       	subi	r28, 0xFF	; 255
    12e0:	d8 01       	movw	r26, r16
    12e2:	9c 91       	ld	r25, X
    12e4:	9c 17       	cp	r25, r28
    12e6:	a8 f7       	brcc	.-22     	; 0x12d2 <ssd1306_write_text+0x36>
				ssd1306_write_data(char_ptr[i]);
			}
			ssd1306_write_data(0x00);
    12e8:	80 e0       	ldi	r24, 0x00	; 0
    12ea:	0e 94 4e 08 	call	0x109c	; 0x109c <ssd1306_write_data>
void ssd1306_write_text(char *string)
{
	uint8_t *char_ptr;
	uint8_t i;

	while (*string != '\0') {
    12ee:	d7 01       	movw	r26, r14
    12f0:	ed 91       	ld	r30, X+
    12f2:	7d 01       	movw	r14, r26
    12f4:	e1 11       	cpse	r30, r1
    12f6:	df cf       	rjmp	.-66     	; 0x12b6 <ssd1306_write_text+0x1a>
			}
			ssd1306_write_data(0x00);
		}
			string++;
	}
}
    12f8:	cf 91       	pop	r28
    12fa:	1f 91       	pop	r17
    12fc:	0f 91       	pop	r16
    12fe:	ff 90       	pop	r15
    1300:	ef 90       	pop	r14
    1302:	08 95       	ret

00001304 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(uint8_t page, uint8_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    1304:	20 e8       	ldi	r18, 0x80	; 128
    1306:	82 9f       	mul	r24, r18
    1308:	c0 01       	movw	r24, r0
    130a:	11 24       	eor	r1, r1
    130c:	86 0f       	add	r24, r22
    130e:	91 1d       	adc	r25, r1
    1310:	e0 91 5d 26 	lds	r30, 0x265D
    1314:	f0 91 5e 26 	lds	r31, 0x265E
    1318:	e8 0f       	add	r30, r24
    131a:	f9 1f       	adc	r31, r25
    131c:	40 83       	st	Z, r20
    131e:	08 95       	ret

00001320 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(uint8_t page, uint8_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    1320:	20 e8       	ldi	r18, 0x80	; 128
    1322:	82 9f       	mul	r24, r18
    1324:	c0 01       	movw	r24, r0
    1326:	11 24       	eor	r1, r1
    1328:	86 0f       	add	r24, r22
    132a:	91 1d       	adc	r25, r1
    132c:	e0 91 5d 26 	lds	r30, 0x265D
    1330:	f0 91 5e 26 	lds	r31, 0x265E
    1334:	e8 0f       	add	r30, r24
    1336:	f9 1f       	adc	r31, r25
}
    1338:	80 81       	ld	r24, Z
    133a:	08 95       	ret

0000133c <gfx_mono_ssd1306_put_byte>:
	gfx_mono_ssd1306_put_byte(0, 0, 0xFF, false);
\endcode
 */
void gfx_mono_ssd1306_put_byte(uint8_t page, uint8_t column,
		uint8_t data, uint8_t force)
{
    133c:	1f 93       	push	r17
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	18 2f       	mov	r17, r24
    1344:	d6 2f       	mov	r29, r22
    1346:	c4 2f       	mov	r28, r20
//#ifdef CONFIG_SSD1306_FRAMEBUFFER
	if (!force && data == gfx_mono_framebuffer_get_byte(page, column)) {
    1348:	21 11       	cpse	r18, r1
    134a:	04 c0       	rjmp	.+8      	; 0x1354 <gfx_mono_ssd1306_put_byte+0x18>
    134c:	0e 94 90 09 	call	0x1320	; 0x1320 <gfx_mono_framebuffer_get_byte>
    1350:	8c 17       	cp	r24, r28
    1352:	71 f0       	breq	.+28     	; 0x1370 <gfx_mono_ssd1306_put_byte+0x34>
		return;
	}
	gfx_mono_framebuffer_put_byte(page, column, data);
    1354:	4c 2f       	mov	r20, r28
    1356:	6d 2f       	mov	r22, r29
    1358:	81 2f       	mov	r24, r17
    135a:	0e 94 82 09 	call	0x1304	; 0x1304 <gfx_mono_framebuffer_put_byte>
//#endif

	ssd1306_set_page_address(page);
    135e:	81 2f       	mov	r24, r17
    1360:	0e 94 70 08 	call	0x10e0	; 0x10e0 <ssd1306_set_page_address>
	ssd1306_set_column_address(column);
    1364:	8d 2f       	mov	r24, r29
    1366:	0e 94 75 08 	call	0x10ea	; 0x10ea <ssd1306_set_column_address>

	ssd1306_write_data(data);
    136a:	8c 2f       	mov	r24, r28
    136c:	0e 94 4e 08 	call	0x109c	; 0x109c <ssd1306_write_data>
}
    1370:	df 91       	pop	r29
    1372:	cf 91       	pop	r28
    1374:	1f 91       	pop	r17
    1376:	08 95       	ret

00001378 <main>:

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
    1378:	cf 93       	push	r28
    137a:	df 93       	push	r29
    137c:	cd b7       	in	r28, 0x3d	; 61
    137e:	de b7       	in	r29, 0x3e	; 62
    1380:	a7 97       	sbiw	r28, 0x27	; 39
    1382:	cd bf       	out	0x3d, r28	; 61
    1384:	de bf       	out	0x3e, r29	; 62

	rtc_initialize();
    1386:	0e 94 8c 0c 	call	0x1918	; 0x1918 <rtc_initialize>
	DigitalPin_t led = {&PORTR, 0};
    138a:	80 ee       	ldi	r24, 0xE0	; 224
    138c:	97 e0       	ldi	r25, 0x07	; 7
    138e:	89 83       	std	Y+1, r24	; 0x01
    1390:	9a 83       	std	Y+2, r25	; 0x02
    1392:	1b 82       	std	Y+3, r1	; 0x03
	DigitalPin_t led2 = {&PORTR, 1};
    1394:	8c 83       	std	Y+4, r24	; 0x04
    1396:	9d 83       	std	Y+5, r25	; 0x05
    1398:	81 e0       	ldi	r24, 0x01	; 1
    139a:	8e 83       	std	Y+6, r24	; 0x06
	gfx_mono_set_framebuffer(framebuffer);
\endcode
 */
void gfx_mono_set_framebuffer(uint8_t *framebuffer)
{
	fbpointer = framebuffer;
    139c:	8f e5       	ldi	r24, 0x5F	; 95
    139e:	96 e2       	ldi	r25, 0x26	; 38
    13a0:	80 93 5d 26 	sts	0x265D, r24
    13a4:	90 93 5e 26 	sts	0x265E, r25
	uint8_t page;
	uint8_t column;

	gfx_mono_set_framebuffer(framebuffer);

	ssd1306_init();
    13a8:	0e 94 c8 08 	call	0x1190	; 0x1190 <ssd1306_init>
	asm("nop");
    13ac:	00 00       	nop
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    13ae:	10 e0       	ldi	r17, 0x00	; 0
    13b0:	0f c0       	rjmp	.+30     	; 0x13d0 <main+0x58>
	{
		for (col = 0; col < 128; ++col)
		{
			ssd1306_set_page_address(page);
    13b2:	81 2f       	mov	r24, r17
    13b4:	0e 94 70 08 	call	0x10e0	; 0x10e0 <ssd1306_set_page_address>
			ssd1306_set_column_address(col);
    13b8:	80 2f       	mov	r24, r16
    13ba:	0e 94 75 08 	call	0x10ea	; 0x10ea <ssd1306_set_column_address>
			ssd1306_write_data(0x00);
    13be:	80 e0       	ldi	r24, 0x00	; 0
    13c0:	0e 94 4e 08 	call	0x109c	; 0x109c <ssd1306_write_data>
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
	{
		for (col = 0; col < 128; ++col)
    13c4:	0f 5f       	subi	r16, 0xFF	; 255
    13c6:	00 38       	cpi	r16, 0x80	; 128
    13c8:	a1 f7       	brne	.-24     	; 0x13b2 <main+0x3a>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    13ca:	1f 5f       	subi	r17, 0xFF	; 255
    13cc:	14 30       	cpi	r17, 0x04	; 4
    13ce:	11 f0       	breq	.+4      	; 0x13d4 <main+0x5c>

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
    13d0:	00 e0       	ldi	r16, 0x00	; 0
    13d2:	ef cf       	rjmp	.-34     	; 0x13b2 <main+0x3a>
 */
static inline void ssd1306_set_display_start_line_address(uint8_t address)
{
	// Make sure address is 6 bits
	address &= 0x3F;
	ssd1306_write_command(SSD1306_CMD_SET_START_LINE(address));
    13d4:	80 e4       	ldi	r24, 0x40	; 64
    13d6:	0e 94 38 08 	call	0x1070	; 0x1070 <ssd1306_write_command>
	ssd1306_clear();

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    13da:	10 e0       	ldi	r17, 0x00	; 0
    13dc:	0c c0       	rjmp	.+24     	; 0x13f6 <main+0x7e>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
    13de:	21 e0       	ldi	r18, 0x01	; 1
    13e0:	40 e0       	ldi	r20, 0x00	; 0
    13e2:	60 2f       	mov	r22, r16
    13e4:	81 2f       	mov	r24, r17
    13e6:	0e 94 9e 09 	call	0x133c	; 0x133c <gfx_mono_ssd1306_put_byte>

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    13ea:	0f 5f       	subi	r16, 0xFF	; 255
    13ec:	00 38       	cpi	r16, 0x80	; 128
    13ee:	b9 f7       	brne	.-18     	; 0x13de <main+0x66>
	ssd1306_clear();

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    13f0:	1f 5f       	subi	r17, 0xFF	; 255
    13f2:	14 30       	cpi	r17, 0x04	; 4
    13f4:	11 f0       	breq	.+4      	; 0x13fa <main+0x82>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    13f6:	00 e0       	ldi	r16, 0x00	; 0
    13f8:	f2 cf       	rjmp	.-28     	; 0x13de <main+0x66>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
		}
	}

	asm("nop");
    13fa:	00 00       	nop
	ssd1306_set_page_address(0);
    13fc:	80 e0       	ldi	r24, 0x00	; 0
    13fe:	0e 94 70 08 	call	0x10e0	; 0x10e0 <ssd1306_set_page_address>
	ssd1306_write_text("EMON");
    1402:	83 ea       	ldi	r24, 0xA3	; 163
    1404:	92 e2       	ldi	r25, 0x22	; 34
    1406:	0e 94 4e 09 	call	0x129c	; 0x129c <ssd1306_write_text>



	DigitalPin_SetDIr(&led,1);
    140a:	61 e0       	ldi	r22, 0x01	; 1
    140c:	ce 01       	movw	r24, r28
    140e:	01 96       	adiw	r24, 0x01	; 1
    1410:	0e 94 87 0a 	call	0x150e	; 0x150e <DigitalPin_SetDIr>
	DigitalPin_SetDIr(&led2,1);
    1414:	61 e0       	ldi	r22, 0x01	; 1
    1416:	ce 01       	movw	r24, r28
    1418:	04 96       	adiw	r24, 0x04	; 4
    141a:	0e 94 87 0a 	call	0x150e	; 0x150e <DigitalPin_SetDIr>
	//PORT_SetDirection(&PORTR,(1<<0));

	CLKSYS_Enable( OSC_RC32MEN_bm );
    141e:	e0 e5       	ldi	r30, 0x50	; 80
    1420:	f0 e0       	ldi	r31, 0x00	; 0
    1422:	80 81       	ld	r24, Z
    1424:	82 60       	ori	r24, 0x02	; 2
    1426:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC32MRDY_bm ) == 0 );
    1428:	81 81       	ldd	r24, Z+1	; 0x01
    142a:	81 ff       	sbrs	r24, 1
    142c:	fd cf       	rjmp	.-6      	; 0x1428 <main+0xb0>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    142e:	81 e0       	ldi	r24, 0x01	; 1
    1430:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    1434:	81 e0       	ldi	r24, 0x01	; 1
    1436:	0e 94 46 0b 	call	0x168c	; 0x168c <CLKSYS_Disable>
	
	char time_string[20];
	uint8_t rxData[33];
	
	
	PORTR.DIRSET = (1<<0);
    143a:	e0 ee       	ldi	r30, 0xE0	; 224
    143c:	f7 e0       	ldi	r31, 0x07	; 7
    143e:	81 e0       	ldi	r24, 0x01	; 1
    1440:	81 83       	std	Z+1, r24	; 0x01
	PORTR.DIRSET = (1<<1);
    1442:	82 e0       	ldi	r24, 0x02	; 2
    1444:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = (1<<4);
    1446:	80 e1       	ldi	r24, 0x10	; 16
    1448:	80 93 61 06 	sts	0x0661, r24
	
	
	//creating the threads
	xTaskCreate(thread_1, (const char*) "t1", 300, NULL, tskIDLE_PRIORITY, NULL );
    144c:	a1 2c       	mov	r10, r1
    144e:	b1 2c       	mov	r11, r1
    1450:	c1 2c       	mov	r12, r1
    1452:	d1 2c       	mov	r13, r1
    1454:	e1 2c       	mov	r14, r1
    1456:	f1 2c       	mov	r15, r1
    1458:	00 e0       	ldi	r16, 0x00	; 0
    145a:	20 e0       	ldi	r18, 0x00	; 0
    145c:	30 e0       	ldi	r19, 0x00	; 0
    145e:	4c e2       	ldi	r20, 0x2C	; 44
    1460:	51 e0       	ldi	r21, 0x01	; 1
    1462:	68 ea       	ldi	r22, 0xA8	; 168
    1464:	72 e2       	ldi	r23, 0x22	; 34
    1466:	80 ef       	ldi	r24, 0xF0	; 240
    1468:	97 e0       	ldi	r25, 0x07	; 7
    146a:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <xTaskGenericCreate>
	xTaskCreate(thread_2,(const char *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
    146e:	20 e0       	ldi	r18, 0x00	; 0
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	44 e6       	ldi	r20, 0x64	; 100
    1474:	50 e0       	ldi	r21, 0x00	; 0
    1476:	6b ea       	ldi	r22, 0xAB	; 171
    1478:	72 e2       	ldi	r23, 0x22	; 34
    147a:	84 e0       	ldi	r24, 0x04	; 4
    147c:	98 e0       	ldi	r25, 0x08	; 8
    147e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <xTaskGenericCreate>
	xTaskCreate(thread_3,(const char *) "t3", 100, NULL, tskIDLE_PRIORITY, NULL );
    1482:	20 e0       	ldi	r18, 0x00	; 0
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	44 e6       	ldi	r20, 0x64	; 100
    1488:	50 e0       	ldi	r21, 0x00	; 0
    148a:	6e ea       	ldi	r22, 0xAE	; 174
    148c:	72 e2       	ldi	r23, 0x22	; 34
    148e:	88 e1       	ldi	r24, 0x18	; 24
    1490:	98 e0       	ldi	r25, 0x08	; 8
    1492:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <xTaskGenericCreate>
	
	
	//starting the scheduler
	vTaskStartScheduler();
    1496:	0e 94 da 05 	call	0xbb4	; 0xbb4 <vTaskStartScheduler>

			ssd1306_set_page_address(0);
			ssd1306_set_column_address(0);
			ssd1306_write_text(rxData);
			
			PORTR.OUTTGL = (1<<0);
    149a:	0f 2e       	mov	r0, r31
    149c:	f0 ee       	ldi	r31, 0xE0	; 224
    149e:	ef 2e       	mov	r14, r31
    14a0:	f7 e0       	ldi	r31, 0x07	; 7
    14a2:	ff 2e       	mov	r15, r31
    14a4:	f0 2d       	mov	r31, r0
// 		//sprintf(time_string,"%d", timeinfo->tm_year);
// 		ssd1306_write_text(time_string);
// 		_delay_ms(500);
		
		
		if((_nrf24l01p_readable(_NRF24L01P_PIPE_P1))){
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	0e 94 27 02 	call	0x44e	; 0x44e <_nrf24l01p_readable>
    14ac:	88 23       	and	r24, r24
    14ae:	d9 f3       	breq	.-10     	; 0x14a6 <main+0x12e>
			int width = _nrf24l01p_read_dyn_pld(_NRF24L01P_PIPE_P1, (uint8_t*) rxData);
    14b0:	be 01       	movw	r22, r28
    14b2:	69 5f       	subi	r22, 0xF9	; 249
    14b4:	7f 4f       	sbci	r23, 0xFF	; 255
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	0e 94 41 02 	call	0x482	; 0x482 <_nrf24l01p_read_dyn_pld>
			rxData[width] = '\0';
    14bc:	27 e0       	ldi	r18, 0x07	; 7
    14be:	30 e0       	ldi	r19, 0x00	; 0
    14c0:	2c 0f       	add	r18, r28
    14c2:	3d 1f       	adc	r19, r29
    14c4:	82 0f       	add	r24, r18
    14c6:	93 1f       	adc	r25, r19
    14c8:	fc 01       	movw	r30, r24
    14ca:	10 82       	st	Z, r1
    14cc:	00 e0       	ldi	r16, 0x00	; 0
    14ce:	0f c0       	rjmp	.+30     	; 0x14ee <main+0x176>
	{
		for (col = 0; col < 128; ++col)
		{
			ssd1306_set_page_address(page);
    14d0:	80 2f       	mov	r24, r16
    14d2:	0e 94 70 08 	call	0x10e0	; 0x10e0 <ssd1306_set_page_address>
			ssd1306_set_column_address(col);
    14d6:	81 2f       	mov	r24, r17
    14d8:	0e 94 75 08 	call	0x10ea	; 0x10ea <ssd1306_set_column_address>
			ssd1306_write_data(0x00);
    14dc:	80 e0       	ldi	r24, 0x00	; 0
    14de:	0e 94 4e 08 	call	0x109c	; 0x109c <ssd1306_write_data>
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
	{
		for (col = 0; col < 128; ++col)
    14e2:	1f 5f       	subi	r17, 0xFF	; 255
    14e4:	10 38       	cpi	r17, 0x80	; 128
    14e6:	a1 f7       	brne	.-24     	; 0x14d0 <main+0x158>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
    14e8:	0f 5f       	subi	r16, 0xFF	; 255
    14ea:	04 30       	cpi	r16, 0x04	; 4
    14ec:	11 f0       	breq	.+4      	; 0x14f2 <main+0x17a>
	ssd1306_clear();

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    14ee:	10 e0       	ldi	r17, 0x00	; 0
    14f0:	ef cf       	rjmp	.-34     	; 0x14d0 <main+0x158>
			rxData[width] = '\0';
			//mynrf.write_to_address_ack(0xC2C2C2C255, (uint8_t*)rxData,strlen(rxData));
			
			ssd1306_clear();

			ssd1306_set_page_address(0);
    14f2:	80 e0       	ldi	r24, 0x00	; 0
    14f4:	0e 94 70 08 	call	0x10e0	; 0x10e0 <ssd1306_set_page_address>
			ssd1306_set_column_address(0);
    14f8:	80 e0       	ldi	r24, 0x00	; 0
    14fa:	0e 94 75 08 	call	0x10ea	; 0x10ea <ssd1306_set_column_address>
			ssd1306_write_text(rxData);
    14fe:	ce 01       	movw	r24, r28
    1500:	07 96       	adiw	r24, 0x07	; 7
    1502:	0e 94 4e 09 	call	0x129c	; 0x129c <ssd1306_write_text>
			
			PORTR.OUTTGL = (1<<0);
    1506:	81 e0       	ldi	r24, 0x01	; 1
    1508:	f7 01       	movw	r30, r14
    150a:	87 83       	std	Z+7, r24	; 0x07
    150c:	cc cf       	rjmp	.-104    	; 0x14a6 <main+0x12e>

0000150e <DigitalPin_SetDIr>:
	SREG = sreg;	
}


void DigitalPin_SetDIr(DigitalPin_t *pin , bool dir){
	if(dir) pin->_port->DIRSET = (1<< pin->_pin);
    150e:	66 23       	and	r22, r22
    1510:	79 f0       	breq	.+30     	; 0x1530 <DigitalPin_SetDIr+0x22>
    1512:	dc 01       	movw	r26, r24
    1514:	ed 91       	ld	r30, X+
    1516:	fc 91       	ld	r31, X
    1518:	11 97       	sbiw	r26, 0x01	; 1
    151a:	21 e0       	ldi	r18, 0x01	; 1
    151c:	30 e0       	ldi	r19, 0x00	; 0
    151e:	a9 01       	movw	r20, r18
    1520:	12 96       	adiw	r26, 0x02	; 2
    1522:	0c 90       	ld	r0, X
    1524:	02 c0       	rjmp	.+4      	; 0x152a <DigitalPin_SetDIr+0x1c>
    1526:	44 0f       	add	r20, r20
    1528:	55 1f       	adc	r21, r21
    152a:	0a 94       	dec	r0
    152c:	e2 f7       	brpl	.-8      	; 0x1526 <DigitalPin_SetDIr+0x18>
    152e:	41 83       	std	Z+1, r20	; 0x01
    1530:	08 95       	ret

00001532 <DigitalPin_SetValue>:
}

void DigitalPin_SetValue(DigitalPin_t *pin){
	pin->_port->OUTSET = (1<< pin->_pin);
    1532:	dc 01       	movw	r26, r24
    1534:	ed 91       	ld	r30, X+
    1536:	fc 91       	ld	r31, X
    1538:	11 97       	sbiw	r26, 0x01	; 1
    153a:	21 e0       	ldi	r18, 0x01	; 1
    153c:	30 e0       	ldi	r19, 0x00	; 0
    153e:	a9 01       	movw	r20, r18
    1540:	12 96       	adiw	r26, 0x02	; 2
    1542:	0c 90       	ld	r0, X
    1544:	02 c0       	rjmp	.+4      	; 0x154a <DigitalPin_SetValue+0x18>
    1546:	44 0f       	add	r20, r20
    1548:	55 1f       	adc	r21, r21
    154a:	0a 94       	dec	r0
    154c:	e2 f7       	brpl	.-8      	; 0x1546 <DigitalPin_SetValue+0x14>
    154e:	45 83       	std	Z+5, r20	; 0x05
    1550:	08 95       	ret

00001552 <DigitalPin_ClearValue>:
}

void DigitalPin_ClearValue(DigitalPin_t *pin){
	pin->_port->OUTCLR = (1<< pin->_pin);
    1552:	dc 01       	movw	r26, r24
    1554:	ed 91       	ld	r30, X+
    1556:	fc 91       	ld	r31, X
    1558:	11 97       	sbiw	r26, 0x01	; 1
    155a:	21 e0       	ldi	r18, 0x01	; 1
    155c:	30 e0       	ldi	r19, 0x00	; 0
    155e:	a9 01       	movw	r20, r18
    1560:	12 96       	adiw	r26, 0x02	; 2
    1562:	0c 90       	ld	r0, X
    1564:	02 c0       	rjmp	.+4      	; 0x156a <DigitalPin_ClearValue+0x18>
    1566:	44 0f       	add	r20, r20
    1568:	55 1f       	adc	r21, r21
    156a:	0a 94       	dec	r0
    156c:	e2 f7       	brpl	.-8      	; 0x1566 <DigitalPin_ClearValue+0x14>
    156e:	46 83       	std	Z+6, r20	; 0x06
    1570:	08 95       	ret

00001572 <__vector_25>:


}

#if defined(USARTC0)
ISR(USARTC0_RXC_vect){
    1572:	1f 92       	push	r1
    1574:	0f 92       	push	r0
    1576:	0f b6       	in	r0, 0x3f	; 63
    1578:	0f 92       	push	r0
    157a:	11 24       	eor	r1, r1

}
    157c:	0f 90       	pop	r0
    157e:	0f be       	out	0x3f, r0	; 63
    1580:	0f 90       	pop	r0
    1582:	1f 90       	pop	r1
    1584:	18 95       	reti

00001586 <__vector_27>:

ISR(USARTC0_TXC_vect){
    1586:	1f 92       	push	r1
    1588:	0f 92       	push	r0
    158a:	0f b6       	in	r0, 0x3f	; 63
    158c:	0f 92       	push	r0
    158e:	11 24       	eor	r1, r1
	
}
    1590:	0f 90       	pop	r0
    1592:	0f be       	out	0x3f, r0	; 63
    1594:	0f 90       	pop	r0
    1596:	1f 90       	pop	r1
    1598:	18 95       	reti

0000159a <__vector_26>:

ISR(USARTC0_DRE_vect){
    159a:	1f 92       	push	r1
    159c:	0f 92       	push	r0
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	0f 92       	push	r0
    15a2:	11 24       	eor	r1, r1
	
}
    15a4:	0f 90       	pop	r0
    15a6:	0f be       	out	0x3f, r0	; 63
    15a8:	0f 90       	pop	r0
    15aa:	1f 90       	pop	r1
    15ac:	18 95       	reti

000015ae <__vector_28>:
#endif


#if defined(USARTC1)
ISR(USARTC1_RXC_vect){
    15ae:	1f 92       	push	r1
    15b0:	0f 92       	push	r0
    15b2:	0f b6       	in	r0, 0x3f	; 63
    15b4:	0f 92       	push	r0
    15b6:	11 24       	eor	r1, r1
	
}
    15b8:	0f 90       	pop	r0
    15ba:	0f be       	out	0x3f, r0	; 63
    15bc:	0f 90       	pop	r0
    15be:	1f 90       	pop	r1
    15c0:	18 95       	reti

000015c2 <__vector_30>:

ISR(USARTC1_TXC_vect){
    15c2:	1f 92       	push	r1
    15c4:	0f 92       	push	r0
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	0f 92       	push	r0
    15ca:	11 24       	eor	r1, r1
	
}
    15cc:	0f 90       	pop	r0
    15ce:	0f be       	out	0x3f, r0	; 63
    15d0:	0f 90       	pop	r0
    15d2:	1f 90       	pop	r1
    15d4:	18 95       	reti

000015d6 <__vector_29>:

ISR(USARTC1_DRE_vect){
    15d6:	1f 92       	push	r1
    15d8:	0f 92       	push	r0
    15da:	0f b6       	in	r0, 0x3f	; 63
    15dc:	0f 92       	push	r0
    15de:	11 24       	eor	r1, r1
	
}
    15e0:	0f 90       	pop	r0
    15e2:	0f be       	out	0x3f, r0	; 63
    15e4:	0f 90       	pop	r0
    15e6:	1f 90       	pop	r1
    15e8:	18 95       	reti

000015ea <__vector_88>:
#endif


#if defined(USARTD0)
ISR(USARTD0_RXC_vect){
    15ea:	1f 92       	push	r1
    15ec:	0f 92       	push	r0
    15ee:	0f b6       	in	r0, 0x3f	; 63
    15f0:	0f 92       	push	r0
    15f2:	11 24       	eor	r1, r1
	
}
    15f4:	0f 90       	pop	r0
    15f6:	0f be       	out	0x3f, r0	; 63
    15f8:	0f 90       	pop	r0
    15fa:	1f 90       	pop	r1
    15fc:	18 95       	reti

000015fe <__vector_90>:

ISR(USARTD0_TXC_vect){
    15fe:	1f 92       	push	r1
    1600:	0f 92       	push	r0
    1602:	0f b6       	in	r0, 0x3f	; 63
    1604:	0f 92       	push	r0
    1606:	11 24       	eor	r1, r1
	
}
    1608:	0f 90       	pop	r0
    160a:	0f be       	out	0x3f, r0	; 63
    160c:	0f 90       	pop	r0
    160e:	1f 90       	pop	r1
    1610:	18 95       	reti

00001612 <__vector_89>:

ISR(USARTD0_DRE_vect){
    1612:	1f 92       	push	r1
    1614:	0f 92       	push	r0
    1616:	0f b6       	in	r0, 0x3f	; 63
    1618:	0f 92       	push	r0
    161a:	11 24       	eor	r1, r1
	
}
    161c:	0f 90       	pop	r0
    161e:	0f be       	out	0x3f, r0	; 63
    1620:	0f 90       	pop	r0
    1622:	1f 90       	pop	r1
    1624:	18 95       	reti

00001626 <__vector_58>:
	
}
#endif

#if defined(USARTE0)
ISR(USARTE0_RXC_vect){
    1626:	1f 92       	push	r1
    1628:	0f 92       	push	r0
    162a:	0f b6       	in	r0, 0x3f	; 63
    162c:	0f 92       	push	r0
    162e:	11 24       	eor	r1, r1
	
}
    1630:	0f 90       	pop	r0
    1632:	0f be       	out	0x3f, r0	; 63
    1634:	0f 90       	pop	r0
    1636:	1f 90       	pop	r1
    1638:	18 95       	reti

0000163a <__vector_60>:

ISR(USARTE0_TXC_vect){
    163a:	1f 92       	push	r1
    163c:	0f 92       	push	r0
    163e:	0f b6       	in	r0, 0x3f	; 63
    1640:	0f 92       	push	r0
    1642:	11 24       	eor	r1, r1
	
}
    1644:	0f 90       	pop	r0
    1646:	0f be       	out	0x3f, r0	; 63
    1648:	0f 90       	pop	r0
    164a:	1f 90       	pop	r1
    164c:	18 95       	reti

0000164e <__vector_59>:

ISR(USARTE0_DRE_vect){
    164e:	1f 92       	push	r1
    1650:	0f 92       	push	r0
    1652:	0f b6       	in	r0, 0x3f	; 63
    1654:	0f 92       	push	r0
    1656:	11 24       	eor	r1, r1
	
}
    1658:	0f 90       	pop	r0
    165a:	0f be       	out	0x3f, r0	; 63
    165c:	0f 90       	pop	r0
    165e:	1f 90       	pop	r1
    1660:	18 95       	reti

00001662 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    1662:	0f 93       	push	r16
    1664:	cf 93       	push	r28
    1666:	df 93       	push	r29
    1668:	1f 92       	push	r1
    166a:	cd b7       	in	r28, 0x3d	; 61
    166c:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    166e:	2f b7       	in	r18, 0x3f	; 63
    1670:	29 83       	std	Y+1, r18	; 0x01
    1672:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    1674:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    1676:	fc 01       	movw	r30, r24
    1678:	08 ed       	ldi	r16, 0xD8	; 216
    167a:	04 bf       	out	0x34, r16	; 52
    167c:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    167e:	89 81       	ldd	r24, Y+1	; 0x01
    1680:	8f bf       	out	0x3f, r24	; 63
#endif
}
    1682:	0f 90       	pop	r0
    1684:	df 91       	pop	r29
    1686:	cf 91       	pop	r28
    1688:	0f 91       	pop	r16
    168a:	08 95       	ret

0000168c <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    168c:	e0 e5       	ldi	r30, 0x50	; 80
    168e:	f0 e0       	ldi	r31, 0x00	; 0
    1690:	90 81       	ld	r25, Z
    1692:	28 2f       	mov	r18, r24
    1694:	20 95       	com	r18
    1696:	92 23       	and	r25, r18
    1698:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    169a:	90 81       	ld	r25, Z
	return clkEnabled;
}
    169c:	89 23       	and	r24, r25
    169e:	08 95       	ret

000016a0 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    16a0:	0f 93       	push	r16
    16a2:	1f 93       	push	r17
    16a4:	cf 93       	push	r28
    16a6:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    16a8:	00 e4       	ldi	r16, 0x40	; 64
    16aa:	10 e0       	ldi	r17, 0x00	; 0
    16ac:	f8 01       	movw	r30, r16
    16ae:	60 81       	ld	r22, Z
    16b0:	68 7f       	andi	r22, 0xF8	; 248
    16b2:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    16b4:	80 e4       	ldi	r24, 0x40	; 64
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	0e 94 31 0b 	call	0x1662	; 0x1662 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    16bc:	f8 01       	movw	r30, r16
    16be:	80 81       	ld	r24, Z
	return clkCtrl;
}
    16c0:	8c 23       	and	r24, r28
    16c2:	cf 91       	pop	r28
    16c4:	1f 91       	pop	r17
    16c6:	0f 91       	pop	r16
    16c8:	08 95       	ret

000016ca <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    16ca:	08 95       	ret

000016cc <Endpoint_SelectEndpoint>:

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);

	USB_Endpoint_SelectedEndpoint = Address;
    16cc:	80 93 7f 28 	sts	0x287F, r24
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
}

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);
    16d0:	28 2f       	mov	r18, r24
    16d2:	2f 70       	andi	r18, 0x0F	; 15

	USB_Endpoint_SelectedEndpoint = Address;

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
    16d4:	30 e0       	ldi	r19, 0x00	; 0
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;
    16d6:	40 91 c6 04 	lds	r20, 0x04C6
    16da:	50 91 c7 04 	lds	r21, 0x04C7

	if (Address & ENDPOINT_DIR_IN)
    16de:	88 23       	and	r24, r24
    16e0:	e4 f4       	brge	.+56     	; 0x171a <Endpoint_SelectEndpoint+0x4e>
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
    16e2:	64 e8       	ldi	r22, 0x84	; 132
    16e4:	62 9f       	mul	r22, r18
    16e6:	c0 01       	movw	r24, r0
    16e8:	63 9f       	mul	r22, r19
    16ea:	90 0d       	add	r25, r0
    16ec:	11 24       	eor	r1, r1
    16ee:	8e 53       	subi	r24, 0x3E	; 62
    16f0:	97 4d       	sbci	r25, 0xD7	; 215
    16f2:	80 93 7b 28 	sts	0x287B, r24
    16f6:	90 93 7c 28 	sts	0x287C, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].IN;
    16fa:	c9 01       	movw	r24, r18
    16fc:	82 95       	swap	r24
    16fe:	92 95       	swap	r25
    1700:	90 7f       	andi	r25, 0xF0	; 240
    1702:	98 27       	eor	r25, r24
    1704:	80 7f       	andi	r24, 0xF0	; 240
    1706:	98 27       	eor	r25, r24
    1708:	08 96       	adiw	r24, 0x08	; 8
    170a:	9a 01       	movw	r18, r20
    170c:	28 0f       	add	r18, r24
    170e:	39 1f       	adc	r19, r25
    1710:	20 93 7d 28 	sts	0x287D, r18
    1714:	30 93 7e 28 	sts	0x287E, r19
    1718:	08 95       	ret
	}
	else
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->OUT;
    171a:	64 e8       	ldi	r22, 0x84	; 132
    171c:	62 9f       	mul	r22, r18
    171e:	c0 01       	movw	r24, r0
    1720:	63 9f       	mul	r22, r19
    1722:	90 0d       	add	r25, r0
    1724:	11 24       	eor	r1, r1
    1726:	80 58       	subi	r24, 0x80	; 128
    1728:	97 4d       	sbci	r25, 0xD7	; 215
    172a:	80 93 7b 28 	sts	0x287B, r24
    172e:	90 93 7c 28 	sts	0x287C, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].OUT;
    1732:	22 95       	swap	r18
    1734:	32 95       	swap	r19
    1736:	30 7f       	andi	r19, 0xF0	; 240
    1738:	32 27       	eor	r19, r18
    173a:	20 7f       	andi	r18, 0xF0	; 240
    173c:	32 27       	eor	r19, r18
    173e:	24 0f       	add	r18, r20
    1740:	35 1f       	adc	r19, r21
    1742:	20 93 7d 28 	sts	0x287D, r18
    1746:	30 93 7e 28 	sts	0x287E, r19
    174a:	08 95       	ret

0000174c <Endpoint_ConfigureEndpoint_PRV>:
}

bool Endpoint_ConfigureEndpoint_PRV(const uint8_t Address,
                                    const uint8_t Config,
                                    const uint8_t Size)
{
    174c:	1f 93       	push	r17
    174e:	cf 93       	push	r28
    1750:	df 93       	push	r29
    1752:	d8 2f       	mov	r29, r24
    1754:	16 2f       	mov	r17, r22
    1756:	c4 2f       	mov	r28, r20
	Endpoint_SelectEndpoint(Address);
    1758:	0e 94 66 0b 	call	0x16cc	; 0x16cc <Endpoint_SelectEndpoint>

	USB_Endpoint_SelectedHandle->CTRL    = 0;
    175c:	e0 91 7d 28 	lds	r30, 0x287D
    1760:	f0 91 7e 28 	lds	r31, 0x287E
    1764:	11 82       	std	Z+1, r1	; 0x01
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    1766:	e0 91 7d 28 	lds	r30, 0x287D
    176a:	f0 91 7e 28 	lds	r31, 0x287E
    176e:	dd 23       	and	r29, r29
    1770:	a4 f0       	brlt	.+40     	; 0x179a <Endpoint_ConfigureEndpoint_PRV+0x4e>
    1772:	10 82       	st	Z, r1
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    1774:	e0 91 7d 28 	lds	r30, 0x287D
    1778:	f0 91 7e 28 	lds	r31, 0x287E
    177c:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    177e:	e0 91 7d 28 	lds	r30, 0x287D
    1782:	f0 91 7e 28 	lds	r31, 0x287E
    1786:	12 82       	std	Z+2, r1	; 0x02
    1788:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    178a:	80 91 7b 28 	lds	r24, 0x287B
    178e:	90 91 7c 28 	lds	r25, 0x287C
    1792:	84 83       	std	Z+4, r24	; 0x04
    1794:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    1796:	40 e0       	ldi	r20, 0x00	; 0
    1798:	14 c0       	rjmp	.+40     	; 0x17c2 <Endpoint_ConfigureEndpoint_PRV+0x76>
                                    const uint8_t Size)
{
	Endpoint_SelectEndpoint(Address);

	USB_Endpoint_SelectedHandle->CTRL    = 0;
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    179a:	82 e0       	ldi	r24, 0x02	; 2
    179c:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    179e:	e0 91 7d 28 	lds	r30, 0x287D
    17a2:	f0 91 7e 28 	lds	r31, 0x287E
    17a6:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    17a8:	e0 91 7d 28 	lds	r30, 0x287D
    17ac:	f0 91 7e 28 	lds	r31, 0x287E
    17b0:	12 82       	std	Z+2, r1	; 0x02
    17b2:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    17b4:	80 91 7b 28 	lds	r24, 0x287B
    17b8:	90 91 7c 28 	lds	r25, 0x287C
    17bc:	84 83       	std	Z+4, r24	; 0x04
    17be:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    17c0:	4c 2f       	mov	r20, r28
    17c2:	fc 01       	movw	r30, r24
    17c4:	e0 5c       	subi	r30, 0xC0	; 192
    17c6:	ff 4f       	sbci	r31, 0xFF	; 255
    17c8:	40 83       	st	Z, r20
	USB_Endpoint_SelectedFIFO->Position  = 0;
    17ca:	31 96       	adiw	r30, 0x01	; 1
    17cc:	10 82       	st	Z, r1

	return true;
}
    17ce:	81 e0       	ldi	r24, 0x01	; 1
    17d0:	df 91       	pop	r29
    17d2:	cf 91       	pop	r28
    17d4:	1f 91       	pop	r17
    17d6:	08 95       	ret

000017d8 <Endpoint_ClearEndpoints>:

void Endpoint_ClearEndpoints(void)
{
    17d8:	20 e0       	ldi	r18, 0x00	; 0
    17da:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
    17dc:	a0 ec       	ldi	r26, 0xC0	; 192
    17de:	b4 e0       	ldi	r27, 0x04	; 4
    17e0:	16 96       	adiw	r26, 0x06	; 6
    17e2:	ed 91       	ld	r30, X+
    17e4:	fc 91       	ld	r31, X
    17e6:	17 97       	sbiw	r26, 0x07	; 7
    17e8:	c9 01       	movw	r24, r18
    17ea:	82 95       	swap	r24
    17ec:	92 95       	swap	r25
    17ee:	90 7f       	andi	r25, 0xF0	; 240
    17f0:	98 27       	eor	r25, r24
    17f2:	80 7f       	andi	r24, 0xF0	; 240
    17f4:	98 27       	eor	r25, r24
    17f6:	e8 0f       	add	r30, r24
    17f8:	f9 1f       	adc	r31, r25
    17fa:	11 86       	std	Z+9, r1	; 0x09
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
    17fc:	16 96       	adiw	r26, 0x06	; 6
    17fe:	4d 91       	ld	r20, X+
    1800:	5c 91       	ld	r21, X
    1802:	17 97       	sbiw	r26, 0x07	; 7
    1804:	fa 01       	movw	r30, r20
    1806:	e8 0f       	add	r30, r24
    1808:	f9 1f       	adc	r31, r25
    180a:	11 82       	std	Z+1, r1	; 0x01
    180c:	2f 5f       	subi	r18, 0xFF	; 255
    180e:	3f 4f       	sbci	r19, 0xFF	; 255
	return true;
}

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1810:	25 30       	cpi	r18, 0x05	; 5
    1812:	31 05       	cpc	r19, r1
    1814:	29 f7       	brne	.-54     	; 0x17e0 <Endpoint_ClearEndpoints+0x8>
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
	}
}
    1816:	08 95       	ret

00001818 <__vector_125>:
	USB.INTFLAGSACLR = 0xFF;
	USB.INTFLAGSBCLR = 0xFF;
}

ISR(USB_BUSEVENT_vect)
{
    1818:	1f 92       	push	r1
    181a:	0f 92       	push	r0
    181c:	0f b6       	in	r0, 0x3f	; 63
    181e:	0f 92       	push	r0
    1820:	11 24       	eor	r1, r1
    1822:	0b b6       	in	r0, 0x3b	; 59
    1824:	0f 92       	push	r0
    1826:	2f 93       	push	r18
    1828:	3f 93       	push	r19
    182a:	4f 93       	push	r20
    182c:	5f 93       	push	r21
    182e:	6f 93       	push	r22
    1830:	7f 93       	push	r23
    1832:	8f 93       	push	r24
    1834:	9f 93       	push	r25
    1836:	af 93       	push	r26
    1838:	bf 93       	push	r27
    183a:	ef 93       	push	r30
    183c:	ff 93       	push	r31
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTFLAGSACLR & USB_SOFIF_bm) ? true : false);
    183e:	80 91 ca 04 	lds	r24, 0x04CA
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1842:	88 23       	and	r24, r24
    1844:	4c f4       	brge	.+18     	; 0x1858 <__vector_125+0x40>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						return ((USB.INTCTRLA & USB_BUSEVIE_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTCTRLA & USB_SOFIE_bm) ? true : false);
    1846:	80 91 c8 04 	lds	r24, 0x04C8
    184a:	88 23       	and	r24, r24
    184c:	2c f4       	brge	.+10     	; 0x1858 <__vector_125+0x40>
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
						break;
					case USB_INT_SOFI:
						USB.INTFLAGSACLR = USB_SOFIF_bm;
    184e:	80 e8       	ldi	r24, 0x80	; 128
    1850:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1854:	0e 94 65 0b 	call	0x16ca	; 0x16ca <USB_Event_Stub>
			static inline bool USB_INT_HasOccurred(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
    1858:	80 91 ca 04 	lds	r24, 0x04CA
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Suspend))
    185c:	86 ff       	sbrs	r24, 6
    185e:	07 c0       	rjmp	.+14     	; 0x186e <__vector_125+0x56>
			static inline void USB_INT_Clear(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
    1860:	80 e4       	ldi	r24, 0x40	; 64
    1862:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Suspend);

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    1866:	10 92 72 28 	sts	0x2872, r1
		EVENT_USB_Device_Disconnect();
    186a:	0e 94 65 0b 	call	0x16ca	; 0x16ca <USB_Event_Stub>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
    186e:	80 91 ca 04 	lds	r24, 0x04CA
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Resume))
    1872:	85 ff       	sbrs	r24, 5
    1874:	16 c0       	rjmp	.+44     	; 0x18a2 <__vector_125+0x8a>
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
    1876:	80 e2       	ldi	r24, 0x20	; 32
    1878:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Resume);

		if (USB_Device_ConfigurationNumber)
    187c:	80 91 6e 28 	lds	r24, 0x286E
    1880:	88 23       	and	r24, r24
    1882:	21 f0       	breq	.+8      	; 0x188c <__vector_125+0x74>
		  USB_DeviceState = DEVICE_STATE_Configured;
    1884:	84 e0       	ldi	r24, 0x04	; 4
    1886:	80 93 72 28 	sts	0x2872, r24
    188a:	09 c0       	rjmp	.+18     	; 0x189e <__vector_125+0x86>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    188c:	80 91 c3 04 	lds	r24, 0x04C3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    1890:	81 11       	cpse	r24, r1
    1892:	02 c0       	rjmp	.+4      	; 0x1898 <__vector_125+0x80>
    1894:	81 e0       	ldi	r24, 0x01	; 1
    1896:	01 c0       	rjmp	.+2      	; 0x189a <__vector_125+0x82>
    1898:	83 e0       	ldi	r24, 0x03	; 3
    189a:	80 93 72 28 	sts	0x2872, r24

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
    189e:	0e 94 65 0b 	call	0x16ca	; 0x16ca <USB_Event_Stub>
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
    18a2:	80 91 ca 04 	lds	r24, 0x04CA
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Reset))
    18a6:	84 ff       	sbrs	r24, 4
    18a8:	18 c0       	rjmp	.+48     	; 0x18da <__vector_125+0xc2>
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
    18aa:	e0 ec       	ldi	r30, 0xC0	; 192
    18ac:	f4 e0       	ldi	r31, 0x04	; 4
    18ae:	80 e1       	ldi	r24, 0x10	; 16
    18b0:	82 87       	std	Z+10, r24	; 0x0a
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Reset);

		USB_DeviceState                = DEVICE_STATE_Default;
    18b2:	82 e0       	ldi	r24, 0x02	; 2
    18b4:	80 93 72 28 	sts	0x2872, r24
		USB_Device_ConfigurationNumber = 0;
    18b8:	10 92 6e 28 	sts	0x286E, r1
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    18bc:	13 82       	std	Z+3, r1	; 0x03

		USB_Device_EnableDeviceAddress(0);

		Endpoint_ClearEndpoints();
    18be:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <Endpoint_ClearEndpoints>
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    18c2:	48 e0       	ldi	r20, 0x08	; 8
    18c4:	68 e4       	ldi	r22, 0x48	; 72
    18c6:	80 e8       	ldi	r24, 0x80	; 128
    18c8:	0e 94 a6 0b 	call	0x174c	; 0x174c <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    18cc:	48 e0       	ldi	r20, 0x08	; 8
    18ce:	68 e4       	ldi	r22, 0x48	; 72
    18d0:	80 e0       	ldi	r24, 0x00	; 0
    18d2:	0e 94 a6 0b 	call	0x174c	; 0x174c <Endpoint_ConfigureEndpoint_PRV>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           USB_Device_ControlEndpointSize, 1);

		EVENT_USB_Device_Reset();
    18d6:	0e 94 65 0b 	call	0x16ca	; 0x16ca <USB_Event_Stub>
	}
}
    18da:	ff 91       	pop	r31
    18dc:	ef 91       	pop	r30
    18de:	bf 91       	pop	r27
    18e0:	af 91       	pop	r26
    18e2:	9f 91       	pop	r25
    18e4:	8f 91       	pop	r24
    18e6:	7f 91       	pop	r23
    18e8:	6f 91       	pop	r22
    18ea:	5f 91       	pop	r21
    18ec:	4f 91       	pop	r20
    18ee:	3f 91       	pop	r19
    18f0:	2f 91       	pop	r18
    18f2:	0f 90       	pop	r0
    18f4:	0b be       	out	0x3b, r0	; 59
    18f6:	0f 90       	pop	r0
    18f8:	0f be       	out	0x3f, r0	; 63
    18fa:	0f 90       	pop	r0
    18fc:	1f 90       	pop	r1
    18fe:	18 95       	reti

00001900 <TC0_ConfigClockSource>:
 *
 *  \param tc              Timer/Counter module instance.
 *  \param clockSelection  Timer/Counter clock source setting.
 */
void TC0_ConfigClockSource( volatile TC0_t * tc, TC_CLKSEL_t clockSelection )
{
    1900:	fc 01       	movw	r30, r24
	tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | clockSelection;
    1902:	90 81       	ld	r25, Z
    1904:	90 7f       	andi	r25, 0xF0	; 240
    1906:	69 2b       	or	r22, r25
    1908:	60 83       	st	Z, r22
    190a:	08 95       	ret

0000190c <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
    190c:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    190e:	96 81       	ldd	r25, Z+6	; 0x06
    1910:	9c 7f       	andi	r25, 0xFC	; 252
    1912:	69 2b       	or	r22, r25
    1914:	66 83       	std	Z+6, r22	; 0x06
    1916:	08 95       	ret

00001918 <rtc_initialize>:
/*
 *	initialize the rtc
 */
void rtc_initialize(){
	//enabling interrupt all three level, high, mid, and low
	OSC.RC32KCAL = 0x10;//smaller, the faster the clock
    1918:	80 e1       	ldi	r24, 0x10	; 16
    191a:	80 93 54 00 	sts	0x0054, r24
	PMIC_CTRL |= (7<<0);
    191e:	e2 ea       	ldi	r30, 0xA2	; 162
    1920:	f0 e0       	ldi	r31, 0x00	; 0
    1922:	80 81       	ld	r24, Z
    1924:	87 60       	ori	r24, 0x07	; 7
    1926:	80 83       	st	Z, r24
	//selecting clock source 32.768kHz from 32.768kHz crystal oscillator on TOSC, enabling RTC clock source
	CLK_RTCCTRL = (5<<1) | (1<<0);//crystal oscillator on TOSC| enabling clock
    1928:	8b e0       	ldi	r24, 0x0B	; 11
    192a:	80 93 43 00 	sts	0x0043, r24
	//enabling interrupts for overflow
	RTC_INTCTRL	|= (0b00000001);
    192e:	e2 e0       	ldi	r30, 0x02	; 2
    1930:	f4 e0       	ldi	r31, 0x04	; 4
    1932:	80 81       	ld	r24, Z
    1934:	81 60       	ori	r24, 0x01	; 1
    1936:	80 83       	st	Z, r24
	RTC_PER = RTC_PER_VAL; //period_val  = 2
    1938:	80 e8       	ldi	r24, 0x80	; 128
    193a:	90 e0       	ldi	r25, 0x00	; 0
    193c:	80 93 0a 04 	sts	0x040A, r24
    1940:	90 93 0b 04 	sts	0x040B, r25
	//selecting clock prescaling
	RTC_CTRL = (1<<0);//no prescaling
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	80 93 00 04 	sts	0x0400, r24
	sei();
    194a:	78 94       	sei
    194c:	08 95       	ret

0000194e <__vector_10>:

/*
 *	interrupt service routine for overflow interrupt event
 */
ISR(RTC_OVF_vect)
{
    194e:	1f 92       	push	r1
    1950:	0f 92       	push	r0
    1952:	0f b6       	in	r0, 0x3f	; 63
    1954:	0f 92       	push	r0
    1956:	11 24       	eor	r1, r1
    1958:	0b b6       	in	r0, 0x3b	; 59
    195a:	0f 92       	push	r0
    195c:	2f 93       	push	r18
    195e:	3f 93       	push	r19
    1960:	4f 93       	push	r20
    1962:	5f 93       	push	r21
    1964:	6f 93       	push	r22
    1966:	7f 93       	push	r23
    1968:	8f 93       	push	r24
    196a:	9f 93       	push	r25
    196c:	af 93       	push	r26
    196e:	bf 93       	push	r27
    1970:	ef 93       	push	r30
    1972:	ff 93       	push	r31
	#if (USE_RTC_TICK == 1)
	rtc_tick_global++;
    1974:	80 91 5f 28 	lds	r24, 0x285F
    1978:	90 91 60 28 	lds	r25, 0x2860
    197c:	01 96       	adiw	r24, 0x01	; 1
    197e:	80 93 5f 28 	sts	0x285F, r24
    1982:	90 93 60 28 	sts	0x2860, r25
	if(rtc_tick_global>=256){
    1986:	80 91 5f 28 	lds	r24, 0x285F
    198a:	90 91 60 28 	lds	r25, 0x2860
    198e:	8f 3f       	cpi	r24, 0xFF	; 255
    1990:	91 05       	cpc	r25, r1
    1992:	39 f0       	breq	.+14     	; 0x19a2 <__vector_10+0x54>
    1994:	34 f0       	brlt	.+12     	; 0x19a2 <__vector_10+0x54>
		rtc_tick_global = 0;
    1996:	10 92 5f 28 	sts	0x285F, r1
    199a:	10 92 60 28 	sts	0x2860, r1
		system_tick();
    199e:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <system_tick>
	#endif
	
	
	
	
}
    19a2:	ff 91       	pop	r31
    19a4:	ef 91       	pop	r30
    19a6:	bf 91       	pop	r27
    19a8:	af 91       	pop	r26
    19aa:	9f 91       	pop	r25
    19ac:	8f 91       	pop	r24
    19ae:	7f 91       	pop	r23
    19b0:	6f 91       	pop	r22
    19b2:	5f 91       	pop	r21
    19b4:	4f 91       	pop	r20
    19b6:	3f 91       	pop	r19
    19b8:	2f 91       	pop	r18
    19ba:	0f 90       	pop	r0
    19bc:	0b be       	out	0x3b, r0	; 59
    19be:	0f 90       	pop	r0
    19c0:	0f be       	out	0x3f, r0	; 63
    19c2:	0f 90       	pop	r0
    19c4:	1f 90       	pop	r1
    19c6:	18 95       	reti

000019c8 <__vector_11>:

/*
 *	interrupt service routine for compare interrupt event
 */
ISR(RTC_COMP_vect)
{
    19c8:	1f 92       	push	r1
    19ca:	0f 92       	push	r0
    19cc:	0f b6       	in	r0, 0x3f	; 63
    19ce:	0f 92       	push	r0
    19d0:	11 24       	eor	r1, r1


}
    19d2:	0f 90       	pop	r0
    19d4:	0f be       	out	0x3f, r0	; 63
    19d6:	0f 90       	pop	r0
    19d8:	1f 90       	pop	r1
    19da:	18 95       	reti

000019dc <system_tick>:
static char ascTimeBuffer[32];


void  system_tick(void){
	
	__system_time++;
    19dc:	80 91 6a 28 	lds	r24, 0x286A
    19e0:	90 91 6b 28 	lds	r25, 0x286B
    19e4:	a0 91 6c 28 	lds	r26, 0x286C
    19e8:	b0 91 6d 28 	lds	r27, 0x286D
    19ec:	01 96       	adiw	r24, 0x01	; 1
    19ee:	a1 1d       	adc	r26, r1
    19f0:	b1 1d       	adc	r27, r1
    19f2:	80 93 6a 28 	sts	0x286A, r24
    19f6:	90 93 6b 28 	sts	0x286B, r25
    19fa:	a0 93 6c 28 	sts	0x286C, r26
    19fe:	b0 93 6d 28 	sts	0x286D, r27
    1a02:	08 95       	ret

00001a04 <__udivmodsi4>:
    1a04:	a1 e2       	ldi	r26, 0x21	; 33
    1a06:	1a 2e       	mov	r1, r26
    1a08:	aa 1b       	sub	r26, r26
    1a0a:	bb 1b       	sub	r27, r27
    1a0c:	fd 01       	movw	r30, r26
    1a0e:	0d c0       	rjmp	.+26     	; 0x1a2a <__udivmodsi4_ep>

00001a10 <__udivmodsi4_loop>:
    1a10:	aa 1f       	adc	r26, r26
    1a12:	bb 1f       	adc	r27, r27
    1a14:	ee 1f       	adc	r30, r30
    1a16:	ff 1f       	adc	r31, r31
    1a18:	a2 17       	cp	r26, r18
    1a1a:	b3 07       	cpc	r27, r19
    1a1c:	e4 07       	cpc	r30, r20
    1a1e:	f5 07       	cpc	r31, r21
    1a20:	20 f0       	brcs	.+8      	; 0x1a2a <__udivmodsi4_ep>
    1a22:	a2 1b       	sub	r26, r18
    1a24:	b3 0b       	sbc	r27, r19
    1a26:	e4 0b       	sbc	r30, r20
    1a28:	f5 0b       	sbc	r31, r21

00001a2a <__udivmodsi4_ep>:
    1a2a:	66 1f       	adc	r22, r22
    1a2c:	77 1f       	adc	r23, r23
    1a2e:	88 1f       	adc	r24, r24
    1a30:	99 1f       	adc	r25, r25
    1a32:	1a 94       	dec	r1
    1a34:	69 f7       	brne	.-38     	; 0x1a10 <__udivmodsi4_loop>
    1a36:	60 95       	com	r22
    1a38:	70 95       	com	r23
    1a3a:	80 95       	com	r24
    1a3c:	90 95       	com	r25
    1a3e:	9b 01       	movw	r18, r22
    1a40:	ac 01       	movw	r20, r24
    1a42:	bd 01       	movw	r22, r26
    1a44:	cf 01       	movw	r24, r30
    1a46:	08 95       	ret

00001a48 <_exit>:
    1a48:	f8 94       	cli

00001a4a <__stop_program>:
    1a4a:	ff cf       	rjmp	.-2      	; 0x1a4a <__stop_program>
