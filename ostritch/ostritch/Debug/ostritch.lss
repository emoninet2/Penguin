
ostritch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002aa  00802000  00000f98  0000102c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000329  008022aa  008022aa  000012d6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000012d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001308  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b8  00000000  00000000  00001348  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009650  00000000  00000000  00001900  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001912  00000000  00000000  0000af50  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000251a  00000000  00000000  0000c862  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000011a0  00000000  00000000  0000ed7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003ef4  00000000  00000000  0000ff1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000048cd  00000000  00000000  00013e10  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005e8  00000000  00000000  000186dd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
   8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
   c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  10:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  14:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  18:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  1c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  20:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  24:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
  28:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  2c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
  30:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  34:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
  38:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	if (Endpoint_IsSETUPReceived())
  3c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  40:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
  44:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  48:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

		switch (USB_ControlRequest.bRequest)
  4c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  50:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  54:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  58:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  5c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  60:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  64:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
  68:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  6c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  70:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
  74:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
  78:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  7c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
  80:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
  84:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  88:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
  8c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  90:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  94:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  98:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

			CurrentStatus = Endpoint_IsStalled();

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
  9c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			break;
		default:
			return;
	}

	Endpoint_ClearSETUP();
  a4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
  a8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
				Endpoint_Write_8(Data >> 8);
  ac:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();
  b4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	Endpoint_ClearStatusStage();
  b8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
  bc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
  cc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
  d8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  dc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

				if (EndpointIndex == ENDPOINT_CONTROLEP)
  e0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
  e4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

				if (Endpoint_IsEnabled())
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
  ec:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
					{
						Endpoint_StallTransaction();
  f4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			 *  \ingroup Group_EndpointPacketManagement_XMEGA
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				USB_Endpoint_SelectedHandle->CTRL &= ~USB_EP_STALL_bm;
  f8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  fc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 100:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 104:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				if (Address & ENDPOINT_DIR_IN)
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].IN.Position  = 0;
				else
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].OUT.Position = 0;
 108:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 10c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 110:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				USB_Endpoint_SelectedHandle->STATUS &= ~USB_EP_TOGGLE_bm;
 114:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 118:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 11c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 120:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
		#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
 124:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	Endpoint_ClearSETUP();
 128:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	Endpoint_ClearStatusStage();
 12c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 130:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
 134:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
 138:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();
 13c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	Endpoint_ClearStatusStage();
 140:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	while (!(Endpoint_IsINReady()));
 144:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 148:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
 14c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
 150:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 154:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 158:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 15c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
 160:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 164:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
 168:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 16c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 170:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 174:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
 178:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
 17c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
 180:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
 184:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 188:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
 18c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte;

					NVM.CMD    = NVM_CMD_READ_CALIB_ROW_gc;
 190:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 194:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 198:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
					SerialByte = pgm_read_byte(SigReadAddress);
 19c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
					NVM.CMD    = 0;
 1a0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

					if (SerialCharNum & 0x01)
 1a8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
					{
						SerialByte >>= 4;
 1ac:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
						SigReadAddress++;
					}

					SerialByte &= 0x0F;
 1b0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
 1b4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1bc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
 1c8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1cc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();
 1d0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
 1d4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1dc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
	Endpoint_ClearOUT();
 1e0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
 1e8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1ec:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f4:	0c 94 34 07 	jmp	0xe68	; 0xe68 <__vector_125>
 1f8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

000001fc <__ctors_end>:
													 )) == NO_DESCRIPTOR)
	{
		return;
	}

	Endpoint_ClearSETUP();
 1fc:	11 24       	eor	r1, r1
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e9       	ldi	r29, 0x9F	; 159
 206:	de bf       	out	0x3e, r29	; 62
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_copy_data>:
 20c:	12 e2       	ldi	r17, 0x22	; 34
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
	EVENT_USB_Device_ConfigurationChanged();
}

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
 212:	e8 e9       	ldi	r30, 0x98	; 152
 214:	ff e0       	ldi	r31, 0x0F	; 15

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
 216:	00 e0       	ldi	r16, 0x00	; 0
 218:	0b bf       	out	0x3b, r16	; 59
 21a:	02 c0       	rjmp	.+4      	; 0x220 <__do_copy_data+0x14>
 21c:	07 90       	elpm	r0, Z+
	Endpoint_ClearIN();
 21e:	0d 92       	st	X+, r0
 220:	aa 3a       	cpi	r26, 0xAA	; 170

	Endpoint_ClearStatusStage();
 222:	b1 07       	cpc	r27, r17
 224:	d9 f7       	brne	.-10     	; 0x21c <__do_copy_data+0x10>

00000226 <__do_clear_bss>:
 226:	25 e2       	ldi	r18, 0x25	; 37
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
 228:	aa ea       	ldi	r26, 0xAA	; 170
 22a:	b2 e2       	ldi	r27, 0x22	; 34
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
 22c:	01 c0       	rjmp	.+2      	; 0x230 <.do_clear_bss_start>

0000022e <.do_clear_bss_loop>:
 22e:	1d 92       	st	X+, r1

00000230 <.do_clear_bss_start>:
 230:	a3 3d       	cpi	r26, 0xD3	; 211
 232:	b2 07       	cpc	r27, r18
	if ((uint8_t)USB_ControlRequest.wValue > DevDescriptorPtr->NumberOfConfigurations)
	  return;
	#endif
	#endif

	Endpoint_ClearSETUP();
 234:	e1 f7       	brne	.-8      	; 0x22e <.do_clear_bss_loop>
 236:	0e 94 65 05 	call	0xaca	; 0xaca <main>

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
 23a:	0c 94 ca 07 	jmp	0xf94	; 0xf94 <_exit>

0000023e <__bad_interrupt>:
 23e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000242 <arch_spi_master_transmit_byte_val>:
}


static uint8_t arch_spi_master_transmit_byte_val(uint8_t data)
{
	NRF24L01P_SPI.DATA = data;
 242:	80 93 c3 08 	sts	0x08C3, r24
	while(!(SPIC.STATUS &(1<<SPI_IF_bp)));
 246:	e0 ec       	ldi	r30, 0xC0	; 192
 248:	f8 e0       	ldi	r31, 0x08	; 8
 24a:	82 81       	ldd	r24, Z+2	; 0x02
 24c:	88 23       	and	r24, r24
 24e:	ec f7       	brge	.-6      	; 0x24a <arch_spi_master_transmit_byte_val+0x8>
	return SPIC.DATA;
 250:	80 91 c3 08 	lds	r24, 0x08C3
}
 254:	08 95       	ret

00000256 <arch_spi_master_transmit_byte_ref>:

static uint8_t arch_spi_master_transmit_byte_ref(uint8_t *data)
{
	NRF24L01P_SPI.DATA = *data;
 256:	fc 01       	movw	r30, r24
 258:	80 81       	ld	r24, Z
 25a:	80 93 c3 08 	sts	0x08C3, r24
	while(!(NRF24L01P_SPI.STATUS &(1<<SPI_IF_bp)));
 25e:	e0 ec       	ldi	r30, 0xC0	; 192
 260:	f8 e0       	ldi	r31, 0x08	; 8
 262:	82 81       	ldd	r24, Z+2	; 0x02
 264:	88 23       	and	r24, r24
 266:	ec f7       	brge	.-6      	; 0x262 <arch_spi_master_transmit_byte_ref+0xc>
	return NRF24L01P_SPI.DATA;
 268:	80 91 c3 08 	lds	r24, 0x08C3
}
 26c:	08 95       	ret

0000026e <_nrf24l01p_ce_pin>:
 */ 

#include "nrf24l01p.h"


void _nrf24l01p_ce_pin(bool state){
 26e:	cf 93       	push	r28
 270:	c8 2f       	mov	r28, r24

static void arch_nrf24l01p_ce_pin(bool state){
	//if(state) NRF24L01P_CE_PIN_PORT.OUTSET = (1<<NRF24L01P_CE_PIN_BIT) ;
	//else NRF24L01P_CE_PIN_PORT.OUTCLR = (1<<NRF24L01P_CE_PIN_BIT);
	
	if(state) DigitalPin_SetValue(&nrf24l01p_ce_pin) ;
 272:	88 23       	and	r24, r24
 274:	29 f0       	breq	.+10     	; 0x280 <_nrf24l01p_ce_pin+0x12>
 276:	80 e0       	ldi	r24, 0x00	; 0
 278:	90 e2       	ldi	r25, 0x20	; 32
 27a:	0e 94 46 06 	call	0xc8c	; 0xc8c <DigitalPin_SetValue>
 27e:	04 c0       	rjmp	.+8      	; 0x288 <_nrf24l01p_ce_pin+0x1a>
	else DigitalPin_ClearValue(&nrf24l01p_ce_pin);
 280:	80 e0       	ldi	r24, 0x00	; 0
 282:	90 e2       	ldi	r25, 0x20	; 32
 284:	0e 94 56 06 	call	0xcac	; 0xcac <DigitalPin_ClearValue>
	arch_nrf24l01p_ce_pin(state);
	ce_value = state;
 288:	c0 93 b5 24 	sts	0x24B5, r28
}
 28c:	cf 91       	pop	r28
 28e:	08 95       	ret

00000290 <_nrf24l01p_csn_pin>:
void _nrf24l01p_csn_pin(bool state){
 290:	cf 93       	push	r28
 292:	c8 2f       	mov	r28, r24

static void arch_nrf24l01p_csn_pin(bool state){
// 	if(state) NRF24L01P_CSN_PIN_PORT.OUTSET = (1<<NRF24L01P_CSN_PIN_BIT) ;
// 	else NRF24L01P_CSN_PIN_PORT.OUTCLR = (1<<NRF24L01P_CSN_PIN_BIT);

	if(state) DigitalPin_SetValue(&nrf24l01p_csn_pin) ;
 294:	88 23       	and	r24, r24
 296:	29 f0       	breq	.+10     	; 0x2a2 <_nrf24l01p_csn_pin+0x12>
 298:	83 e0       	ldi	r24, 0x03	; 3
 29a:	90 e2       	ldi	r25, 0x20	; 32
 29c:	0e 94 46 06 	call	0xc8c	; 0xc8c <DigitalPin_SetValue>
 2a0:	04 c0       	rjmp	.+8      	; 0x2aa <_nrf24l01p_csn_pin+0x1a>
	else DigitalPin_ClearValue(&nrf24l01p_csn_pin);
 2a2:	83 e0       	ldi	r24, 0x03	; 3
 2a4:	90 e2       	ldi	r25, 0x20	; 32
 2a6:	0e 94 56 06 	call	0xcac	; 0xcac <DigitalPin_ClearValue>

	arch_nrf24l01p_csn_pin(state);
	csn_value = state;
 2aa:	c0 93 b4 24 	sts	0x24B4, r28
}
 2ae:	cf 91       	pop	r28
 2b0:	08 95       	ret

000002b2 <_nrf24l01p_read_register>:
	_nrf24l01p_startup();
	
}


void _nrf24l01p_read_register(uint8_t address, uint8_t *dataout, int len){
 2b2:	ef 92       	push	r14
 2b4:	ff 92       	push	r15
 2b6:	0f 93       	push	r16
 2b8:	1f 93       	push	r17
 2ba:	cf 93       	push	r28
 2bc:	df 93       	push	r29
 2be:	c8 2f       	mov	r28, r24
 2c0:	7b 01       	movw	r14, r22
 2c2:	8a 01       	movw	r16, r20
	_nrf24l01p_csn_pin(0);
 2c4:	80 e0       	ldi	r24, 0x00	; 0
 2c6:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(address&(_NRF24L01P_REG_ADDRESS_MASK));
 2ca:	8c 2f       	mov	r24, r28
 2cc:	8f 71       	andi	r24, 0x1F	; 31
 2ce:	0e 94 21 01 	call	0x242	; 0x242 <arch_spi_master_transmit_byte_val>
	for(int i=0;i<len;i++){
 2d2:	10 16       	cp	r1, r16
 2d4:	11 06       	cpc	r1, r17
 2d6:	94 f4       	brge	.+36     	; 0x2fc <_nrf24l01p_read_register+0x4a>
 2d8:	e7 01       	movw	r28, r14
 2da:	0e 0d       	add	r16, r14
 2dc:	1f 1d       	adc	r17, r15
}

static void arch_spi_master_receive_byte_ref(uint8_t *data){
	//transmit dummy byte
	arch_spi_master_transmit_byte_val(0xFF);
	*data = NRF24L01P_SPI.DATA;
 2de:	0f 2e       	mov	r0, r31
 2e0:	f0 ec       	ldi	r31, 0xC0	; 192
 2e2:	ef 2e       	mov	r14, r31
 2e4:	f8 e0       	ldi	r31, 0x08	; 8
 2e6:	ff 2e       	mov	r15, r31
 2e8:	f0 2d       	mov	r31, r0
	return NRF24L01P_SPI.DATA;
}

static void arch_spi_master_receive_byte_ref(uint8_t *data){
	//transmit dummy byte
	arch_spi_master_transmit_byte_val(0xFF);
 2ea:	8f ef       	ldi	r24, 0xFF	; 255
 2ec:	0e 94 21 01 	call	0x242	; 0x242 <arch_spi_master_transmit_byte_val>
	*data = NRF24L01P_SPI.DATA;
 2f0:	f7 01       	movw	r30, r14
 2f2:	83 81       	ldd	r24, Z+3	; 0x03
 2f4:	89 93       	st	Y+, r24
 2f6:	c0 17       	cp	r28, r16
 2f8:	d1 07       	cpc	r29, r17
 2fa:	b9 f7       	brne	.-18     	; 0x2ea <_nrf24l01p_read_register+0x38>
		arch_spi_master_receive_byte_ref(dataout+ i);
	}
	_nrf24l01p_csn_pin(1);
 2fc:	81 e0       	ldi	r24, 0x01	; 1
 2fe:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
}
 302:	df 91       	pop	r29
 304:	cf 91       	pop	r28
 306:	1f 91       	pop	r17
 308:	0f 91       	pop	r16
 30a:	ff 90       	pop	r15
 30c:	ef 90       	pop	r14
 30e:	08 95       	ret

00000310 <_nrf24l01p_write_register>:
// 	uint8_t temp =  arch_spi_master_transmit_byte_val(0xff);
// 	_nrf24l01p_csn_pin(1);

// 	return temp;
// }
void _nrf24l01p_write_register(uint8_t address, uint8_t *datain, int len){
 310:	ef 92       	push	r14
 312:	ff 92       	push	r15
 314:	0f 93       	push	r16
 316:	1f 93       	push	r17
 318:	cf 93       	push	r28
 31a:	df 93       	push	r29
 31c:	c8 2f       	mov	r28, r24
 31e:	7b 01       	movw	r14, r22
 320:	8a 01       	movw	r16, r20
	_nrf24l01p_csn_pin(0);
 322:	80 e0       	ldi	r24, 0x00	; 0
 324:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(( _NRF24L01P_SPI_CMD_WR_REG | (address&(_NRF24L01P_REG_ADDRESS_MASK))));
 328:	8c 2f       	mov	r24, r28
 32a:	8f 71       	andi	r24, 0x1F	; 31
 32c:	80 62       	ori	r24, 0x20	; 32
 32e:	0e 94 21 01 	call	0x242	; 0x242 <arch_spi_master_transmit_byte_val>
	for(int i=0;i<len;i++){
 332:	10 16       	cp	r1, r16
 334:	11 06       	cpc	r1, r17
 336:	54 f4       	brge	.+20     	; 0x34c <_nrf24l01p_write_register+0x3c>
 338:	e7 01       	movw	r28, r14
 33a:	0e 0d       	add	r16, r14
 33c:	1f 1d       	adc	r17, r15
		arch_spi_master_transmit_byte_ref(datain+i);
 33e:	ce 01       	movw	r24, r28
 340:	0e 94 2b 01 	call	0x256	; 0x256 <arch_spi_master_transmit_byte_ref>
 344:	21 96       	adiw	r28, 0x01	; 1
// 	return temp;
// }
void _nrf24l01p_write_register(uint8_t address, uint8_t *datain, int len){
	_nrf24l01p_csn_pin(0);
	arch_spi_master_transmit_byte_val(( _NRF24L01P_SPI_CMD_WR_REG | (address&(_NRF24L01P_REG_ADDRESS_MASK))));
	for(int i=0;i<len;i++){
 346:	c0 17       	cp	r28, r16
 348:	d1 07       	cpc	r29, r17
 34a:	c9 f7       	brne	.-14     	; 0x33e <_nrf24l01p_write_register+0x2e>
		arch_spi_master_transmit_byte_ref(datain+i);
	}
	_nrf24l01p_csn_pin(1);
 34c:	81 e0       	ldi	r24, 0x01	; 1
 34e:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
}
 352:	df 91       	pop	r29
 354:	cf 91       	pop	r28
 356:	1f 91       	pop	r17
 358:	0f 91       	pop	r16
 35a:	ff 90       	pop	r15
 35c:	ef 90       	pop	r14
 35e:	08 95       	ret

00000360 <_nrf24l01p_write_tx_payload>:
	for(int i=0;i<pay_len;i++){
		arch_spi_master_receive_byte_ref(dataout+ i);
	}
	_nrf24l01p_csn_pin(1);
}
void _nrf24l01p_write_tx_payload(uint8_t *datain, int pay_len){
 360:	ef 92       	push	r14
 362:	ff 92       	push	r15
 364:	0f 93       	push	r16
 366:	1f 93       	push	r17
 368:	cf 93       	push	r28
 36a:	df 93       	push	r29
 36c:	7c 01       	movw	r14, r24
 36e:	8b 01       	movw	r16, r22
	_nrf24l01p_csn_pin(0);
 370:	80 e0       	ldi	r24, 0x00	; 0
 372:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_WR_TX_PAYLOAD);
 376:	80 ea       	ldi	r24, 0xA0	; 160
 378:	0e 94 21 01 	call	0x242	; 0x242 <arch_spi_master_transmit_byte_val>
	for(int i=0;i<pay_len;i++){
 37c:	10 16       	cp	r1, r16
 37e:	11 06       	cpc	r1, r17
 380:	54 f4       	brge	.+20     	; 0x396 <_nrf24l01p_write_tx_payload+0x36>
 382:	e7 01       	movw	r28, r14
 384:	0e 0d       	add	r16, r14
 386:	1f 1d       	adc	r17, r15
		arch_spi_master_transmit_byte_ref(datain+i);
 388:	ce 01       	movw	r24, r28
 38a:	0e 94 2b 01 	call	0x256	; 0x256 <arch_spi_master_transmit_byte_ref>
 38e:	21 96       	adiw	r28, 0x01	; 1
	_nrf24l01p_csn_pin(1);
}
void _nrf24l01p_write_tx_payload(uint8_t *datain, int pay_len){
	_nrf24l01p_csn_pin(0);
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_WR_TX_PAYLOAD);
	for(int i=0;i<pay_len;i++){
 390:	c0 17       	cp	r28, r16
 392:	d1 07       	cpc	r29, r17
 394:	c9 f7       	brne	.-14     	; 0x388 <_nrf24l01p_write_tx_payload+0x28>
		arch_spi_master_transmit_byte_ref(datain+i);
	}
	_nrf24l01p_csn_pin(1);
 396:	81 e0       	ldi	r24, 0x01	; 1
 398:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
}
 39c:	df 91       	pop	r29
 39e:	cf 91       	pop	r28
 3a0:	1f 91       	pop	r17
 3a2:	0f 91       	pop	r16
 3a4:	ff 90       	pop	r15
 3a6:	ef 90       	pop	r14
 3a8:	08 95       	ret

000003aa <_nrf24l01p_flush_rx>:
	_nrf24l01p_csn_pin(0);
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_FLUSH_TX);
	_nrf24l01p_csn_pin(1);
}
void _nrf24l01p_flush_rx(){
	_nrf24l01p_csn_pin(0);
 3aa:	80 e0       	ldi	r24, 0x00	; 0
 3ac:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_FLUSH_RX);
 3b0:	82 ee       	ldi	r24, 0xE2	; 226
 3b2:	0e 94 21 01 	call	0x242	; 0x242 <arch_spi_master_transmit_byte_val>
	_nrf24l01p_csn_pin(1);
 3b6:	81 e0       	ldi	r24, 0x01	; 1
 3b8:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
 3bc:	08 95       	ret

000003be <_nrf24l01p_get_status>:
		arch_spi_master_transmit_byte_ref(datain+i);
	}
	_nrf24l01p_csn_pin(1);
}

int _nrf24l01p_get_status(){
 3be:	cf 93       	push	r28
	_nrf24l01p_csn_pin(0);
 3c0:	80 e0       	ldi	r24, 0x00	; 0
 3c2:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
	int temp = arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_NOP);
 3c6:	8f ef       	ldi	r24, 0xFF	; 255
 3c8:	0e 94 21 01 	call	0x242	; 0x242 <arch_spi_master_transmit_byte_val>
 3cc:	c8 2f       	mov	r28, r24
	_nrf24l01p_csn_pin(1);
 3ce:	81 e0       	ldi	r24, 0x01	; 1
 3d0:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
	
	return temp;
}
 3d4:	8c 2f       	mov	r24, r28
 3d6:	90 e0       	ldi	r25, 0x00	; 0
 3d8:	cf 91       	pop	r28
 3da:	08 95       	ret

000003dc <_nrf24l01p_power_up>:

void _nrf24l01p_power_up(){
 3dc:	cf 93       	push	r28
 3de:	df 93       	push	r29
 3e0:	1f 92       	push	r1
 3e2:	cd b7       	in	r28, 0x3d	; 61
 3e4:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
 3e6:	41 e0       	ldi	r20, 0x01	; 1
 3e8:	50 e0       	ldi	r21, 0x00	; 0
 3ea:	be 01       	movw	r22, r28
 3ec:	6f 5f       	subi	r22, 0xFF	; 255
 3ee:	7f 4f       	sbci	r23, 0xFF	; 255
 3f0:	80 e0       	ldi	r24, 0x00	; 0
 3f2:	0e 94 59 01 	call	0x2b2	; 0x2b2 <_nrf24l01p_read_register>
	temp |= _NRF24L01P_CONFIG_PWR_UP;
 3f6:	89 81       	ldd	r24, Y+1	; 0x01
 3f8:	82 60       	ori	r24, 0x02	; 2
 3fa:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
 3fc:	41 e0       	ldi	r20, 0x01	; 1
 3fe:	50 e0       	ldi	r21, 0x00	; 0
 400:	be 01       	movw	r22, r28
 402:	6f 5f       	subi	r22, 0xFF	; 255
 404:	7f 4f       	sbci	r23, 0xFF	; 255
 406:	80 e0       	ldi	r24, 0x00	; 0
 408:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 40c:	8f e9       	ldi	r24, 0x9F	; 159
 40e:	9c e8       	ldi	r25, 0x8C	; 140
 410:	01 97       	sbiw	r24, 0x01	; 1
 412:	f1 f7       	brne	.-4      	; 0x410 <_nrf24l01p_power_up+0x34>
 414:	00 c0       	rjmp	.+0      	; 0x416 <_nrf24l01p_power_up+0x3a>
 416:	00 00       	nop
	_nrf24l01p_delay_us(_NRF24L01P_TIMING_Tpd2stby_us);
	mode = _NRF24L01P_MODE_STANDBY;
 418:	82 e0       	ldi	r24, 0x02	; 2
 41a:	80 93 b6 24 	sts	0x24B6, r24
}
 41e:	0f 90       	pop	r0
 420:	df 91       	pop	r29
 422:	cf 91       	pop	r28
 424:	08 95       	ret

00000426 <_nrf24l01p_power_down>:
void _nrf24l01p_power_down(){
 426:	cf 93       	push	r28
 428:	df 93       	push	r29
 42a:	1f 92       	push	r1
 42c:	cd b7       	in	r28, 0x3d	; 61
 42e:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
 430:	41 e0       	ldi	r20, 0x01	; 1
 432:	50 e0       	ldi	r21, 0x00	; 0
 434:	be 01       	movw	r22, r28
 436:	6f 5f       	subi	r22, 0xFF	; 255
 438:	7f 4f       	sbci	r23, 0xFF	; 255
 43a:	80 e0       	ldi	r24, 0x00	; 0
 43c:	0e 94 59 01 	call	0x2b2	; 0x2b2 <_nrf24l01p_read_register>
	temp &= ~_NRF24L01P_CONFIG_PWR_UP;
 440:	89 81       	ldd	r24, Y+1	; 0x01
 442:	8d 7f       	andi	r24, 0xFD	; 253
 444:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
 446:	41 e0       	ldi	r20, 0x01	; 1
 448:	50 e0       	ldi	r21, 0x00	; 0
 44a:	be 01       	movw	r22, r28
 44c:	6f 5f       	subi	r22, 0xFF	; 255
 44e:	7f 4f       	sbci	r23, 0xFF	; 255
 450:	80 e0       	ldi	r24, 0x00	; 0
 452:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	mode = _NRF24L01P_MODE_POWER_DOWN;
 456:	81 e0       	ldi	r24, 0x01	; 1
 458:	80 93 b6 24 	sts	0x24B6, r24
}
 45c:	0f 90       	pop	r0
 45e:	df 91       	pop	r29
 460:	cf 91       	pop	r28
 462:	08 95       	ret

00000464 <_nrf24l01p_rx_mode>:
void _nrf24l01p_rx_mode(){
 464:	cf 93       	push	r28
 466:	df 93       	push	r29
 468:	1f 92       	push	r1
 46a:	cd b7       	in	r28, 0x3d	; 61
 46c:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
 46e:	41 e0       	ldi	r20, 0x01	; 1
 470:	50 e0       	ldi	r21, 0x00	; 0
 472:	be 01       	movw	r22, r28
 474:	6f 5f       	subi	r22, 0xFF	; 255
 476:	7f 4f       	sbci	r23, 0xFF	; 255
 478:	80 e0       	ldi	r24, 0x00	; 0
 47a:	0e 94 59 01 	call	0x2b2	; 0x2b2 <_nrf24l01p_read_register>
	temp |= _NRF24L01P_CONFIG_PRIM_RX;
 47e:	89 81       	ldd	r24, Y+1	; 0x01
 480:	81 60       	ori	r24, 0x01	; 1
 482:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
 484:	41 e0       	ldi	r20, 0x01	; 1
 486:	50 e0       	ldi	r21, 0x00	; 0
 488:	be 01       	movw	r22, r28
 48a:	6f 5f       	subi	r22, 0xFF	; 255
 48c:	7f 4f       	sbci	r23, 0xFF	; 255
 48e:	80 e0       	ldi	r24, 0x00	; 0
 490:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	mode = _NRF24L01P_MODE_RX;
 494:	83 e0       	ldi	r24, 0x03	; 3
 496:	80 93 b6 24 	sts	0x24B6, r24
}
 49a:	0f 90       	pop	r0
 49c:	df 91       	pop	r29
 49e:	cf 91       	pop	r28
 4a0:	08 95       	ret

000004a2 <_nrf24l01p_tx_mode>:
void _nrf24l01p_tx_mode(){
 4a2:	cf 93       	push	r28
 4a4:	df 93       	push	r29
 4a6:	1f 92       	push	r1
 4a8:	cd b7       	in	r28, 0x3d	; 61
 4aa:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
 4ac:	41 e0       	ldi	r20, 0x01	; 1
 4ae:	50 e0       	ldi	r21, 0x00	; 0
 4b0:	be 01       	movw	r22, r28
 4b2:	6f 5f       	subi	r22, 0xFF	; 255
 4b4:	7f 4f       	sbci	r23, 0xFF	; 255
 4b6:	80 e0       	ldi	r24, 0x00	; 0
 4b8:	0e 94 59 01 	call	0x2b2	; 0x2b2 <_nrf24l01p_read_register>
	temp &= ~_NRF24L01P_CONFIG_PRIM_RX;
 4bc:	89 81       	ldd	r24, Y+1	; 0x01
 4be:	8e 7f       	andi	r24, 0xFE	; 254
 4c0:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
 4c2:	41 e0       	ldi	r20, 0x01	; 1
 4c4:	50 e0       	ldi	r21, 0x00	; 0
 4c6:	be 01       	movw	r22, r28
 4c8:	6f 5f       	subi	r22, 0xFF	; 255
 4ca:	7f 4f       	sbci	r23, 0xFF	; 255
 4cc:	80 e0       	ldi	r24, 0x00	; 0
 4ce:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	mode = _NRF24L01P_MODE_TX;
 4d2:	84 e0       	ldi	r24, 0x04	; 4
 4d4:	80 93 b6 24 	sts	0x24B6, r24
}
 4d8:	0f 90       	pop	r0
 4da:	df 91       	pop	r29
 4dc:	cf 91       	pop	r28
 4de:	08 95       	ret

000004e0 <_nrf24l01p_disable_auto_ack_all_pipes>:
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(temp));
	clr_bit(temp,pipe);
	_nrf24l01p_write_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(temp));
}
void _nrf24l01p_disable_auto_ack_all_pipes(){
 4e0:	cf 93       	push	r28
 4e2:	df 93       	push	r29
 4e4:	1f 92       	push	r1
 4e6:	cd b7       	in	r28, 0x3d	; 61
 4e8:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp = 0;
 4ea:	19 82       	std	Y+1, r1	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(temp));
 4ec:	41 e0       	ldi	r20, 0x01	; 1
 4ee:	50 e0       	ldi	r21, 0x00	; 0
 4f0:	be 01       	movw	r22, r28
 4f2:	6f 5f       	subi	r22, 0xFF	; 255
 4f4:	7f 4f       	sbci	r23, 0xFF	; 255
 4f6:	81 e0       	ldi	r24, 0x01	; 1
 4f8:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
}
 4fc:	0f 90       	pop	r0
 4fe:	df 91       	pop	r29
 500:	cf 91       	pop	r28
 502:	08 95       	ret

00000504 <_nrf24l01p_enable_rx_on_pipe>:

void _nrf24l01p_enable_rx_on_pipe(_nrf24l01p_pipe_t pipe){
 504:	1f 93       	push	r17
 506:	cf 93       	push	r28
 508:	df 93       	push	r29
 50a:	1f 92       	push	r1
 50c:	cd b7       	in	r28, 0x3d	; 61
 50e:	de b7       	in	r29, 0x3e	; 62
 510:	18 2f       	mov	r17, r24
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_EN_RXADDR,&temp,sizeof(temp));
 512:	41 e0       	ldi	r20, 0x01	; 1
 514:	50 e0       	ldi	r21, 0x00	; 0
 516:	be 01       	movw	r22, r28
 518:	6f 5f       	subi	r22, 0xFF	; 255
 51a:	7f 4f       	sbci	r23, 0xFF	; 255
 51c:	82 e0       	ldi	r24, 0x02	; 2
 51e:	0e 94 59 01 	call	0x2b2	; 0x2b2 <_nrf24l01p_read_register>
	set_bit(temp,pipe);
 522:	21 e0       	ldi	r18, 0x01	; 1
 524:	30 e0       	ldi	r19, 0x00	; 0
 526:	c9 01       	movw	r24, r18
 528:	02 c0       	rjmp	.+4      	; 0x52e <_nrf24l01p_enable_rx_on_pipe+0x2a>
 52a:	88 0f       	add	r24, r24
 52c:	99 1f       	adc	r25, r25
 52e:	1a 95       	dec	r17
 530:	e2 f7       	brpl	.-8      	; 0x52a <_nrf24l01p_enable_rx_on_pipe+0x26>
 532:	99 81       	ldd	r25, Y+1	; 0x01
 534:	89 2b       	or	r24, r25
 536:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_EN_RXADDR,&temp,sizeof(temp));
 538:	41 e0       	ldi	r20, 0x01	; 1
 53a:	50 e0       	ldi	r21, 0x00	; 0
 53c:	be 01       	movw	r22, r28
 53e:	6f 5f       	subi	r22, 0xFF	; 255
 540:	7f 4f       	sbci	r23, 0xFF	; 255
 542:	82 e0       	ldi	r24, 0x02	; 2
 544:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
}
 548:	0f 90       	pop	r0
 54a:	df 91       	pop	r29
 54c:	cf 91       	pop	r28
 54e:	1f 91       	pop	r17
 550:	08 95       	ret

00000552 <_nrf24l01p_get_data_sent_flag>:
}

bool _nrf24l01p_get_data_sent_flag(){
	bool flag;
	//(_nrf24l01p_get_status()&_NRF24L01P_STATUS_TX_DS)?flag = 1 : flag = 0;
	if(_nrf24l01p_get_status()&_NRF24L01P_STATUS_TX_DS) flag = 1;
 552:	0e 94 df 01 	call	0x3be	; 0x3be <_nrf24l01p_get_status>
 556:	96 95       	lsr	r25
 558:	87 95       	ror	r24
 55a:	92 95       	swap	r25
 55c:	82 95       	swap	r24
 55e:	8f 70       	andi	r24, 0x0F	; 15
 560:	89 27       	eor	r24, r25
 562:	9f 70       	andi	r25, 0x0F	; 15
 564:	89 27       	eor	r24, r25
	else flag  = 0;
	return flag;
}
 566:	81 70       	andi	r24, 0x01	; 1
 568:	08 95       	ret

0000056a <_nrf24l01p_clear_data_sent_flag>:

void _nrf24l01p_clear_data_sent_flag(){
 56a:	cf 93       	push	r28
 56c:	df 93       	push	r29
 56e:	1f 92       	push	r1
 570:	cd b7       	in	r28, 0x3d	; 61
 572:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp = _nrf24l01p_get_status();
 574:	0e 94 df 01 	call	0x3be	; 0x3be <_nrf24l01p_get_status>
	temp |= _NRF24L01P_STATUS_TX_DS;
 578:	80 62       	ori	r24, 0x20	; 32
 57a:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_STATUS,&temp,sizeof(temp));
 57c:	41 e0       	ldi	r20, 0x01	; 1
 57e:	50 e0       	ldi	r21, 0x00	; 0
 580:	be 01       	movw	r22, r28
 582:	6f 5f       	subi	r22, 0xFF	; 255
 584:	7f 4f       	sbci	r23, 0xFF	; 255
 586:	87 e0       	ldi	r24, 0x07	; 7
 588:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
}
 58c:	0f 90       	pop	r0
 58e:	df 91       	pop	r29
 590:	cf 91       	pop	r28
 592:	08 95       	ret

00000594 <_nrf24l01p_enable_dynamic_payload_pipe>:
	if(temp&_NRF24L01P_FIFO_STATUS_RX_REUSE) flag = 1 ;
	else flag = 0;
	return flag;
}

void _nrf24l01p_enable_dynamic_payload_pipe(_nrf24l01p_pipe_t pipe){
 594:	1f 93       	push	r17
 596:	cf 93       	push	r28
 598:	df 93       	push	r29
 59a:	1f 92       	push	r1
 59c:	cd b7       	in	r28, 0x3d	; 61
 59e:	de b7       	in	r29, 0x3e	; 62
 5a0:	18 2f       	mov	r17, r24
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));
 5a2:	41 e0       	ldi	r20, 0x01	; 1
 5a4:	50 e0       	ldi	r21, 0x00	; 0
 5a6:	be 01       	movw	r22, r28
 5a8:	6f 5f       	subi	r22, 0xFF	; 255
 5aa:	7f 4f       	sbci	r23, 0xFF	; 255
 5ac:	8c e1       	ldi	r24, 0x1C	; 28
 5ae:	0e 94 59 01 	call	0x2b2	; 0x2b2 <_nrf24l01p_read_register>
	temp |= (1<<pipe);
 5b2:	21 e0       	ldi	r18, 0x01	; 1
 5b4:	30 e0       	ldi	r19, 0x00	; 0
 5b6:	c9 01       	movw	r24, r18
 5b8:	02 c0       	rjmp	.+4      	; 0x5be <_nrf24l01p_enable_dynamic_payload_pipe+0x2a>
 5ba:	88 0f       	add	r24, r24
 5bc:	99 1f       	adc	r25, r25
 5be:	1a 95       	dec	r17
 5c0:	e2 f7       	brpl	.-8      	; 0x5ba <_nrf24l01p_enable_dynamic_payload_pipe+0x26>
 5c2:	99 81       	ldd	r25, Y+1	; 0x01
 5c4:	89 2b       	or	r24, r25
 5c6:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));
 5c8:	41 e0       	ldi	r20, 0x01	; 1
 5ca:	50 e0       	ldi	r21, 0x00	; 0
 5cc:	be 01       	movw	r22, r28
 5ce:	6f 5f       	subi	r22, 0xFF	; 255
 5d0:	7f 4f       	sbci	r23, 0xFF	; 255
 5d2:	8c e1       	ldi	r24, 0x1C	; 28
 5d4:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
}
 5d8:	0f 90       	pop	r0
 5da:	df 91       	pop	r29
 5dc:	cf 91       	pop	r28
 5de:	1f 91       	pop	r17
 5e0:	08 95       	ret

000005e2 <_nrf24l01p_disable_dynamic_payload_all_pipe>:
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));
	temp &= ~(1<<pipe);
	_nrf24l01p_write_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));
}
void _nrf24l01p_disable_dynamic_payload_all_pipe(){
 5e2:	cf 93       	push	r28
 5e4:	df 93       	push	r29
 5e6:	1f 92       	push	r1
 5e8:	cd b7       	in	r28, 0x3d	; 61
 5ea:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp = 0x00;
 5ec:	19 82       	std	Y+1, r1	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));
 5ee:	41 e0       	ldi	r20, 0x01	; 1
 5f0:	50 e0       	ldi	r21, 0x00	; 0
 5f2:	be 01       	movw	r22, r28
 5f4:	6f 5f       	subi	r22, 0xFF	; 255
 5f6:	7f 4f       	sbci	r23, 0xFF	; 255
 5f8:	8c e1       	ldi	r24, 0x1C	; 28
 5fa:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	
}
 5fe:	0f 90       	pop	r0
 600:	df 91       	pop	r29
 602:	cf 91       	pop	r28
 604:	08 95       	ret

00000606 <_nrf24l01p_enable_dynamic_payload>:
void _nrf24l01p_enable_dynamic_payload(){
 606:	cf 93       	push	r28
 608:	df 93       	push	r29
 60a:	1f 92       	push	r1
 60c:	cd b7       	in	r28, 0x3d	; 61
 60e:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_FEATURE,&temp,sizeof(temp));
 610:	41 e0       	ldi	r20, 0x01	; 1
 612:	50 e0       	ldi	r21, 0x00	; 0
 614:	be 01       	movw	r22, r28
 616:	6f 5f       	subi	r22, 0xFF	; 255
 618:	7f 4f       	sbci	r23, 0xFF	; 255
 61a:	8d e1       	ldi	r24, 0x1D	; 29
 61c:	0e 94 59 01 	call	0x2b2	; 0x2b2 <_nrf24l01p_read_register>
	temp |= _NRF24L01_FEATURE_EN_DPL;
 620:	89 81       	ldd	r24, Y+1	; 0x01
 622:	84 60       	ori	r24, 0x04	; 4
 624:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_FEATURE,&temp,sizeof(temp));
 626:	41 e0       	ldi	r20, 0x01	; 1
 628:	50 e0       	ldi	r21, 0x00	; 0
 62a:	be 01       	movw	r22, r28
 62c:	6f 5f       	subi	r22, 0xFF	; 255
 62e:	7f 4f       	sbci	r23, 0xFF	; 255
 630:	8d e1       	ldi	r24, 0x1D	; 29
 632:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
}
 636:	0f 90       	pop	r0
 638:	df 91       	pop	r29
 63a:	cf 91       	pop	r28
 63c:	08 95       	ret

0000063e <_nrf24l01p_startup>:
// 	printf("fifo status : %x\r\n",read_register(_NRF24L01P_REG_FIFO_STATUS));
}


//////////////////////////////////////////////////////////////////////////
void _nrf24l01p_startup(){
 63e:	cf 93       	push	r28
 640:	df 93       	push	r29
 642:	1f 92       	push	r1
 644:	cd b7       	in	r28, 0x3d	; 61
 646:	de b7       	in	r29, 0x3e	; 62
	#define TRANSFER_SIZE 1
	//nrf24l01p_write_rf_setup(0b00000111);
	uint8_t temp = 0b00000111;
 648:	87 e0       	ldi	r24, 0x07	; 7
 64a:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_RF_SETUP,&temp, sizeof(temp));
 64c:	41 e0       	ldi	r20, 0x01	; 1
 64e:	50 e0       	ldi	r21, 0x00	; 0
 650:	be 01       	movw	r22, r28
 652:	6f 5f       	subi	r22, 0xFF	; 255
 654:	7f 4f       	sbci	r23, 0xFF	; 255
 656:	86 e0       	ldi	r24, 0x06	; 6
 658:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	//
	// 	nrf24l01p_write_en_aa(0);
	temp = 0;
 65c:	19 82       	std	Y+1, r1	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(uint8_t));
 65e:	41 e0       	ldi	r20, 0x01	; 1
 660:	50 e0       	ldi	r21, 0x00	; 0
 662:	be 01       	movw	r22, r28
 664:	6f 5f       	subi	r22, 0xFF	; 255
 666:	7f 4f       	sbci	r23, 0xFF	; 255
 668:	81 e0       	ldi	r24, 0x01	; 1
 66a:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	//
	// 	nrf24l01p_write_rx_pw(0, TRANSFER_SIZE);
	temp = TRANSFER_SIZE;
 66e:	81 e0       	ldi	r24, 0x01	; 1
 670:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_RF_SETUP,&temp, sizeof(temp));
 672:	41 e0       	ldi	r20, 0x01	; 1
 674:	50 e0       	ldi	r21, 0x00	; 0
 676:	be 01       	movw	r22, r28
 678:	6f 5f       	subi	r22, 0xFF	; 255
 67a:	7f 4f       	sbci	r23, 0xFF	; 255
 67c:	86 e0       	ldi	r24, 0x06	; 6
 67e:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	_nrf24l01p_power_up();
 682:	0e 94 ee 01 	call	0x3dc	; 0x3dc <_nrf24l01p_power_up>
 686:	8f e9       	ldi	r24, 0x9F	; 159
 688:	9c e8       	ldi	r25, 0x8C	; 140
 68a:	01 97       	sbiw	r24, 0x01	; 1
 68c:	f1 f7       	brne	.-4      	; 0x68a <_nrf24l01p_startup+0x4c>
 68e:	00 c0       	rjmp	.+0      	; 0x690 <_nrf24l01p_startup+0x52>
 690:	00 00       	nop
	_nrf24l01p_delay_us(_NRF24L01P_TIMING_Tpd2stby_us);
	//
	_nrf24l01p_rx_mode();
 692:	0e 94 32 02 	call	0x464	; 0x464 <_nrf24l01p_rx_mode>
	_nrf24l01p_ce_pin(1);
 696:	81 e0       	ldi	r24, 0x01	; 1
 698:	0e 94 37 01 	call	0x26e	; 0x26e <_nrf24l01p_ce_pin>

}
 69c:	0f 90       	pop	r0
 69e:	df 91       	pop	r29
 6a0:	cf 91       	pop	r28
 6a2:	08 95       	ret

000006a4 <_nrf24l01p_init>:

	arch_nrf24l01p_csn_pin(state);
	csn_value = state;
}

void _nrf24l01p_init(){
 6a4:	cf 93       	push	r28
 6a6:	df 93       	push	r29
 6a8:	1f 92       	push	r1
 6aa:	1f 92       	push	r1
 6ac:	cd b7       	in	r28, 0x3d	; 61
 6ae:	de b7       	in	r29, 0x3e	; 62
	if(state) DigitalPin_SetValue(&nrf24l01p_csn_pin) ;
	else DigitalPin_ClearValue(&nrf24l01p_csn_pin);
}

static void arch_nrf24l01p_initialize(){
	NRF24L01P_SPI_PORT.DIRSET = (1<<5) | (1<<4) | (1<<7);
 6b0:	e0 e4       	ldi	r30, 0x40	; 64
 6b2:	f6 e0       	ldi	r31, 0x06	; 6
 6b4:	80 eb       	ldi	r24, 0xB0	; 176
 6b6:	81 83       	std	Z+1, r24	; 0x01
	NRF24L01P_SPI.CTRL = (1<<SPI_ENABLE_bp) | (1<<SPI_MASTER_bp);
 6b8:	80 e5       	ldi	r24, 0x50	; 80
 6ba:	80 93 c0 08 	sts	0x08C0, r24
	NRF24L01P_CSN_PIN_PORT.DIRSET = (1<<NRF24L01P_CSN_PIN_BIT);
 6be:	80 e1       	ldi	r24, 0x10	; 16
 6c0:	81 83       	std	Z+1, r24	; 0x01
	NRF24L01P_CE_PIN_PORT.DIRSET = (1<<NRF24L01P_CE_PIN_BIT);
 6c2:	82 e0       	ldi	r24, 0x02	; 2
 6c4:	81 83       	std	Z+1, r24	; 0x01
	arch_nrf24l01p_initialize();
	
	_nrf24l01p_ce_pin(0);
 6c6:	80 e0       	ldi	r24, 0x00	; 0
 6c8:	0e 94 37 01 	call	0x26e	; 0x26e <_nrf24l01p_ce_pin>
	_nrf24l01p_csn_pin(1);
 6cc:	81 e0       	ldi	r24, 0x01	; 1
 6ce:	0e 94 48 01 	call	0x290	; 0x290 <_nrf24l01p_csn_pin>
	
	
	_nrf24l01p_flush_rx();
 6d2:	0e 94 d5 01 	call	0x3aa	; 0x3aa <_nrf24l01p_flush_rx>
	_nrf24l01p_power_down();
 6d6:	0e 94 13 02 	call	0x426	; 0x426 <_nrf24l01p_power_down>
	uint8_t status_rst_val = 0x0e;//reset status
 6da:	8e e0       	ldi	r24, 0x0E	; 14
 6dc:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_STATUS, &status_rst_val,1);
 6de:	41 e0       	ldi	r20, 0x01	; 1
 6e0:	50 e0       	ldi	r21, 0x00	; 0
 6e2:	be 01       	movw	r22, r28
 6e4:	6f 5f       	subi	r22, 0xFF	; 255
 6e6:	7f 4f       	sbci	r23, 0xFF	; 255
 6e8:	87 e0       	ldi	r24, 0x07	; 7
 6ea:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	uint8_t config_rst_val = 0x0b;//reset config
 6ee:	8b e0       	ldi	r24, 0x0B	; 11
 6f0:	8a 83       	std	Y+2, r24	; 0x02
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG, &config_rst_val,1);
 6f2:	41 e0       	ldi	r20, 0x01	; 1
 6f4:	50 e0       	ldi	r21, 0x00	; 0
 6f6:	be 01       	movw	r22, r28
 6f8:	6e 5f       	subi	r22, 0xFE	; 254
 6fa:	7f 4f       	sbci	r23, 0xFF	; 255
 6fc:	80 e0       	ldi	r24, 0x00	; 0
 6fe:	0e 94 88 01 	call	0x310	; 0x310 <_nrf24l01p_write_register>
	_nrf24l01p_disable_auto_ack_all_pipes();
 702:	0e 94 70 02 	call	0x4e0	; 0x4e0 <_nrf24l01p_disable_auto_ack_all_pipes>
	_nrf24l01p_disable_dynamic_payload_all_pipe();/////////ALSO CREEATE FOR DISABLE AUTO ACK FOR ALL PIPE
 706:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <_nrf24l01p_disable_dynamic_payload_all_pipe>
	_nrf24l01p_startup();
 70a:	0e 94 1f 03 	call	0x63e	; 0x63e <_nrf24l01p_startup>
	
}
 70e:	0f 90       	pop	r0
 710:	0f 90       	pop	r0
 712:	df 91       	pop	r29
 714:	cf 91       	pop	r28
 716:	08 95       	ret

00000718 <_nrf24l01p_write>:
	return flag;
}

volatile int mystat;

int _nrf24l01p_write(uint8_t *data, int datalen){
 718:	ef 92       	push	r14
 71a:	ff 92       	push	r15
 71c:	1f 93       	push	r17
 71e:	cf 93       	push	r28
 720:	df 93       	push	r29
 722:	7c 01       	movw	r14, r24
 724:	eb 01       	movw	r28, r22
	int originalCe = ce_value;//backup original ce_value
 726:	10 91 b5 24 	lds	r17, 0x24B5
	_nrf24l01p_ce_pin(0);//disable();
 72a:	80 e0       	ldi	r24, 0x00	; 0
 72c:	0e 94 37 01 	call	0x26e	; 0x26e <_nrf24l01p_ce_pin>
	if ( datalen <= 0 ) return 0;
 730:	1c 16       	cp	r1, r28
 732:	1d 06       	cpc	r1, r29
 734:	94 f5       	brge	.+100    	; 0x79a <_nrf24l01p_write+0x82>
	if ( datalen > _NRF24L01P_TX_FIFO_SIZE ) datalen = _NRF24L01P_TX_FIFO_SIZE;
	
	_nrf24l01p_clear_data_sent_flag();
 736:	0e 94 b5 02 	call	0x56a	; 0x56a <_nrf24l01p_clear_data_sent_flag>
 73a:	be 01       	movw	r22, r28
 73c:	a1 97       	sbiw	r28, 0x21	; 33
 73e:	14 f0       	brlt	.+4      	; 0x744 <_nrf24l01p_write+0x2c>
 740:	60 e2       	ldi	r22, 0x20	; 32
 742:	70 e0       	ldi	r23, 0x00	; 0
	_nrf24l01p_write_tx_payload(data,datalen);
 744:	c7 01       	movw	r24, r14
 746:	0e 94 b0 01 	call	0x360	; 0x360 <_nrf24l01p_write_tx_payload>
	
	int originalMode = mode; //backup mode
 74a:	c0 91 b6 24 	lds	r28, 0x24B6
	_nrf24l01p_tx_mode();
 74e:	0e 94 51 02 	call	0x4a2	; 0x4a2 <_nrf24l01p_tx_mode>
	
	_nrf24l01p_ce_pin(1);//enable();
 752:	81 e0       	ldi	r24, 0x01	; 1
 754:	0e 94 37 01 	call	0x26e	; 0x26e <_nrf24l01p_ce_pin>
 758:	8a e6       	ldi	r24, 0x6A	; 106
 75a:	8a 95       	dec	r24
 75c:	f1 f7       	brne	.-4      	; 0x75a <_nrf24l01p_write+0x42>
 75e:	00 c0       	rjmp	.+0      	; 0x760 <_nrf24l01p_write+0x48>
	_nrf24l01p_delay_us(_NRF24L01P_TIMING_Thce_us);
	_nrf24l01p_ce_pin(0);
 760:	80 e0       	ldi	r24, 0x00	; 0
 762:	0e 94 37 01 	call	0x26e	; 0x26e <_nrf24l01p_ce_pin>
	
	while ( !(_nrf24l01p_get_data_sent_flag()) ){
 766:	07 c0       	rjmp	.+14     	; 0x776 <_nrf24l01p_write+0x5e>
		mystat = _nrf24l01p_get_status();
 768:	0e 94 df 01 	call	0x3be	; 0x3be <_nrf24l01p_get_status>
 76c:	80 93 b7 24 	sts	0x24B7, r24
 770:	90 93 b8 24 	sts	0x24B8, r25
		asm("nop");
 774:	00 00       	nop
	
	_nrf24l01p_ce_pin(1);//enable();
	_nrf24l01p_delay_us(_NRF24L01P_TIMING_Thce_us);
	_nrf24l01p_ce_pin(0);
	
	while ( !(_nrf24l01p_get_data_sent_flag()) ){
 776:	0e 94 a9 02 	call	0x552	; 0x552 <_nrf24l01p_get_data_sent_flag>
 77a:	88 23       	and	r24, r24
 77c:	a9 f3       	breq	.-22     	; 0x768 <_nrf24l01p_write+0x50>
		mystat = _nrf24l01p_get_status();
		asm("nop");
	}
	asm("nop");//UFFFFFFFFFF
 77e:	00 00       	nop
	_nrf24l01p_clear_data_sent_flag();
 780:	0e 94 b5 02 	call	0x56a	; 0x56a <_nrf24l01p_clear_data_sent_flag>
	if ( originalMode == _NRF24L01P_MODE_RX ) _nrf24l01p_rx_mode();//restore original mode
 784:	c3 30       	cpi	r28, 0x03	; 3
 786:	11 f4       	brne	.+4      	; 0x78c <_nrf24l01p_write+0x74>
 788:	0e 94 32 02 	call	0x464	; 0x464 <_nrf24l01p_rx_mode>
	_nrf24l01p_ce_pin(originalCe);//restore original CE pin status
 78c:	81 2f       	mov	r24, r17
 78e:	0e 94 37 01 	call	0x26e	; 0x26e <_nrf24l01p_ce_pin>
 792:	8a e2       	ldi	r24, 0x2A	; 42
 794:	8a 95       	dec	r24
 796:	f1 f7       	brne	.-4      	; 0x794 <_nrf24l01p_write+0x7c>
 798:	00 c0       	rjmp	.+0      	; 0x79a <_nrf24l01p_write+0x82>
	_nrf24l01p_delay_us( _NRF24L01P_TIMING_Tpece2csn_us );
	
	return 0;
}
 79a:	80 e0       	ldi	r24, 0x00	; 0
 79c:	90 e0       	ldi	r25, 0x00	; 0
 79e:	df 91       	pop	r29
 7a0:	cf 91       	pop	r28
 7a2:	1f 91       	pop	r17
 7a4:	ff 90       	pop	r15
 7a6:	ef 90       	pop	r14
 7a8:	08 95       	ret

000007aa <usart_spi_transmit_receive>:
 *
 * @param usart
 * @param txdata
 * @return data received from slave
 */
uint8_t usart_spi_transmit_receive(USART_t * usart,uint8_t txdata){
 7aa:	fc 01       	movw	r30, r24
	
	while ((usart->STATUS & USART_DREIF_bm) == 0);
 7ac:	81 81       	ldd	r24, Z+1	; 0x01
 7ae:	85 ff       	sbrs	r24, 5
 7b0:	fd cf       	rjmp	.-6      	; 0x7ac <usart_spi_transmit_receive+0x2>
	usart->DATA = txdata;
 7b2:	60 83       	st	Z, r22
	while((usart->STATUS & USART_TXCIF_bm) == 0);
 7b4:	81 81       	ldd	r24, Z+1	; 0x01
 7b6:	86 ff       	sbrs	r24, 6
 7b8:	fd cf       	rjmp	.-6      	; 0x7b4 <usart_spi_transmit_receive+0xa>
	(usart)->STATUS = USART_TXCIF_bm;
 7ba:	80 e4       	ldi	r24, 0x40	; 64
 7bc:	81 83       	std	Z+1, r24	; 0x01
	return (usart)->DATA;
 7be:	80 81       	ld	r24, Z
}
 7c0:	08 95       	ret

000007c2 <ssd1306_write_command>:
 * data write function is called based on the selected interface.
 *
 * \param command the command to write
 */
static void ssd1306_write_command(uint8_t command)
{
 7c2:	1f 93       	push	r17
 7c4:	cf 93       	push	r28
 7c6:	df 93       	push	r29
	port_out_value_clear_mask(&PORTF,(1<<3));//select device
 7c8:	c0 ea       	ldi	r28, 0xA0	; 160
 7ca:	d6 e0       	ldi	r29, 0x06	; 6
 7cc:	18 e0       	ldi	r17, 0x08	; 8
 7ce:	1e 83       	std	Y+6, r17	; 0x06
	port_out_value_clear_mask(&PORTD,(1<<0));//select command
 7d0:	e0 e6       	ldi	r30, 0x60	; 96
 7d2:	f6 e0       	ldi	r31, 0x06	; 6
 7d4:	91 e0       	ldi	r25, 0x01	; 1
 7d6:	96 83       	std	Z+6, r25	; 0x06
	ssd1306_sel_cmd() ;
 7d8:	96 83       	std	Z+6, r25	; 0x06
	usart_spi_transmit_receive(&USARTD0, command);//transmit
 7da:	68 2f       	mov	r22, r24
 7dc:	80 ea       	ldi	r24, 0xA0	; 160
 7de:	99 e0       	ldi	r25, 0x09	; 9
 7e0:	0e 94 d5 03 	call	0x7aa	; 0x7aa <usart_spi_transmit_receive>
	port_out_value_set_mask(&PORTF,(1<<3));//deselect device
 7e4:	1d 83       	std	Y+5, r17	; 0x05
	
}
 7e6:	df 91       	pop	r29
 7e8:	cf 91       	pop	r28
 7ea:	1f 91       	pop	r17
 7ec:	08 95       	ret

000007ee <ssd1306_write_data>:
 * data write function is called based on the selected interface.
 *
 * \param data the data to write
 */
void ssd1306_write_data(uint8_t data)
{
 7ee:	ef 92       	push	r14
 7f0:	ff 92       	push	r15
 7f2:	0f 93       	push	r16
 7f4:	1f 93       	push	r17
 7f6:	cf 93       	push	r28
 7f8:	df 93       	push	r29
	
	port_out_value_clear_mask(&PORTF,(1<<3));//select device
 7fa:	c0 ea       	ldi	r28, 0xA0	; 160
 7fc:	d6 e0       	ldi	r29, 0x06	; 6
 7fe:	18 e0       	ldi	r17, 0x08	; 8
 800:	1e 83       	std	Y+6, r17	; 0x06
	ssd1306_sel_data() ;
 802:	0f 2e       	mov	r0, r31
 804:	f0 e6       	ldi	r31, 0x60	; 96
 806:	ef 2e       	mov	r14, r31
 808:	f6 e0       	ldi	r31, 0x06	; 6
 80a:	ff 2e       	mov	r15, r31
 80c:	f0 2d       	mov	r31, r0
 80e:	01 e0       	ldi	r16, 0x01	; 1
 810:	f7 01       	movw	r30, r14
 812:	05 83       	std	Z+5, r16	; 0x05
	usart_spi_transmit_receive(&USARTD0, data);//transmit
 814:	68 2f       	mov	r22, r24
 816:	80 ea       	ldi	r24, 0xA0	; 160
 818:	99 e0       	ldi	r25, 0x09	; 9
 81a:	0e 94 d5 03 	call	0x7aa	; 0x7aa <usart_spi_transmit_receive>
	ssd1306_sel_cmd();
 81e:	f7 01       	movw	r30, r14
 820:	06 83       	std	Z+6, r16	; 0x06
	port_out_value_set_mask(&PORTF,(1<<3));//deselect device
 822:	1d 83       	std	Y+5, r17	; 0x05

}
 824:	df 91       	pop	r29
 826:	cf 91       	pop	r28
 828:	1f 91       	pop	r17
 82a:	0f 91       	pop	r16
 82c:	ff 90       	pop	r15
 82e:	ef 90       	pop	r14
 830:	08 95       	ret

00000832 <ssd1306_set_page_address>:
 */
void ssd1306_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
 832:	87 70       	andi	r24, 0x07	; 7
 834:	80 6b       	ori	r24, 0xB0	; 176
 836:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
 83a:	08 95       	ret

0000083c <ssd1306_set_column_address>:
 * \brief Set current column in display RAM
 *
 * \param address the column address
 */
void ssd1306_set_column_address(uint8_t address)
{
 83c:	cf 93       	push	r28
 83e:	c8 2f       	mov	r28, r24
	// Make sure the address is 7 bits
	address &= 0x7F;
 840:	98 2f       	mov	r25, r24
 842:	9f 77       	andi	r25, 0x7F	; 127
	ssd1306_write_command(SSD1306_CMD_SET_HIGH_COL(address >> 4));
 844:	89 2f       	mov	r24, r25
 846:	82 95       	swap	r24
 848:	8f 70       	andi	r24, 0x0F	; 15
 84a:	80 61       	ori	r24, 0x10	; 16
 84c:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_write_command(SSD1306_CMD_SET_LOW_COL(address & 0x0F));
 850:	8c 2f       	mov	r24, r28
 852:	8f 70       	andi	r24, 0x0F	; 15
 854:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
}
 858:	cf 91       	pop	r28
 85a:	08 95       	ret

0000085c <usart_init_spi>:
	}
}


void usart_init_spi(USART_t *usart, const usart_spi_options_emon_t *opt)
{
 85c:	cf 93       	push	r28
 85e:	df 93       	push	r29
 860:	ec 01       	movw	r28, r24
 862:	fb 01       	movw	r30, r22
	//ioport_pin_t sck_pin;
	//uint8_t invert_sck;

	(usart)->CTRLB &= ~USART_RXEN_bm;
 864:	8c 81       	ldd	r24, Y+4	; 0x04
 866:	8f 7e       	andi	r24, 0xEF	; 239
 868:	8c 83       	std	Y+4, r24	; 0x04

	//invert_sck = (opt->spimode == 2) || (opt->spimode == 3);

	PORTD.DIRSET = (1<<1);//sck pin output
 86a:	a0 e6       	ldi	r26, 0x60	; 96
 86c:	b6 e0       	ldi	r27, 0x06	; 6
 86e:	82 e0       	ldi	r24, 0x02	; 2
 870:	11 96       	adiw	r26, 0x01	; 1
 872:	8c 93       	st	X, r24
 874:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.OUTSET = (1<<1);//sck pin output level high
 876:	15 96       	adiw	r26, 0x05	; 5
 878:	8c 93       	st	X, r24

	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | USART_CMODE_MSPI_gc;
 87a:	8d 81       	ldd	r24, Y+5	; 0x05
 87c:	80 6c       	ori	r24, 0xC0	; 192
 87e:	8d 83       	std	Y+5, r24	; 0x05

	if (opt->spimode == 1 || opt->spimode == 3) {
 880:	84 81       	ldd	r24, Z+4	; 0x04
 882:	8d 7f       	andi	r24, 0xFD	; 253
 884:	81 30       	cpi	r24, 0x01	; 1
 886:	21 f4       	brne	.+8      	; 0x890 <usart_init_spi+0x34>
		usart->CTRLC |= USART_UCPHA_bm;
 888:	8d 81       	ldd	r24, Y+5	; 0x05
 88a:	82 60       	ori	r24, 0x02	; 2
 88c:	8d 83       	std	Y+5, r24	; 0x05
 88e:	03 c0       	rjmp	.+6      	; 0x896 <usart_init_spi+0x3a>
	}
	else {
		usart->CTRLC &= ~USART_UCPHA_bm;
 890:	8d 81       	ldd	r24, Y+5	; 0x05
 892:	8d 7f       	andi	r24, 0xFD	; 253
 894:	8d 83       	std	Y+5, r24	; 0x05
	}
	
	if (opt->data_order) {
 896:	85 81       	ldd	r24, Z+5	; 0x05
 898:	88 23       	and	r24, r24
 89a:	21 f0       	breq	.+8      	; 0x8a4 <usart_init_spi+0x48>
		(usart)->CTRLC |= USART_DORD_bm;
 89c:	8d 81       	ldd	r24, Y+5	; 0x05
 89e:	84 60       	ori	r24, 0x04	; 4
 8a0:	8d 83       	std	Y+5, r24	; 0x05
 8a2:	03 c0       	rjmp	.+6      	; 0x8aa <usart_init_spi+0x4e>
	}
	else {
		(usart)->CTRLC &= ~USART_DORD_bm;
 8a4:	8d 81       	ldd	r24, Y+5	; 0x05
 8a6:	8b 7f       	andi	r24, 0xFB	; 251
 8a8:	8d 83       	std	Y+5, r24	; 0x05
	}


	uint16_t bsel_value = (32000000UL/ (opt->baudrate*2)) -1 ;
 8aa:	80 81       	ld	r24, Z
 8ac:	91 81       	ldd	r25, Z+1	; 0x01
 8ae:	a2 81       	ldd	r26, Z+2	; 0x02
 8b0:	b3 81       	ldd	r27, Z+3	; 0x03
 8b2:	9c 01       	movw	r18, r24
 8b4:	ad 01       	movw	r20, r26
 8b6:	22 0f       	add	r18, r18
 8b8:	33 1f       	adc	r19, r19
 8ba:	44 1f       	adc	r20, r20
 8bc:	55 1f       	adc	r21, r21
 8be:	60 e0       	ldi	r22, 0x00	; 0
 8c0:	78 e4       	ldi	r23, 0x48	; 72
 8c2:	88 ee       	ldi	r24, 0xE8	; 232
 8c4:	91 e0       	ldi	r25, 0x01	; 1
 8c6:	0e 94 a8 07 	call	0xf50	; 0xf50 <__udivmodsi4>
 8ca:	21 50       	subi	r18, 0x01	; 1
 8cc:	31 09       	sbc	r19, r1
	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
 8ce:	83 2f       	mov	r24, r19
 8d0:	8f 70       	andi	r24, 0x0F	; 15
 8d2:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
 8d4:	2e 83       	std	Y+6, r18	; 0x06
	
	(usart)->CTRLB |= USART_TXEN_bm;
 8d6:	8c 81       	ldd	r24, Y+4	; 0x04
 8d8:	88 60       	ori	r24, 0x08	; 8
 8da:	8c 83       	std	Y+4, r24	; 0x04

}
 8dc:	df 91       	pop	r29
 8de:	cf 91       	pop	r28
 8e0:	08 95       	ret

000008e2 <ssd1306_init>:




void ssd1306_init(void)
{
 8e2:	cf 93       	push	r28
 8e4:	df 93       	push	r29
 8e6:	00 d0       	rcall	.+0      	; 0x8e8 <ssd1306_init+0x6>
 8e8:	00 d0       	rcall	.+0      	; 0x8ea <ssd1306_init+0x8>
 8ea:	cd b7       	in	r28, 0x3d	; 61
 8ec:	de b7       	in	r29, 0x3e	; 62

	port_direction_set_mask(&PORTF,(1<<3));//ss
 8ee:	20 ea       	ldi	r18, 0xA0	; 160
 8f0:	36 e0       	ldi	r19, 0x06	; 6
 8f2:	88 e0       	ldi	r24, 0x08	; 8
 8f4:	d9 01       	movw	r26, r18
 8f6:	11 96       	adiw	r26, 0x01	; 1
 8f8:	8c 93       	st	X, r24
	port_direction_set_mask(&PORTD,(1<<0));//data_cmd
 8fa:	a0 e6       	ldi	r26, 0x60	; 96
 8fc:	b6 e0       	ldi	r27, 0x06	; 6
 8fe:	91 e0       	ldi	r25, 0x01	; 1
 900:	11 96       	adiw	r26, 0x01	; 1
 902:	9c 93       	st	X, r25
 904:	11 97       	sbiw	r26, 0x01	; 1
	port_direction_set_mask(&PORTA,(1<<3));//reset
 906:	e0 e0       	ldi	r30, 0x00	; 0
 908:	f6 e0       	ldi	r31, 0x06	; 6
 90a:	81 83       	std	Z+1, r24	; 0x01
	port_direction_set_mask(&PORTD,(1<<1));//sck
 90c:	92 e0       	ldi	r25, 0x02	; 2
 90e:	11 96       	adiw	r26, 0x01	; 1
 910:	9c 93       	st	X, r25
 912:	11 97       	sbiw	r26, 0x01	; 1
	port_direction_set_mask(&PORTD,(1<<3));//mosi
 914:	11 96       	adiw	r26, 0x01	; 1
 916:	8c 93       	st	X, r24
// 	
	port_out_value_set_mask(&PORTF,(1<<3));//ss
 918:	d9 01       	movw	r26, r18
 91a:	15 96       	adiw	r26, 0x05	; 5
 91c:	8c 93       	st	X, r24
 * \note this functions should not be confused with the \ref ssd1306_soft_reset()
 * function, this command will control the RST pin.
 */
static inline void ssd1306_hard_reset(void)
{
	PORTA.OUTCLR = (1<<3);
 91e:	86 83       	std	Z+6, r24	; 0x06
 920:	ba e6       	ldi	r27, 0x6A	; 106
 922:	ba 95       	dec	r27
 924:	f1 f7       	brne	.-4      	; 0x922 <ssd1306_init+0x40>
 926:	00 c0       	rjmp	.+0      	; 0x928 <ssd1306_init+0x46>
	delay_us(10); // At least 3us
	PORTA.OUTSET = (1<<3);
 928:	85 83       	std	Z+5, r24	; 0x05
 92a:	ea e6       	ldi	r30, 0x6A	; 106
 92c:	ea 95       	dec	r30
 92e:	f1 f7       	brne	.-4      	; 0x92c <ssd1306_init+0x4a>
 930:	00 c0       	rjmp	.+0      	; 0x932 <ssd1306_init+0x50>
	spi_flags_t spi_flags = 0;
	//board_spi_select_id_t spi_select_id = 0;
	
	//irqflags_t flags = cpu_irq_save();
	//*((uint8_t *)&PR.PRGEN + SYSCLK_PORT_D) &= ~PR_USART0_bm;
	PR.PRPD &= ~PR_USART0_bm;
 932:	e0 e7       	ldi	r30, 0x70	; 112
 934:	f0 e0       	ldi	r31, 0x00	; 0
 936:	84 81       	ldd	r24, Z+4	; 0x04
 938:	8f 7e       	andi	r24, 0xEF	; 239
 93a:	84 83       	std	Z+4, r24	; 0x04
	
	//cpu_irq_restore(flags);
	
	usart_spi_options_emon_t opt;
	opt.baudrate=12000000;
 93c:	80 e0       	ldi	r24, 0x00	; 0
 93e:	9b e1       	ldi	r25, 0x1B	; 27
 940:	a7 eb       	ldi	r26, 0xB7	; 183
 942:	b0 e0       	ldi	r27, 0x00	; 0
 944:	89 83       	std	Y+1, r24	; 0x01
 946:	9a 83       	std	Y+2, r25	; 0x02
 948:	ab 83       	std	Y+3, r26	; 0x03
 94a:	bc 83       	std	Y+4, r27	; 0x04
	opt.spimode=spi_flags;
 94c:	1d 82       	std	Y+5, r1	; 0x05
	opt.data_order=0;
 94e:	1e 82       	std	Y+6, r1	; 0x06
	usart_init_spi(&USARTD0, &opt);
 950:	be 01       	movw	r22, r28
 952:	6f 5f       	subi	r22, 0xFF	; 255
 954:	7f 4f       	sbci	r23, 0xFF	; 255
 956:	80 ea       	ldi	r24, 0xA0	; 160
 958:	99 e0       	ldi	r25, 0x09	; 9
 95a:	0e 94 2e 04 	call	0x85c	; 0x85c <usart_init_spi>
	

	// 1/32 Duty (0x0F~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_MULTIPLEX_RATIO);
 95e:	88 ea       	ldi	r24, 0xA8	; 168
 960:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_write_command(0x1F);
 964:	8f e1       	ldi	r24, 0x1F	; 31
 966:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	// Shift Mapping RAM Counter (0x00~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_OFFSET);
 96a:	83 ed       	ldi	r24, 0xD3	; 211
 96c:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_write_command(0x00);
 970:	80 e0       	ldi	r24, 0x00	; 0
 972:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	// Set Mapping RAM Display Start Line (0x00~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_START_LINE(0x00));
 976:	80 e4       	ldi	r24, 0x40	; 64
 978:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	// Set Column Address 0 Mapped to SEG0
	ssd1306_write_command(SSD1306_CMD_SET_SEGMENT_RE_MAP_COL127_SEG0);
 97c:	81 ea       	ldi	r24, 0xA1	; 161
 97e:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	// Set COM/Row Scan Scan from COM63 to 0
	ssd1306_write_command(SSD1306_CMD_SET_COM_OUTPUT_SCAN_DOWN);
 982:	88 ec       	ldi	r24, 0xC8	; 200
 984:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	// Set COM Pins hardware configuration
	ssd1306_write_command(SSD1306_CMD_SET_COM_PINS);
 988:	8a ed       	ldi	r24, 0xDA	; 218
 98a:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_write_command(0x02);
 98e:	82 e0       	ldi	r24, 0x02	; 2
 990:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	//ssd1306_set_contrast(0x8F);
	ssd1306_write_command(SSD1306_CMD_SET_CONTRAST_CONTROL_FOR_BANK0);
 994:	81 e8       	ldi	r24, 0x81	; 129
 996:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_write_command(0x8F);
 99a:	8f e8       	ldi	r24, 0x8F	; 143
 99c:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

		
	// Disable Entire display On
	ssd1306_write_command(SSD1306_CMD_ENTIRE_DISPLAY_AND_GDDRAM_ON);
 9a0:	84 ea       	ldi	r24, 0xA4	; 164
 9a2:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	//ssd1306_display_invert_disable();
	ssd1306_write_command(SSD1306_CMD_SET_NORMAL_DISPLAY);
 9a6:	86 ea       	ldi	r24, 0xA6	; 166
 9a8:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	// Set Display Clock Divide Ratio / Oscillator Frequency (Default => 0x80)
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_CLOCK_DIVIDE_RATIO);
 9ac:	85 ed       	ldi	r24, 0xD5	; 213
 9ae:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_write_command(0x80);
 9b2:	80 e8       	ldi	r24, 0x80	; 128
 9b4:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	// Enable charge pump regulator
	ssd1306_write_command(SSD1306_CMD_SET_CHARGE_PUMP_SETTING);
 9b8:	8d e8       	ldi	r24, 0x8D	; 141
 9ba:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_write_command(0x14);
 9be:	84 e1       	ldi	r24, 0x14	; 20
 9c0:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	// Set VCOMH Deselect Level
	ssd1306_write_command(SSD1306_CMD_SET_VCOMH_DESELECT_LEVEL);
 9c4:	8b ed       	ldi	r24, 0xDB	; 219
 9c6:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_write_command(0x40); // Default => 0x20 (0.77*VCC)
 9ca:	80 e4       	ldi	r24, 0x40	; 64
 9cc:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	// Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
	ssd1306_write_command(SSD1306_CMD_SET_PRE_CHARGE_PERIOD);
 9d0:	89 ed       	ldi	r24, 0xD9	; 217
 9d2:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_write_command(0xF1);
 9d6:	81 ef       	ldi	r24, 0xF1	; 241
 9d8:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>

	//ssd1306_display_on();
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_ON);
 9dc:	8f ea       	ldi	r24, 0xAF	; 175
 9de:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
}
 9e2:	26 96       	adiw	r28, 0x06	; 6
 9e4:	cd bf       	out	0x3d, r28	; 61
 9e6:	de bf       	out	0x3e, r29	; 62
 9e8:	df 91       	pop	r29
 9ea:	cf 91       	pop	r28
 9ec:	08 95       	ret

000009ee <ssd1306_write_text>:
/**
 * \brief Display text on OLED screen.
 * \param string String to display.
 */
void ssd1306_write_text(char *string)
{
 9ee:	ef 92       	push	r14
 9f0:	ff 92       	push	r15
 9f2:	0f 93       	push	r16
 9f4:	1f 93       	push	r17
 9f6:	cf 93       	push	r28
	uint8_t *char_ptr;
	uint8_t i;

	while (*string != '\0') {
 9f8:	dc 01       	movw	r26, r24
 9fa:	ec 91       	ld	r30, X
 9fc:	ee 23       	and	r30, r30
 9fe:	29 f1       	breq	.+74     	; 0xa4a <ssd1306_write_text+0x5c>
 a00:	7c 01       	movw	r14, r24
 a02:	bf ef       	ldi	r27, 0xFF	; 255
 a04:	eb 1a       	sub	r14, r27
 a06:	fb 0a       	sbc	r15, r27
		if (*string < 0x7F) {
 a08:	ef 37       	cpi	r30, 0x7F	; 127
 a0a:	d0 f4       	brcc	.+52     	; 0xa40 <ssd1306_write_text+0x52>
			char_ptr = font_table[*string - 32];
 a0c:	f0 e0       	ldi	r31, 0x00	; 0
 a0e:	ee 0f       	add	r30, r30
 a10:	ff 1f       	adc	r31, r31
 a12:	ef 56       	subi	r30, 0x6F	; 111
 a14:	fe 4d       	sbci	r31, 0xDE	; 222
 a16:	00 81       	ld	r16, Z
 a18:	11 81       	ldd	r17, Z+1	; 0x01
			for (i = 1; i <= char_ptr[0]; i++) {
 a1a:	f8 01       	movw	r30, r16
 a1c:	80 81       	ld	r24, Z
 a1e:	88 23       	and	r24, r24
 a20:	61 f0       	breq	.+24     	; 0xa3a <ssd1306_write_text+0x4c>
 a22:	c1 e0       	ldi	r28, 0x01	; 1
				ssd1306_write_data(char_ptr[i]);
 a24:	f8 01       	movw	r30, r16
 a26:	ec 0f       	add	r30, r28
 a28:	f1 1d       	adc	r31, r1
 a2a:	80 81       	ld	r24, Z
 a2c:	0e 94 f7 03 	call	0x7ee	; 0x7ee <ssd1306_write_data>
	uint8_t i;

	while (*string != '\0') {
		if (*string < 0x7F) {
			char_ptr = font_table[*string - 32];
			for (i = 1; i <= char_ptr[0]; i++) {
 a30:	cf 5f       	subi	r28, 0xFF	; 255
 a32:	d8 01       	movw	r26, r16
 a34:	9c 91       	ld	r25, X
 a36:	9c 17       	cp	r25, r28
 a38:	a8 f7       	brcc	.-22     	; 0xa24 <ssd1306_write_text+0x36>
				ssd1306_write_data(char_ptr[i]);
			}
			ssd1306_write_data(0x00);
 a3a:	80 e0       	ldi	r24, 0x00	; 0
 a3c:	0e 94 f7 03 	call	0x7ee	; 0x7ee <ssd1306_write_data>
void ssd1306_write_text(char *string)
{
	uint8_t *char_ptr;
	uint8_t i;

	while (*string != '\0') {
 a40:	d7 01       	movw	r26, r14
 a42:	ed 91       	ld	r30, X+
 a44:	7d 01       	movw	r14, r26
 a46:	e1 11       	cpse	r30, r1
 a48:	df cf       	rjmp	.-66     	; 0xa08 <ssd1306_write_text+0x1a>
			}
			ssd1306_write_data(0x00);
		}
			string++;
	}
}
 a4a:	cf 91       	pop	r28
 a4c:	1f 91       	pop	r17
 a4e:	0f 91       	pop	r16
 a50:	ff 90       	pop	r15
 a52:	ef 90       	pop	r14
 a54:	08 95       	ret

00000a56 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(uint8_t page, uint8_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
 a56:	20 e8       	ldi	r18, 0x80	; 128
 a58:	82 9f       	mul	r24, r18
 a5a:	c0 01       	movw	r24, r0
 a5c:	11 24       	eor	r1, r1
 a5e:	86 0f       	add	r24, r22
 a60:	91 1d       	adc	r25, r1
 a62:	e0 91 b2 22 	lds	r30, 0x22B2
 a66:	f0 91 b3 22 	lds	r31, 0x22B3
 a6a:	e8 0f       	add	r30, r24
 a6c:	f9 1f       	adc	r31, r25
 a6e:	40 83       	st	Z, r20
 a70:	08 95       	ret

00000a72 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(uint8_t page, uint8_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
 a72:	20 e8       	ldi	r18, 0x80	; 128
 a74:	82 9f       	mul	r24, r18
 a76:	c0 01       	movw	r24, r0
 a78:	11 24       	eor	r1, r1
 a7a:	86 0f       	add	r24, r22
 a7c:	91 1d       	adc	r25, r1
 a7e:	e0 91 b2 22 	lds	r30, 0x22B2
 a82:	f0 91 b3 22 	lds	r31, 0x22B3
 a86:	e8 0f       	add	r30, r24
 a88:	f9 1f       	adc	r31, r25
}
 a8a:	80 81       	ld	r24, Z
 a8c:	08 95       	ret

00000a8e <gfx_mono_ssd1306_put_byte>:
	gfx_mono_ssd1306_put_byte(0, 0, 0xFF, false);
\endcode
 */
void gfx_mono_ssd1306_put_byte(uint8_t page, uint8_t column,
		uint8_t data, uint8_t force)
{
 a8e:	1f 93       	push	r17
 a90:	cf 93       	push	r28
 a92:	df 93       	push	r29
 a94:	18 2f       	mov	r17, r24
 a96:	d6 2f       	mov	r29, r22
 a98:	c4 2f       	mov	r28, r20
//#ifdef CONFIG_SSD1306_FRAMEBUFFER
	if (!force && data == gfx_mono_framebuffer_get_byte(page, column)) {
 a9a:	21 11       	cpse	r18, r1
 a9c:	04 c0       	rjmp	.+8      	; 0xaa6 <gfx_mono_ssd1306_put_byte+0x18>
 a9e:	0e 94 39 05 	call	0xa72	; 0xa72 <gfx_mono_framebuffer_get_byte>
 aa2:	8c 17       	cp	r24, r28
 aa4:	71 f0       	breq	.+28     	; 0xac2 <gfx_mono_ssd1306_put_byte+0x34>
		return;
	}
	gfx_mono_framebuffer_put_byte(page, column, data);
 aa6:	4c 2f       	mov	r20, r28
 aa8:	6d 2f       	mov	r22, r29
 aaa:	81 2f       	mov	r24, r17
 aac:	0e 94 2b 05 	call	0xa56	; 0xa56 <gfx_mono_framebuffer_put_byte>
//#endif

	ssd1306_set_page_address(page);
 ab0:	81 2f       	mov	r24, r17
 ab2:	0e 94 19 04 	call	0x832	; 0x832 <ssd1306_set_page_address>
	ssd1306_set_column_address(column);
 ab6:	8d 2f       	mov	r24, r29
 ab8:	0e 94 1e 04 	call	0x83c	; 0x83c <ssd1306_set_column_address>

	ssd1306_write_data(data);
 abc:	8c 2f       	mov	r24, r28
 abe:	0e 94 f7 03 	call	0x7ee	; 0x7ee <ssd1306_write_data>
}
 ac2:	df 91       	pop	r29
 ac4:	cf 91       	pop	r28
 ac6:	1f 91       	pop	r17
 ac8:	08 95       	ret

00000aca <main>:

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
 aca:	cf 93       	push	r28
 acc:	df 93       	push	r29
 ace:	cd b7       	in	r28, 0x3d	; 61
 ad0:	de b7       	in	r29, 0x3e	; 62
 ad2:	28 97       	sbiw	r28, 0x08	; 8
 ad4:	cd bf       	out	0x3d, r28	; 61
 ad6:	de bf       	out	0x3e, r29	; 62
	
	DigitalPin_t led = {&PORTR, 0};
 ad8:	80 ee       	ldi	r24, 0xE0	; 224
 ada:	97 e0       	ldi	r25, 0x07	; 7
 adc:	89 83       	std	Y+1, r24	; 0x01
 ade:	9a 83       	std	Y+2, r25	; 0x02
 ae0:	1b 82       	std	Y+3, r1	; 0x03
	
	
	
	
	
	_nrf24l01p_init();
 ae2:	0e 94 52 03 	call	0x6a4	; 0x6a4 <_nrf24l01p_init>
	_nrf24l01p_enable_dynamic_payload();
 ae6:	0e 94 03 03 	call	0x606	; 0x606 <_nrf24l01p_enable_dynamic_payload>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P0);
 aea:	80 e0       	ldi	r24, 0x00	; 0
 aec:	0e 94 82 02 	call	0x504	; 0x504 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P1);
 af0:	81 e0       	ldi	r24, 0x01	; 1
 af2:	0e 94 82 02 	call	0x504	; 0x504 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P2);
 af6:	82 e0       	ldi	r24, 0x02	; 2
 af8:	0e 94 82 02 	call	0x504	; 0x504 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P3);
 afc:	83 e0       	ldi	r24, 0x03	; 3
 afe:	0e 94 82 02 	call	0x504	; 0x504 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P4);
 b02:	84 e0       	ldi	r24, 0x04	; 4
 b04:	0e 94 82 02 	call	0x504	; 0x504 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P5);
 b08:	85 e0       	ldi	r24, 0x05	; 5
 b0a:	0e 94 82 02 	call	0x504	; 0x504 <_nrf24l01p_enable_rx_on_pipe>
	
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P0);
 b0e:	80 e0       	ldi	r24, 0x00	; 0
 b10:	0e 94 ca 02 	call	0x594	; 0x594 <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P1);
 b14:	81 e0       	ldi	r24, 0x01	; 1
 b16:	0e 94 ca 02 	call	0x594	; 0x594 <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P2);
 b1a:	82 e0       	ldi	r24, 0x02	; 2
 b1c:	0e 94 ca 02 	call	0x594	; 0x594 <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P3);
 b20:	83 e0       	ldi	r24, 0x03	; 3
 b22:	0e 94 ca 02 	call	0x594	; 0x594 <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P4);
 b26:	84 e0       	ldi	r24, 0x04	; 4
 b28:	0e 94 ca 02 	call	0x594	; 0x594 <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P5);
 b2c:	85 e0       	ldi	r24, 0x05	; 5
 b2e:	0e 94 ca 02 	call	0x594	; 0x594 <_nrf24l01p_enable_dynamic_payload_pipe>
	gfx_mono_set_framebuffer(framebuffer);
\endcode
 */
void gfx_mono_set_framebuffer(uint8_t *framebuffer)
{
	fbpointer = framebuffer;
 b32:	84 eb       	ldi	r24, 0xB4	; 180
 b34:	92 e2       	ldi	r25, 0x22	; 34
 b36:	80 93 b2 22 	sts	0x22B2, r24
 b3a:	90 93 b3 22 	sts	0x22B3, r25
	uint8_t page;
	uint8_t column;

	gfx_mono_set_framebuffer(framebuffer);

	ssd1306_init();
 b3e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <ssd1306_init>
	asm("nop");
 b42:	00 00       	nop
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
 b44:	00 e0       	ldi	r16, 0x00	; 0
	{
		ssd1306_set_page_address(page);
 b46:	80 2f       	mov	r24, r16
 b48:	0e 94 19 04 	call	0x832	; 0x832 <ssd1306_set_page_address>
		ssd1306_set_column_address(0);
 b4c:	80 e0       	ldi	r24, 0x00	; 0
 b4e:	0e 94 1e 04 	call	0x83c	; 0x83c <ssd1306_set_column_address>
 b52:	10 e0       	ldi	r17, 0x00	; 0
		for (col = 0; col < 128; ++col)
		{
			ssd1306_write_data(0x00);
 b54:	80 e0       	ldi	r24, 0x00	; 0
 b56:	0e 94 f7 03 	call	0x7ee	; 0x7ee <ssd1306_write_data>

	for (page = 0; page < 4; ++page)
	{
		ssd1306_set_page_address(page);
		ssd1306_set_column_address(0);
		for (col = 0; col < 128; ++col)
 b5a:	1f 5f       	subi	r17, 0xFF	; 255
 b5c:	10 38       	cpi	r17, 0x80	; 128
 b5e:	d1 f7       	brne	.-12     	; 0xb54 <main+0x8a>
static inline void ssd1306_clear(void)
{
	uint8_t page = 0;
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
 b60:	0f 5f       	subi	r16, 0xFF	; 255
 b62:	04 30       	cpi	r16, 0x04	; 4
 b64:	81 f7       	brne	.-32     	; 0xb46 <main+0x7c>
 */
static inline void ssd1306_set_display_start_line_address(uint8_t address)
{
	// Make sure address is 6 bits
	address &= 0x3F;
	ssd1306_write_command(SSD1306_CMD_SET_START_LINE(address));
 b66:	80 e4       	ldi	r24, 0x40	; 64
 b68:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <ssd1306_write_command>
	ssd1306_clear();

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
 b6c:	00 e0       	ldi	r16, 0x00	; 0
 b6e:	0c c0       	rjmp	.+24     	; 0xb88 <main+0xbe>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
 b70:	21 e0       	ldi	r18, 0x01	; 1
 b72:	40 e0       	ldi	r20, 0x00	; 0
 b74:	61 2f       	mov	r22, r17
 b76:	80 2f       	mov	r24, r16
 b78:	0e 94 47 05 	call	0xa8e	; 0xa8e <gfx_mono_ssd1306_put_byte>

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
 b7c:	1f 5f       	subi	r17, 0xFF	; 255
 b7e:	10 38       	cpi	r17, 0x80	; 128
 b80:	b9 f7       	brne	.-18     	; 0xb70 <main+0xa6>
	ssd1306_clear();

	ssd1306_set_display_start_line_address(0);


	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
 b82:	0f 5f       	subi	r16, 0xFF	; 255
 b84:	04 30       	cpi	r16, 0x04	; 4
 b86:	11 f0       	breq	.+4      	; 0xb8c <main+0xc2>
	uint8_t col = 0;

	for (page = 0; page < 4; ++page)
	{
		ssd1306_set_page_address(page);
		ssd1306_set_column_address(0);
 b88:	10 e0       	ldi	r17, 0x00	; 0
 b8a:	f2 cf       	rjmp	.-28     	; 0xb70 <main+0xa6>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, 1);
		}
	}

	asm("nop");
 b8c:	00 00       	nop
	ssd1306_set_page_address(0);
 b8e:	80 e0       	ldi	r24, 0x00	; 0
 b90:	0e 94 19 04 	call	0x832	; 0x832 <ssd1306_set_page_address>
	ssd1306_write_text("EMON");
 b94:	8f e9       	ldi	r24, 0x9F	; 159
 b96:	92 e2       	ldi	r25, 0x22	; 34
 b98:	0e 94 f7 04 	call	0x9ee	; 0x9ee <ssd1306_write_text>
 	//SetupHardware();
// 
 	//LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
 	//GlobalInterruptEnable();

	DigitalPin_SetDIr(&led,1);
 b9c:	61 e0       	ldi	r22, 0x01	; 1
 b9e:	ce 01       	movw	r24, r28
 ba0:	01 96       	adiw	r24, 0x01	; 1
 ba2:	0e 94 34 06 	call	0xc68	; 0xc68 <DigitalPin_SetDIr>
	//PORT_SetDirection(&PORTR,(1<<0));

	CLKSYS_Enable( OSC_RC32MEN_bm );
 ba6:	e0 e5       	ldi	r30, 0x50	; 80
 ba8:	f0 e0       	ldi	r31, 0x00	; 0
 baa:	80 81       	ld	r24, Z
 bac:	82 60       	ori	r24, 0x02	; 2
 bae:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC32MRDY_bm ) == 0 );
 bb0:	81 81       	ldd	r24, Z+1	; 0x01
 bb2:	81 ff       	sbrs	r24, 1
 bb4:	fd cf       	rjmp	.-6      	; 0xbb0 <main+0xe6>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
 bb6:	81 e0       	ldi	r24, 0x01	; 1
 bb8:	0e 94 85 06 	call	0xd0a	; 0xd0a <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
 bbc:	81 e0       	ldi	r24, 0x01	; 1
 bbe:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <CLKSYS_Disable>
		
	while(1)
	{

			
 			PORT_TogglePins(&PORTR,(1<<0));
 bc2:	0f 2e       	mov	r0, r31
 bc4:	f0 ee       	ldi	r31, 0xE0	; 224
 bc6:	cf 2e       	mov	r12, r31
 bc8:	f7 e0       	ldi	r31, 0x07	; 7
 bca:	df 2e       	mov	r13, r31
 bcc:	f0 2d       	mov	r31, r0
 bce:	ee 24       	eor	r14, r14
 bd0:	e3 94       	inc	r14
			 _delay_ms(1000);
 			char myname[] = "test";
 bd2:	0f 2e       	mov	r0, r31
 bd4:	f5 e0       	ldi	r31, 0x05	; 5
 bd6:	ff 2e       	mov	r15, r31
 bd8:	f0 2d       	mov	r31, r0
 bda:	8e 01       	movw	r16, r28
 bdc:	0c 5f       	subi	r16, 0xFC	; 252
 bde:	1f 4f       	sbci	r17, 0xFF	; 255
		
	while(1)
	{

			
 			PORT_TogglePins(&PORTR,(1<<0));
 be0:	f6 01       	movw	r30, r12
 be2:	e7 82       	std	Z+7, r14	; 0x07
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 be4:	ff ef       	ldi	r31, 0xFF	; 255
 be6:	27 ea       	ldi	r18, 0xA7	; 167
 be8:	81 e6       	ldi	r24, 0x61	; 97
 bea:	f1 50       	subi	r31, 0x01	; 1
 bec:	20 40       	sbci	r18, 0x00	; 0
 bee:	80 40       	sbci	r24, 0x00	; 0
 bf0:	e1 f7       	brne	.-8      	; 0xbea <main+0x120>
 bf2:	00 c0       	rjmp	.+0      	; 0xbf4 <main+0x12a>
 bf4:	00 00       	nop
			 _delay_ms(1000);
 			char myname[] = "test";
 bf6:	e4 ea       	ldi	r30, 0xA4	; 164
 bf8:	f2 e2       	ldi	r31, 0x22	; 34
 bfa:	d8 01       	movw	r26, r16
 bfc:	8f 2d       	mov	r24, r15
 bfe:	01 90       	ld	r0, Z+
 c00:	0d 92       	st	X+, r0
 c02:	8a 95       	dec	r24
 c04:	e1 f7       	brne	.-8      	; 0xbfe <main+0x134>
			_nrf24l01p_write((uint8_t*) myname, strlen(myname));
 c06:	f8 01       	movw	r30, r16
 c08:	01 90       	ld	r0, Z+
 c0a:	00 20       	and	r0, r0
 c0c:	e9 f7       	brne	.-6      	; 0xc08 <main+0x13e>
 c0e:	31 97       	sbiw	r30, 0x01	; 1
 c10:	bf 01       	movw	r22, r30
 c12:	60 1b       	sub	r22, r16
 c14:	71 0b       	sbc	r23, r17
 c16:	c8 01       	movw	r24, r16
 c18:	0e 94 8c 03 	call	0x718	; 0x718 <_nrf24l01p_write>

		
 			//HID_Device_USBTask(&Generic_HID_Interface);
 			//USB_USBTask();
	}
 c1c:	e1 cf       	rjmp	.-62     	; 0xbe0 <main+0x116>

00000c1e <EVENT_USB_Device_Connect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
 c1e:	83 e0       	ldi	r24, 0x03	; 3
 c20:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
 c24:	80 e3       	ldi	r24, 0x30	; 48
 c26:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
 c2a:	82 e0       	ldi	r24, 0x02	; 2
 c2c:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
 c30:	80 e1       	ldi	r24, 0x10	; 16
 c32:	80 93 65 06 	sts	0x0665, r24
 c36:	08 95       	ret

00000c38 <EVENT_USB_Device_Disconnect>:
				PORTD_OUTCLR = LEDMask & LEDS_PORTD_LEDS;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTR_OUTCLR = LEDS_PORTR_LEDS;
 c38:	83 e0       	ldi	r24, 0x03	; 3
 c3a:	80 93 e6 07 	sts	0x07E6, r24
				PORTD_OUTCLR = LEDS_PORTD_LEDS;
 c3e:	80 e3       	ldi	r24, 0x30	; 48
 c40:	80 93 66 06 	sts	0x0666, r24

				PORTR_OUTSET = (LEDMask & LEDS_PORTR_LEDS);
 c44:	81 e0       	ldi	r24, 0x01	; 1
 c46:	80 93 e5 07 	sts	0x07E5, r24
				PORTD_OUTSET = (LEDMask & LEDS_PORTD_LEDS);
 c4a:	10 92 65 06 	sts	0x0665, r1
 c4e:	08 95       	ret

00000c50 <EVENT_USB_Device_StartOfFrame>:
			 *  \param[in,out] HIDInterfaceInfo  Pointer to a structure containing a HID Class configuration and state.
			 */
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo) ATTR_ALWAYS_INLINE ATTR_NON_NULL_PTR_ARG(1);
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
			{
				if (HIDInterfaceInfo->State.IdleMSRemaining)
 c50:	80 91 9d 22 	lds	r24, 0x229D
 c54:	90 91 9e 22 	lds	r25, 0x229E
 c58:	00 97       	sbiw	r24, 0x00	; 0
 c5a:	29 f0       	breq	.+10     	; 0xc66 <EVENT_USB_Device_StartOfFrame+0x16>
				  HIDInterfaceInfo->State.IdleMSRemaining--;
 c5c:	01 97       	sbiw	r24, 0x01	; 1
 c5e:	80 93 9d 22 	sts	0x229D, r24
 c62:	90 93 9e 22 	sts	0x229E, r25
 c66:	08 95       	ret

00000c68 <DigitalPin_SetDIr>:
	SREG = sreg;	
}


void DigitalPin_SetDIr(DigitalPin_t *pin , bool dir){
	if(dir) pin->_port->DIRSET = (1<< pin->_pin);
 c68:	66 23       	and	r22, r22
 c6a:	79 f0       	breq	.+30     	; 0xc8a <DigitalPin_SetDIr+0x22>
 c6c:	dc 01       	movw	r26, r24
 c6e:	ed 91       	ld	r30, X+
 c70:	fc 91       	ld	r31, X
 c72:	11 97       	sbiw	r26, 0x01	; 1
 c74:	21 e0       	ldi	r18, 0x01	; 1
 c76:	30 e0       	ldi	r19, 0x00	; 0
 c78:	a9 01       	movw	r20, r18
 c7a:	12 96       	adiw	r26, 0x02	; 2
 c7c:	0c 90       	ld	r0, X
 c7e:	02 c0       	rjmp	.+4      	; 0xc84 <DigitalPin_SetDIr+0x1c>
 c80:	44 0f       	add	r20, r20
 c82:	55 1f       	adc	r21, r21
 c84:	0a 94       	dec	r0
 c86:	e2 f7       	brpl	.-8      	; 0xc80 <DigitalPin_SetDIr+0x18>
 c88:	41 83       	std	Z+1, r20	; 0x01
 c8a:	08 95       	ret

00000c8c <DigitalPin_SetValue>:
}

void DigitalPin_SetValue(DigitalPin_t *pin){
	pin->_port->OUTSET = (1<< pin->_pin);
 c8c:	dc 01       	movw	r26, r24
 c8e:	ed 91       	ld	r30, X+
 c90:	fc 91       	ld	r31, X
 c92:	11 97       	sbiw	r26, 0x01	; 1
 c94:	21 e0       	ldi	r18, 0x01	; 1
 c96:	30 e0       	ldi	r19, 0x00	; 0
 c98:	a9 01       	movw	r20, r18
 c9a:	12 96       	adiw	r26, 0x02	; 2
 c9c:	0c 90       	ld	r0, X
 c9e:	02 c0       	rjmp	.+4      	; 0xca4 <DigitalPin_SetValue+0x18>
 ca0:	44 0f       	add	r20, r20
 ca2:	55 1f       	adc	r21, r21
 ca4:	0a 94       	dec	r0
 ca6:	e2 f7       	brpl	.-8      	; 0xca0 <DigitalPin_SetValue+0x14>
 ca8:	45 83       	std	Z+5, r20	; 0x05
 caa:	08 95       	ret

00000cac <DigitalPin_ClearValue>:
}

void DigitalPin_ClearValue(DigitalPin_t *pin){
	pin->_port->OUTCLR = (1<< pin->_pin);
 cac:	dc 01       	movw	r26, r24
 cae:	ed 91       	ld	r30, X+
 cb0:	fc 91       	ld	r31, X
 cb2:	11 97       	sbiw	r26, 0x01	; 1
 cb4:	21 e0       	ldi	r18, 0x01	; 1
 cb6:	30 e0       	ldi	r19, 0x00	; 0
 cb8:	a9 01       	movw	r20, r18
 cba:	12 96       	adiw	r26, 0x02	; 2
 cbc:	0c 90       	ld	r0, X
 cbe:	02 c0       	rjmp	.+4      	; 0xcc4 <DigitalPin_ClearValue+0x18>
 cc0:	44 0f       	add	r20, r20
 cc2:	55 1f       	adc	r21, r21
 cc4:	0a 94       	dec	r0
 cc6:	e2 f7       	brpl	.-8      	; 0xcc0 <DigitalPin_ClearValue+0x14>
 cc8:	46 83       	std	Z+6, r20	; 0x06
 cca:	08 95       	ret

00000ccc <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
 ccc:	0f 93       	push	r16
 cce:	cf 93       	push	r28
 cd0:	df 93       	push	r29
 cd2:	1f 92       	push	r1
 cd4:	cd b7       	in	r28, 0x3d	; 61
 cd6:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
 cd8:	2f b7       	in	r18, 0x3f	; 63
 cda:	29 83       	std	Y+1, r18	; 0x01
 cdc:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
 cde:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
 ce0:	fc 01       	movw	r30, r24
 ce2:	08 ed       	ldi	r16, 0xD8	; 216
 ce4:	04 bf       	out	0x34, r16	; 52
 ce6:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
 ce8:	89 81       	ldd	r24, Y+1	; 0x01
 cea:	8f bf       	out	0x3f, r24	; 63
#endif
}
 cec:	0f 90       	pop	r0
 cee:	df 91       	pop	r29
 cf0:	cf 91       	pop	r28
 cf2:	0f 91       	pop	r16
 cf4:	08 95       	ret

00000cf6 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
 cf6:	e0 e5       	ldi	r30, 0x50	; 80
 cf8:	f0 e0       	ldi	r31, 0x00	; 0
 cfa:	90 81       	ld	r25, Z
 cfc:	28 2f       	mov	r18, r24
 cfe:	20 95       	com	r18
 d00:	92 23       	and	r25, r18
 d02:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
 d04:	90 81       	ld	r25, Z
	return clkEnabled;
}
 d06:	89 23       	and	r24, r25
 d08:	08 95       	ret

00000d0a <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
 d0a:	0f 93       	push	r16
 d0c:	1f 93       	push	r17
 d0e:	cf 93       	push	r28
 d10:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
 d12:	00 e4       	ldi	r16, 0x40	; 64
 d14:	10 e0       	ldi	r17, 0x00	; 0
 d16:	f8 01       	movw	r30, r16
 d18:	60 81       	ld	r22, Z
 d1a:	68 7f       	andi	r22, 0xF8	; 248
 d1c:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
 d1e:	80 e4       	ldi	r24, 0x40	; 64
 d20:	90 e0       	ldi	r25, 0x00	; 0
 d22:	0e 94 66 06 	call	0xccc	; 0xccc <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
 d26:	f8 01       	movw	r30, r16
 d28:	80 81       	ld	r24, Z
	return clkCtrl;
}
 d2a:	8c 23       	and	r24, r28
 d2c:	cf 91       	pop	r28
 d2e:	1f 91       	pop	r17
 d30:	0f 91       	pop	r16
 d32:	08 95       	ret

00000d34 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
 d34:	08 95       	ret

00000d36 <Endpoint_SelectEndpoint>:

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);

	USB_Endpoint_SelectedEndpoint = Address;
 d36:	80 93 ca 24 	sts	0x24CA, r24
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
}

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);
 d3a:	28 2f       	mov	r18, r24
 d3c:	2f 70       	andi	r18, 0x0F	; 15

	USB_Endpoint_SelectedEndpoint = Address;

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
 d3e:	30 e0       	ldi	r19, 0x00	; 0
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;
 d40:	40 91 c6 04 	lds	r20, 0x04C6
 d44:	50 91 c7 04 	lds	r21, 0x04C7

	if (Address & ENDPOINT_DIR_IN)
 d48:	88 23       	and	r24, r24
 d4a:	e4 f4       	brge	.+56     	; 0xd84 <Endpoint_SelectEndpoint+0x4e>
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
 d4c:	64 e8       	ldi	r22, 0x84	; 132
 d4e:	62 9f       	mul	r22, r18
 d50:	c0 01       	movw	r24, r0
 d52:	63 9f       	mul	r22, r19
 d54:	90 0d       	add	r25, r0
 d56:	11 24       	eor	r1, r1
 d58:	83 5f       	subi	r24, 0xF3	; 243
 d5a:	9a 4d       	sbci	r25, 0xDA	; 218
 d5c:	80 93 c6 24 	sts	0x24C6, r24
 d60:	90 93 c7 24 	sts	0x24C7, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].IN;
 d64:	c9 01       	movw	r24, r18
 d66:	82 95       	swap	r24
 d68:	92 95       	swap	r25
 d6a:	90 7f       	andi	r25, 0xF0	; 240
 d6c:	98 27       	eor	r25, r24
 d6e:	80 7f       	andi	r24, 0xF0	; 240
 d70:	98 27       	eor	r25, r24
 d72:	08 96       	adiw	r24, 0x08	; 8
 d74:	9a 01       	movw	r18, r20
 d76:	28 0f       	add	r18, r24
 d78:	39 1f       	adc	r19, r25
 d7a:	20 93 c8 24 	sts	0x24C8, r18
 d7e:	30 93 c9 24 	sts	0x24C9, r19
 d82:	08 95       	ret
	}
	else
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->OUT;
 d84:	64 e8       	ldi	r22, 0x84	; 132
 d86:	62 9f       	mul	r22, r18
 d88:	c0 01       	movw	r24, r0
 d8a:	63 9f       	mul	r22, r19
 d8c:	90 0d       	add	r25, r0
 d8e:	11 24       	eor	r1, r1
 d90:	85 53       	subi	r24, 0x35	; 53
 d92:	9b 4d       	sbci	r25, 0xDB	; 219
 d94:	80 93 c6 24 	sts	0x24C6, r24
 d98:	90 93 c7 24 	sts	0x24C7, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].OUT;
 d9c:	22 95       	swap	r18
 d9e:	32 95       	swap	r19
 da0:	30 7f       	andi	r19, 0xF0	; 240
 da2:	32 27       	eor	r19, r18
 da4:	20 7f       	andi	r18, 0xF0	; 240
 da6:	32 27       	eor	r19, r18
 da8:	24 0f       	add	r18, r20
 daa:	35 1f       	adc	r19, r21
 dac:	20 93 c8 24 	sts	0x24C8, r18
 db0:	30 93 c9 24 	sts	0x24C9, r19
 db4:	08 95       	ret

00000db6 <Endpoint_ConfigureEndpoint_PRV>:
}

bool Endpoint_ConfigureEndpoint_PRV(const uint8_t Address,
                                    const uint8_t Config,
                                    const uint8_t Size)
{
 db6:	1f 93       	push	r17
 db8:	cf 93       	push	r28
 dba:	df 93       	push	r29
 dbc:	d8 2f       	mov	r29, r24
 dbe:	16 2f       	mov	r17, r22
 dc0:	c4 2f       	mov	r28, r20
	Endpoint_SelectEndpoint(Address);
 dc2:	0e 94 9b 06 	call	0xd36	; 0xd36 <Endpoint_SelectEndpoint>

	USB_Endpoint_SelectedHandle->CTRL    = 0;
 dc6:	e0 91 c8 24 	lds	r30, 0x24C8
 dca:	f0 91 c9 24 	lds	r31, 0x24C9
 dce:	11 82       	std	Z+1, r1	; 0x01
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
 dd0:	e0 91 c8 24 	lds	r30, 0x24C8
 dd4:	f0 91 c9 24 	lds	r31, 0x24C9
 dd8:	dd 23       	and	r29, r29
 dda:	a4 f0       	brlt	.+40     	; 0xe04 <Endpoint_ConfigureEndpoint_PRV+0x4e>
 ddc:	10 82       	st	Z, r1
	USB_Endpoint_SelectedHandle->CTRL    = Config;
 dde:	e0 91 c8 24 	lds	r30, 0x24C8
 de2:	f0 91 c9 24 	lds	r31, 0x24C9
 de6:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
 de8:	e0 91 c8 24 	lds	r30, 0x24C8
 dec:	f0 91 c9 24 	lds	r31, 0x24C9
 df0:	12 82       	std	Z+2, r1	; 0x02
 df2:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
 df4:	80 91 c6 24 	lds	r24, 0x24C6
 df8:	90 91 c7 24 	lds	r25, 0x24C7
 dfc:	84 83       	std	Z+4, r24	; 0x04
 dfe:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
 e00:	40 e0       	ldi	r20, 0x00	; 0
 e02:	14 c0       	rjmp	.+40     	; 0xe2c <Endpoint_ConfigureEndpoint_PRV+0x76>
                                    const uint8_t Size)
{
	Endpoint_SelectEndpoint(Address);

	USB_Endpoint_SelectedHandle->CTRL    = 0;
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
 e04:	82 e0       	ldi	r24, 0x02	; 2
 e06:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->CTRL    = Config;
 e08:	e0 91 c8 24 	lds	r30, 0x24C8
 e0c:	f0 91 c9 24 	lds	r31, 0x24C9
 e10:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
 e12:	e0 91 c8 24 	lds	r30, 0x24C8
 e16:	f0 91 c9 24 	lds	r31, 0x24C9
 e1a:	12 82       	std	Z+2, r1	; 0x02
 e1c:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
 e1e:	80 91 c6 24 	lds	r24, 0x24C6
 e22:	90 91 c7 24 	lds	r25, 0x24C7
 e26:	84 83       	std	Z+4, r24	; 0x04
 e28:	95 83       	std	Z+5, r25	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
 e2a:	4c 2f       	mov	r20, r28
 e2c:	fc 01       	movw	r30, r24
 e2e:	e0 5c       	subi	r30, 0xC0	; 192
 e30:	ff 4f       	sbci	r31, 0xFF	; 255
 e32:	40 83       	st	Z, r20
	USB_Endpoint_SelectedFIFO->Position  = 0;
 e34:	31 96       	adiw	r30, 0x01	; 1
 e36:	10 82       	st	Z, r1

	return true;
}
 e38:	81 e0       	ldi	r24, 0x01	; 1
 e3a:	df 91       	pop	r29
 e3c:	cf 91       	pop	r28
 e3e:	1f 91       	pop	r17
 e40:	08 95       	ret

00000e42 <Endpoint_ClearEndpoints>:

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
 e42:	e0 ec       	ldi	r30, 0xC0	; 192
 e44:	f4 e0       	ldi	r31, 0x04	; 4
 e46:	a6 81       	ldd	r26, Z+6	; 0x06
 e48:	b7 81       	ldd	r27, Z+7	; 0x07
 e4a:	19 96       	adiw	r26, 0x09	; 9
 e4c:	1c 92       	st	X, r1
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
 e4e:	a6 81       	ldd	r26, Z+6	; 0x06
 e50:	b7 81       	ldd	r27, Z+7	; 0x07
 e52:	11 96       	adiw	r26, 0x01	; 1
 e54:	1c 92       	st	X, r1

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
 e56:	a6 81       	ldd	r26, Z+6	; 0x06
 e58:	b7 81       	ldd	r27, Z+7	; 0x07
 e5a:	59 96       	adiw	r26, 0x19	; 25
 e5c:	1c 92       	st	X, r1
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
 e5e:	06 80       	ldd	r0, Z+6	; 0x06
 e60:	f7 81       	ldd	r31, Z+7	; 0x07
 e62:	e0 2d       	mov	r30, r0
 e64:	11 8a       	std	Z+17, r1	; 0x11
 e66:	08 95       	ret

00000e68 <__vector_125>:
	USB.INTFLAGSACLR = 0xFF;
	USB.INTFLAGSBCLR = 0xFF;
}

ISR(USB_BUSEVENT_vect)
{
 e68:	1f 92       	push	r1
 e6a:	0f 92       	push	r0
 e6c:	0f b6       	in	r0, 0x3f	; 63
 e6e:	0f 92       	push	r0
 e70:	11 24       	eor	r1, r1
 e72:	0b b6       	in	r0, 0x3b	; 59
 e74:	0f 92       	push	r0
 e76:	2f 93       	push	r18
 e78:	3f 93       	push	r19
 e7a:	4f 93       	push	r20
 e7c:	5f 93       	push	r21
 e7e:	6f 93       	push	r22
 e80:	7f 93       	push	r23
 e82:	8f 93       	push	r24
 e84:	9f 93       	push	r25
 e86:	af 93       	push	r26
 e88:	bf 93       	push	r27
 e8a:	ef 93       	push	r30
 e8c:	ff 93       	push	r31
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTFLAGSACLR & USB_SOFIF_bm) ? true : false);
 e8e:	80 91 ca 04 	lds	r24, 0x04CA
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
 e92:	88 23       	and	r24, r24
 e94:	4c f4       	brge	.+18     	; 0xea8 <__vector_125+0x40>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						return ((USB.INTCTRLA & USB_BUSEVIE_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTCTRLA & USB_SOFIE_bm) ? true : false);
 e96:	80 91 c8 04 	lds	r24, 0x04C8
 e9a:	88 23       	and	r24, r24
 e9c:	2c f4       	brge	.+10     	; 0xea8 <__vector_125+0x40>
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
						break;
					case USB_INT_SOFI:
						USB.INTFLAGSACLR = USB_SOFIF_bm;
 e9e:	80 e8       	ldi	r24, 0x80	; 128
 ea0:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
 ea4:	0e 94 28 06 	call	0xc50	; 0xc50 <EVENT_USB_Device_StartOfFrame>
			static inline bool USB_INT_HasOccurred(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
 ea8:	80 91 ca 04 	lds	r24, 0x04CA
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Suspend))
 eac:	86 ff       	sbrs	r24, 6
 eae:	07 c0       	rjmp	.+14     	; 0xebe <__vector_125+0x56>
			static inline void USB_INT_Clear(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
 eb0:	80 e4       	ldi	r24, 0x40	; 64
 eb2:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Suspend);

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
 eb6:	10 92 bd 24 	sts	0x24BD, r1
		EVENT_USB_Device_Disconnect();
 eba:	0e 94 1c 06 	call	0xc38	; 0xc38 <EVENT_USB_Device_Disconnect>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
 ebe:	80 91 ca 04 	lds	r24, 0x04CA
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Resume))
 ec2:	85 ff       	sbrs	r24, 5
 ec4:	16 c0       	rjmp	.+44     	; 0xef2 <__vector_125+0x8a>
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
 ec6:	80 e2       	ldi	r24, 0x20	; 32
 ec8:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Resume);

		if (USB_Device_ConfigurationNumber)
 ecc:	80 91 b9 24 	lds	r24, 0x24B9
 ed0:	88 23       	and	r24, r24
 ed2:	21 f0       	breq	.+8      	; 0xedc <__vector_125+0x74>
		  USB_DeviceState = DEVICE_STATE_Configured;
 ed4:	84 e0       	ldi	r24, 0x04	; 4
 ed6:	80 93 bd 24 	sts	0x24BD, r24
 eda:	09 c0       	rjmp	.+18     	; 0xeee <__vector_125+0x86>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
 edc:	80 91 c3 04 	lds	r24, 0x04C3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
 ee0:	81 11       	cpse	r24, r1
 ee2:	02 c0       	rjmp	.+4      	; 0xee8 <__vector_125+0x80>
 ee4:	81 e0       	ldi	r24, 0x01	; 1
 ee6:	01 c0       	rjmp	.+2      	; 0xeea <__vector_125+0x82>
 ee8:	83 e0       	ldi	r24, 0x03	; 3
 eea:	80 93 bd 24 	sts	0x24BD, r24

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
 eee:	0e 94 0f 06 	call	0xc1e	; 0xc1e <EVENT_USB_Device_Connect>
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
 ef2:	80 91 ca 04 	lds	r24, 0x04CA
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Reset))
 ef6:	84 ff       	sbrs	r24, 4
 ef8:	18 c0       	rjmp	.+48     	; 0xf2a <__vector_125+0xc2>
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
 efa:	e0 ec       	ldi	r30, 0xC0	; 192
 efc:	f4 e0       	ldi	r31, 0x04	; 4
 efe:	80 e1       	ldi	r24, 0x10	; 16
 f00:	82 87       	std	Z+10, r24	; 0x0a
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Reset);

		USB_DeviceState                = DEVICE_STATE_Default;
 f02:	82 e0       	ldi	r24, 0x02	; 2
 f04:	80 93 bd 24 	sts	0x24BD, r24
		USB_Device_ConfigurationNumber = 0;
 f08:	10 92 b9 24 	sts	0x24B9, r1
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
 f0c:	13 82       	std	Z+3, r1	; 0x03

		USB_Device_EnableDeviceAddress(0);

		Endpoint_ClearEndpoints();
 f0e:	0e 94 21 07 	call	0xe42	; 0xe42 <Endpoint_ClearEndpoints>
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
 f12:	48 e0       	ldi	r20, 0x08	; 8
 f14:	68 e4       	ldi	r22, 0x48	; 72
 f16:	80 e8       	ldi	r24, 0x80	; 128
 f18:	0e 94 db 06 	call	0xdb6	; 0xdb6 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
 f1c:	48 e0       	ldi	r20, 0x08	; 8
 f1e:	68 e4       	ldi	r22, 0x48	; 72
 f20:	80 e0       	ldi	r24, 0x00	; 0
 f22:	0e 94 db 06 	call	0xdb6	; 0xdb6 <Endpoint_ConfigureEndpoint_PRV>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           USB_Device_ControlEndpointSize, 1);

		EVENT_USB_Device_Reset();
 f26:	0e 94 9a 06 	call	0xd34	; 0xd34 <USB_Event_Stub>
	}
}
 f2a:	ff 91       	pop	r31
 f2c:	ef 91       	pop	r30
 f2e:	bf 91       	pop	r27
 f30:	af 91       	pop	r26
 f32:	9f 91       	pop	r25
 f34:	8f 91       	pop	r24
 f36:	7f 91       	pop	r23
 f38:	6f 91       	pop	r22
 f3a:	5f 91       	pop	r21
 f3c:	4f 91       	pop	r20
 f3e:	3f 91       	pop	r19
 f40:	2f 91       	pop	r18
 f42:	0f 90       	pop	r0
 f44:	0b be       	out	0x3b, r0	; 59
 f46:	0f 90       	pop	r0
 f48:	0f be       	out	0x3f, r0	; 63
 f4a:	0f 90       	pop	r0
 f4c:	1f 90       	pop	r1
 f4e:	18 95       	reti

00000f50 <__udivmodsi4>:
 f50:	a1 e2       	ldi	r26, 0x21	; 33
 f52:	1a 2e       	mov	r1, r26
 f54:	aa 1b       	sub	r26, r26
 f56:	bb 1b       	sub	r27, r27
 f58:	fd 01       	movw	r30, r26
 f5a:	0d c0       	rjmp	.+26     	; 0xf76 <__udivmodsi4_ep>

00000f5c <__udivmodsi4_loop>:
 f5c:	aa 1f       	adc	r26, r26
 f5e:	bb 1f       	adc	r27, r27
 f60:	ee 1f       	adc	r30, r30
 f62:	ff 1f       	adc	r31, r31
 f64:	a2 17       	cp	r26, r18
 f66:	b3 07       	cpc	r27, r19
 f68:	e4 07       	cpc	r30, r20
 f6a:	f5 07       	cpc	r31, r21
 f6c:	20 f0       	brcs	.+8      	; 0xf76 <__udivmodsi4_ep>
 f6e:	a2 1b       	sub	r26, r18
 f70:	b3 0b       	sbc	r27, r19
 f72:	e4 0b       	sbc	r30, r20
 f74:	f5 0b       	sbc	r31, r21

00000f76 <__udivmodsi4_ep>:
 f76:	66 1f       	adc	r22, r22
 f78:	77 1f       	adc	r23, r23
 f7a:	88 1f       	adc	r24, r24
 f7c:	99 1f       	adc	r25, r25
 f7e:	1a 94       	dec	r1
 f80:	69 f7       	brne	.-38     	; 0xf5c <__udivmodsi4_loop>
 f82:	60 95       	com	r22
 f84:	70 95       	com	r23
 f86:	80 95       	com	r24
 f88:	90 95       	com	r25
 f8a:	9b 01       	movw	r18, r22
 f8c:	ac 01       	movw	r20, r24
 f8e:	bd 01       	movw	r22, r26
 f90:	cf 01       	movw	r24, r30
 f92:	08 95       	ret

00000f94 <_exit>:
 f94:	f8 94       	cli

00000f96 <__stop_program>:
 f96:	ff cf       	rjmp	.-2      	; 0xf96 <__stop_program>
